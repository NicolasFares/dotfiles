"use strict";
/*
 Copyright (c) 42Crunch Ltd. All rights reserved.
 Licensed under the GNU Affero General Public License version 3. See LICENSE.txt in the project root for license information.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseJson = parseJson;
exports.parseYaml = parseYaml;
const yaml_1 = require("./visit/yaml");
const json_1 = require("./visit/json");
const preserve_1 = require("./preserve");
const json_parser_1 = require("./json-parser");
const json = require("jsonc-parser");
const yaml = require("yaml");
const custom_tags_1 = require("./custom-tags");
function extendedErrorToMessage(error) {
    if (error.extendedError) {
        if (error.extendedError === 1 /* ExtendedErrorCode.DuplicateKey */) {
            return "DuplicateKey";
        }
        return "<unknown ExtendedErrorCode>";
    }
    return json.printParseErrorCode(error.error);
}
function parseJson(text) {
    const parseErrors = [];
    const node = (0, json_parser_1.parseTree)(text, parseErrors, {
        disallowComments: true,
        allowTrailingComma: false,
        allowEmptyContent: false,
    });
    const normalizedErrors = parseErrors.map((error) => ({
        message: extendedErrorToMessage(error),
        offset: error.offset,
        length: error.length,
    }));
    if (node) {
        const parsed = runvisitor(json_1.visitJson, undefined, node);
        return [parsed, normalizedErrors];
    }
    return [undefined, normalizedErrors];
}
function parseYaml(text, customTags) {
    const documents = yaml.parseAllDocuments(text, {
        customTags: (0, custom_tags_1.getCustomTags)(customTags || {}),
    });
    if (documents.length !== 1) {
        return [undefined, []];
    }
    const document = documents[0];
    const normalizedErrors = document.errors.map((error) => ({
        message: error.message,
        offset: error.pos[0],
        length: error.pos[1] - error.pos[0],
    }));
    yaml.visit(document, {
        Alias(key, node) {
            if (!node.resolve(document)) {
                normalizedErrors.push({
                    message: `Alias "${key}" could not be resolved`,
                    offset: node.range[0],
                    length: node.range[1] - node.range[0],
                });
            }
        },
    });
    const parsed = runvisitor(yaml_1.visitYaml, document, document.contents);
    return [parsed, normalizedErrors];
}
function runvisitor(visit, document, root) {
    var _a;
    let container = {};
    const stack = [container];
    visit(document, null, "fakeroot", root, {
        onObjectStart: (parent, key, value, location) => {
            if (location) {
                (0, preserve_1.setPreservedLocation)(container, key, location);
            }
            stack.push(container);
            container = container[key] = {};
        },
        onObjectEnd: () => {
            container = stack.pop();
        },
        onArrayStart: (parent, key, value, location) => {
            if (location) {
                (0, preserve_1.setPreservedLocation)(container, key, location);
            }
            stack.push(container);
            container = container[key] = [];
        },
        onArrayEnd: () => {
            container = stack.pop();
        },
        onValue: (parent, key, value, raw, location) => {
            container[key] = value;
            if (typeof value === "number" && raw !== undefined) {
                (0, preserve_1.setPreservedValue)(container, key, raw);
            }
            if (location) {
                (0, preserve_1.setPreservedLocation)(container, key, location);
            }
        },
    });
    if (typeof stack[0].fakeroot !== "object") {
        return undefined;
    }
    const range = (_a = (0, preserve_1.getPreservedLocation)(stack[0], "fakeroot")) === null || _a === void 0 ? void 0 : _a.value;
    (0, preserve_1.setPreservedRootRange)(stack[0].fakeroot, range);
    return stack[0].fakeroot;
}
