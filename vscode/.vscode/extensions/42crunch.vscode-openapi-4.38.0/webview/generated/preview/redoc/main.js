var jR = Object.defineProperty;
var LR = (e, t, r) => t in e ? jR(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var t1 = (e, t, r) => LR(e, typeof t != "symbol" ? t + "" : t, r);
var r1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function NS(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function _o(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(n) {
    var o = Object.getOwnPropertyDescriptor(e, n);
    Object.defineProperty(r, n, o.get ? o : {
      enumerable: !0,
      get: function() {
        return e[n];
      }
    });
  }), r;
}
var Yb = { exports: {} }, xd = {}, Gb = { exports: {} }, jt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var n1;
function MR() {
  if (n1) return jt;
  n1 = 1;
  var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), i = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), d = Symbol.for("react.memo"), m = Symbol.for("react.lazy"), g = Symbol.iterator;
  function v(F) {
    return F === null || typeof F != "object" ? null : (F = g && F[g] || F["@@iterator"], typeof F == "function" ? F : null);
  }
  var S = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, k = Object.assign, b = {};
  function x(F, J, W) {
    this.props = F, this.context = J, this.refs = b, this.updater = W || S;
  }
  x.prototype.isReactComponent = {}, x.prototype.setState = function(F, J) {
    if (typeof F != "object" && typeof F != "function" && F != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, F, J, "setState");
  }, x.prototype.forceUpdate = function(F) {
    this.updater.enqueueForceUpdate(this, F, "forceUpdate");
  };
  function A() {
  }
  A.prototype = x.prototype;
  function _(F, J, W) {
    this.props = F, this.context = J, this.refs = b, this.updater = W || S;
  }
  var O = _.prototype = new A();
  O.constructor = _, k(O, x.prototype), O.isPureReactComponent = !0;
  var R = Array.isArray, C = Object.prototype.hasOwnProperty, T = { current: null }, j = { key: !0, ref: !0, __self: !0, __source: !0 };
  function D(F, J, W) {
    var q, X = {}, Q = null, ye = null;
    if (J != null) for (q in J.ref !== void 0 && (ye = J.ref), J.key !== void 0 && (Q = "" + J.key), J) C.call(J, q) && !j.hasOwnProperty(q) && (X[q] = J[q]);
    var Se = arguments.length - 2;
    if (Se === 1) X.children = W;
    else if (1 < Se) {
      for (var Ne = Array(Se), N = 0; N < Se; N++) Ne[N] = arguments[N + 2];
      X.children = Ne;
    }
    if (F && F.defaultProps) for (q in Se = F.defaultProps, Se) X[q] === void 0 && (X[q] = Se[q]);
    return { $$typeof: e, type: F, key: Q, ref: ye, props: X, _owner: T.current };
  }
  function V(F, J) {
    return { $$typeof: e, type: F.type, key: J, ref: F.ref, props: F.props, _owner: F._owner };
  }
  function U(F) {
    return typeof F == "object" && F !== null && F.$$typeof === e;
  }
  function ne(F) {
    var J = { "=": "=0", ":": "=2" };
    return "$" + F.replace(/[=:]/g, function(W) {
      return J[W];
    });
  }
  var H = /\/+/g;
  function ae(F, J) {
    return typeof F == "object" && F !== null && F.key != null ? ne("" + F.key) : J.toString(36);
  }
  function ge(F, J, W, q, X) {
    var Q = typeof F;
    (Q === "undefined" || Q === "boolean") && (F = null);
    var ye = !1;
    if (F === null) ye = !0;
    else switch (Q) {
      case "string":
      case "number":
        ye = !0;
        break;
      case "object":
        switch (F.$$typeof) {
          case e:
          case t:
            ye = !0;
        }
    }
    if (ye) return ye = F, X = X(ye), F = q === "" ? "." + ae(ye, 0) : q, R(X) ? (W = "", F != null && (W = F.replace(H, "$&/") + "/"), ge(X, J, W, "", function(N) {
      return N;
    })) : X != null && (U(X) && (X = V(X, W + (!X.key || ye && ye.key === X.key ? "" : ("" + X.key).replace(H, "$&/") + "/") + F)), J.push(X)), 1;
    if (ye = 0, q = q === "" ? "." : q + ":", R(F)) for (var Se = 0; Se < F.length; Se++) {
      Q = F[Se];
      var Ne = q + ae(Q, Se);
      ye += ge(Q, J, W, Ne, X);
    }
    else if (Ne = v(F), typeof Ne == "function") for (F = Ne.call(F), Se = 0; !(Q = F.next()).done; ) Q = Q.value, Ne = q + ae(Q, Se++), ye += ge(Q, J, W, Ne, X);
    else if (Q === "object") throw J = String(F), Error("Objects are not valid as a React child (found: " + (J === "[object Object]" ? "object with keys {" + Object.keys(F).join(", ") + "}" : J) + "). If you meant to render a collection of children, use an array instead.");
    return ye;
  }
  function fe(F, J, W) {
    if (F == null) return F;
    var q = [], X = 0;
    return ge(F, q, "", "", function(Q) {
      return J.call(W, Q, X++);
    }), q;
  }
  function ve(F) {
    if (F._status === -1) {
      var J = F._result;
      J = J(), J.then(function(W) {
        (F._status === 0 || F._status === -1) && (F._status = 1, F._result = W);
      }, function(W) {
        (F._status === 0 || F._status === -1) && (F._status = 2, F._result = W);
      }), F._status === -1 && (F._status = 0, F._result = J);
    }
    if (F._status === 1) return F._result.default;
    throw F._result;
  }
  var $e = { current: null }, ce = { transition: null }, se = { ReactCurrentDispatcher: $e, ReactCurrentBatchConfig: ce, ReactCurrentOwner: T };
  function te() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  return jt.Children = { map: fe, forEach: function(F, J, W) {
    fe(F, function() {
      J.apply(this, arguments);
    }, W);
  }, count: function(F) {
    var J = 0;
    return fe(F, function() {
      J++;
    }), J;
  }, toArray: function(F) {
    return fe(F, function(J) {
      return J;
    }) || [];
  }, only: function(F) {
    if (!U(F)) throw Error("React.Children.only expected to receive a single React element child.");
    return F;
  } }, jt.Component = x, jt.Fragment = r, jt.Profiler = o, jt.PureComponent = _, jt.StrictMode = n, jt.Suspense = c, jt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = se, jt.act = te, jt.cloneElement = function(F, J, W) {
    if (F == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + F + ".");
    var q = k({}, F.props), X = F.key, Q = F.ref, ye = F._owner;
    if (J != null) {
      if (J.ref !== void 0 && (Q = J.ref, ye = T.current), J.key !== void 0 && (X = "" + J.key), F.type && F.type.defaultProps) var Se = F.type.defaultProps;
      for (Ne in J) C.call(J, Ne) && !j.hasOwnProperty(Ne) && (q[Ne] = J[Ne] === void 0 && Se !== void 0 ? Se[Ne] : J[Ne]);
    }
    var Ne = arguments.length - 2;
    if (Ne === 1) q.children = W;
    else if (1 < Ne) {
      Se = Array(Ne);
      for (var N = 0; N < Ne; N++) Se[N] = arguments[N + 2];
      q.children = Se;
    }
    return { $$typeof: e, type: F.type, key: X, ref: Q, props: q, _owner: ye };
  }, jt.createContext = function(F) {
    return F = { $$typeof: i, _currentValue: F, _currentValue2: F, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, F.Provider = { $$typeof: a, _context: F }, F.Consumer = F;
  }, jt.createElement = D, jt.createFactory = function(F) {
    var J = D.bind(null, F);
    return J.type = F, J;
  }, jt.createRef = function() {
    return { current: null };
  }, jt.forwardRef = function(F) {
    return { $$typeof: u, render: F };
  }, jt.isValidElement = U, jt.lazy = function(F) {
    return { $$typeof: m, _payload: { _status: -1, _result: F }, _init: ve };
  }, jt.memo = function(F, J) {
    return { $$typeof: d, type: F, compare: J === void 0 ? null : J };
  }, jt.startTransition = function(F) {
    var J = ce.transition;
    ce.transition = {};
    try {
      F();
    } finally {
      ce.transition = J;
    }
  }, jt.unstable_act = te, jt.useCallback = function(F, J) {
    return $e.current.useCallback(F, J);
  }, jt.useContext = function(F) {
    return $e.current.useContext(F);
  }, jt.useDebugValue = function() {
  }, jt.useDeferredValue = function(F) {
    return $e.current.useDeferredValue(F);
  }, jt.useEffect = function(F, J) {
    return $e.current.useEffect(F, J);
  }, jt.useId = function() {
    return $e.current.useId();
  }, jt.useImperativeHandle = function(F, J, W) {
    return $e.current.useImperativeHandle(F, J, W);
  }, jt.useInsertionEffect = function(F, J) {
    return $e.current.useInsertionEffect(F, J);
  }, jt.useLayoutEffect = function(F, J) {
    return $e.current.useLayoutEffect(F, J);
  }, jt.useMemo = function(F, J) {
    return $e.current.useMemo(F, J);
  }, jt.useReducer = function(F, J, W) {
    return $e.current.useReducer(F, J, W);
  }, jt.useRef = function(F) {
    return $e.current.useRef(F);
  }, jt.useState = function(F) {
    return $e.current.useState(F);
  }, jt.useSyncExternalStore = function(F, J, W) {
    return $e.current.useSyncExternalStore(F, J, W);
  }, jt.useTransition = function() {
    return $e.current.useTransition();
  }, jt.version = "18.3.1", jt;
}
var i1;
function ch() {
  return i1 || (i1 = 1, Gb.exports = MR()), Gb.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var s1;
function DR() {
  if (s1) return xd;
  s1 = 1;
  var e = ch(), t = Symbol.for("react.element"), r = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, a = { key: !0, ref: !0, __self: !0, __source: !0 };
  function i(u, c, d) {
    var m, g = {}, v = null, S = null;
    d !== void 0 && (v = "" + d), c.key !== void 0 && (v = "" + c.key), c.ref !== void 0 && (S = c.ref);
    for (m in c) n.call(c, m) && !a.hasOwnProperty(m) && (g[m] = c[m]);
    if (u && u.defaultProps) for (m in c = u.defaultProps, c) g[m] === void 0 && (g[m] = c[m]);
    return { $$typeof: t, type: u, key: v, ref: S, props: g, _owner: o.current };
  }
  return xd.Fragment = r, xd.jsx = i, xd.jsxs = i, xd;
}
var o1;
function FR() {
  return o1 || (o1 = 1, Yb.exports = DR()), Yb.exports;
}
var Uw = FR(), Xb = { exports: {} }, Yn = {}, Jb = { exports: {} }, Zb = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var a1;
function qR() {
  return a1 || (a1 = 1, function(e) {
    function t(ce, se) {
      var te = ce.length;
      ce.push(se);
      e: for (; 0 < te; ) {
        var F = te - 1 >>> 1, J = ce[F];
        if (0 < o(J, se)) ce[F] = se, ce[te] = J, te = F;
        else break e;
      }
    }
    function r(ce) {
      return ce.length === 0 ? null : ce[0];
    }
    function n(ce) {
      if (ce.length === 0) return null;
      var se = ce[0], te = ce.pop();
      if (te !== se) {
        ce[0] = te;
        e: for (var F = 0, J = ce.length, W = J >>> 1; F < W; ) {
          var q = 2 * (F + 1) - 1, X = ce[q], Q = q + 1, ye = ce[Q];
          if (0 > o(X, te)) Q < J && 0 > o(ye, X) ? (ce[F] = ye, ce[Q] = te, F = Q) : (ce[F] = X, ce[q] = te, F = q);
          else if (Q < J && 0 > o(ye, te)) ce[F] = ye, ce[Q] = te, F = Q;
          else break e;
        }
      }
      return se;
    }
    function o(ce, se) {
      var te = ce.sortIndex - se.sortIndex;
      return te !== 0 ? te : ce.id - se.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var a = performance;
      e.unstable_now = function() {
        return a.now();
      };
    } else {
      var i = Date, u = i.now();
      e.unstable_now = function() {
        return i.now() - u;
      };
    }
    var c = [], d = [], m = 1, g = null, v = 3, S = !1, k = !1, b = !1, x = typeof setTimeout == "function" ? setTimeout : null, A = typeof clearTimeout == "function" ? clearTimeout : null, _ = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function O(ce) {
      for (var se = r(d); se !== null; ) {
        if (se.callback === null) n(d);
        else if (se.startTime <= ce) n(d), se.sortIndex = se.expirationTime, t(c, se);
        else break;
        se = r(d);
      }
    }
    function R(ce) {
      if (b = !1, O(ce), !k) if (r(c) !== null) k = !0, ve(C);
      else {
        var se = r(d);
        se !== null && $e(R, se.startTime - ce);
      }
    }
    function C(ce, se) {
      k = !1, b && (b = !1, A(D), D = -1), S = !0;
      var te = v;
      try {
        for (O(se), g = r(c); g !== null && (!(g.expirationTime > se) || ce && !ne()); ) {
          var F = g.callback;
          if (typeof F == "function") {
            g.callback = null, v = g.priorityLevel;
            var J = F(g.expirationTime <= se);
            se = e.unstable_now(), typeof J == "function" ? g.callback = J : g === r(c) && n(c), O(se);
          } else n(c);
          g = r(c);
        }
        if (g !== null) var W = !0;
        else {
          var q = r(d);
          q !== null && $e(R, q.startTime - se), W = !1;
        }
        return W;
      } finally {
        g = null, v = te, S = !1;
      }
    }
    var T = !1, j = null, D = -1, V = 5, U = -1;
    function ne() {
      return !(e.unstable_now() - U < V);
    }
    function H() {
      if (j !== null) {
        var ce = e.unstable_now();
        U = ce;
        var se = !0;
        try {
          se = j(!0, ce);
        } finally {
          se ? ae() : (T = !1, j = null);
        }
      } else T = !1;
    }
    var ae;
    if (typeof _ == "function") ae = function() {
      _(H);
    };
    else if (typeof MessageChannel < "u") {
      var ge = new MessageChannel(), fe = ge.port2;
      ge.port1.onmessage = H, ae = function() {
        fe.postMessage(null);
      };
    } else ae = function() {
      x(H, 0);
    };
    function ve(ce) {
      j = ce, T || (T = !0, ae());
    }
    function $e(ce, se) {
      D = x(function() {
        ce(e.unstable_now());
      }, se);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(ce) {
      ce.callback = null;
    }, e.unstable_continueExecution = function() {
      k || S || (k = !0, ve(C));
    }, e.unstable_forceFrameRate = function(ce) {
      0 > ce || 125 < ce ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : V = 0 < ce ? Math.floor(1e3 / ce) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return v;
    }, e.unstable_getFirstCallbackNode = function() {
      return r(c);
    }, e.unstable_next = function(ce) {
      switch (v) {
        case 1:
        case 2:
        case 3:
          var se = 3;
          break;
        default:
          se = v;
      }
      var te = v;
      v = se;
      try {
        return ce();
      } finally {
        v = te;
      }
    }, e.unstable_pauseExecution = function() {
    }, e.unstable_requestPaint = function() {
    }, e.unstable_runWithPriority = function(ce, se) {
      switch (ce) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          ce = 3;
      }
      var te = v;
      v = ce;
      try {
        return se();
      } finally {
        v = te;
      }
    }, e.unstable_scheduleCallback = function(ce, se, te) {
      var F = e.unstable_now();
      switch (typeof te == "object" && te !== null ? (te = te.delay, te = typeof te == "number" && 0 < te ? F + te : F) : te = F, ce) {
        case 1:
          var J = -1;
          break;
        case 2:
          J = 250;
          break;
        case 5:
          J = 1073741823;
          break;
        case 4:
          J = 1e4;
          break;
        default:
          J = 5e3;
      }
      return J = te + J, ce = { id: m++, callback: se, priorityLevel: ce, startTime: te, expirationTime: J, sortIndex: -1 }, te > F ? (ce.sortIndex = te, t(d, ce), r(c) === null && ce === r(d) && (b ? (A(D), D = -1) : b = !0, $e(R, te - F))) : (ce.sortIndex = J, t(c, ce), k || S || (k = !0, ve(C))), ce;
    }, e.unstable_shouldYield = ne, e.unstable_wrapCallback = function(ce) {
      var se = v;
      return function() {
        var te = v;
        v = se;
        try {
          return ce.apply(this, arguments);
        } finally {
          v = te;
        }
      };
    };
  }(Zb)), Zb;
}
var l1;
function zR() {
  return l1 || (l1 = 1, Jb.exports = qR()), Jb.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var u1;
function BR() {
  if (u1) return Yn;
  u1 = 1;
  var e = ch(), t = zR();
  function r(s) {
    for (var l = "https://reactjs.org/docs/error-decoder.html?invariant=" + s, y = 1; y < arguments.length; y++) l += "&args[]=" + encodeURIComponent(arguments[y]);
    return "Minified React error #" + s + "; visit " + l + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var n = /* @__PURE__ */ new Set(), o = {};
  function a(s, l) {
    i(s, l), i(s + "Capture", l);
  }
  function i(s, l) {
    for (o[s] = l, s = 0; s < l.length; s++) n.add(l[s]);
  }
  var u = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), c = Object.prototype.hasOwnProperty, d = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, m = {}, g = {};
  function v(s) {
    return c.call(g, s) ? !0 : c.call(m, s) ? !1 : d.test(s) ? g[s] = !0 : (m[s] = !0, !1);
  }
  function S(s, l, y, E) {
    if (y !== null && y.type === 0) return !1;
    switch (typeof l) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return E ? !1 : y !== null ? !y.acceptsBooleans : (s = s.toLowerCase().slice(0, 5), s !== "data-" && s !== "aria-");
      default:
        return !1;
    }
  }
  function k(s, l, y, E) {
    if (l === null || typeof l > "u" || S(s, l, y, E)) return !0;
    if (E) return !1;
    if (y !== null) switch (y.type) {
      case 3:
        return !l;
      case 4:
        return l === !1;
      case 5:
        return isNaN(l);
      case 6:
        return isNaN(l) || 1 > l;
    }
    return !1;
  }
  function b(s, l, y, E, I, M, G) {
    this.acceptsBooleans = l === 2 || l === 3 || l === 4, this.attributeName = E, this.attributeNamespace = I, this.mustUseProperty = y, this.propertyName = s, this.type = l, this.sanitizeURL = M, this.removeEmptyString = G;
  }
  var x = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(s) {
    x[s] = new b(s, 0, !1, s, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(s) {
    var l = s[0];
    x[l] = new b(l, 1, !1, s[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(s) {
    x[s] = new b(s, 2, !1, s.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(s) {
    x[s] = new b(s, 2, !1, s, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(s) {
    x[s] = new b(s, 3, !1, s.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(s) {
    x[s] = new b(s, 3, !0, s, null, !1, !1);
  }), ["capture", "download"].forEach(function(s) {
    x[s] = new b(s, 4, !1, s, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(s) {
    x[s] = new b(s, 6, !1, s, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(s) {
    x[s] = new b(s, 5, !1, s.toLowerCase(), null, !1, !1);
  });
  var A = /[\-:]([a-z])/g;
  function _(s) {
    return s[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(s) {
    var l = s.replace(
      A,
      _
    );
    x[l] = new b(l, 1, !1, s, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(s) {
    var l = s.replace(A, _);
    x[l] = new b(l, 1, !1, s, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(s) {
    var l = s.replace(A, _);
    x[l] = new b(l, 1, !1, s, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(s) {
    x[s] = new b(s, 1, !1, s.toLowerCase(), null, !1, !1);
  }), x.xlinkHref = new b("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(s) {
    x[s] = new b(s, 1, !1, s.toLowerCase(), null, !0, !0);
  });
  function O(s, l, y, E) {
    var I = x.hasOwnProperty(l) ? x[l] : null;
    (I !== null ? I.type !== 0 : E || !(2 < l.length) || l[0] !== "o" && l[0] !== "O" || l[1] !== "n" && l[1] !== "N") && (k(l, y, I, E) && (y = null), E || I === null ? v(l) && (y === null ? s.removeAttribute(l) : s.setAttribute(l, "" + y)) : I.mustUseProperty ? s[I.propertyName] = y === null ? I.type === 3 ? !1 : "" : y : (l = I.attributeName, E = I.attributeNamespace, y === null ? s.removeAttribute(l) : (I = I.type, y = I === 3 || I === 4 && y === !0 ? "" : "" + y, E ? s.setAttributeNS(E, l, y) : s.setAttribute(l, y))));
  }
  var R = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, C = Symbol.for("react.element"), T = Symbol.for("react.portal"), j = Symbol.for("react.fragment"), D = Symbol.for("react.strict_mode"), V = Symbol.for("react.profiler"), U = Symbol.for("react.provider"), ne = Symbol.for("react.context"), H = Symbol.for("react.forward_ref"), ae = Symbol.for("react.suspense"), ge = Symbol.for("react.suspense_list"), fe = Symbol.for("react.memo"), ve = Symbol.for("react.lazy"), $e = Symbol.for("react.offscreen"), ce = Symbol.iterator;
  function se(s) {
    return s === null || typeof s != "object" ? null : (s = ce && s[ce] || s["@@iterator"], typeof s == "function" ? s : null);
  }
  var te = Object.assign, F;
  function J(s) {
    if (F === void 0) try {
      throw Error();
    } catch (y) {
      var l = y.stack.trim().match(/\n( *(at )?)/);
      F = l && l[1] || "";
    }
    return `
` + F + s;
  }
  var W = !1;
  function q(s, l) {
    if (!s || W) return "";
    W = !0;
    var y = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (l) if (l = function() {
        throw Error();
      }, Object.defineProperty(l.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(l, []);
        } catch (Re) {
          var E = Re;
        }
        Reflect.construct(s, [], l);
      } else {
        try {
          l.call();
        } catch (Re) {
          E = Re;
        }
        s.call(l.prototype);
      }
      else {
        try {
          throw Error();
        } catch (Re) {
          E = Re;
        }
        s();
      }
    } catch (Re) {
      if (Re && E && typeof Re.stack == "string") {
        for (var I = Re.stack.split(`
`), M = E.stack.split(`
`), G = I.length - 1, de = M.length - 1; 1 <= G && 0 <= de && I[G] !== M[de]; ) de--;
        for (; 1 <= G && 0 <= de; G--, de--) if (I[G] !== M[de]) {
          if (G !== 1 || de !== 1)
            do
              if (G--, de--, 0 > de || I[G] !== M[de]) {
                var be = `
` + I[G].replace(" at new ", " at ");
                return s.displayName && be.includes("<anonymous>") && (be = be.replace("<anonymous>", s.displayName)), be;
              }
            while (1 <= G && 0 <= de);
          break;
        }
      }
    } finally {
      W = !1, Error.prepareStackTrace = y;
    }
    return (s = s ? s.displayName || s.name : "") ? J(s) : "";
  }
  function X(s) {
    switch (s.tag) {
      case 5:
        return J(s.type);
      case 16:
        return J("Lazy");
      case 13:
        return J("Suspense");
      case 19:
        return J("SuspenseList");
      case 0:
      case 2:
      case 15:
        return s = q(s.type, !1), s;
      case 11:
        return s = q(s.type.render, !1), s;
      case 1:
        return s = q(s.type, !0), s;
      default:
        return "";
    }
  }
  function Q(s) {
    if (s == null) return null;
    if (typeof s == "function") return s.displayName || s.name || null;
    if (typeof s == "string") return s;
    switch (s) {
      case j:
        return "Fragment";
      case T:
        return "Portal";
      case V:
        return "Profiler";
      case D:
        return "StrictMode";
      case ae:
        return "Suspense";
      case ge:
        return "SuspenseList";
    }
    if (typeof s == "object") switch (s.$$typeof) {
      case ne:
        return (s.displayName || "Context") + ".Consumer";
      case U:
        return (s._context.displayName || "Context") + ".Provider";
      case H:
        var l = s.render;
        return s = s.displayName, s || (s = l.displayName || l.name || "", s = s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef"), s;
      case fe:
        return l = s.displayName || null, l !== null ? l : Q(s.type) || "Memo";
      case ve:
        l = s._payload, s = s._init;
        try {
          return Q(s(l));
        } catch {
        }
    }
    return null;
  }
  function ye(s) {
    var l = s.type;
    switch (s.tag) {
      case 24:
        return "Cache";
      case 9:
        return (l.displayName || "Context") + ".Consumer";
      case 10:
        return (l._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return s = l.render, s = s.displayName || s.name || "", l.displayName || (s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return l;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Q(l);
      case 8:
        return l === D ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof l == "function") return l.displayName || l.name || null;
        if (typeof l == "string") return l;
    }
    return null;
  }
  function Se(s) {
    switch (typeof s) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return s;
      case "object":
        return s;
      default:
        return "";
    }
  }
  function Ne(s) {
    var l = s.type;
    return (s = s.nodeName) && s.toLowerCase() === "input" && (l === "checkbox" || l === "radio");
  }
  function N(s) {
    var l = Ne(s) ? "checked" : "value", y = Object.getOwnPropertyDescriptor(s.constructor.prototype, l), E = "" + s[l];
    if (!s.hasOwnProperty(l) && typeof y < "u" && typeof y.get == "function" && typeof y.set == "function") {
      var I = y.get, M = y.set;
      return Object.defineProperty(s, l, { configurable: !0, get: function() {
        return I.call(this);
      }, set: function(G) {
        E = "" + G, M.call(this, G);
      } }), Object.defineProperty(s, l, { enumerable: y.enumerable }), { getValue: function() {
        return E;
      }, setValue: function(G) {
        E = "" + G;
      }, stopTracking: function() {
        s._valueTracker = null, delete s[l];
      } };
    }
  }
  function B(s) {
    s._valueTracker || (s._valueTracker = N(s));
  }
  function oe(s) {
    if (!s) return !1;
    var l = s._valueTracker;
    if (!l) return !0;
    var y = l.getValue(), E = "";
    return s && (E = Ne(s) ? s.checked ? "true" : "false" : s.value), s = E, s !== y ? (l.setValue(s), !0) : !1;
  }
  function ie(s) {
    if (s = s || (typeof document < "u" ? document : void 0), typeof s > "u") return null;
    try {
      return s.activeElement || s.body;
    } catch {
      return s.body;
    }
  }
  function he(s, l) {
    var y = l.checked;
    return te({}, l, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: y ?? s._wrapperState.initialChecked });
  }
  function Z(s, l) {
    var y = l.defaultValue == null ? "" : l.defaultValue, E = l.checked != null ? l.checked : l.defaultChecked;
    y = Se(l.value != null ? l.value : y), s._wrapperState = { initialChecked: E, initialValue: y, controlled: l.type === "checkbox" || l.type === "radio" ? l.checked != null : l.value != null };
  }
  function re(s, l) {
    l = l.checked, l != null && O(s, "checked", l, !1);
  }
  function Pe(s, l) {
    re(s, l);
    var y = Se(l.value), E = l.type;
    if (y != null) E === "number" ? (y === 0 && s.value === "" || s.value != y) && (s.value = "" + y) : s.value !== "" + y && (s.value = "" + y);
    else if (E === "submit" || E === "reset") {
      s.removeAttribute("value");
      return;
    }
    l.hasOwnProperty("value") ? qe(s, l.type, y) : l.hasOwnProperty("defaultValue") && qe(s, l.type, Se(l.defaultValue)), l.checked == null && l.defaultChecked != null && (s.defaultChecked = !!l.defaultChecked);
  }
  function Oe(s, l, y) {
    if (l.hasOwnProperty("value") || l.hasOwnProperty("defaultValue")) {
      var E = l.type;
      if (!(E !== "submit" && E !== "reset" || l.value !== void 0 && l.value !== null)) return;
      l = "" + s._wrapperState.initialValue, y || l === s.value || (s.value = l), s.defaultValue = l;
    }
    y = s.name, y !== "" && (s.name = ""), s.defaultChecked = !!s._wrapperState.initialChecked, y !== "" && (s.name = y);
  }
  function qe(s, l, y) {
    (l !== "number" || ie(s.ownerDocument) !== s) && (y == null ? s.defaultValue = "" + s._wrapperState.initialValue : s.defaultValue !== "" + y && (s.defaultValue = "" + y));
  }
  var je = Array.isArray;
  function $(s, l, y, E) {
    if (s = s.options, l) {
      l = {};
      for (var I = 0; I < y.length; I++) l["$" + y[I]] = !0;
      for (y = 0; y < s.length; y++) I = l.hasOwnProperty("$" + s[y].value), s[y].selected !== I && (s[y].selected = I), I && E && (s[y].defaultSelected = !0);
    } else {
      for (y = "" + Se(y), l = null, I = 0; I < s.length; I++) {
        if (s[I].value === y) {
          s[I].selected = !0, E && (s[I].defaultSelected = !0);
          return;
        }
        l !== null || s[I].disabled || (l = s[I]);
      }
      l !== null && (l.selected = !0);
    }
  }
  function K(s, l) {
    if (l.dangerouslySetInnerHTML != null) throw Error(r(91));
    return te({}, l, { value: void 0, defaultValue: void 0, children: "" + s._wrapperState.initialValue });
  }
  function me(s, l) {
    var y = l.value;
    if (y == null) {
      if (y = l.children, l = l.defaultValue, y != null) {
        if (l != null) throw Error(r(92));
        if (je(y)) {
          if (1 < y.length) throw Error(r(93));
          y = y[0];
        }
        l = y;
      }
      l == null && (l = ""), y = l;
    }
    s._wrapperState = { initialValue: Se(y) };
  }
  function Te(s, l) {
    var y = Se(l.value), E = Se(l.defaultValue);
    y != null && (y = "" + y, y !== s.value && (s.value = y), l.defaultValue == null && s.defaultValue !== y && (s.defaultValue = y)), E != null && (s.defaultValue = "" + E);
  }
  function ke(s) {
    var l = s.textContent;
    l === s._wrapperState.initialValue && l !== "" && l !== null && (s.value = l);
  }
  function De(s) {
    switch (s) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Fe(s, l) {
    return s == null || s === "http://www.w3.org/1999/xhtml" ? De(l) : s === "http://www.w3.org/2000/svg" && l === "foreignObject" ? "http://www.w3.org/1999/xhtml" : s;
  }
  var Xe, ct = function(s) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(l, y, E, I) {
      MSApp.execUnsafeLocalFunction(function() {
        return s(l, y, E, I);
      });
    } : s;
  }(function(s, l) {
    if (s.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in s) s.innerHTML = l;
    else {
      for (Xe = Xe || document.createElement("div"), Xe.innerHTML = "<svg>" + l.valueOf().toString() + "</svg>", l = Xe.firstChild; s.firstChild; ) s.removeChild(s.firstChild);
      for (; l.firstChild; ) s.appendChild(l.firstChild);
    }
  });
  function mt(s, l) {
    if (l) {
      var y = s.firstChild;
      if (y && y === s.lastChild && y.nodeType === 3) {
        y.nodeValue = l;
        return;
      }
    }
    s.textContent = l;
  }
  var st = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, at = ["Webkit", "ms", "Moz", "O"];
  Object.keys(st).forEach(function(s) {
    at.forEach(function(l) {
      l = l + s.charAt(0).toUpperCase() + s.substring(1), st[l] = st[s];
    });
  });
  function Vt(s, l, y) {
    return l == null || typeof l == "boolean" || l === "" ? "" : y || typeof l != "number" || l === 0 || st.hasOwnProperty(s) && st[s] ? ("" + l).trim() : l + "px";
  }
  function Y(s, l) {
    s = s.style;
    for (var y in l) if (l.hasOwnProperty(y)) {
      var E = y.indexOf("--") === 0, I = Vt(y, l[y], E);
      y === "float" && (y = "cssFloat"), E ? s.setProperty(y, I) : s[y] = I;
    }
  }
  var Ie = te({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function Le(s, l) {
    if (l) {
      if (Ie[s] && (l.children != null || l.dangerouslySetInnerHTML != null)) throw Error(r(137, s));
      if (l.dangerouslySetInnerHTML != null) {
        if (l.children != null) throw Error(r(60));
        if (typeof l.dangerouslySetInnerHTML != "object" || !("__html" in l.dangerouslySetInnerHTML)) throw Error(r(61));
      }
      if (l.style != null && typeof l.style != "object") throw Error(r(62));
    }
  }
  function Me(s, l) {
    if (s.indexOf("-") === -1) return typeof l.is == "string";
    switch (s) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var ze = null;
  function He(s) {
    return s = s.target || s.srcElement || window, s.correspondingUseElement && (s = s.correspondingUseElement), s.nodeType === 3 ? s.parentNode : s;
  }
  var rt = null, Ye = null, Ze = null;
  function Ge(s) {
    if (s = Na(s)) {
      if (typeof rt != "function") throw Error(r(280));
      var l = s.stateNode;
      l && (l = fc(l), rt(s.stateNode, s.type, l));
    }
  }
  function bt(s) {
    Ye ? Ze ? Ze.push(s) : Ze = [s] : Ye = s;
  }
  function kt() {
    if (Ye) {
      var s = Ye, l = Ze;
      if (Ze = Ye = null, Ge(s), l) for (s = 0; s < l.length; s++) Ge(l[s]);
    }
  }
  function Tt(s, l) {
    return s(l);
  }
  function It() {
  }
  var Xr = !1;
  function er(s, l, y) {
    if (Xr) return s(l, y);
    Xr = !0;
    try {
      return Tt(s, l, y);
    } finally {
      Xr = !1, (Ye !== null || Ze !== null) && (It(), kt());
    }
  }
  function Xi(s, l) {
    var y = s.stateNode;
    if (y === null) return null;
    var E = fc(y);
    if (E === null) return null;
    y = E[l];
    e: switch (l) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (E = !E.disabled) || (s = s.type, E = !(s === "button" || s === "input" || s === "select" || s === "textarea")), s = !E;
        break e;
      default:
        s = !1;
    }
    if (s) return null;
    if (y && typeof y != "function") throw Error(r(231, l, typeof y));
    return y;
  }
  var Ns = !1;
  if (u) try {
    var Ji = {};
    Object.defineProperty(Ji, "passive", { get: function() {
      Ns = !0;
    } }), window.addEventListener("test", Ji, Ji), window.removeEventListener("test", Ji, Ji);
  } catch {
    Ns = !1;
  }
  function Kp(s, l, y, E, I, M, G, de, be) {
    var Re = Array.prototype.slice.call(arguments, 3);
    try {
      l.apply(y, Re);
    } catch (Be) {
      this.onError(Be);
    }
  }
  var js = !1, In = null, Zi = !1, ya = null, xl = { onError: function(s) {
    js = !0, In = s;
  } };
  function cr(s, l, y, E, I, M, G, de, be) {
    js = !1, In = null, Kp.apply(xl, arguments);
  }
  function Wu(s, l, y, E, I, M, G, de, be) {
    if (cr.apply(this, arguments), js) {
      if (js) {
        var Re = In;
        js = !1, In = null;
      } else throw Error(r(198));
      Zi || (Zi = !0, ya = Re);
    }
  }
  function Ht(s) {
    var l = s, y = s;
    if (s.alternate) for (; l.return; ) l = l.return;
    else {
      s = l;
      do
        l = s, (l.flags & 4098) !== 0 && (y = l.return), s = l.return;
      while (s);
    }
    return l.tag === 3 ? y : null;
  }
  function va(s) {
    if (s.tag === 13) {
      var l = s.memoizedState;
      if (l === null && (s = s.alternate, s !== null && (l = s.memoizedState)), l !== null) return l.dehydrated;
    }
    return null;
  }
  function Xt(s) {
    if (Ht(s) !== s) throw Error(r(188));
  }
  function Ls(s) {
    var l = s.alternate;
    if (!l) {
      if (l = Ht(s), l === null) throw Error(r(188));
      return l !== s ? null : s;
    }
    for (var y = s, E = l; ; ) {
      var I = y.return;
      if (I === null) break;
      var M = I.alternate;
      if (M === null) {
        if (E = I.return, E !== null) {
          y = E;
          continue;
        }
        break;
      }
      if (I.child === M.child) {
        for (M = I.child; M; ) {
          if (M === y) return Xt(I), s;
          if (M === E) return Xt(I), l;
          M = M.sibling;
        }
        throw Error(r(188));
      }
      if (y.return !== E.return) y = I, E = M;
      else {
        for (var G = !1, de = I.child; de; ) {
          if (de === y) {
            G = !0, y = I, E = M;
            break;
          }
          if (de === E) {
            G = !0, E = I, y = M;
            break;
          }
          de = de.sibling;
        }
        if (!G) {
          for (de = M.child; de; ) {
            if (de === y) {
              G = !0, y = M, E = I;
              break;
            }
            if (de === E) {
              G = !0, E = M, y = I;
              break;
            }
            de = de.sibling;
          }
          if (!G) throw Error(r(189));
        }
      }
      if (y.alternate !== E) throw Error(r(190));
    }
    if (y.tag !== 3) throw Error(r(188));
    return y.stateNode.current === y ? s : l;
  }
  function Ms(s) {
    return s = Ls(s), s !== null ? es(s) : null;
  }
  function es(s) {
    if (s.tag === 5 || s.tag === 6) return s;
    for (s = s.child; s !== null; ) {
      var l = es(s);
      if (l !== null) return l;
      s = s.sibling;
    }
    return null;
  }
  var Eo = t.unstable_scheduleCallback, ba = t.unstable_cancelCallback, _l = t.unstable_shouldYield, Nn = t.unstable_requestPaint, Kt = t.unstable_now, ri = t.unstable_getCurrentPriorityLevel, Ds = t.unstable_ImmediatePriority, bi = t.unstable_UserBlockingPriority, jn = t.unstable_NormalPriority, Oo = t.unstable_LowPriority, ts = t.unstable_IdlePriority, rs = null, Jr = null;
  function Ku(s) {
    if (Jr && typeof Jr.onCommitFiberRoot == "function") try {
      Jr.onCommitFiberRoot(rs, s, void 0, (s.current.flags & 128) === 128);
    } catch {
    }
  }
  var Mr = Math.clz32 ? Math.clz32 : is, ns = Math.log, wi = Math.LN2;
  function is(s) {
    return s >>>= 0, s === 0 ? 32 : 31 - (ns(s) / wi | 0) | 0;
  }
  var Fs = 64, qs = 4194304;
  function Si(s) {
    switch (s & -s) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return s & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return s & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return s;
    }
  }
  function ss(s, l) {
    var y = s.pendingLanes;
    if (y === 0) return 0;
    var E = 0, I = s.suspendedLanes, M = s.pingedLanes, G = y & 268435455;
    if (G !== 0) {
      var de = G & ~I;
      de !== 0 ? E = Si(de) : (M &= G, M !== 0 && (E = Si(M)));
    } else G = y & ~I, G !== 0 ? E = Si(G) : M !== 0 && (E = Si(M));
    if (E === 0) return 0;
    if (l !== 0 && l !== E && (l & I) === 0 && (I = E & -E, M = l & -l, I >= M || I === 16 && (M & 4194240) !== 0)) return l;
    if ((E & 4) !== 0 && (E |= y & 16), l = s.entangledLanes, l !== 0) for (s = s.entanglements, l &= E; 0 < l; ) y = 31 - Mr(l), I = 1 << y, E |= s[y], l &= ~I;
    return E;
  }
  function El(s, l) {
    switch (s) {
      case 1:
      case 2:
      case 4:
        return l + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function ko(s, l) {
    for (var y = s.suspendedLanes, E = s.pingedLanes, I = s.expirationTimes, M = s.pendingLanes; 0 < M; ) {
      var G = 31 - Mr(M), de = 1 << G, be = I[G];
      be === -1 ? ((de & y) === 0 || (de & E) !== 0) && (I[G] = El(de, l)) : be <= l && (s.expiredLanes |= de), M &= ~de;
    }
  }
  function Ln(s) {
    return s = s.pendingLanes & -1073741825, s !== 0 ? s : s & 1073741824 ? 1073741824 : 0;
  }
  function Mn() {
    var s = Fs;
    return Fs <<= 1, (Fs & 4194240) === 0 && (Fs = 64), s;
  }
  function Dn(s) {
    for (var l = [], y = 0; 31 > y; y++) l.push(s);
    return l;
  }
  function xi(s, l, y) {
    s.pendingLanes |= l, l !== 536870912 && (s.suspendedLanes = 0, s.pingedLanes = 0), s = s.eventTimes, l = 31 - Mr(l), s[l] = y;
  }
  function os(s, l) {
    var y = s.pendingLanes & ~l;
    s.pendingLanes = l, s.suspendedLanes = 0, s.pingedLanes = 0, s.expiredLanes &= l, s.mutableReadLanes &= l, s.entangledLanes &= l, l = s.entanglements;
    var E = s.eventTimes;
    for (s = s.expirationTimes; 0 < y; ) {
      var I = 31 - Mr(y), M = 1 << I;
      l[I] = 0, E[I] = -1, s[I] = -1, y &= ~M;
    }
  }
  function wa(s, l) {
    var y = s.entangledLanes |= l;
    for (s = s.entanglements; y; ) {
      var E = 31 - Mr(y), I = 1 << E;
      I & l | s[E] & l && (s[E] |= l), y &= ~I;
    }
  }
  var Lt = 0;
  function ni(s) {
    return s &= -s, 1 < s ? 4 < s ? (s & 268435455) !== 0 ? 16 : 536870912 : 4 : 1;
  }
  var Ol, _i, Sa, kl, mr, Ei = !1, xa = [], ii = null, Fn = null, qn = null, zs = /* @__PURE__ */ new Map(), Ao = /* @__PURE__ */ new Map(), br = [], Po = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function _a(s, l) {
    switch (s) {
      case "focusin":
      case "focusout":
        ii = null;
        break;
      case "dragenter":
      case "dragleave":
        Fn = null;
        break;
      case "mouseover":
      case "mouseout":
        qn = null;
        break;
      case "pointerover":
      case "pointerout":
        zs.delete(l.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Ao.delete(l.pointerId);
    }
  }
  function si(s, l, y, E, I, M) {
    return s === null || s.nativeEvent !== M ? (s = { blockedOn: l, domEventName: y, eventSystemFlags: E, nativeEvent: M, targetContainers: [I] }, l !== null && (l = Na(l), l !== null && _i(l)), s) : (s.eventSystemFlags |= E, l = s.targetContainers, I !== null && l.indexOf(I) === -1 && l.push(I), s);
  }
  function Oi(s, l, y, E, I) {
    switch (l) {
      case "focusin":
        return ii = si(ii, s, l, y, E, I), !0;
      case "dragenter":
        return Fn = si(Fn, s, l, y, E, I), !0;
      case "mouseover":
        return qn = si(qn, s, l, y, E, I), !0;
      case "pointerover":
        var M = I.pointerId;
        return zs.set(M, si(zs.get(M) || null, s, l, y, E, I)), !0;
      case "gotpointercapture":
        return M = I.pointerId, Ao.set(M, si(Ao.get(M) || null, s, l, y, E, I)), !0;
    }
    return !1;
  }
  function To(s) {
    var l = Ks(s.target);
    if (l !== null) {
      var y = Ht(l);
      if (y !== null) {
        if (l = y.tag, l === 13) {
          if (l = va(y), l !== null) {
            s.blockedOn = l, mr(s.priority, function() {
              Sa(y);
            });
            return;
          }
        } else if (l === 3 && y.stateNode.current.memoizedState.isDehydrated) {
          s.blockedOn = y.tag === 3 ? y.stateNode.containerInfo : null;
          return;
        }
      }
    }
    s.blockedOn = null;
  }
  function ln(s) {
    if (s.blockedOn !== null) return !1;
    for (var l = s.targetContainers; 0 < l.length; ) {
      var y = wr(s.domEventName, s.eventSystemFlags, l[0], s.nativeEvent);
      if (y === null) {
        y = s.nativeEvent;
        var E = new y.constructor(y.type, y);
        ze = E, y.target.dispatchEvent(E), ze = null;
      } else return l = Na(y), l !== null && _i(l), s.blockedOn = y, !1;
      l.shift();
    }
    return !0;
  }
  function Al(s, l, y) {
    ln(s) && y.delete(l);
  }
  function Ea() {
    Ei = !1, ii !== null && ln(ii) && (ii = null), Fn !== null && ln(Fn) && (Fn = null), qn !== null && ln(qn) && (qn = null), zs.forEach(Al), Ao.forEach(Al);
  }
  function ki(s, l) {
    s.blockedOn === l && (s.blockedOn = null, Ei || (Ei = !0, t.unstable_scheduleCallback(t.unstable_NormalPriority, Ea)));
  }
  function oi(s) {
    function l(I) {
      return ki(I, s);
    }
    if (0 < xa.length) {
      ki(xa[0], s);
      for (var y = 1; y < xa.length; y++) {
        var E = xa[y];
        E.blockedOn === s && (E.blockedOn = null);
      }
    }
    for (ii !== null && ki(ii, s), Fn !== null && ki(Fn, s), qn !== null && ki(qn, s), zs.forEach(l), Ao.forEach(l), y = 0; y < br.length; y++) E = br[y], E.blockedOn === s && (E.blockedOn = null);
    for (; 0 < br.length && (y = br[0], y.blockedOn === null); ) To(y), y.blockedOn === null && br.shift();
  }
  var as = R.ReactCurrentBatchConfig, ft = !0;
  function _e(s, l, y, E) {
    var I = Lt, M = as.transition;
    as.transition = null;
    try {
      Lt = 1, lt(s, l, y, E);
    } finally {
      Lt = I, as.transition = M;
    }
  }
  function Ke(s, l, y, E) {
    var I = Lt, M = as.transition;
    as.transition = null;
    try {
      Lt = 4, lt(s, l, y, E);
    } finally {
      Lt = I, as.transition = M;
    }
  }
  function lt(s, l, y, E) {
    if (ft) {
      var I = wr(s, l, y, E);
      if (I === null) ac(s, l, E, qt, y), _a(s, E);
      else if (Oi(I, s, l, y, E)) E.stopPropagation();
      else if (_a(s, E), l & 4 && -1 < Po.indexOf(s)) {
        for (; I !== null; ) {
          var M = Na(I);
          if (M !== null && Ol(M), M = wr(s, l, y, E), M === null && ac(s, l, E, qt, y), M === I) break;
          I = M;
        }
        I !== null && E.stopPropagation();
      } else ac(s, l, E, null, y);
    }
  }
  var qt = null;
  function wr(s, l, y, E) {
    if (qt = null, s = He(E), s = Ks(s), s !== null) if (l = Ht(s), l === null) s = null;
    else if (y = l.tag, y === 13) {
      if (s = va(l), s !== null) return s;
      s = null;
    } else if (y === 3) {
      if (l.stateNode.current.memoizedState.isDehydrated) return l.tag === 3 ? l.stateNode.containerInfo : null;
      s = null;
    } else l !== s && (s = null);
    return qt = s, null;
  }
  function Sr(s) {
    switch (s) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (ri()) {
          case Ds:
            return 1;
          case bi:
            return 4;
          case jn:
          case Oo:
            return 16;
          case ts:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var tr = null, Ut = null, Ai = null;
  function Or() {
    if (Ai) return Ai;
    var s, l = Ut, y = l.length, E, I = "value" in tr ? tr.value : tr.textContent, M = I.length;
    for (s = 0; s < y && l[s] === I[s]; s++) ;
    var G = y - s;
    for (E = 1; E <= G && l[y - E] === I[M - E]; E++) ;
    return Ai = I.slice(s, 1 < E ? 1 - E : void 0);
  }
  function Co(s) {
    var l = s.keyCode;
    return "charCode" in s ? (s = s.charCode, s === 0 && l === 13 && (s = 13)) : s = l, s === 10 && (s = 13), 32 <= s || s === 13 ? s : 0;
  }
  function Dt() {
    return !0;
  }
  function Ch() {
    return !1;
  }
  function wn(s) {
    function l(y, E, I, M, G) {
      this._reactName = y, this._targetInst = I, this.type = E, this.nativeEvent = M, this.target = G, this.currentTarget = null;
      for (var de in s) s.hasOwnProperty(de) && (y = s[de], this[de] = y ? y(M) : M[de]);
      return this.isDefaultPrevented = (M.defaultPrevented != null ? M.defaultPrevented : M.returnValue === !1) ? Dt : Ch, this.isPropagationStopped = Ch, this;
    }
    return te(l.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var y = this.nativeEvent;
      y && (y.preventDefault ? y.preventDefault() : typeof y.returnValue != "unknown" && (y.returnValue = !1), this.isDefaultPrevented = Dt);
    }, stopPropagation: function() {
      var y = this.nativeEvent;
      y && (y.stopPropagation ? y.stopPropagation() : typeof y.cancelBubble != "unknown" && (y.cancelBubble = !0), this.isPropagationStopped = Dt);
    }, persist: function() {
    }, isPersistent: Dt }), l;
  }
  var $o = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(s) {
    return s.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, Oa = wn($o), Pl = te({}, $o, { view: 0, detail: 0 }), db = wn(Pl), Qp, ka, Aa, Ro = te({}, Pl, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Zp, button: 0, buttons: 0, relatedTarget: function(s) {
    return s.relatedTarget === void 0 ? s.fromElement === s.srcElement ? s.toElement : s.fromElement : s.relatedTarget;
  }, movementX: function(s) {
    return "movementX" in s ? s.movementX : (s !== Aa && (Aa && s.type === "mousemove" ? (Qp = s.screenX - Aa.screenX, ka = s.screenY - Aa.screenY) : ka = Qp = 0, Aa = s), Qp);
  }, movementY: function(s) {
    return "movementY" in s ? s.movementY : ka;
  } }), Yp = wn(Ro), $h = te({}, Ro, { dataTransfer: 0 }), Gp = wn($h), wt = te({}, Pl, { relatedTarget: 0 }), tt = wn(wt), hb = te({}, $o, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Rh = wn(hb), Bs = te({}, $o, { clipboardData: function(s) {
    return "clipboardData" in s ? s.clipboardData : window.clipboardData;
  } }), Xp = wn(Bs), Ih = te({}, $o, { data: 0 }), Jp = wn(Ih), Us = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Qu = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Nh = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function ht(s) {
    var l = this.nativeEvent;
    return l.getModifierState ? l.getModifierState(s) : (s = Nh[s]) ? !!l[s] : !1;
  }
  function Zp() {
    return ht;
  }
  var mb = te({}, Pl, { key: function(s) {
    if (s.key) {
      var l = Us[s.key] || s.key;
      if (l !== "Unidentified") return l;
    }
    return s.type === "keypress" ? (s = Co(s), s === 13 ? "Enter" : String.fromCharCode(s)) : s.type === "keydown" || s.type === "keyup" ? Qu[s.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Zp, charCode: function(s) {
    return s.type === "keypress" ? Co(s) : 0;
  }, keyCode: function(s) {
    return s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0;
  }, which: function(s) {
    return s.type === "keypress" ? Co(s) : s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0;
  } }), gb = wn(mb), jh = te({}, Ro, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Lh = wn(jh), yb = te({}, Pl, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Zp }), Mh = wn(yb), Dh = te({}, $o, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), vb = wn(Dh), Fh = te({}, Ro, {
    deltaX: function(s) {
      return "deltaX" in s ? s.deltaX : "wheelDeltaX" in s ? -s.wheelDeltaX : 0;
    },
    deltaY: function(s) {
      return "deltaY" in s ? s.deltaY : "wheelDeltaY" in s ? -s.wheelDeltaY : "wheelDelta" in s ? -s.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), qh = wn(Fh), ef = [9, 13, 27, 32], tf = u && "CompositionEvent" in window, Pi = null;
  u && "documentMode" in document && (Pi = document.documentMode);
  var bb = u && "TextEvent" in window && !Pi, rf = u && (!tf || Pi && 8 < Pi && 11 >= Pi), zh = " ", Bh = !1;
  function Uh(s, l) {
    switch (s) {
      case "keyup":
        return ef.indexOf(l.keyCode) !== -1;
      case "keydown":
        return l.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function nf(s) {
    return s = s.detail, typeof s == "object" && "data" in s ? s.data : null;
  }
  var Pa = !1;
  function wb(s, l) {
    switch (s) {
      case "compositionend":
        return nf(l);
      case "keypress":
        return l.which !== 32 ? null : (Bh = !0, zh);
      case "textInput":
        return s = l.data, s === zh && Bh ? null : s;
      default:
        return null;
    }
  }
  function Vh(s, l) {
    if (Pa) return s === "compositionend" || !tf && Uh(s, l) ? (s = Or(), Ai = Ut = tr = null, Pa = !1, s) : null;
    switch (s) {
      case "paste":
        return null;
      case "keypress":
        if (!(l.ctrlKey || l.altKey || l.metaKey) || l.ctrlKey && l.altKey) {
          if (l.char && 1 < l.char.length) return l.char;
          if (l.which) return String.fromCharCode(l.which);
        }
        return null;
      case "compositionend":
        return rf && l.locale !== "ko" ? null : l.data;
      default:
        return null;
    }
  }
  var Hh = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function sf(s) {
    var l = s && s.nodeName && s.nodeName.toLowerCase();
    return l === "input" ? !!Hh[s.type] : l === "textarea";
  }
  function Wh(s, l, y, E) {
    bt(E), l = lc(l, "onChange"), 0 < l.length && (y = new Oa("onChange", "change", null, y, E), s.push({ event: y, listeners: l }));
  }
  var Tl = null, Cl = null;
  function Kh(s) {
    No(s, 0);
  }
  function Yu(s) {
    var l = ja(s);
    if (oe(l)) return s;
  }
  function Sb(s, l) {
    if (s === "change") return l;
  }
  var of = !1;
  if (u) {
    var af;
    if (u) {
      var Gu = "oninput" in document;
      if (!Gu) {
        var $l = document.createElement("div");
        $l.setAttribute("oninput", "return;"), Gu = typeof $l.oninput == "function";
      }
      af = Gu;
    } else af = !1;
    of = af && (!document.documentMode || 9 < document.documentMode);
  }
  function Qh() {
    Tl && (Tl.detachEvent("onpropertychange", Yh), Cl = Tl = null);
  }
  function Yh(s) {
    if (s.propertyName === "value" && Yu(Cl)) {
      var l = [];
      Wh(l, Cl, s, He(s)), er(Kh, l);
    }
  }
  function xb(s, l, y) {
    s === "focusin" ? (Qh(), Tl = l, Cl = y, Tl.attachEvent("onpropertychange", Yh)) : s === "focusout" && Qh();
  }
  function Xu(s) {
    if (s === "selectionchange" || s === "keyup" || s === "keydown") return Yu(Cl);
  }
  function Gh(s, l) {
    if (s === "click") return Yu(l);
  }
  function Xh(s, l) {
    if (s === "input" || s === "change") return Yu(l);
  }
  function Jh(s, l) {
    return s === l && (s !== 0 || 1 / s === 1 / l) || s !== s && l !== l;
  }
  var kr = typeof Object.is == "function" ? Object.is : Jh;
  function Vs(s, l) {
    if (kr(s, l)) return !0;
    if (typeof s != "object" || s === null || typeof l != "object" || l === null) return !1;
    var y = Object.keys(s), E = Object.keys(l);
    if (y.length !== E.length) return !1;
    for (E = 0; E < y.length; E++) {
      var I = y[E];
      if (!c.call(l, I) || !kr(s[I], l[I])) return !1;
    }
    return !0;
  }
  function Rl(s) {
    for (; s && s.firstChild; ) s = s.firstChild;
    return s;
  }
  function Il(s, l) {
    var y = Rl(s);
    s = 0;
    for (var E; y; ) {
      if (y.nodeType === 3) {
        if (E = s + y.textContent.length, s <= l && E >= l) return { node: y, offset: l - s };
        s = E;
      }
      e: {
        for (; y; ) {
          if (y.nextSibling) {
            y = y.nextSibling;
            break e;
          }
          y = y.parentNode;
        }
        y = void 0;
      }
      y = Rl(y);
    }
  }
  function Nl(s, l) {
    return s && l ? s === l ? !0 : s && s.nodeType === 3 ? !1 : l && l.nodeType === 3 ? Nl(s, l.parentNode) : "contains" in s ? s.contains(l) : s.compareDocumentPosition ? !!(s.compareDocumentPosition(l) & 16) : !1 : !1;
  }
  function lf() {
    for (var s = window, l = ie(); l instanceof s.HTMLIFrameElement; ) {
      try {
        var y = typeof l.contentWindow.location.href == "string";
      } catch {
        y = !1;
      }
      if (y) s = l.contentWindow;
      else break;
      l = ie(s.document);
    }
    return l;
  }
  function Ju(s) {
    var l = s && s.nodeName && s.nodeName.toLowerCase();
    return l && (l === "input" && (s.type === "text" || s.type === "search" || s.type === "tel" || s.type === "url" || s.type === "password") || l === "textarea" || s.contentEditable === "true");
  }
  function _b(s) {
    var l = lf(), y = s.focusedElem, E = s.selectionRange;
    if (l !== y && y && y.ownerDocument && Nl(y.ownerDocument.documentElement, y)) {
      if (E !== null && Ju(y)) {
        if (l = E.start, s = E.end, s === void 0 && (s = l), "selectionStart" in y) y.selectionStart = l, y.selectionEnd = Math.min(s, y.value.length);
        else if (s = (l = y.ownerDocument || document) && l.defaultView || window, s.getSelection) {
          s = s.getSelection();
          var I = y.textContent.length, M = Math.min(E.start, I);
          E = E.end === void 0 ? M : Math.min(E.end, I), !s.extend && M > E && (I = E, E = M, M = I), I = Il(y, M);
          var G = Il(
            y,
            E
          );
          I && G && (s.rangeCount !== 1 || s.anchorNode !== I.node || s.anchorOffset !== I.offset || s.focusNode !== G.node || s.focusOffset !== G.offset) && (l = l.createRange(), l.setStart(I.node, I.offset), s.removeAllRanges(), M > E ? (s.addRange(l), s.extend(G.node, G.offset)) : (l.setEnd(G.node, G.offset), s.addRange(l)));
        }
      }
      for (l = [], s = y; s = s.parentNode; ) s.nodeType === 1 && l.push({ element: s, left: s.scrollLeft, top: s.scrollTop });
      for (typeof y.focus == "function" && y.focus(), y = 0; y < l.length; y++) s = l[y], s.element.scrollLeft = s.left, s.element.scrollTop = s.top;
    }
  }
  var Eb = u && "documentMode" in document && 11 >= document.documentMode, Ta = null, Ca = null, $a = null, Zu = !1;
  function uf(s, l, y) {
    var E = y.window === y ? y.document : y.nodeType === 9 ? y : y.ownerDocument;
    Zu || Ta == null || Ta !== ie(E) || (E = Ta, "selectionStart" in E && Ju(E) ? E = { start: E.selectionStart, end: E.selectionEnd } : (E = (E.ownerDocument && E.ownerDocument.defaultView || window).getSelection(), E = { anchorNode: E.anchorNode, anchorOffset: E.anchorOffset, focusNode: E.focusNode, focusOffset: E.focusOffset }), $a && Vs($a, E) || ($a = E, E = lc(Ca, "onSelect"), 0 < E.length && (l = new Oa("onSelect", "select", null, l, y), s.push({ event: l, listeners: E }), l.target = Ta)));
  }
  function ls(s, l) {
    var y = {};
    return y[s.toLowerCase()] = l.toLowerCase(), y["Webkit" + s] = "webkit" + l, y["Moz" + s] = "moz" + l, y;
  }
  var Hs = { animationend: ls("Animation", "AnimationEnd"), animationiteration: ls("Animation", "AnimationIteration"), animationstart: ls("Animation", "AnimationStart"), transitionend: ls("Transition", "TransitionEnd") }, ec = {}, tc = {};
  u && (tc = document.createElement("div").style, "AnimationEvent" in window || (delete Hs.animationend.animation, delete Hs.animationiteration.animation, delete Hs.animationstart.animation), "TransitionEvent" in window || delete Hs.transitionend.transition);
  function Ra(s) {
    if (ec[s]) return ec[s];
    if (!Hs[s]) return s;
    var l = Hs[s], y;
    for (y in l) if (l.hasOwnProperty(y) && y in tc) return ec[s] = l[y];
    return s;
  }
  var cf = Ra("animationend"), pf = Ra("animationiteration"), rc = Ra("animationstart"), Io = Ra("transitionend"), Zh = /* @__PURE__ */ new Map(), em = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ai(s, l) {
    Zh.set(s, l), a(l, [s]);
  }
  for (var nc = 0; nc < em.length; nc++) {
    var Zr = em[nc], tm = Zr.toLowerCase(), ff = Zr[0].toUpperCase() + Zr.slice(1);
    ai(tm, "on" + ff);
  }
  ai(cf, "onAnimationEnd"), ai(pf, "onAnimationIteration"), ai(rc, "onAnimationStart"), ai("dblclick", "onDoubleClick"), ai("focusin", "onFocus"), ai("focusout", "onBlur"), ai(Io, "onTransitionEnd"), i("onMouseEnter", ["mouseout", "mouseover"]), i("onMouseLeave", ["mouseout", "mouseover"]), i("onPointerEnter", ["pointerout", "pointerover"]), i("onPointerLeave", ["pointerout", "pointerover"]), a("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), a("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), a("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), a("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), a("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), a("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var jl = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Ob = new Set("cancel close invalid load scroll toggle".split(" ").concat(jl));
  function ic(s, l, y) {
    var E = s.type || "unknown-event";
    s.currentTarget = y, Wu(E, l, void 0, s), s.currentTarget = null;
  }
  function No(s, l) {
    l = (l & 4) !== 0;
    for (var y = 0; y < s.length; y++) {
      var E = s[y], I = E.event;
      E = E.listeners;
      e: {
        var M = void 0;
        if (l) for (var G = E.length - 1; 0 <= G; G--) {
          var de = E[G], be = de.instance, Re = de.currentTarget;
          if (de = de.listener, be !== M && I.isPropagationStopped()) break e;
          ic(I, de, Re), M = be;
        }
        else for (G = 0; G < E.length; G++) {
          if (de = E[G], be = de.instance, Re = de.currentTarget, de = de.listener, be !== M && I.isPropagationStopped()) break e;
          ic(I, de, Re), M = be;
        }
      }
    }
    if (Zi) throw s = ya, Zi = !1, ya = null, s;
  }
  function Qt(s, l) {
    var y = l[yf];
    y === void 0 && (y = l[yf] = /* @__PURE__ */ new Set());
    var E = s + "__bubble";
    y.has(E) || (rm(l, s, 2, !1), y.add(E));
  }
  function sc(s, l, y) {
    var E = 0;
    l && (E |= 4), rm(y, s, E, l);
  }
  var oc = "_reactListening" + Math.random().toString(36).slice(2);
  function Ll(s) {
    if (!s[oc]) {
      s[oc] = !0, n.forEach(function(y) {
        y !== "selectionchange" && (Ob.has(y) || sc(y, !1, s), sc(y, !0, s));
      });
      var l = s.nodeType === 9 ? s : s.ownerDocument;
      l === null || l[oc] || (l[oc] = !0, sc("selectionchange", !1, l));
    }
  }
  function rm(s, l, y, E) {
    switch (Sr(l)) {
      case 1:
        var I = _e;
        break;
      case 4:
        I = Ke;
        break;
      default:
        I = lt;
    }
    y = I.bind(null, l, y, s), I = void 0, !Ns || l !== "touchstart" && l !== "touchmove" && l !== "wheel" || (I = !0), E ? I !== void 0 ? s.addEventListener(l, y, { capture: !0, passive: I }) : s.addEventListener(l, y, !0) : I !== void 0 ? s.addEventListener(l, y, { passive: I }) : s.addEventListener(l, y, !1);
  }
  function ac(s, l, y, E, I) {
    var M = E;
    if ((l & 1) === 0 && (l & 2) === 0 && E !== null) e: for (; ; ) {
      if (E === null) return;
      var G = E.tag;
      if (G === 3 || G === 4) {
        var de = E.stateNode.containerInfo;
        if (de === I || de.nodeType === 8 && de.parentNode === I) break;
        if (G === 4) for (G = E.return; G !== null; ) {
          var be = G.tag;
          if ((be === 3 || be === 4) && (be = G.stateNode.containerInfo, be === I || be.nodeType === 8 && be.parentNode === I)) return;
          G = G.return;
        }
        for (; de !== null; ) {
          if (G = Ks(de), G === null) return;
          if (be = G.tag, be === 5 || be === 6) {
            E = M = G;
            continue e;
          }
          de = de.parentNode;
        }
      }
      E = E.return;
    }
    er(function() {
      var Re = M, Be = He(y), We = [];
      e: {
        var Ue = Zh.get(s);
        if (Ue !== void 0) {
          var et = Oa, ut = s;
          switch (s) {
            case "keypress":
              if (Co(y) === 0) break e;
            case "keydown":
            case "keyup":
              et = gb;
              break;
            case "focusin":
              ut = "focus", et = tt;
              break;
            case "focusout":
              ut = "blur", et = tt;
              break;
            case "beforeblur":
            case "afterblur":
              et = tt;
              break;
            case "click":
              if (y.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              et = Yp;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              et = Gp;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              et = Mh;
              break;
            case cf:
            case pf:
            case rc:
              et = Rh;
              break;
            case Io:
              et = vb;
              break;
            case "scroll":
              et = db;
              break;
            case "wheel":
              et = qh;
              break;
            case "copy":
            case "cut":
            case "paste":
              et = Xp;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              et = Lh;
          }
          var pt = (l & 4) !== 0, gr = !pt && s === "scroll", Ae = pt ? Ue !== null ? Ue + "Capture" : null : Ue;
          pt = [];
          for (var Ee = Re, Ce; Ee !== null; ) {
            Ce = Ee;
            var Qe = Ce.stateNode;
            if (Ce.tag === 5 && Qe !== null && (Ce = Qe, Ae !== null && (Qe = Xi(Ee, Ae), Qe != null && pt.push(Ml(Ee, Qe, Ce)))), gr) break;
            Ee = Ee.return;
          }
          0 < pt.length && (Ue = new et(Ue, ut, null, y, Be), We.push({ event: Ue, listeners: pt }));
        }
      }
      if ((l & 7) === 0) {
        e: {
          if (Ue = s === "mouseover" || s === "pointerover", et = s === "mouseout" || s === "pointerout", Ue && y !== ze && (ut = y.relatedTarget || y.fromElement) && (Ks(ut) || ut[Ti])) break e;
          if ((et || Ue) && (Ue = Be.window === Be ? Be : (Ue = Be.ownerDocument) ? Ue.defaultView || Ue.parentWindow : window, et ? (ut = y.relatedTarget || y.toElement, et = Re, ut = ut ? Ks(ut) : null, ut !== null && (gr = Ht(ut), ut !== gr || ut.tag !== 5 && ut.tag !== 6) && (ut = null)) : (et = null, ut = Re), et !== ut)) {
            if (pt = Yp, Qe = "onMouseLeave", Ae = "onMouseEnter", Ee = "mouse", (s === "pointerout" || s === "pointerover") && (pt = Lh, Qe = "onPointerLeave", Ae = "onPointerEnter", Ee = "pointer"), gr = et == null ? Ue : ja(et), Ce = ut == null ? Ue : ja(ut), Ue = new pt(Qe, Ee + "leave", et, y, Be), Ue.target = gr, Ue.relatedTarget = Ce, Qe = null, Ks(Be) === Re && (pt = new pt(Ae, Ee + "enter", ut, y, Be), pt.target = Ce, pt.relatedTarget = gr, Qe = pt), gr = Qe, et && ut) t: {
              for (pt = et, Ae = ut, Ee = 0, Ce = pt; Ce; Ce = jo(Ce)) Ee++;
              for (Ce = 0, Qe = Ae; Qe; Qe = jo(Qe)) Ce++;
              for (; 0 < Ee - Ce; ) pt = jo(pt), Ee--;
              for (; 0 < Ce - Ee; ) Ae = jo(Ae), Ce--;
              for (; Ee--; ) {
                if (pt === Ae || Ae !== null && pt === Ae.alternate) break t;
                pt = jo(pt), Ae = jo(Ae);
              }
              pt = null;
            }
            else pt = null;
            et !== null && df(We, Ue, et, pt, !1), ut !== null && gr !== null && df(We, gr, ut, pt, !0);
          }
        }
        e: {
          if (Ue = Re ? ja(Re) : window, et = Ue.nodeName && Ue.nodeName.toLowerCase(), et === "select" || et === "input" && Ue.type === "file") var ot = Sb;
          else if (sf(Ue)) if (of) ot = Xh;
          else {
            ot = Xu;
            var yt = xb;
          }
          else (et = Ue.nodeName) && et.toLowerCase() === "input" && (Ue.type === "checkbox" || Ue.type === "radio") && (ot = Gh);
          if (ot && (ot = ot(s, Re))) {
            Wh(We, ot, y, Be);
            break e;
          }
          yt && yt(s, Ue, Re), s === "focusout" && (yt = Ue._wrapperState) && yt.controlled && Ue.type === "number" && qe(Ue, "number", Ue.value);
        }
        switch (yt = Re ? ja(Re) : window, s) {
          case "focusin":
            (sf(yt) || yt.contentEditable === "true") && (Ta = yt, Ca = Re, $a = null);
            break;
          case "focusout":
            $a = Ca = Ta = null;
            break;
          case "mousedown":
            Zu = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Zu = !1, uf(We, y, Be);
            break;
          case "selectionchange":
            if (Eb) break;
          case "keydown":
          case "keyup":
            uf(We, y, Be);
        }
        var vt;
        if (tf) e: {
          switch (s) {
            case "compositionstart":
              var xt = "onCompositionStart";
              break e;
            case "compositionend":
              xt = "onCompositionEnd";
              break e;
            case "compositionupdate":
              xt = "onCompositionUpdate";
              break e;
          }
          xt = void 0;
        }
        else Pa ? Uh(s, y) && (xt = "onCompositionEnd") : s === "keydown" && y.keyCode === 229 && (xt = "onCompositionStart");
        xt && (rf && y.locale !== "ko" && (Pa || xt !== "onCompositionStart" ? xt === "onCompositionEnd" && Pa && (vt = Or()) : (tr = Be, Ut = "value" in tr ? tr.value : tr.textContent, Pa = !0)), yt = lc(Re, xt), 0 < yt.length && (xt = new Jp(xt, s, null, y, Be), We.push({ event: xt, listeners: yt }), vt ? xt.data = vt : (vt = nf(y), vt !== null && (xt.data = vt)))), (vt = bb ? wb(s, y) : Vh(s, y)) && (Re = lc(Re, "onBeforeInput"), 0 < Re.length && (Be = new Jp("onBeforeInput", "beforeinput", null, y, Be), We.push({ event: Be, listeners: Re }), Be.data = vt));
      }
      No(We, l);
    });
  }
  function Ml(s, l, y) {
    return { instance: s, listener: l, currentTarget: y };
  }
  function lc(s, l) {
    for (var y = l + "Capture", E = []; s !== null; ) {
      var I = s, M = I.stateNode;
      I.tag === 5 && M !== null && (I = M, M = Xi(s, y), M != null && E.unshift(Ml(s, M, I)), M = Xi(s, l), M != null && E.push(Ml(s, M, I))), s = s.return;
    }
    return E;
  }
  function jo(s) {
    if (s === null) return null;
    do
      s = s.return;
    while (s && s.tag !== 5);
    return s || null;
  }
  function df(s, l, y, E, I) {
    for (var M = l._reactName, G = []; y !== null && y !== E; ) {
      var de = y, be = de.alternate, Re = de.stateNode;
      if (be !== null && be === E) break;
      de.tag === 5 && Re !== null && (de = Re, I ? (be = Xi(y, M), be != null && G.unshift(Ml(y, be, de))) : I || (be = Xi(y, M), be != null && G.push(Ml(y, be, de)))), y = y.return;
    }
    G.length !== 0 && s.push({ event: l, listeners: G });
  }
  var uc = /\r\n?/g, kb = /\u0000|\uFFFD/g;
  function nm(s) {
    return (typeof s == "string" ? s : "" + s).replace(uc, `
`).replace(kb, "");
  }
  function un(s, l, y) {
    if (l = nm(l), nm(s) !== l && y) throw Error(r(425));
  }
  function Ia() {
  }
  var cc = null, Dr = null;
  function hf(s, l) {
    return s === "textarea" || s === "noscript" || typeof l.children == "string" || typeof l.children == "number" || typeof l.dangerouslySetInnerHTML == "object" && l.dangerouslySetInnerHTML !== null && l.dangerouslySetInnerHTML.__html != null;
  }
  var mf = typeof setTimeout == "function" ? setTimeout : void 0, Ab = typeof clearTimeout == "function" ? clearTimeout : void 0, gf = typeof Promise == "function" ? Promise : void 0, Pb = typeof queueMicrotask == "function" ? queueMicrotask : typeof gf < "u" ? function(s) {
    return gf.resolve(null).then(s).catch(Tb);
  } : mf;
  function Tb(s) {
    setTimeout(function() {
      throw s;
    });
  }
  function pc(s, l) {
    var y = l, E = 0;
    do {
      var I = y.nextSibling;
      if (s.removeChild(y), I && I.nodeType === 8) if (y = I.data, y === "/$") {
        if (E === 0) {
          s.removeChild(I), oi(l);
          return;
        }
        E--;
      } else y !== "$" && y !== "$?" && y !== "$!" || E++;
      y = I;
    } while (y);
    oi(l);
  }
  function Ws(s) {
    for (; s != null; s = s.nextSibling) {
      var l = s.nodeType;
      if (l === 1 || l === 3) break;
      if (l === 8) {
        if (l = s.data, l === "$" || l === "$!" || l === "$?") break;
        if (l === "/$") return null;
      }
    }
    return s;
  }
  function im(s) {
    s = s.previousSibling;
    for (var l = 0; s; ) {
      if (s.nodeType === 8) {
        var y = s.data;
        if (y === "$" || y === "$!" || y === "$?") {
          if (l === 0) return s;
          l--;
        } else y === "/$" && l++;
      }
      s = s.previousSibling;
    }
    return null;
  }
  var Lo = Math.random().toString(36).slice(2), li = "__reactFiber$" + Lo, Dl = "__reactProps$" + Lo, Ti = "__reactContainer$" + Lo, yf = "__reactEvents$" + Lo, Cb = "__reactListeners$" + Lo, sm = "__reactHandles$" + Lo;
  function Ks(s) {
    var l = s[li];
    if (l) return l;
    for (var y = s.parentNode; y; ) {
      if (l = y[Ti] || y[li]) {
        if (y = l.alternate, l.child !== null || y !== null && y.child !== null) for (s = im(s); s !== null; ) {
          if (y = s[li]) return y;
          s = im(s);
        }
        return l;
      }
      s = y, y = s.parentNode;
    }
    return null;
  }
  function Na(s) {
    return s = s[li] || s[Ti], !s || s.tag !== 5 && s.tag !== 6 && s.tag !== 13 && s.tag !== 3 ? null : s;
  }
  function ja(s) {
    if (s.tag === 5 || s.tag === 6) return s.stateNode;
    throw Error(r(33));
  }
  function fc(s) {
    return s[Dl] || null;
  }
  var Qs = [], Hr = -1;
  function Ys(s) {
    return { current: s };
  }
  function Jt(s) {
    0 > Hr || (s.current = Qs[Hr], Qs[Hr] = null, Hr--);
  }
  function Yt(s, l) {
    Hr++, Qs[Hr] = s.current, s.current = l;
  }
  var us = {}, Wr = Ys(us), cn = Ys(!1), Gs = us;
  function Mo(s, l) {
    var y = s.type.contextTypes;
    if (!y) return us;
    var E = s.stateNode;
    if (E && E.__reactInternalMemoizedUnmaskedChildContext === l) return E.__reactInternalMemoizedMaskedChildContext;
    var I = {}, M;
    for (M in y) I[M] = l[M];
    return E && (s = s.stateNode, s.__reactInternalMemoizedUnmaskedChildContext = l, s.__reactInternalMemoizedMaskedChildContext = I), I;
  }
  function en(s) {
    return s = s.childContextTypes, s != null;
  }
  function Do() {
    Jt(cn), Jt(Wr);
  }
  function ui(s, l, y) {
    if (Wr.current !== us) throw Error(r(168));
    Yt(Wr, l), Yt(cn, y);
  }
  function om(s, l, y) {
    var E = s.stateNode;
    if (l = l.childContextTypes, typeof E.getChildContext != "function") return y;
    E = E.getChildContext();
    for (var I in E) if (!(I in l)) throw Error(r(108, ye(s) || "Unknown", I));
    return te({}, y, E);
  }
  function dc(s) {
    return s = (s = s.stateNode) && s.__reactInternalMemoizedMergedChildContext || us, Gs = Wr.current, Yt(Wr, s), Yt(cn, cn.current), !0;
  }
  function Fo(s, l, y) {
    var E = s.stateNode;
    if (!E) throw Error(r(169));
    y ? (s = om(s, l, Gs), E.__reactInternalMemoizedMergedChildContext = s, Jt(cn), Jt(Wr), Yt(Wr, s)) : Jt(cn), Yt(cn, y);
  }
  var tn = null, zn = !1, vf = !1;
  function am(s) {
    tn === null ? tn = [s] : tn.push(s);
  }
  function hc(s) {
    zn = !0, am(s);
  }
  function Ci() {
    if (!vf && tn !== null) {
      vf = !0;
      var s = 0, l = Lt;
      try {
        var y = tn;
        for (Lt = 1; s < y.length; s++) {
          var E = y[s];
          do
            E = E(!0);
          while (E !== null);
        }
        tn = null, zn = !1;
      } catch (I) {
        throw tn !== null && (tn = tn.slice(s + 1)), Eo(Ds, Ci), I;
      } finally {
        Lt = l, vf = !1;
      }
    }
    return null;
  }
  var qo = [], Sn = 0, Xs = null, Fl = 0, xn = [], Tr = 0, zo = null, _n = 1, cs = "";
  function ps(s, l) {
    qo[Sn++] = Fl, qo[Sn++] = Xs, Xs = s, Fl = l;
  }
  function lm(s, l, y) {
    xn[Tr++] = _n, xn[Tr++] = cs, xn[Tr++] = zo, zo = s;
    var E = _n;
    s = cs;
    var I = 32 - Mr(E) - 1;
    E &= ~(1 << I), y += 1;
    var M = 32 - Mr(l) + I;
    if (30 < M) {
      var G = I - I % 5;
      M = (E & (1 << G) - 1).toString(32), E >>= G, I -= G, _n = 1 << 32 - Mr(l) + I | y << I | E, cs = M + s;
    } else _n = 1 << M | y << I | E, cs = s;
  }
  function ql(s) {
    s.return !== null && (ps(s, 1), lm(s, 1, 0));
  }
  function Bo(s) {
    for (; s === Xs; ) Xs = qo[--Sn], qo[Sn] = null, Fl = qo[--Sn], qo[Sn] = null;
    for (; s === zo; ) zo = xn[--Tr], xn[Tr] = null, cs = xn[--Tr], xn[Tr] = null, _n = xn[--Tr], xn[Tr] = null;
  }
  var En = null, Kr = null, Zt = !1, Bn = null;
  function bf(s, l) {
    var y = Kn(5, null, null, 0);
    y.elementType = "DELETED", y.stateNode = l, y.return = s, l = s.deletions, l === null ? (s.deletions = [y], s.flags |= 16) : l.push(y);
  }
  function wf(s, l) {
    switch (s.tag) {
      case 5:
        var y = s.type;
        return l = l.nodeType !== 1 || y.toLowerCase() !== l.nodeName.toLowerCase() ? null : l, l !== null ? (s.stateNode = l, En = s, Kr = Ws(l.firstChild), !0) : !1;
      case 6:
        return l = s.pendingProps === "" || l.nodeType !== 3 ? null : l, l !== null ? (s.stateNode = l, En = s, Kr = null, !0) : !1;
      case 13:
        return l = l.nodeType !== 8 ? null : l, l !== null ? (y = zo !== null ? { id: _n, overflow: cs } : null, s.memoizedState = { dehydrated: l, treeContext: y, retryLane: 1073741824 }, y = Kn(18, null, null, 0), y.stateNode = l, y.return = s, s.child = y, En = s, Kr = null, !0) : !1;
      default:
        return !1;
    }
  }
  function mc(s) {
    return (s.mode & 1) !== 0 && (s.flags & 128) === 0;
  }
  function Sf(s) {
    if (Zt) {
      var l = Kr;
      if (l) {
        var y = l;
        if (!wf(s, l)) {
          if (mc(s)) throw Error(r(418));
          l = Ws(y.nextSibling);
          var E = En;
          l && wf(s, l) ? bf(E, y) : (s.flags = s.flags & -4097 | 2, Zt = !1, En = s);
        }
      } else {
        if (mc(s)) throw Error(r(418));
        s.flags = s.flags & -4097 | 2, Zt = !1, En = s;
      }
    }
  }
  function gc(s) {
    for (s = s.return; s !== null && s.tag !== 5 && s.tag !== 3 && s.tag !== 13; ) s = s.return;
    En = s;
  }
  function yc(s) {
    if (s !== En) return !1;
    if (!Zt) return gc(s), Zt = !0, !1;
    var l;
    if ((l = s.tag !== 3) && !(l = s.tag !== 5) && (l = s.type, l = l !== "head" && l !== "body" && !hf(s.type, s.memoizedProps)), l && (l = Kr)) {
      if (mc(s)) throw $i(), Error(r(418));
      for (; l; ) bf(s, l), l = Ws(l.nextSibling);
    }
    if (gc(s), s.tag === 13) {
      if (s = s.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(r(317));
      e: {
        for (s = s.nextSibling, l = 0; s; ) {
          if (s.nodeType === 8) {
            var y = s.data;
            if (y === "/$") {
              if (l === 0) {
                Kr = Ws(s.nextSibling);
                break e;
              }
              l--;
            } else y !== "$" && y !== "$!" && y !== "$?" || l++;
          }
          s = s.nextSibling;
        }
        Kr = null;
      }
    } else Kr = En ? Ws(s.stateNode.nextSibling) : null;
    return !0;
  }
  function $i() {
    for (var s = Kr; s; ) s = Ws(s.nextSibling);
  }
  function Un() {
    Kr = En = null, Zt = !1;
  }
  function La(s) {
    Bn === null ? Bn = [s] : Bn.push(s);
  }
  var $b = R.ReactCurrentBatchConfig;
  function Ma(s, l, y) {
    if (s = y.ref, s !== null && typeof s != "function" && typeof s != "object") {
      if (y._owner) {
        if (y = y._owner, y) {
          if (y.tag !== 1) throw Error(r(309));
          var E = y.stateNode;
        }
        if (!E) throw Error(r(147, s));
        var I = E, M = "" + s;
        return l !== null && l.ref !== null && typeof l.ref == "function" && l.ref._stringRef === M ? l.ref : (l = function(G) {
          var de = I.refs;
          G === null ? delete de[M] : de[M] = G;
        }, l._stringRef = M, l);
      }
      if (typeof s != "string") throw Error(r(284));
      if (!y._owner) throw Error(r(290, s));
    }
    return s;
  }
  function vc(s, l) {
    throw s = Object.prototype.toString.call(l), Error(r(31, s === "[object Object]" ? "object with keys {" + Object.keys(l).join(", ") + "}" : s));
  }
  function xf(s) {
    var l = s._init;
    return l(s._payload);
  }
  function um(s) {
    function l(Ae, Ee) {
      if (s) {
        var Ce = Ae.deletions;
        Ce === null ? (Ae.deletions = [Ee], Ae.flags |= 16) : Ce.push(Ee);
      }
    }
    function y(Ae, Ee) {
      if (!s) return null;
      for (; Ee !== null; ) l(Ae, Ee), Ee = Ee.sibling;
      return null;
    }
    function E(Ae, Ee) {
      for (Ae = /* @__PURE__ */ new Map(); Ee !== null; ) Ee.key !== null ? Ae.set(Ee.key, Ee) : Ae.set(Ee.index, Ee), Ee = Ee.sibling;
      return Ae;
    }
    function I(Ae, Ee) {
      return Ae = uo(Ae, Ee), Ae.index = 0, Ae.sibling = null, Ae;
    }
    function M(Ae, Ee, Ce) {
      return Ae.index = Ce, s ? (Ce = Ae.alternate, Ce !== null ? (Ce = Ce.index, Ce < Ee ? (Ae.flags |= 2, Ee) : Ce) : (Ae.flags |= 2, Ee)) : (Ae.flags |= 1048576, Ee);
    }
    function G(Ae) {
      return s && Ae.alternate === null && (Ae.flags |= 2), Ae;
    }
    function de(Ae, Ee, Ce, Qe) {
      return Ee === null || Ee.tag !== 6 ? (Ee = Kc(Ce, Ae.mode, Qe), Ee.return = Ae, Ee) : (Ee = I(Ee, Ce), Ee.return = Ae, Ee);
    }
    function be(Ae, Ee, Ce, Qe) {
      var ot = Ce.type;
      return ot === j ? Be(Ae, Ee, Ce.props.children, Qe, Ce.key) : Ee !== null && (Ee.elementType === ot || typeof ot == "object" && ot !== null && ot.$$typeof === ve && xf(ot) === Ee.type) ? (Qe = I(Ee, Ce.props), Qe.ref = Ma(Ae, Ee, Ce), Qe.return = Ae, Qe) : (Qe = ys(Ce.type, Ce.key, Ce.props, null, Ae.mode, Qe), Qe.ref = Ma(Ae, Ee, Ce), Qe.return = Ae, Qe);
    }
    function Re(Ae, Ee, Ce, Qe) {
      return Ee === null || Ee.tag !== 4 || Ee.stateNode.containerInfo !== Ce.containerInfo || Ee.stateNode.implementation !== Ce.implementation ? (Ee = Qc(Ce, Ae.mode, Qe), Ee.return = Ae, Ee) : (Ee = I(Ee, Ce.children || []), Ee.return = Ae, Ee);
    }
    function Be(Ae, Ee, Ce, Qe, ot) {
      return Ee === null || Ee.tag !== 7 ? (Ee = Zo(Ce, Ae.mode, Qe, ot), Ee.return = Ae, Ee) : (Ee = I(Ee, Ce), Ee.return = Ae, Ee);
    }
    function We(Ae, Ee, Ce) {
      if (typeof Ee == "string" && Ee !== "" || typeof Ee == "number") return Ee = Kc("" + Ee, Ae.mode, Ce), Ee.return = Ae, Ee;
      if (typeof Ee == "object" && Ee !== null) {
        switch (Ee.$$typeof) {
          case C:
            return Ce = ys(Ee.type, Ee.key, Ee.props, null, Ae.mode, Ce), Ce.ref = Ma(Ae, null, Ee), Ce.return = Ae, Ce;
          case T:
            return Ee = Qc(Ee, Ae.mode, Ce), Ee.return = Ae, Ee;
          case ve:
            var Qe = Ee._init;
            return We(Ae, Qe(Ee._payload), Ce);
        }
        if (je(Ee) || se(Ee)) return Ee = Zo(Ee, Ae.mode, Ce, null), Ee.return = Ae, Ee;
        vc(Ae, Ee);
      }
      return null;
    }
    function Ue(Ae, Ee, Ce, Qe) {
      var ot = Ee !== null ? Ee.key : null;
      if (typeof Ce == "string" && Ce !== "" || typeof Ce == "number") return ot !== null ? null : de(Ae, Ee, "" + Ce, Qe);
      if (typeof Ce == "object" && Ce !== null) {
        switch (Ce.$$typeof) {
          case C:
            return Ce.key === ot ? be(Ae, Ee, Ce, Qe) : null;
          case T:
            return Ce.key === ot ? Re(Ae, Ee, Ce, Qe) : null;
          case ve:
            return ot = Ce._init, Ue(
              Ae,
              Ee,
              ot(Ce._payload),
              Qe
            );
        }
        if (je(Ce) || se(Ce)) return ot !== null ? null : Be(Ae, Ee, Ce, Qe, null);
        vc(Ae, Ce);
      }
      return null;
    }
    function et(Ae, Ee, Ce, Qe, ot) {
      if (typeof Qe == "string" && Qe !== "" || typeof Qe == "number") return Ae = Ae.get(Ce) || null, de(Ee, Ae, "" + Qe, ot);
      if (typeof Qe == "object" && Qe !== null) {
        switch (Qe.$$typeof) {
          case C:
            return Ae = Ae.get(Qe.key === null ? Ce : Qe.key) || null, be(Ee, Ae, Qe, ot);
          case T:
            return Ae = Ae.get(Qe.key === null ? Ce : Qe.key) || null, Re(Ee, Ae, Qe, ot);
          case ve:
            var yt = Qe._init;
            return et(Ae, Ee, Ce, yt(Qe._payload), ot);
        }
        if (je(Qe) || se(Qe)) return Ae = Ae.get(Ce) || null, Be(Ee, Ae, Qe, ot, null);
        vc(Ee, Qe);
      }
      return null;
    }
    function ut(Ae, Ee, Ce, Qe) {
      for (var ot = null, yt = null, vt = Ee, xt = Ee = 0, Rr = null; vt !== null && xt < Ce.length; xt++) {
        vt.index > xt ? (Rr = vt, vt = null) : Rr = vt.sibling;
        var Ft = Ue(Ae, vt, Ce[xt], Qe);
        if (Ft === null) {
          vt === null && (vt = Rr);
          break;
        }
        s && vt && Ft.alternate === null && l(Ae, vt), Ee = M(Ft, Ee, xt), yt === null ? ot = Ft : yt.sibling = Ft, yt = Ft, vt = Rr;
      }
      if (xt === Ce.length) return y(Ae, vt), Zt && ps(Ae, xt), ot;
      if (vt === null) {
        for (; xt < Ce.length; xt++) vt = We(Ae, Ce[xt], Qe), vt !== null && (Ee = M(vt, Ee, xt), yt === null ? ot = vt : yt.sibling = vt, yt = vt);
        return Zt && ps(Ae, xt), ot;
      }
      for (vt = E(Ae, vt); xt < Ce.length; xt++) Rr = et(vt, Ae, xt, Ce[xt], Qe), Rr !== null && (s && Rr.alternate !== null && vt.delete(Rr.key === null ? xt : Rr.key), Ee = M(Rr, Ee, xt), yt === null ? ot = Rr : yt.sibling = Rr, yt = Rr);
      return s && vt.forEach(function(vs) {
        return l(Ae, vs);
      }), Zt && ps(Ae, xt), ot;
    }
    function pt(Ae, Ee, Ce, Qe) {
      var ot = se(Ce);
      if (typeof ot != "function") throw Error(r(150));
      if (Ce = ot.call(Ce), Ce == null) throw Error(r(151));
      for (var yt = ot = null, vt = Ee, xt = Ee = 0, Rr = null, Ft = Ce.next(); vt !== null && !Ft.done; xt++, Ft = Ce.next()) {
        vt.index > xt ? (Rr = vt, vt = null) : Rr = vt.sibling;
        var vs = Ue(Ae, vt, Ft.value, Qe);
        if (vs === null) {
          vt === null && (vt = Rr);
          break;
        }
        s && vt && vs.alternate === null && l(Ae, vt), Ee = M(vs, Ee, xt), yt === null ? ot = vs : yt.sibling = vs, yt = vs, vt = Rr;
      }
      if (Ft.done) return y(
        Ae,
        vt
      ), Zt && ps(Ae, xt), ot;
      if (vt === null) {
        for (; !Ft.done; xt++, Ft = Ce.next()) Ft = We(Ae, Ft.value, Qe), Ft !== null && (Ee = M(Ft, Ee, xt), yt === null ? ot = Ft : yt.sibling = Ft, yt = Ft);
        return Zt && ps(Ae, xt), ot;
      }
      for (vt = E(Ae, vt); !Ft.done; xt++, Ft = Ce.next()) Ft = et(vt, Ae, xt, Ft.value, Qe), Ft !== null && (s && Ft.alternate !== null && vt.delete(Ft.key === null ? xt : Ft.key), Ee = M(Ft, Ee, xt), yt === null ? ot = Ft : yt.sibling = Ft, yt = Ft);
      return s && vt.forEach(function(Wb) {
        return l(Ae, Wb);
      }), Zt && ps(Ae, xt), ot;
    }
    function gr(Ae, Ee, Ce, Qe) {
      if (typeof Ce == "object" && Ce !== null && Ce.type === j && Ce.key === null && (Ce = Ce.props.children), typeof Ce == "object" && Ce !== null) {
        switch (Ce.$$typeof) {
          case C:
            e: {
              for (var ot = Ce.key, yt = Ee; yt !== null; ) {
                if (yt.key === ot) {
                  if (ot = Ce.type, ot === j) {
                    if (yt.tag === 7) {
                      y(Ae, yt.sibling), Ee = I(yt, Ce.props.children), Ee.return = Ae, Ae = Ee;
                      break e;
                    }
                  } else if (yt.elementType === ot || typeof ot == "object" && ot !== null && ot.$$typeof === ve && xf(ot) === yt.type) {
                    y(Ae, yt.sibling), Ee = I(yt, Ce.props), Ee.ref = Ma(Ae, yt, Ce), Ee.return = Ae, Ae = Ee;
                    break e;
                  }
                  y(Ae, yt);
                  break;
                } else l(Ae, yt);
                yt = yt.sibling;
              }
              Ce.type === j ? (Ee = Zo(Ce.props.children, Ae.mode, Qe, Ce.key), Ee.return = Ae, Ae = Ee) : (Qe = ys(Ce.type, Ce.key, Ce.props, null, Ae.mode, Qe), Qe.ref = Ma(Ae, Ee, Ce), Qe.return = Ae, Ae = Qe);
            }
            return G(Ae);
          case T:
            e: {
              for (yt = Ce.key; Ee !== null; ) {
                if (Ee.key === yt) if (Ee.tag === 4 && Ee.stateNode.containerInfo === Ce.containerInfo && Ee.stateNode.implementation === Ce.implementation) {
                  y(Ae, Ee.sibling), Ee = I(Ee, Ce.children || []), Ee.return = Ae, Ae = Ee;
                  break e;
                } else {
                  y(Ae, Ee);
                  break;
                }
                else l(Ae, Ee);
                Ee = Ee.sibling;
              }
              Ee = Qc(Ce, Ae.mode, Qe), Ee.return = Ae, Ae = Ee;
            }
            return G(Ae);
          case ve:
            return yt = Ce._init, gr(Ae, Ee, yt(Ce._payload), Qe);
        }
        if (je(Ce)) return ut(Ae, Ee, Ce, Qe);
        if (se(Ce)) return pt(Ae, Ee, Ce, Qe);
        vc(Ae, Ce);
      }
      return typeof Ce == "string" && Ce !== "" || typeof Ce == "number" ? (Ce = "" + Ce, Ee !== null && Ee.tag === 6 ? (y(Ae, Ee.sibling), Ee = I(Ee, Ce), Ee.return = Ae, Ae = Ee) : (y(Ae, Ee), Ee = Kc(Ce, Ae.mode, Qe), Ee.return = Ae, Ae = Ee), G(Ae)) : y(Ae, Ee);
    }
    return gr;
  }
  var Uo = um(!0), or = um(!1), Da = Ys(null), bc = null, Fa = null, _f = null;
  function Ef() {
    _f = Fa = bc = null;
  }
  function Of(s) {
    var l = Da.current;
    Jt(Da), s._currentValue = l;
  }
  function fs(s, l, y) {
    for (; s !== null; ) {
      var E = s.alternate;
      if ((s.childLanes & l) !== l ? (s.childLanes |= l, E !== null && (E.childLanes |= l)) : E !== null && (E.childLanes & l) !== l && (E.childLanes |= l), s === y) break;
      s = s.return;
    }
  }
  function Js(s, l) {
    bc = s, _f = Fa = null, s = s.dependencies, s !== null && s.firstContext !== null && ((s.lanes & l) !== 0 && (fn = !0), s.firstContext = null);
  }
  function pn(s) {
    var l = s._currentValue;
    if (_f !== s) if (s = { context: s, memoizedValue: l, next: null }, Fa === null) {
      if (bc === null) throw Error(r(308));
      Fa = s, bc.dependencies = { lanes: 0, firstContext: s };
    } else Fa = Fa.next = s;
    return l;
  }
  var Ri = null;
  function kf(s) {
    Ri === null ? Ri = [s] : Ri.push(s);
  }
  function Af(s, l, y, E) {
    var I = l.interleaved;
    return I === null ? (y.next = y, kf(l)) : (y.next = I.next, I.next = y), l.interleaved = y, Ii(s, E);
  }
  function Ii(s, l) {
    s.lanes |= l;
    var y = s.alternate;
    for (y !== null && (y.lanes |= l), y = s, s = s.return; s !== null; ) s.childLanes |= l, y = s.alternate, y !== null && (y.childLanes |= l), y = s, s = s.return;
    return y.tag === 3 ? y.stateNode : null;
  }
  var Zs = !1;
  function Pf(s) {
    s.updateQueue = { baseState: s.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function Tf(s, l) {
    s = s.updateQueue, l.updateQueue === s && (l.updateQueue = { baseState: s.baseState, firstBaseUpdate: s.firstBaseUpdate, lastBaseUpdate: s.lastBaseUpdate, shared: s.shared, effects: s.effects });
  }
  function ds(s, l) {
    return { eventTime: s, lane: l, tag: 0, payload: null, callback: null, next: null };
  }
  function eo(s, l, y) {
    var E = s.updateQueue;
    if (E === null) return null;
    if (E = E.shared, (Nt & 2) !== 0) {
      var I = E.pending;
      return I === null ? l.next = l : (l.next = I.next, I.next = l), E.pending = l, Ii(s, y);
    }
    return I = E.interleaved, I === null ? (l.next = l, kf(E)) : (l.next = I.next, I.next = l), E.interleaved = l, Ii(s, y);
  }
  function zl(s, l, y) {
    if (l = l.updateQueue, l !== null && (l = l.shared, (y & 4194240) !== 0)) {
      var E = l.lanes;
      E &= s.pendingLanes, y |= E, l.lanes = y, wa(s, y);
    }
  }
  function cm(s, l) {
    var y = s.updateQueue, E = s.alternate;
    if (E !== null && (E = E.updateQueue, y === E)) {
      var I = null, M = null;
      if (y = y.firstBaseUpdate, y !== null) {
        do {
          var G = { eventTime: y.eventTime, lane: y.lane, tag: y.tag, payload: y.payload, callback: y.callback, next: null };
          M === null ? I = M = G : M = M.next = G, y = y.next;
        } while (y !== null);
        M === null ? I = M = l : M = M.next = l;
      } else I = M = l;
      y = { baseState: E.baseState, firstBaseUpdate: I, lastBaseUpdate: M, shared: E.shared, effects: E.effects }, s.updateQueue = y;
      return;
    }
    s = y.lastBaseUpdate, s === null ? y.firstBaseUpdate = l : s.next = l, y.lastBaseUpdate = l;
  }
  function Vn(s, l, y, E) {
    var I = s.updateQueue;
    Zs = !1;
    var M = I.firstBaseUpdate, G = I.lastBaseUpdate, de = I.shared.pending;
    if (de !== null) {
      I.shared.pending = null;
      var be = de, Re = be.next;
      be.next = null, G === null ? M = Re : G.next = Re, G = be;
      var Be = s.alternate;
      Be !== null && (Be = Be.updateQueue, de = Be.lastBaseUpdate, de !== G && (de === null ? Be.firstBaseUpdate = Re : de.next = Re, Be.lastBaseUpdate = be));
    }
    if (M !== null) {
      var We = I.baseState;
      G = 0, Be = Re = be = null, de = M;
      do {
        var Ue = de.lane, et = de.eventTime;
        if ((E & Ue) === Ue) {
          Be !== null && (Be = Be.next = {
            eventTime: et,
            lane: 0,
            tag: de.tag,
            payload: de.payload,
            callback: de.callback,
            next: null
          });
          e: {
            var ut = s, pt = de;
            switch (Ue = l, et = y, pt.tag) {
              case 1:
                if (ut = pt.payload, typeof ut == "function") {
                  We = ut.call(et, We, Ue);
                  break e;
                }
                We = ut;
                break e;
              case 3:
                ut.flags = ut.flags & -65537 | 128;
              case 0:
                if (ut = pt.payload, Ue = typeof ut == "function" ? ut.call(et, We, Ue) : ut, Ue == null) break e;
                We = te({}, We, Ue);
                break e;
              case 2:
                Zs = !0;
            }
          }
          de.callback !== null && de.lane !== 0 && (s.flags |= 64, Ue = I.effects, Ue === null ? I.effects = [de] : Ue.push(de));
        } else et = { eventTime: et, lane: Ue, tag: de.tag, payload: de.payload, callback: de.callback, next: null }, Be === null ? (Re = Be = et, be = We) : Be = Be.next = et, G |= Ue;
        if (de = de.next, de === null) {
          if (de = I.shared.pending, de === null) break;
          Ue = de, de = Ue.next, Ue.next = null, I.lastBaseUpdate = Ue, I.shared.pending = null;
        }
      } while (!0);
      if (Be === null && (be = We), I.baseState = be, I.firstBaseUpdate = Re, I.lastBaseUpdate = Be, l = I.shared.interleaved, l !== null) {
        I = l;
        do
          G |= I.lane, I = I.next;
        while (I !== l);
      } else M === null && (I.shared.lanes = 0);
      Yo |= G, s.lanes = G, s.memoizedState = We;
    }
  }
  function pm(s, l, y) {
    if (s = l.effects, l.effects = null, s !== null) for (l = 0; l < s.length; l++) {
      var E = s[l], I = E.callback;
      if (I !== null) {
        if (E.callback = null, E = y, typeof I != "function") throw Error(r(191, I));
        I.call(E);
      }
    }
  }
  var Bl = {}, Ni = Ys(Bl), qa = Ys(Bl), Ul = Ys(Bl);
  function Vo(s) {
    if (s === Bl) throw Error(r(174));
    return s;
  }
  function za(s, l) {
    switch (Yt(Ul, l), Yt(qa, s), Yt(Ni, Bl), s = l.nodeType, s) {
      case 9:
      case 11:
        l = (l = l.documentElement) ? l.namespaceURI : Fe(null, "");
        break;
      default:
        s = s === 8 ? l.parentNode : l, l = s.namespaceURI || null, s = s.tagName, l = Fe(l, s);
    }
    Jt(Ni), Yt(Ni, l);
  }
  function Ho() {
    Jt(Ni), Jt(qa), Jt(Ul);
  }
  function Cf(s) {
    Vo(Ul.current);
    var l = Vo(Ni.current), y = Fe(l, s.type);
    l !== y && (Yt(qa, s), Yt(Ni, y));
  }
  function $f(s) {
    qa.current === s && (Jt(Ni), Jt(qa));
  }
  var rr = Ys(0);
  function wc(s) {
    for (var l = s; l !== null; ) {
      if (l.tag === 13) {
        var y = l.memoizedState;
        if (y !== null && (y = y.dehydrated, y === null || y.data === "$?" || y.data === "$!")) return l;
      } else if (l.tag === 19 && l.memoizedProps.revealOrder !== void 0) {
        if ((l.flags & 128) !== 0) return l;
      } else if (l.child !== null) {
        l.child.return = l, l = l.child;
        continue;
      }
      if (l === s) break;
      for (; l.sibling === null; ) {
        if (l.return === null || l.return === s) return null;
        l = l.return;
      }
      l.sibling.return = l.return, l = l.sibling;
    }
    return null;
  }
  var Rf = [];
  function Sc() {
    for (var s = 0; s < Rf.length; s++) Rf[s]._workInProgressVersionPrimary = null;
    Rf.length = 0;
  }
  var xc = R.ReactCurrentDispatcher, to = R.ReactCurrentBatchConfig, Wo = 0, ar = null, pr = null, nr = null, _c = !1, Vl = !1, Hl = 0, Ec = 0;
  function Fr() {
    throw Error(r(321));
  }
  function Oc(s, l) {
    if (l === null) return !1;
    for (var y = 0; y < l.length && y < s.length; y++) if (!kr(s[y], l[y])) return !1;
    return !0;
  }
  function kc(s, l, y, E, I, M) {
    if (Wo = M, ar = l, l.memoizedState = null, l.updateQueue = null, l.lanes = 0, xc.current = s === null || s.memoizedState === null ? zt : Rb, s = y(E, I), Vl) {
      M = 0;
      do {
        if (Vl = !1, Hl = 0, 25 <= M) throw Error(r(301));
        M += 1, nr = pr = null, l.updateQueue = null, xc.current = kn, s = y(E, I);
      } while (Vl);
    }
    if (xc.current = Xl, l = pr !== null && pr.next !== null, Wo = 0, nr = pr = ar = null, _c = !1, l) throw Error(r(300));
    return s;
  }
  function If() {
    var s = Hl !== 0;
    return Hl = 0, s;
  }
  function ji() {
    var s = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return nr === null ? ar.memoizedState = nr = s : nr = nr.next = s, nr;
  }
  function On() {
    if (pr === null) {
      var s = ar.alternate;
      s = s !== null ? s.memoizedState : null;
    } else s = pr.next;
    var l = nr === null ? ar.memoizedState : nr.next;
    if (l !== null) nr = l, pr = s;
    else {
      if (s === null) throw Error(r(310));
      pr = s, s = { memoizedState: pr.memoizedState, baseState: pr.baseState, baseQueue: pr.baseQueue, queue: pr.queue, next: null }, nr === null ? ar.memoizedState = nr = s : nr = nr.next = s;
    }
    return nr;
  }
  function xr(s, l) {
    return typeof l == "function" ? l(s) : l;
  }
  function Nf(s) {
    var l = On(), y = l.queue;
    if (y === null) throw Error(r(311));
    y.lastRenderedReducer = s;
    var E = pr, I = E.baseQueue, M = y.pending;
    if (M !== null) {
      if (I !== null) {
        var G = I.next;
        I.next = M.next, M.next = G;
      }
      E.baseQueue = I = M, y.pending = null;
    }
    if (I !== null) {
      M = I.next, E = E.baseState;
      var de = G = null, be = null, Re = M;
      do {
        var Be = Re.lane;
        if ((Wo & Be) === Be) be !== null && (be = be.next = { lane: 0, action: Re.action, hasEagerState: Re.hasEagerState, eagerState: Re.eagerState, next: null }), E = Re.hasEagerState ? Re.eagerState : s(E, Re.action);
        else {
          var We = {
            lane: Be,
            action: Re.action,
            hasEagerState: Re.hasEagerState,
            eagerState: Re.eagerState,
            next: null
          };
          be === null ? (de = be = We, G = E) : be = be.next = We, ar.lanes |= Be, Yo |= Be;
        }
        Re = Re.next;
      } while (Re !== null && Re !== M);
      be === null ? G = E : be.next = de, kr(E, l.memoizedState) || (fn = !0), l.memoizedState = E, l.baseState = G, l.baseQueue = be, y.lastRenderedState = E;
    }
    if (s = y.interleaved, s !== null) {
      I = s;
      do
        M = I.lane, ar.lanes |= M, Yo |= M, I = I.next;
      while (I !== s);
    } else I === null && (y.lanes = 0);
    return [l.memoizedState, y.dispatch];
  }
  function jf(s) {
    var l = On(), y = l.queue;
    if (y === null) throw Error(r(311));
    y.lastRenderedReducer = s;
    var E = y.dispatch, I = y.pending, M = l.memoizedState;
    if (I !== null) {
      y.pending = null;
      var G = I = I.next;
      do
        M = s(M, G.action), G = G.next;
      while (G !== I);
      kr(M, l.memoizedState) || (fn = !0), l.memoizedState = M, l.baseQueue === null && (l.baseState = M), y.lastRenderedState = M;
    }
    return [M, E];
  }
  function fm() {
  }
  function dm(s, l) {
    var y = ar, E = On(), I = l(), M = !kr(E.memoizedState, I);
    if (M && (E.memoizedState = I, fn = !0), E = E.queue, Ql(gm.bind(null, y, E, s), [s]), E.getSnapshot !== l || M || nr !== null && nr.memoizedState.tag & 1) {
      if (y.flags |= 2048, Wl(9, mm.bind(null, y, E, I, l), void 0, null), $r === null) throw Error(r(349));
      (Wo & 30) !== 0 || hm(y, l, I);
    }
    return I;
  }
  function hm(s, l, y) {
    s.flags |= 16384, s = { getSnapshot: l, value: y }, l = ar.updateQueue, l === null ? (l = { lastEffect: null, stores: null }, ar.updateQueue = l, l.stores = [s]) : (y = l.stores, y === null ? l.stores = [s] : y.push(s));
  }
  function mm(s, l, y, E) {
    l.value = y, l.getSnapshot = E, Li(l) && Lf(s);
  }
  function gm(s, l, y) {
    return y(function() {
      Li(l) && Lf(s);
    });
  }
  function Li(s) {
    var l = s.getSnapshot;
    s = s.value;
    try {
      var y = l();
      return !kr(s, y);
    } catch {
      return !0;
    }
  }
  function Lf(s) {
    var l = Ii(s, 1);
    l !== null && mn(l, s, 1, -1);
  }
  function Mi(s) {
    var l = ji();
    return typeof s == "function" && (s = s()), l.memoizedState = l.baseState = s, s = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: xr, lastRenderedState: s }, l.queue = s, s = s.dispatch = $c.bind(null, ar, s), [l.memoizedState, s];
  }
  function Wl(s, l, y, E) {
    return s = { tag: s, create: l, destroy: y, deps: E, next: null }, l = ar.updateQueue, l === null ? (l = { lastEffect: null, stores: null }, ar.updateQueue = l, l.lastEffect = s.next = s) : (y = l.lastEffect, y === null ? l.lastEffect = s.next = s : (E = y.next, y.next = s, s.next = E, l.lastEffect = s)), s;
  }
  function Ac() {
    return On().memoizedState;
  }
  function Kl(s, l, y, E) {
    var I = ji();
    ar.flags |= s, I.memoizedState = Wl(1 | l, y, void 0, E === void 0 ? null : E);
  }
  function Di(s, l, y, E) {
    var I = On();
    E = E === void 0 ? null : E;
    var M = void 0;
    if (pr !== null) {
      var G = pr.memoizedState;
      if (M = G.destroy, E !== null && Oc(E, G.deps)) {
        I.memoizedState = Wl(l, y, M, E);
        return;
      }
    }
    ar.flags |= s, I.memoizedState = Wl(1 | l, y, M, E);
  }
  function ro(s, l) {
    return Kl(8390656, 8, s, l);
  }
  function Ql(s, l) {
    return Di(2048, 8, s, l);
  }
  function ym(s, l) {
    return Di(4, 2, s, l);
  }
  function vm(s, l) {
    return Di(4, 4, s, l);
  }
  function Mf(s, l) {
    if (typeof l == "function") return s = s(), l(s), function() {
      l(null);
    };
    if (l != null) return s = s(), l.current = s, function() {
      l.current = null;
    };
  }
  function Df(s, l, y) {
    return y = y != null ? y.concat([s]) : null, Di(4, 4, Mf.bind(null, l, s), y);
  }
  function Yl() {
  }
  function Ff(s, l) {
    var y = On();
    l = l === void 0 ? null : l;
    var E = y.memoizedState;
    return E !== null && l !== null && Oc(l, E[1]) ? E[0] : (y.memoizedState = [s, l], s);
  }
  function bm(s, l) {
    var y = On();
    l = l === void 0 ? null : l;
    var E = y.memoizedState;
    return E !== null && l !== null && Oc(l, E[1]) ? E[0] : (s = s(), y.memoizedState = [s, l], s);
  }
  function Pc(s, l, y) {
    return (Wo & 21) === 0 ? (s.baseState && (s.baseState = !1, fn = !0), s.memoizedState = y) : (kr(y, l) || (y = Mn(), ar.lanes |= y, Yo |= y, s.baseState = !0), l);
  }
  function wm(s, l) {
    var y = Lt;
    Lt = y !== 0 && 4 > y ? y : 4, s(!0);
    var E = to.transition;
    to.transition = {};
    try {
      s(!1), l();
    } finally {
      Lt = y, to.transition = E;
    }
  }
  function Tc() {
    return On().memoizedState;
  }
  function Cc(s, l, y) {
    var E = oo(s);
    if (y = { lane: E, action: y, hasEagerState: !1, eagerState: null, next: null }, Gl(s)) qf(l, y);
    else if (y = Af(s, l, y, E), y !== null) {
      var I = rn();
      mn(y, s, E, I), zf(y, l, E);
    }
  }
  function $c(s, l, y) {
    var E = oo(s), I = { lane: E, action: y, hasEagerState: !1, eagerState: null, next: null };
    if (Gl(s)) qf(l, I);
    else {
      var M = s.alternate;
      if (s.lanes === 0 && (M === null || M.lanes === 0) && (M = l.lastRenderedReducer, M !== null)) try {
        var G = l.lastRenderedState, de = M(G, y);
        if (I.hasEagerState = !0, I.eagerState = de, kr(de, G)) {
          var be = l.interleaved;
          be === null ? (I.next = I, kf(l)) : (I.next = be.next, be.next = I), l.interleaved = I;
          return;
        }
      } catch {
      } finally {
      }
      y = Af(s, l, I, E), y !== null && (I = rn(), mn(y, s, E, I), zf(y, l, E));
    }
  }
  function Gl(s) {
    var l = s.alternate;
    return s === ar || l !== null && l === ar;
  }
  function qf(s, l) {
    Vl = _c = !0;
    var y = s.pending;
    y === null ? l.next = l : (l.next = y.next, y.next = l), s.pending = l;
  }
  function zf(s, l, y) {
    if ((y & 4194240) !== 0) {
      var E = l.lanes;
      E &= s.pendingLanes, y |= E, l.lanes = y, wa(s, y);
    }
  }
  var Xl = { readContext: pn, useCallback: Fr, useContext: Fr, useEffect: Fr, useImperativeHandle: Fr, useInsertionEffect: Fr, useLayoutEffect: Fr, useMemo: Fr, useReducer: Fr, useRef: Fr, useState: Fr, useDebugValue: Fr, useDeferredValue: Fr, useTransition: Fr, useMutableSource: Fr, useSyncExternalStore: Fr, useId: Fr, unstable_isNewReconciler: !1 }, zt = { readContext: pn, useCallback: function(s, l) {
    return ji().memoizedState = [s, l === void 0 ? null : l], s;
  }, useContext: pn, useEffect: ro, useImperativeHandle: function(s, l, y) {
    return y = y != null ? y.concat([s]) : null, Kl(
      4194308,
      4,
      Mf.bind(null, l, s),
      y
    );
  }, useLayoutEffect: function(s, l) {
    return Kl(4194308, 4, s, l);
  }, useInsertionEffect: function(s, l) {
    return Kl(4, 2, s, l);
  }, useMemo: function(s, l) {
    var y = ji();
    return l = l === void 0 ? null : l, s = s(), y.memoizedState = [s, l], s;
  }, useReducer: function(s, l, y) {
    var E = ji();
    return l = y !== void 0 ? y(l) : l, E.memoizedState = E.baseState = l, s = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: s, lastRenderedState: l }, E.queue = s, s = s.dispatch = Cc.bind(null, ar, s), [E.memoizedState, s];
  }, useRef: function(s) {
    var l = ji();
    return s = { current: s }, l.memoizedState = s;
  }, useState: Mi, useDebugValue: Yl, useDeferredValue: function(s) {
    return ji().memoizedState = s;
  }, useTransition: function() {
    var s = Mi(!1), l = s[0];
    return s = wm.bind(null, s[1]), ji().memoizedState = s, [l, s];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(s, l, y) {
    var E = ar, I = ji();
    if (Zt) {
      if (y === void 0) throw Error(r(407));
      y = y();
    } else {
      if (y = l(), $r === null) throw Error(r(349));
      (Wo & 30) !== 0 || hm(E, l, y);
    }
    I.memoizedState = y;
    var M = { value: y, getSnapshot: l };
    return I.queue = M, ro(gm.bind(
      null,
      E,
      M,
      s
    ), [s]), E.flags |= 2048, Wl(9, mm.bind(null, E, M, y, l), void 0, null), y;
  }, useId: function() {
    var s = ji(), l = $r.identifierPrefix;
    if (Zt) {
      var y = cs, E = _n;
      y = (E & ~(1 << 32 - Mr(E) - 1)).toString(32) + y, l = ":" + l + "R" + y, y = Hl++, 0 < y && (l += "H" + y.toString(32)), l += ":";
    } else y = Ec++, l = ":" + l + "r" + y.toString(32) + ":";
    return s.memoizedState = l;
  }, unstable_isNewReconciler: !1 }, Rb = {
    readContext: pn,
    useCallback: Ff,
    useContext: pn,
    useEffect: Ql,
    useImperativeHandle: Df,
    useInsertionEffect: ym,
    useLayoutEffect: vm,
    useMemo: bm,
    useReducer: Nf,
    useRef: Ac,
    useState: function() {
      return Nf(xr);
    },
    useDebugValue: Yl,
    useDeferredValue: function(s) {
      var l = On();
      return Pc(l, pr.memoizedState, s);
    },
    useTransition: function() {
      var s = Nf(xr)[0], l = On().memoizedState;
      return [s, l];
    },
    useMutableSource: fm,
    useSyncExternalStore: dm,
    useId: Tc,
    unstable_isNewReconciler: !1
  }, kn = { readContext: pn, useCallback: Ff, useContext: pn, useEffect: Ql, useImperativeHandle: Df, useInsertionEffect: ym, useLayoutEffect: vm, useMemo: bm, useReducer: jf, useRef: Ac, useState: function() {
    return jf(xr);
  }, useDebugValue: Yl, useDeferredValue: function(s) {
    var l = On();
    return pr === null ? l.memoizedState = s : Pc(l, pr.memoizedState, s);
  }, useTransition: function() {
    var s = jf(xr)[0], l = On().memoizedState;
    return [s, l];
  }, useMutableSource: fm, useSyncExternalStore: dm, useId: Tc, unstable_isNewReconciler: !1 };
  function Hn(s, l) {
    if (s && s.defaultProps) {
      l = te({}, l), s = s.defaultProps;
      for (var y in s) l[y] === void 0 && (l[y] = s[y]);
      return l;
    }
    return l;
  }
  function Ba(s, l, y, E) {
    l = s.memoizedState, y = y(E, l), y = y == null ? l : te({}, l, y), s.memoizedState = y, s.lanes === 0 && (s.updateQueue.baseState = y);
  }
  var Jl = { isMounted: function(s) {
    return (s = s._reactInternals) ? Ht(s) === s : !1;
  }, enqueueSetState: function(s, l, y) {
    s = s._reactInternals;
    var E = rn(), I = oo(s), M = ds(E, I);
    M.payload = l, y != null && (M.callback = y), l = eo(s, M, I), l !== null && (mn(l, s, I, E), zl(l, s, I));
  }, enqueueReplaceState: function(s, l, y) {
    s = s._reactInternals;
    var E = rn(), I = oo(s), M = ds(E, I);
    M.tag = 1, M.payload = l, y != null && (M.callback = y), l = eo(s, M, I), l !== null && (mn(l, s, I, E), zl(l, s, I));
  }, enqueueForceUpdate: function(s, l) {
    s = s._reactInternals;
    var y = rn(), E = oo(s), I = ds(y, E);
    I.tag = 2, l != null && (I.callback = l), l = eo(s, I, E), l !== null && (mn(l, s, E, y), zl(l, s, E));
  } };
  function Zl(s, l, y, E, I, M, G) {
    return s = s.stateNode, typeof s.shouldComponentUpdate == "function" ? s.shouldComponentUpdate(E, M, G) : l.prototype && l.prototype.isPureReactComponent ? !Vs(y, E) || !Vs(I, M) : !0;
  }
  function Rc(s, l, y) {
    var E = !1, I = us, M = l.contextType;
    return typeof M == "object" && M !== null ? M = pn(M) : (I = en(l) ? Gs : Wr.current, E = l.contextTypes, M = (E = E != null) ? Mo(s, I) : us), l = new l(y, M), s.memoizedState = l.state !== null && l.state !== void 0 ? l.state : null, l.updater = Jl, s.stateNode = l, l._reactInternals = s, E && (s = s.stateNode, s.__reactInternalMemoizedUnmaskedChildContext = I, s.__reactInternalMemoizedMaskedChildContext = M), l;
  }
  function Bf(s, l, y, E) {
    s = l.state, typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps(y, E), typeof l.UNSAFE_componentWillReceiveProps == "function" && l.UNSAFE_componentWillReceiveProps(y, E), l.state !== s && Jl.enqueueReplaceState(l, l.state, null);
  }
  function Ic(s, l, y, E) {
    var I = s.stateNode;
    I.props = y, I.state = s.memoizedState, I.refs = {}, Pf(s);
    var M = l.contextType;
    typeof M == "object" && M !== null ? I.context = pn(M) : (M = en(l) ? Gs : Wr.current, I.context = Mo(s, M)), I.state = s.memoizedState, M = l.getDerivedStateFromProps, typeof M == "function" && (Ba(s, l, M, y), I.state = s.memoizedState), typeof l.getDerivedStateFromProps == "function" || typeof I.getSnapshotBeforeUpdate == "function" || typeof I.UNSAFE_componentWillMount != "function" && typeof I.componentWillMount != "function" || (l = I.state, typeof I.componentWillMount == "function" && I.componentWillMount(), typeof I.UNSAFE_componentWillMount == "function" && I.UNSAFE_componentWillMount(), l !== I.state && Jl.enqueueReplaceState(I, I.state, null), Vn(s, y, I, E), I.state = s.memoizedState), typeof I.componentDidMount == "function" && (s.flags |= 4194308);
  }
  function Ua(s, l) {
    try {
      var y = "", E = l;
      do
        y += X(E), E = E.return;
      while (E);
      var I = y;
    } catch (M) {
      I = `
Error generating stack: ` + M.message + `
` + M.stack;
    }
    return { value: s, source: l, stack: I, digest: null };
  }
  function Ko(s, l, y) {
    return { value: s, source: null, stack: y ?? null, digest: l ?? null };
  }
  function Uf(s, l) {
    try {
      console.error(l.value);
    } catch (y) {
      setTimeout(function() {
        throw y;
      });
    }
  }
  var Ib = typeof WeakMap == "function" ? WeakMap : Map;
  function Sm(s, l, y) {
    y = ds(-1, y), y.tag = 3, y.payload = { element: null };
    var E = l.value;
    return y.callback = function() {
      au || (au = !0, Xa = E), Uf(s, l);
    }, y;
  }
  function xm(s, l, y) {
    y = ds(-1, y), y.tag = 3;
    var E = s.type.getDerivedStateFromError;
    if (typeof E == "function") {
      var I = l.value;
      y.payload = function() {
        return E(I);
      }, y.callback = function() {
        Uf(s, l);
      };
    }
    var M = s.stateNode;
    return M !== null && typeof M.componentDidCatch == "function" && (y.callback = function() {
      Uf(s, l), typeof E != "function" && (zi === null ? zi = /* @__PURE__ */ new Set([this]) : zi.add(this));
      var G = l.stack;
      this.componentDidCatch(l.value, { componentStack: G !== null ? G : "" });
    }), y;
  }
  function no(s, l, y) {
    var E = s.pingCache;
    if (E === null) {
      E = s.pingCache = new Ib();
      var I = /* @__PURE__ */ new Set();
      E.set(l, I);
    } else I = E.get(l), I === void 0 && (I = /* @__PURE__ */ new Set(), E.set(l, I));
    I.has(y) || (I.add(y), s = Fb.bind(null, s, l, y), l.then(s, s));
  }
  function _m(s) {
    do {
      var l;
      if ((l = s.tag === 13) && (l = s.memoizedState, l = l !== null ? l.dehydrated !== null : !0), l) return s;
      s = s.return;
    } while (s !== null);
    return null;
  }
  function Vf(s, l, y, E, I) {
    return (s.mode & 1) === 0 ? (s === l ? s.flags |= 65536 : (s.flags |= 128, y.flags |= 131072, y.flags &= -52805, y.tag === 1 && (y.alternate === null ? y.tag = 17 : (l = ds(-1, 1), l.tag = 2, eo(y, l, 1))), y.lanes |= 1), s) : (s.flags |= 65536, s.lanes = I, s);
  }
  var Em = R.ReactCurrentOwner, fn = !1;
  function Cr(s, l, y, E) {
    l.child = s === null ? or(l, null, y, E) : Uo(l, s.child, y, E);
  }
  function Om(s, l, y, E, I) {
    y = y.render;
    var M = l.ref;
    return Js(l, I), E = kc(s, l, y, E, M, I), y = If(), s !== null && !fn ? (l.updateQueue = s.updateQueue, l.flags &= -2053, s.lanes &= ~I, Fi(s, l, I)) : (Zt && y && ql(l), l.flags |= 1, Cr(s, l, E, I), l.child);
  }
  function km(s, l, y, E, I) {
    if (s === null) {
      var M = y.type;
      return typeof M == "function" && !ud(M) && M.defaultProps === void 0 && y.compare === null && y.defaultProps === void 0 ? (l.tag = 15, l.type = M, Va(s, l, M, E, I)) : (s = ys(y.type, null, E, l, l.mode, I), s.ref = l.ref, s.return = l, l.child = s);
    }
    if (M = s.child, (s.lanes & I) === 0) {
      var G = M.memoizedProps;
      if (y = y.compare, y = y !== null ? y : Vs, y(G, E) && s.ref === l.ref) return Fi(s, l, I);
    }
    return l.flags |= 1, s = uo(M, E), s.ref = l.ref, s.return = l, l.child = s;
  }
  function Va(s, l, y, E, I) {
    if (s !== null) {
      var M = s.memoizedProps;
      if (Vs(M, E) && s.ref === l.ref) if (fn = !1, l.pendingProps = E = M, (s.lanes & I) !== 0) (s.flags & 131072) !== 0 && (fn = !0);
      else return l.lanes = s.lanes, Fi(s, l, I);
    }
    return Lc(s, l, y, E, I);
  }
  function Nc(s, l, y) {
    var E = l.pendingProps, I = E.children, M = s !== null ? s.memoizedState : null;
    if (E.mode === "hidden") if ((l.mode & 1) === 0) l.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Yt(Ya, dn), dn |= y;
    else {
      if ((y & 1073741824) === 0) return s = M !== null ? M.baseLanes | y : y, l.lanes = l.childLanes = 1073741824, l.memoizedState = { baseLanes: s, cachePool: null, transitions: null }, l.updateQueue = null, Yt(Ya, dn), dn |= s, null;
      l.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, E = M !== null ? M.baseLanes : y, Yt(Ya, dn), dn |= E;
    }
    else M !== null ? (E = M.baseLanes | y, l.memoizedState = null) : E = y, Yt(Ya, dn), dn |= E;
    return Cr(s, l, I, y), l.child;
  }
  function jc(s, l) {
    var y = l.ref;
    (s === null && y !== null || s !== null && s.ref !== y) && (l.flags |= 512, l.flags |= 2097152);
  }
  function Lc(s, l, y, E, I) {
    var M = en(y) ? Gs : Wr.current;
    return M = Mo(l, M), Js(l, I), y = kc(s, l, y, E, M, I), E = If(), s !== null && !fn ? (l.updateQueue = s.updateQueue, l.flags &= -2053, s.lanes &= ~I, Fi(s, l, I)) : (Zt && E && ql(l), l.flags |= 1, Cr(s, l, y, I), l.child);
  }
  function Hf(s, l, y, E, I) {
    if (en(y)) {
      var M = !0;
      dc(l);
    } else M = !1;
    if (Js(l, I), l.stateNode === null) qc(s, l), Rc(l, y, E), Ic(l, y, E, I), E = !0;
    else if (s === null) {
      var G = l.stateNode, de = l.memoizedProps;
      G.props = de;
      var be = G.context, Re = y.contextType;
      typeof Re == "object" && Re !== null ? Re = pn(Re) : (Re = en(y) ? Gs : Wr.current, Re = Mo(l, Re));
      var Be = y.getDerivedStateFromProps, We = typeof Be == "function" || typeof G.getSnapshotBeforeUpdate == "function";
      We || typeof G.UNSAFE_componentWillReceiveProps != "function" && typeof G.componentWillReceiveProps != "function" || (de !== E || be !== Re) && Bf(l, G, E, Re), Zs = !1;
      var Ue = l.memoizedState;
      G.state = Ue, Vn(l, E, G, I), be = l.memoizedState, de !== E || Ue !== be || cn.current || Zs ? (typeof Be == "function" && (Ba(l, y, Be, E), be = l.memoizedState), (de = Zs || Zl(l, y, de, E, Ue, be, Re)) ? (We || typeof G.UNSAFE_componentWillMount != "function" && typeof G.componentWillMount != "function" || (typeof G.componentWillMount == "function" && G.componentWillMount(), typeof G.UNSAFE_componentWillMount == "function" && G.UNSAFE_componentWillMount()), typeof G.componentDidMount == "function" && (l.flags |= 4194308)) : (typeof G.componentDidMount == "function" && (l.flags |= 4194308), l.memoizedProps = E, l.memoizedState = be), G.props = E, G.state = be, G.context = Re, E = de) : (typeof G.componentDidMount == "function" && (l.flags |= 4194308), E = !1);
    } else {
      G = l.stateNode, Tf(s, l), de = l.memoizedProps, Re = l.type === l.elementType ? de : Hn(l.type, de), G.props = Re, We = l.pendingProps, Ue = G.context, be = y.contextType, typeof be == "object" && be !== null ? be = pn(be) : (be = en(y) ? Gs : Wr.current, be = Mo(l, be));
      var et = y.getDerivedStateFromProps;
      (Be = typeof et == "function" || typeof G.getSnapshotBeforeUpdate == "function") || typeof G.UNSAFE_componentWillReceiveProps != "function" && typeof G.componentWillReceiveProps != "function" || (de !== We || Ue !== be) && Bf(l, G, E, be), Zs = !1, Ue = l.memoizedState, G.state = Ue, Vn(l, E, G, I);
      var ut = l.memoizedState;
      de !== We || Ue !== ut || cn.current || Zs ? (typeof et == "function" && (Ba(l, y, et, E), ut = l.memoizedState), (Re = Zs || Zl(l, y, Re, E, Ue, ut, be) || !1) ? (Be || typeof G.UNSAFE_componentWillUpdate != "function" && typeof G.componentWillUpdate != "function" || (typeof G.componentWillUpdate == "function" && G.componentWillUpdate(E, ut, be), typeof G.UNSAFE_componentWillUpdate == "function" && G.UNSAFE_componentWillUpdate(E, ut, be)), typeof G.componentDidUpdate == "function" && (l.flags |= 4), typeof G.getSnapshotBeforeUpdate == "function" && (l.flags |= 1024)) : (typeof G.componentDidUpdate != "function" || de === s.memoizedProps && Ue === s.memoizedState || (l.flags |= 4), typeof G.getSnapshotBeforeUpdate != "function" || de === s.memoizedProps && Ue === s.memoizedState || (l.flags |= 1024), l.memoizedProps = E, l.memoizedState = ut), G.props = E, G.state = ut, G.context = be, E = Re) : (typeof G.componentDidUpdate != "function" || de === s.memoizedProps && Ue === s.memoizedState || (l.flags |= 4), typeof G.getSnapshotBeforeUpdate != "function" || de === s.memoizedProps && Ue === s.memoizedState || (l.flags |= 1024), E = !1);
    }
    return Wf(s, l, y, E, M, I);
  }
  function Wf(s, l, y, E, I, M) {
    jc(s, l);
    var G = (l.flags & 128) !== 0;
    if (!E && !G) return I && Fo(l, y, !1), Fi(s, l, M);
    E = l.stateNode, Em.current = l;
    var de = G && typeof y.getDerivedStateFromError != "function" ? null : E.render();
    return l.flags |= 1, s !== null && G ? (l.child = Uo(l, s.child, null, M), l.child = Uo(l, null, de, M)) : Cr(s, l, de, M), l.memoizedState = E.state, I && Fo(l, y, !0), l.child;
  }
  function Am(s) {
    var l = s.stateNode;
    l.pendingContext ? ui(s, l.pendingContext, l.pendingContext !== l.context) : l.context && ui(s, l.context, !1), za(s, l.containerInfo);
  }
  function Kf(s, l, y, E, I) {
    return Un(), La(I), l.flags |= 256, Cr(s, l, y, E), l.child;
  }
  var Qf = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Yf(s) {
    return { baseLanes: s, cachePool: null, transitions: null };
  }
  function Gf(s, l, y) {
    var E = l.pendingProps, I = rr.current, M = !1, G = (l.flags & 128) !== 0, de;
    if ((de = G) || (de = s !== null && s.memoizedState === null ? !1 : (I & 2) !== 0), de ? (M = !0, l.flags &= -129) : (s === null || s.memoizedState !== null) && (I |= 1), Yt(rr, I & 1), s === null)
      return Sf(l), s = l.memoizedState, s !== null && (s = s.dehydrated, s !== null) ? ((l.mode & 1) === 0 ? l.lanes = 1 : s.data === "$!" ? l.lanes = 8 : l.lanes = 1073741824, null) : (G = E.children, s = E.fallback, M ? (E = l.mode, M = l.child, G = { mode: "hidden", children: G }, (E & 1) === 0 && M !== null ? (M.childLanes = 0, M.pendingProps = G) : M = ea(G, E, 0, null), s = Zo(s, E, y, null), M.return = l, s.return = l, M.sibling = s, l.child = M, l.child.memoizedState = Yf(y), l.memoizedState = Qf, s) : Mc(l, G));
    if (I = s.memoizedState, I !== null && (de = I.dehydrated, de !== null)) return Pm(s, l, G, E, de, I, y);
    if (M) {
      M = E.fallback, G = l.mode, I = s.child, de = I.sibling;
      var be = { mode: "hidden", children: E.children };
      return (G & 1) === 0 && l.child !== I ? (E = l.child, E.childLanes = 0, E.pendingProps = be, l.deletions = null) : (E = uo(I, be), E.subtreeFlags = I.subtreeFlags & 14680064), de !== null ? M = uo(de, M) : (M = Zo(M, G, y, null), M.flags |= 2), M.return = l, E.return = l, E.sibling = M, l.child = E, E = M, M = l.child, G = s.child.memoizedState, G = G === null ? Yf(y) : { baseLanes: G.baseLanes | y, cachePool: null, transitions: G.transitions }, M.memoizedState = G, M.childLanes = s.childLanes & ~y, l.memoizedState = Qf, E;
    }
    return M = s.child, s = M.sibling, E = uo(M, { mode: "visible", children: E.children }), (l.mode & 1) === 0 && (E.lanes = y), E.return = l, E.sibling = null, s !== null && (y = l.deletions, y === null ? (l.deletions = [s], l.flags |= 16) : y.push(s)), l.child = E, l.memoizedState = null, E;
  }
  function Mc(s, l) {
    return l = ea({ mode: "visible", children: l }, s.mode, 0, null), l.return = s, s.child = l;
  }
  function Dc(s, l, y, E) {
    return E !== null && La(E), Uo(l, s.child, null, y), s = Mc(l, l.pendingProps.children), s.flags |= 2, l.memoizedState = null, s;
  }
  function Pm(s, l, y, E, I, M, G) {
    if (y)
      return l.flags & 256 ? (l.flags &= -257, E = Ko(Error(r(422))), Dc(s, l, G, E)) : l.memoizedState !== null ? (l.child = s.child, l.flags |= 128, null) : (M = E.fallback, I = l.mode, E = ea({ mode: "visible", children: E.children }, I, 0, null), M = Zo(M, I, G, null), M.flags |= 2, E.return = l, M.return = l, E.sibling = M, l.child = E, (l.mode & 1) !== 0 && Uo(l, s.child, null, G), l.child.memoizedState = Yf(G), l.memoizedState = Qf, M);
    if ((l.mode & 1) === 0) return Dc(s, l, G, null);
    if (I.data === "$!") {
      if (E = I.nextSibling && I.nextSibling.dataset, E) var de = E.dgst;
      return E = de, M = Error(r(419)), E = Ko(M, E, void 0), Dc(s, l, G, E);
    }
    if (de = (G & s.childLanes) !== 0, fn || de) {
      if (E = $r, E !== null) {
        switch (G & -G) {
          case 4:
            I = 2;
            break;
          case 16:
            I = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            I = 32;
            break;
          case 536870912:
            I = 268435456;
            break;
          default:
            I = 0;
        }
        I = (I & (E.suspendedLanes | G)) !== 0 ? 0 : I, I !== 0 && I !== M.retryLane && (M.retryLane = I, Ii(s, I), mn(E, s, I, -1));
      }
      return Za(), E = Ko(Error(r(421))), Dc(s, l, G, E);
    }
    return I.data === "$?" ? (l.flags |= 128, l.child = s.child, l = qb.bind(null, s), I._reactRetry = l, null) : (s = M.treeContext, Kr = Ws(I.nextSibling), En = l, Zt = !0, Bn = null, s !== null && (xn[Tr++] = _n, xn[Tr++] = cs, xn[Tr++] = zo, _n = s.id, cs = s.overflow, zo = l), l = Mc(l, E.children), l.flags |= 4096, l);
  }
  function Tm(s, l, y) {
    s.lanes |= l;
    var E = s.alternate;
    E !== null && (E.lanes |= l), fs(s.return, l, y);
  }
  function Fc(s, l, y, E, I) {
    var M = s.memoizedState;
    M === null ? s.memoizedState = { isBackwards: l, rendering: null, renderingStartTime: 0, last: E, tail: y, tailMode: I } : (M.isBackwards = l, M.rendering = null, M.renderingStartTime = 0, M.last = E, M.tail = y, M.tailMode = I);
  }
  function Cm(s, l, y) {
    var E = l.pendingProps, I = E.revealOrder, M = E.tail;
    if (Cr(s, l, E.children, y), E = rr.current, (E & 2) !== 0) E = E & 1 | 2, l.flags |= 128;
    else {
      if (s !== null && (s.flags & 128) !== 0) e: for (s = l.child; s !== null; ) {
        if (s.tag === 13) s.memoizedState !== null && Tm(s, y, l);
        else if (s.tag === 19) Tm(s, y, l);
        else if (s.child !== null) {
          s.child.return = s, s = s.child;
          continue;
        }
        if (s === l) break e;
        for (; s.sibling === null; ) {
          if (s.return === null || s.return === l) break e;
          s = s.return;
        }
        s.sibling.return = s.return, s = s.sibling;
      }
      E &= 1;
    }
    if (Yt(rr, E), (l.mode & 1) === 0) l.memoizedState = null;
    else switch (I) {
      case "forwards":
        for (y = l.child, I = null; y !== null; ) s = y.alternate, s !== null && wc(s) === null && (I = y), y = y.sibling;
        y = I, y === null ? (I = l.child, l.child = null) : (I = y.sibling, y.sibling = null), Fc(l, !1, I, y, M);
        break;
      case "backwards":
        for (y = null, I = l.child, l.child = null; I !== null; ) {
          if (s = I.alternate, s !== null && wc(s) === null) {
            l.child = I;
            break;
          }
          s = I.sibling, I.sibling = y, y = I, I = s;
        }
        Fc(l, !0, y, null, M);
        break;
      case "together":
        Fc(l, !1, null, null, void 0);
        break;
      default:
        l.memoizedState = null;
    }
    return l.child;
  }
  function qc(s, l) {
    (l.mode & 1) === 0 && s !== null && (s.alternate = null, l.alternate = null, l.flags |= 2);
  }
  function Fi(s, l, y) {
    if (s !== null && (l.dependencies = s.dependencies), Yo |= l.lanes, (y & l.childLanes) === 0) return null;
    if (s !== null && l.child !== s.child) throw Error(r(153));
    if (l.child !== null) {
      for (s = l.child, y = uo(s, s.pendingProps), l.child = y, y.return = l; s.sibling !== null; ) s = s.sibling, y = y.sibling = uo(s, s.pendingProps), y.return = l;
      y.sibling = null;
    }
    return l.child;
  }
  function Ha(s, l, y) {
    switch (l.tag) {
      case 3:
        Am(l), Un();
        break;
      case 5:
        Cf(l);
        break;
      case 1:
        en(l.type) && dc(l);
        break;
      case 4:
        za(l, l.stateNode.containerInfo);
        break;
      case 10:
        var E = l.type._context, I = l.memoizedProps.value;
        Yt(Da, E._currentValue), E._currentValue = I;
        break;
      case 13:
        if (E = l.memoizedState, E !== null)
          return E.dehydrated !== null ? (Yt(rr, rr.current & 1), l.flags |= 128, null) : (y & l.child.childLanes) !== 0 ? Gf(s, l, y) : (Yt(rr, rr.current & 1), s = Fi(s, l, y), s !== null ? s.sibling : null);
        Yt(rr, rr.current & 1);
        break;
      case 19:
        if (E = (y & l.childLanes) !== 0, (s.flags & 128) !== 0) {
          if (E) return Cm(s, l, y);
          l.flags |= 128;
        }
        if (I = l.memoizedState, I !== null && (I.rendering = null, I.tail = null, I.lastEffect = null), Yt(rr, rr.current), E) break;
        return null;
      case 22:
      case 23:
        return l.lanes = 0, Nc(s, l, y);
    }
    return Fi(s, l, y);
  }
  var eu, Wa, $m, Rm;
  eu = function(s, l) {
    for (var y = l.child; y !== null; ) {
      if (y.tag === 5 || y.tag === 6) s.appendChild(y.stateNode);
      else if (y.tag !== 4 && y.child !== null) {
        y.child.return = y, y = y.child;
        continue;
      }
      if (y === l) break;
      for (; y.sibling === null; ) {
        if (y.return === null || y.return === l) return;
        y = y.return;
      }
      y.sibling.return = y.return, y = y.sibling;
    }
  }, Wa = function() {
  }, $m = function(s, l, y, E) {
    var I = s.memoizedProps;
    if (I !== E) {
      s = l.stateNode, Vo(Ni.current);
      var M = null;
      switch (y) {
        case "input":
          I = he(s, I), E = he(s, E), M = [];
          break;
        case "select":
          I = te({}, I, { value: void 0 }), E = te({}, E, { value: void 0 }), M = [];
          break;
        case "textarea":
          I = K(s, I), E = K(s, E), M = [];
          break;
        default:
          typeof I.onClick != "function" && typeof E.onClick == "function" && (s.onclick = Ia);
      }
      Le(y, E);
      var G;
      y = null;
      for (Re in I) if (!E.hasOwnProperty(Re) && I.hasOwnProperty(Re) && I[Re] != null) if (Re === "style") {
        var de = I[Re];
        for (G in de) de.hasOwnProperty(G) && (y || (y = {}), y[G] = "");
      } else Re !== "dangerouslySetInnerHTML" && Re !== "children" && Re !== "suppressContentEditableWarning" && Re !== "suppressHydrationWarning" && Re !== "autoFocus" && (o.hasOwnProperty(Re) ? M || (M = []) : (M = M || []).push(Re, null));
      for (Re in E) {
        var be = E[Re];
        if (de = I != null ? I[Re] : void 0, E.hasOwnProperty(Re) && be !== de && (be != null || de != null)) if (Re === "style") if (de) {
          for (G in de) !de.hasOwnProperty(G) || be && be.hasOwnProperty(G) || (y || (y = {}), y[G] = "");
          for (G in be) be.hasOwnProperty(G) && de[G] !== be[G] && (y || (y = {}), y[G] = be[G]);
        } else y || (M || (M = []), M.push(
          Re,
          y
        )), y = be;
        else Re === "dangerouslySetInnerHTML" ? (be = be ? be.__html : void 0, de = de ? de.__html : void 0, be != null && de !== be && (M = M || []).push(Re, be)) : Re === "children" ? typeof be != "string" && typeof be != "number" || (M = M || []).push(Re, "" + be) : Re !== "suppressContentEditableWarning" && Re !== "suppressHydrationWarning" && (o.hasOwnProperty(Re) ? (be != null && Re === "onScroll" && Qt("scroll", s), M || de === be || (M = [])) : (M = M || []).push(Re, be));
      }
      y && (M = M || []).push("style", y);
      var Re = M;
      (l.updateQueue = Re) && (l.flags |= 4);
    }
  }, Rm = function(s, l, y, E) {
    y !== E && (l.flags |= 4);
  };
  function tu(s, l) {
    if (!Zt) switch (s.tailMode) {
      case "hidden":
        l = s.tail;
        for (var y = null; l !== null; ) l.alternate !== null && (y = l), l = l.sibling;
        y === null ? s.tail = null : y.sibling = null;
        break;
      case "collapsed":
        y = s.tail;
        for (var E = null; y !== null; ) y.alternate !== null && (E = y), y = y.sibling;
        E === null ? l || s.tail === null ? s.tail = null : s.tail.sibling = null : E.sibling = null;
    }
  }
  function qr(s) {
    var l = s.alternate !== null && s.alternate.child === s.child, y = 0, E = 0;
    if (l) for (var I = s.child; I !== null; ) y |= I.lanes | I.childLanes, E |= I.subtreeFlags & 14680064, E |= I.flags & 14680064, I.return = s, I = I.sibling;
    else for (I = s.child; I !== null; ) y |= I.lanes | I.childLanes, E |= I.subtreeFlags, E |= I.flags, I.return = s, I = I.sibling;
    return s.subtreeFlags |= E, s.childLanes = y, l;
  }
  function Nb(s, l, y) {
    var E = l.pendingProps;
    switch (Bo(l), l.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return qr(l), null;
      case 1:
        return en(l.type) && Do(), qr(l), null;
      case 3:
        return E = l.stateNode, Ho(), Jt(cn), Jt(Wr), Sc(), E.pendingContext && (E.context = E.pendingContext, E.pendingContext = null), (s === null || s.child === null) && (yc(l) ? l.flags |= 4 : s === null || s.memoizedState.isDehydrated && (l.flags & 256) === 0 || (l.flags |= 1024, Bn !== null && (Ja(Bn), Bn = null))), Wa(s, l), qr(l), null;
      case 5:
        $f(l);
        var I = Vo(Ul.current);
        if (y = l.type, s !== null && l.stateNode != null) $m(s, l, y, E, I), s.ref !== l.ref && (l.flags |= 512, l.flags |= 2097152);
        else {
          if (!E) {
            if (l.stateNode === null) throw Error(r(166));
            return qr(l), null;
          }
          if (s = Vo(Ni.current), yc(l)) {
            E = l.stateNode, y = l.type;
            var M = l.memoizedProps;
            switch (E[li] = l, E[Dl] = M, s = (l.mode & 1) !== 0, y) {
              case "dialog":
                Qt("cancel", E), Qt("close", E);
                break;
              case "iframe":
              case "object":
              case "embed":
                Qt("load", E);
                break;
              case "video":
              case "audio":
                for (I = 0; I < jl.length; I++) Qt(jl[I], E);
                break;
              case "source":
                Qt("error", E);
                break;
              case "img":
              case "image":
              case "link":
                Qt(
                  "error",
                  E
                ), Qt("load", E);
                break;
              case "details":
                Qt("toggle", E);
                break;
              case "input":
                Z(E, M), Qt("invalid", E);
                break;
              case "select":
                E._wrapperState = { wasMultiple: !!M.multiple }, Qt("invalid", E);
                break;
              case "textarea":
                me(E, M), Qt("invalid", E);
            }
            Le(y, M), I = null;
            for (var G in M) if (M.hasOwnProperty(G)) {
              var de = M[G];
              G === "children" ? typeof de == "string" ? E.textContent !== de && (M.suppressHydrationWarning !== !0 && un(E.textContent, de, s), I = ["children", de]) : typeof de == "number" && E.textContent !== "" + de && (M.suppressHydrationWarning !== !0 && un(
                E.textContent,
                de,
                s
              ), I = ["children", "" + de]) : o.hasOwnProperty(G) && de != null && G === "onScroll" && Qt("scroll", E);
            }
            switch (y) {
              case "input":
                B(E), Oe(E, M, !0);
                break;
              case "textarea":
                B(E), ke(E);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof M.onClick == "function" && (E.onclick = Ia);
            }
            E = I, l.updateQueue = E, E !== null && (l.flags |= 4);
          } else {
            G = I.nodeType === 9 ? I : I.ownerDocument, s === "http://www.w3.org/1999/xhtml" && (s = De(y)), s === "http://www.w3.org/1999/xhtml" ? y === "script" ? (s = G.createElement("div"), s.innerHTML = "<script><\/script>", s = s.removeChild(s.firstChild)) : typeof E.is == "string" ? s = G.createElement(y, { is: E.is }) : (s = G.createElement(y), y === "select" && (G = s, E.multiple ? G.multiple = !0 : E.size && (G.size = E.size))) : s = G.createElementNS(s, y), s[li] = l, s[Dl] = E, eu(s, l, !1, !1), l.stateNode = s;
            e: {
              switch (G = Me(y, E), y) {
                case "dialog":
                  Qt("cancel", s), Qt("close", s), I = E;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  Qt("load", s), I = E;
                  break;
                case "video":
                case "audio":
                  for (I = 0; I < jl.length; I++) Qt(jl[I], s);
                  I = E;
                  break;
                case "source":
                  Qt("error", s), I = E;
                  break;
                case "img":
                case "image":
                case "link":
                  Qt(
                    "error",
                    s
                  ), Qt("load", s), I = E;
                  break;
                case "details":
                  Qt("toggle", s), I = E;
                  break;
                case "input":
                  Z(s, E), I = he(s, E), Qt("invalid", s);
                  break;
                case "option":
                  I = E;
                  break;
                case "select":
                  s._wrapperState = { wasMultiple: !!E.multiple }, I = te({}, E, { value: void 0 }), Qt("invalid", s);
                  break;
                case "textarea":
                  me(s, E), I = K(s, E), Qt("invalid", s);
                  break;
                default:
                  I = E;
              }
              Le(y, I), de = I;
              for (M in de) if (de.hasOwnProperty(M)) {
                var be = de[M];
                M === "style" ? Y(s, be) : M === "dangerouslySetInnerHTML" ? (be = be ? be.__html : void 0, be != null && ct(s, be)) : M === "children" ? typeof be == "string" ? (y !== "textarea" || be !== "") && mt(s, be) : typeof be == "number" && mt(s, "" + be) : M !== "suppressContentEditableWarning" && M !== "suppressHydrationWarning" && M !== "autoFocus" && (o.hasOwnProperty(M) ? be != null && M === "onScroll" && Qt("scroll", s) : be != null && O(s, M, be, G));
              }
              switch (y) {
                case "input":
                  B(s), Oe(s, E, !1);
                  break;
                case "textarea":
                  B(s), ke(s);
                  break;
                case "option":
                  E.value != null && s.setAttribute("value", "" + Se(E.value));
                  break;
                case "select":
                  s.multiple = !!E.multiple, M = E.value, M != null ? $(s, !!E.multiple, M, !1) : E.defaultValue != null && $(
                    s,
                    !!E.multiple,
                    E.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof I.onClick == "function" && (s.onclick = Ia);
              }
              switch (y) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  E = !!E.autoFocus;
                  break e;
                case "img":
                  E = !0;
                  break e;
                default:
                  E = !1;
              }
            }
            E && (l.flags |= 4);
          }
          l.ref !== null && (l.flags |= 512, l.flags |= 2097152);
        }
        return qr(l), null;
      case 6:
        if (s && l.stateNode != null) Rm(s, l, s.memoizedProps, E);
        else {
          if (typeof E != "string" && l.stateNode === null) throw Error(r(166));
          if (y = Vo(Ul.current), Vo(Ni.current), yc(l)) {
            if (E = l.stateNode, y = l.memoizedProps, E[li] = l, (M = E.nodeValue !== y) && (s = En, s !== null)) switch (s.tag) {
              case 3:
                un(E.nodeValue, y, (s.mode & 1) !== 0);
                break;
              case 5:
                s.memoizedProps.suppressHydrationWarning !== !0 && un(E.nodeValue, y, (s.mode & 1) !== 0);
            }
            M && (l.flags |= 4);
          } else E = (y.nodeType === 9 ? y : y.ownerDocument).createTextNode(E), E[li] = l, l.stateNode = E;
        }
        return qr(l), null;
      case 13:
        if (Jt(rr), E = l.memoizedState, s === null || s.memoizedState !== null && s.memoizedState.dehydrated !== null) {
          if (Zt && Kr !== null && (l.mode & 1) !== 0 && (l.flags & 128) === 0) $i(), Un(), l.flags |= 98560, M = !1;
          else if (M = yc(l), E !== null && E.dehydrated !== null) {
            if (s === null) {
              if (!M) throw Error(r(318));
              if (M = l.memoizedState, M = M !== null ? M.dehydrated : null, !M) throw Error(r(317));
              M[li] = l;
            } else Un(), (l.flags & 128) === 0 && (l.memoizedState = null), l.flags |= 4;
            qr(l), M = !1;
          } else Bn !== null && (Ja(Bn), Bn = null), M = !0;
          if (!M) return l.flags & 65536 ? l : null;
        }
        return (l.flags & 128) !== 0 ? (l.lanes = y, l) : (E = E !== null, E !== (s !== null && s.memoizedState !== null) && E && (l.child.flags |= 8192, (l.mode & 1) !== 0 && (s === null || (rr.current & 1) !== 0 ? Ar === 0 && (Ar = 3) : Za())), l.updateQueue !== null && (l.flags |= 4), qr(l), null);
      case 4:
        return Ho(), Wa(s, l), s === null && Ll(l.stateNode.containerInfo), qr(l), null;
      case 10:
        return Of(l.type._context), qr(l), null;
      case 17:
        return en(l.type) && Do(), qr(l), null;
      case 19:
        if (Jt(rr), M = l.memoizedState, M === null) return qr(l), null;
        if (E = (l.flags & 128) !== 0, G = M.rendering, G === null) if (E) tu(M, !1);
        else {
          if (Ar !== 0 || s !== null && (s.flags & 128) !== 0) for (s = l.child; s !== null; ) {
            if (G = wc(s), G !== null) {
              for (l.flags |= 128, tu(M, !1), E = G.updateQueue, E !== null && (l.updateQueue = E, l.flags |= 4), l.subtreeFlags = 0, E = y, y = l.child; y !== null; ) M = y, s = E, M.flags &= 14680066, G = M.alternate, G === null ? (M.childLanes = 0, M.lanes = s, M.child = null, M.subtreeFlags = 0, M.memoizedProps = null, M.memoizedState = null, M.updateQueue = null, M.dependencies = null, M.stateNode = null) : (M.childLanes = G.childLanes, M.lanes = G.lanes, M.child = G.child, M.subtreeFlags = 0, M.deletions = null, M.memoizedProps = G.memoizedProps, M.memoizedState = G.memoizedState, M.updateQueue = G.updateQueue, M.type = G.type, s = G.dependencies, M.dependencies = s === null ? null : { lanes: s.lanes, firstContext: s.firstContext }), y = y.sibling;
              return Yt(rr, rr.current & 1 | 2), l.child;
            }
            s = s.sibling;
          }
          M.tail !== null && Kt() > Ga && (l.flags |= 128, E = !0, tu(M, !1), l.lanes = 4194304);
        }
        else {
          if (!E) if (s = wc(G), s !== null) {
            if (l.flags |= 128, E = !0, y = s.updateQueue, y !== null && (l.updateQueue = y, l.flags |= 4), tu(M, !0), M.tail === null && M.tailMode === "hidden" && !G.alternate && !Zt) return qr(l), null;
          } else 2 * Kt() - M.renderingStartTime > Ga && y !== 1073741824 && (l.flags |= 128, E = !0, tu(M, !1), l.lanes = 4194304);
          M.isBackwards ? (G.sibling = l.child, l.child = G) : (y = M.last, y !== null ? y.sibling = G : l.child = G, M.last = G);
        }
        return M.tail !== null ? (l = M.tail, M.rendering = l, M.tail = l.sibling, M.renderingStartTime = Kt(), l.sibling = null, y = rr.current, Yt(rr, E ? y & 1 | 2 : y & 1), l) : (qr(l), null);
      case 22:
      case 23:
        return cu(), E = l.memoizedState !== null, s !== null && s.memoizedState !== null !== E && (l.flags |= 8192), E && (l.mode & 1) !== 0 ? (dn & 1073741824) !== 0 && (qr(l), l.subtreeFlags & 6 && (l.flags |= 8192)) : qr(l), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(r(156, l.tag));
  }
  function jb(s, l) {
    switch (Bo(l), l.tag) {
      case 1:
        return en(l.type) && Do(), s = l.flags, s & 65536 ? (l.flags = s & -65537 | 128, l) : null;
      case 3:
        return Ho(), Jt(cn), Jt(Wr), Sc(), s = l.flags, (s & 65536) !== 0 && (s & 128) === 0 ? (l.flags = s & -65537 | 128, l) : null;
      case 5:
        return $f(l), null;
      case 13:
        if (Jt(rr), s = l.memoizedState, s !== null && s.dehydrated !== null) {
          if (l.alternate === null) throw Error(r(340));
          Un();
        }
        return s = l.flags, s & 65536 ? (l.flags = s & -65537 | 128, l) : null;
      case 19:
        return Jt(rr), null;
      case 4:
        return Ho(), null;
      case 10:
        return Of(l.type._context), null;
      case 22:
      case 23:
        return cu(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var ru = !1, zr = !1, Im = typeof WeakSet == "function" ? WeakSet : Set, nt = null;
  function Qo(s, l) {
    var y = s.ref;
    if (y !== null) if (typeof y == "function") try {
      y(null);
    } catch (E) {
      fr(s, l, E);
    }
    else y.current = null;
  }
  function Xf(s, l, y) {
    try {
      y();
    } catch (E) {
      fr(s, l, E);
    }
  }
  var Nm = !1;
  function Lb(s, l) {
    if (cc = ft, s = lf(), Ju(s)) {
      if ("selectionStart" in s) var y = { start: s.selectionStart, end: s.selectionEnd };
      else e: {
        y = (y = s.ownerDocument) && y.defaultView || window;
        var E = y.getSelection && y.getSelection();
        if (E && E.rangeCount !== 0) {
          y = E.anchorNode;
          var I = E.anchorOffset, M = E.focusNode;
          E = E.focusOffset;
          try {
            y.nodeType, M.nodeType;
          } catch {
            y = null;
            break e;
          }
          var G = 0, de = -1, be = -1, Re = 0, Be = 0, We = s, Ue = null;
          t: for (; ; ) {
            for (var et; We !== y || I !== 0 && We.nodeType !== 3 || (de = G + I), We !== M || E !== 0 && We.nodeType !== 3 || (be = G + E), We.nodeType === 3 && (G += We.nodeValue.length), (et = We.firstChild) !== null; )
              Ue = We, We = et;
            for (; ; ) {
              if (We === s) break t;
              if (Ue === y && ++Re === I && (de = G), Ue === M && ++Be === E && (be = G), (et = We.nextSibling) !== null) break;
              We = Ue, Ue = We.parentNode;
            }
            We = et;
          }
          y = de === -1 || be === -1 ? null : { start: de, end: be };
        } else y = null;
      }
      y = y || { start: 0, end: 0 };
    } else y = null;
    for (Dr = { focusedElem: s, selectionRange: y }, ft = !1, nt = l; nt !== null; ) if (l = nt, s = l.child, (l.subtreeFlags & 1028) !== 0 && s !== null) s.return = l, nt = s;
    else for (; nt !== null; ) {
      l = nt;
      try {
        var ut = l.alternate;
        if ((l.flags & 1024) !== 0) switch (l.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (ut !== null) {
              var pt = ut.memoizedProps, gr = ut.memoizedState, Ae = l.stateNode, Ee = Ae.getSnapshotBeforeUpdate(l.elementType === l.type ? pt : Hn(l.type, pt), gr);
              Ae.__reactInternalSnapshotBeforeUpdate = Ee;
            }
            break;
          case 3:
            var Ce = l.stateNode.containerInfo;
            Ce.nodeType === 1 ? Ce.textContent = "" : Ce.nodeType === 9 && Ce.documentElement && Ce.removeChild(Ce.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(r(163));
        }
      } catch (Qe) {
        fr(l, l.return, Qe);
      }
      if (s = l.sibling, s !== null) {
        s.return = l.return, nt = s;
        break;
      }
      nt = l.return;
    }
    return ut = Nm, Nm = !1, ut;
  }
  function Ka(s, l, y) {
    var E = l.updateQueue;
    if (E = E !== null ? E.lastEffect : null, E !== null) {
      var I = E = E.next;
      do {
        if ((I.tag & s) === s) {
          var M = I.destroy;
          I.destroy = void 0, M !== void 0 && Xf(l, y, M);
        }
        I = I.next;
      } while (I !== E);
    }
  }
  function zc(s, l) {
    if (l = l.updateQueue, l = l !== null ? l.lastEffect : null, l !== null) {
      var y = l = l.next;
      do {
        if ((y.tag & s) === s) {
          var E = y.create;
          y.destroy = E();
        }
        y = y.next;
      } while (y !== l);
    }
  }
  function Jf(s) {
    var l = s.ref;
    if (l !== null) {
      var y = s.stateNode;
      switch (s.tag) {
        case 5:
          s = y;
          break;
        default:
          s = y;
      }
      typeof l == "function" ? l(s) : l.current = s;
    }
  }
  function Zf(s) {
    var l = s.alternate;
    l !== null && (s.alternate = null, Zf(l)), s.child = null, s.deletions = null, s.sibling = null, s.tag === 5 && (l = s.stateNode, l !== null && (delete l[li], delete l[Dl], delete l[yf], delete l[Cb], delete l[sm])), s.stateNode = null, s.return = null, s.dependencies = null, s.memoizedProps = null, s.memoizedState = null, s.pendingProps = null, s.stateNode = null, s.updateQueue = null;
  }
  function ed(s) {
    return s.tag === 5 || s.tag === 3 || s.tag === 4;
  }
  function nu(s) {
    e: for (; ; ) {
      for (; s.sibling === null; ) {
        if (s.return === null || ed(s.return)) return null;
        s = s.return;
      }
      for (s.sibling.return = s.return, s = s.sibling; s.tag !== 5 && s.tag !== 6 && s.tag !== 18; ) {
        if (s.flags & 2 || s.child === null || s.tag === 4) continue e;
        s.child.return = s, s = s.child;
      }
      if (!(s.flags & 2)) return s.stateNode;
    }
  }
  function Qa(s, l, y) {
    var E = s.tag;
    if (E === 5 || E === 6) s = s.stateNode, l ? y.nodeType === 8 ? y.parentNode.insertBefore(s, l) : y.insertBefore(s, l) : (y.nodeType === 8 ? (l = y.parentNode, l.insertBefore(s, y)) : (l = y, l.appendChild(s)), y = y._reactRootContainer, y != null || l.onclick !== null || (l.onclick = Ia));
    else if (E !== 4 && (s = s.child, s !== null)) for (Qa(s, l, y), s = s.sibling; s !== null; ) Qa(s, l, y), s = s.sibling;
  }
  function Bc(s, l, y) {
    var E = s.tag;
    if (E === 5 || E === 6) s = s.stateNode, l ? y.insertBefore(s, l) : y.appendChild(s);
    else if (E !== 4 && (s = s.child, s !== null)) for (Bc(s, l, y), s = s.sibling; s !== null; ) Bc(s, l, y), s = s.sibling;
  }
  var Br = null, ci = !1;
  function io(s, l, y) {
    for (y = y.child; y !== null; ) iu(s, l, y), y = y.sibling;
  }
  function iu(s, l, y) {
    if (Jr && typeof Jr.onCommitFiberUnmount == "function") try {
      Jr.onCommitFiberUnmount(rs, y);
    } catch {
    }
    switch (y.tag) {
      case 5:
        zr || Qo(y, l);
      case 6:
        var E = Br, I = ci;
        Br = null, io(s, l, y), Br = E, ci = I, Br !== null && (ci ? (s = Br, y = y.stateNode, s.nodeType === 8 ? s.parentNode.removeChild(y) : s.removeChild(y)) : Br.removeChild(y.stateNode));
        break;
      case 18:
        Br !== null && (ci ? (s = Br, y = y.stateNode, s.nodeType === 8 ? pc(s.parentNode, y) : s.nodeType === 1 && pc(s, y), oi(s)) : pc(Br, y.stateNode));
        break;
      case 4:
        E = Br, I = ci, Br = y.stateNode.containerInfo, ci = !0, io(s, l, y), Br = E, ci = I;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!zr && (E = y.updateQueue, E !== null && (E = E.lastEffect, E !== null))) {
          I = E = E.next;
          do {
            var M = I, G = M.destroy;
            M = M.tag, G !== void 0 && ((M & 2) !== 0 || (M & 4) !== 0) && Xf(y, l, G), I = I.next;
          } while (I !== E);
        }
        io(s, l, y);
        break;
      case 1:
        if (!zr && (Qo(y, l), E = y.stateNode, typeof E.componentWillUnmount == "function")) try {
          E.props = y.memoizedProps, E.state = y.memoizedState, E.componentWillUnmount();
        } catch (de) {
          fr(y, l, de);
        }
        io(s, l, y);
        break;
      case 21:
        io(s, l, y);
        break;
      case 22:
        y.mode & 1 ? (zr = (E = zr) || y.memoizedState !== null, io(s, l, y), zr = E) : io(s, l, y);
        break;
      default:
        io(s, l, y);
    }
  }
  function td(s) {
    var l = s.updateQueue;
    if (l !== null) {
      s.updateQueue = null;
      var y = s.stateNode;
      y === null && (y = s.stateNode = new Im()), l.forEach(function(E) {
        var I = Wm.bind(null, s, E);
        y.has(E) || (y.add(E), E.then(I, I));
      });
    }
  }
  function Wn(s, l) {
    var y = l.deletions;
    if (y !== null) for (var E = 0; E < y.length; E++) {
      var I = y[E];
      try {
        var M = s, G = l, de = G;
        e: for (; de !== null; ) {
          switch (de.tag) {
            case 5:
              Br = de.stateNode, ci = !1;
              break e;
            case 3:
              Br = de.stateNode.containerInfo, ci = !0;
              break e;
            case 4:
              Br = de.stateNode.containerInfo, ci = !0;
              break e;
          }
          de = de.return;
        }
        if (Br === null) throw Error(r(160));
        iu(M, G, I), Br = null, ci = !1;
        var be = I.alternate;
        be !== null && (be.return = null), I.return = null;
      } catch (Re) {
        fr(I, l, Re);
      }
    }
    if (l.subtreeFlags & 12854) for (l = l.child; l !== null; ) rd(l, s), l = l.sibling;
  }
  function rd(s, l) {
    var y = s.alternate, E = s.flags;
    switch (s.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (Wn(l, s), An(s), E & 4) {
          try {
            Ka(3, s, s.return), zc(3, s);
          } catch (pt) {
            fr(s, s.return, pt);
          }
          try {
            Ka(5, s, s.return);
          } catch (pt) {
            fr(s, s.return, pt);
          }
        }
        break;
      case 1:
        Wn(l, s), An(s), E & 512 && y !== null && Qo(y, y.return);
        break;
      case 5:
        if (Wn(l, s), An(s), E & 512 && y !== null && Qo(y, y.return), s.flags & 32) {
          var I = s.stateNode;
          try {
            mt(I, "");
          } catch (pt) {
            fr(s, s.return, pt);
          }
        }
        if (E & 4 && (I = s.stateNode, I != null)) {
          var M = s.memoizedProps, G = y !== null ? y.memoizedProps : M, de = s.type, be = s.updateQueue;
          if (s.updateQueue = null, be !== null) try {
            de === "input" && M.type === "radio" && M.name != null && re(I, M), Me(de, G);
            var Re = Me(de, M);
            for (G = 0; G < be.length; G += 2) {
              var Be = be[G], We = be[G + 1];
              Be === "style" ? Y(I, We) : Be === "dangerouslySetInnerHTML" ? ct(I, We) : Be === "children" ? mt(I, We) : O(I, Be, We, Re);
            }
            switch (de) {
              case "input":
                Pe(I, M);
                break;
              case "textarea":
                Te(I, M);
                break;
              case "select":
                var Ue = I._wrapperState.wasMultiple;
                I._wrapperState.wasMultiple = !!M.multiple;
                var et = M.value;
                et != null ? $(I, !!M.multiple, et, !1) : Ue !== !!M.multiple && (M.defaultValue != null ? $(
                  I,
                  !!M.multiple,
                  M.defaultValue,
                  !0
                ) : $(I, !!M.multiple, M.multiple ? [] : "", !1));
            }
            I[Dl] = M;
          } catch (pt) {
            fr(s, s.return, pt);
          }
        }
        break;
      case 6:
        if (Wn(l, s), An(s), E & 4) {
          if (s.stateNode === null) throw Error(r(162));
          I = s.stateNode, M = s.memoizedProps;
          try {
            I.nodeValue = M;
          } catch (pt) {
            fr(s, s.return, pt);
          }
        }
        break;
      case 3:
        if (Wn(l, s), An(s), E & 4 && y !== null && y.memoizedState.isDehydrated) try {
          oi(l.containerInfo);
        } catch (pt) {
          fr(s, s.return, pt);
        }
        break;
      case 4:
        Wn(l, s), An(s);
        break;
      case 13:
        Wn(l, s), An(s), I = s.child, I.flags & 8192 && (M = I.memoizedState !== null, I.stateNode.isHidden = M, !M || I.alternate !== null && I.alternate.memoizedState !== null || (sd = Kt())), E & 4 && td(s);
        break;
      case 22:
        if (Be = y !== null && y.memoizedState !== null, s.mode & 1 ? (zr = (Re = zr) || Be, Wn(l, s), zr = Re) : Wn(l, s), An(s), E & 8192) {
          if (Re = s.memoizedState !== null, (s.stateNode.isHidden = Re) && !Be && (s.mode & 1) !== 0) for (nt = s, Be = s.child; Be !== null; ) {
            for (We = nt = Be; nt !== null; ) {
              switch (Ue = nt, et = Ue.child, Ue.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Ka(4, Ue, Ue.return);
                  break;
                case 1:
                  Qo(Ue, Ue.return);
                  var ut = Ue.stateNode;
                  if (typeof ut.componentWillUnmount == "function") {
                    E = Ue, y = Ue.return;
                    try {
                      l = E, ut.props = l.memoizedProps, ut.state = l.memoizedState, ut.componentWillUnmount();
                    } catch (pt) {
                      fr(E, y, pt);
                    }
                  }
                  break;
                case 5:
                  Qo(Ue, Ue.return);
                  break;
                case 22:
                  if (Ue.memoizedState !== null) {
                    Lm(We);
                    continue;
                  }
              }
              et !== null ? (et.return = Ue, nt = et) : Lm(We);
            }
            Be = Be.sibling;
          }
          e: for (Be = null, We = s; ; ) {
            if (We.tag === 5) {
              if (Be === null) {
                Be = We;
                try {
                  I = We.stateNode, Re ? (M = I.style, typeof M.setProperty == "function" ? M.setProperty("display", "none", "important") : M.display = "none") : (de = We.stateNode, be = We.memoizedProps.style, G = be != null && be.hasOwnProperty("display") ? be.display : null, de.style.display = Vt("display", G));
                } catch (pt) {
                  fr(s, s.return, pt);
                }
              }
            } else if (We.tag === 6) {
              if (Be === null) try {
                We.stateNode.nodeValue = Re ? "" : We.memoizedProps;
              } catch (pt) {
                fr(s, s.return, pt);
              }
            } else if ((We.tag !== 22 && We.tag !== 23 || We.memoizedState === null || We === s) && We.child !== null) {
              We.child.return = We, We = We.child;
              continue;
            }
            if (We === s) break e;
            for (; We.sibling === null; ) {
              if (We.return === null || We.return === s) break e;
              Be === We && (Be = null), We = We.return;
            }
            Be === We && (Be = null), We.sibling.return = We.return, We = We.sibling;
          }
        }
        break;
      case 19:
        Wn(l, s), An(s), E & 4 && td(s);
        break;
      case 21:
        break;
      default:
        Wn(
          l,
          s
        ), An(s);
    }
  }
  function An(s) {
    var l = s.flags;
    if (l & 2) {
      try {
        e: {
          for (var y = s.return; y !== null; ) {
            if (ed(y)) {
              var E = y;
              break e;
            }
            y = y.return;
          }
          throw Error(r(160));
        }
        switch (E.tag) {
          case 5:
            var I = E.stateNode;
            E.flags & 32 && (mt(I, ""), E.flags &= -33);
            var M = nu(s);
            Bc(s, M, I);
            break;
          case 3:
          case 4:
            var G = E.stateNode.containerInfo, de = nu(s);
            Qa(s, de, G);
            break;
          default:
            throw Error(r(161));
        }
      } catch (be) {
        fr(s, s.return, be);
      }
      s.flags &= -3;
    }
    l & 4096 && (s.flags &= -4097);
  }
  function nd(s, l, y) {
    nt = s, qi(s);
  }
  function qi(s, l, y) {
    for (var E = (s.mode & 1) !== 0; nt !== null; ) {
      var I = nt, M = I.child;
      if (I.tag === 22 && E) {
        var G = I.memoizedState !== null || ru;
        if (!G) {
          var de = I.alternate, be = de !== null && de.memoizedState !== null || zr;
          de = ru;
          var Re = zr;
          if (ru = G, (zr = be) && !Re) for (nt = I; nt !== null; ) G = nt, be = G.child, G.tag === 22 && G.memoizedState !== null ? Mm(I) : be !== null ? (be.return = G, nt = be) : Mm(I);
          for (; M !== null; ) nt = M, qi(M), M = M.sibling;
          nt = I, ru = de, zr = Re;
        }
        jm(s);
      } else (I.subtreeFlags & 8772) !== 0 && M !== null ? (M.return = I, nt = M) : jm(s);
    }
  }
  function jm(s) {
    for (; nt !== null; ) {
      var l = nt;
      if ((l.flags & 8772) !== 0) {
        var y = l.alternate;
        try {
          if ((l.flags & 8772) !== 0) switch (l.tag) {
            case 0:
            case 11:
            case 15:
              zr || zc(5, l);
              break;
            case 1:
              var E = l.stateNode;
              if (l.flags & 4 && !zr) if (y === null) E.componentDidMount();
              else {
                var I = l.elementType === l.type ? y.memoizedProps : Hn(l.type, y.memoizedProps);
                E.componentDidUpdate(I, y.memoizedState, E.__reactInternalSnapshotBeforeUpdate);
              }
              var M = l.updateQueue;
              M !== null && pm(l, M, E);
              break;
            case 3:
              var G = l.updateQueue;
              if (G !== null) {
                if (y = null, l.child !== null) switch (l.child.tag) {
                  case 5:
                    y = l.child.stateNode;
                    break;
                  case 1:
                    y = l.child.stateNode;
                }
                pm(l, G, y);
              }
              break;
            case 5:
              var de = l.stateNode;
              if (y === null && l.flags & 4) {
                y = de;
                var be = l.memoizedProps;
                switch (l.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    be.autoFocus && y.focus();
                    break;
                  case "img":
                    be.src && (y.src = be.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (l.memoizedState === null) {
                var Re = l.alternate;
                if (Re !== null) {
                  var Be = Re.memoizedState;
                  if (Be !== null) {
                    var We = Be.dehydrated;
                    We !== null && oi(We);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(r(163));
          }
          zr || l.flags & 512 && Jf(l);
        } catch (Ue) {
          fr(l, l.return, Ue);
        }
      }
      if (l === s) {
        nt = null;
        break;
      }
      if (y = l.sibling, y !== null) {
        y.return = l.return, nt = y;
        break;
      }
      nt = l.return;
    }
  }
  function Lm(s) {
    for (; nt !== null; ) {
      var l = nt;
      if (l === s) {
        nt = null;
        break;
      }
      var y = l.sibling;
      if (y !== null) {
        y.return = l.return, nt = y;
        break;
      }
      nt = l.return;
    }
  }
  function Mm(s) {
    for (; nt !== null; ) {
      var l = nt;
      try {
        switch (l.tag) {
          case 0:
          case 11:
          case 15:
            var y = l.return;
            try {
              zc(4, l);
            } catch (be) {
              fr(l, y, be);
            }
            break;
          case 1:
            var E = l.stateNode;
            if (typeof E.componentDidMount == "function") {
              var I = l.return;
              try {
                E.componentDidMount();
              } catch (be) {
                fr(l, I, be);
              }
            }
            var M = l.return;
            try {
              Jf(l);
            } catch (be) {
              fr(l, M, be);
            }
            break;
          case 5:
            var G = l.return;
            try {
              Jf(l);
            } catch (be) {
              fr(l, G, be);
            }
        }
      } catch (be) {
        fr(l, l.return, be);
      }
      if (l === s) {
        nt = null;
        break;
      }
      var de = l.sibling;
      if (de !== null) {
        de.return = l.return, nt = de;
        break;
      }
      nt = l.return;
    }
  }
  var Dm = Math.ceil, Uc = R.ReactCurrentDispatcher, id = R.ReactCurrentOwner, Pn = R.ReactCurrentBatchConfig, Nt = 0, $r = null, _r = null, Ur = 0, dn = 0, Ya = Ys(0), Ar = 0, su = null, Yo = 0, Tn = 0, Vc = 0, ou = null, hn = null, sd = 0, Ga = 1 / 0, hs = null, au = !1, Xa = null, zi = null, lu = !1, so = null, ms = 0, uu = 0, od = null, Hc = -1, Go = 0;
  function rn() {
    return (Nt & 6) !== 0 ? Kt() : Hc !== -1 ? Hc : Hc = Kt();
  }
  function oo(s) {
    return (s.mode & 1) === 0 ? 1 : (Nt & 2) !== 0 && Ur !== 0 ? Ur & -Ur : $b.transition !== null ? (Go === 0 && (Go = Mn()), Go) : (s = Lt, s !== 0 || (s = window.event, s = s === void 0 ? 16 : Sr(s.type)), s);
  }
  function mn(s, l, y, E) {
    if (50 < uu) throw uu = 0, od = null, Error(r(185));
    xi(s, y, E), ((Nt & 2) === 0 || s !== $r) && (s === $r && ((Nt & 2) === 0 && (Tn |= y), Ar === 4 && gs(s, Ur)), gn(s, E), y === 1 && Nt === 0 && (l.mode & 1) === 0 && (Ga = Kt() + 500, zn && Ci()));
  }
  function gn(s, l) {
    var y = s.callbackNode;
    ko(s, l);
    var E = ss(s, s === $r ? Ur : 0);
    if (E === 0) y !== null && ba(y), s.callbackNode = null, s.callbackPriority = 0;
    else if (l = E & -E, s.callbackPriority !== l) {
      if (y != null && ba(y), l === 1) s.tag === 0 ? hc(qm.bind(null, s)) : am(qm.bind(null, s)), Pb(function() {
        (Nt & 6) === 0 && Ci();
      }), y = null;
      else {
        switch (ni(E)) {
          case 1:
            y = Ds;
            break;
          case 4:
            y = bi;
            break;
          case 16:
            y = jn;
            break;
          case 536870912:
            y = ts;
            break;
          default:
            y = jn;
        }
        y = Qm(y, Fm.bind(null, s));
      }
      s.callbackPriority = l, s.callbackNode = y;
    }
  }
  function Fm(s, l) {
    if (Hc = -1, Go = 0, (Nt & 6) !== 0) throw Error(r(327));
    var y = s.callbackNode;
    if (el() && s.callbackNode !== y) return null;
    var E = ss(s, s === $r ? Ur : 0);
    if (E === 0) return null;
    if ((E & 30) !== 0 || (E & s.expiredLanes) !== 0 || l) l = pu(s, E);
    else {
      l = E;
      var I = Nt;
      Nt |= 2;
      var M = Jo();
      ($r !== s || Ur !== l) && (hs = null, Ga = Kt() + 500, Xo(s, l));
      do
        try {
          Um();
          break;
        } catch (de) {
          zm(s, de);
        }
      while (!0);
      Ef(), Uc.current = M, Nt = I, _r !== null ? l = 0 : ($r = null, Ur = 0, l = Ar);
    }
    if (l !== 0) {
      if (l === 2 && (I = Ln(s), I !== 0 && (E = I, l = ad(s, I))), l === 1) throw y = su, Xo(s, 0), gs(s, E), gn(s, Kt()), y;
      if (l === 6) gs(s, E);
      else {
        if (I = s.current.alternate, (E & 30) === 0 && !Mb(I) && (l = pu(s, E), l === 2 && (M = Ln(s), M !== 0 && (E = M, l = ad(s, M))), l === 1)) throw y = su, Xo(s, 0), gs(s, E), gn(s, Kt()), y;
        switch (s.finishedWork = I, s.finishedLanes = E, l) {
          case 0:
          case 1:
            throw Error(r(345));
          case 2:
            lo(s, hn, hs);
            break;
          case 3:
            if (gs(s, E), (E & 130023424) === E && (l = sd + 500 - Kt(), 10 < l)) {
              if (ss(s, 0) !== 0) break;
              if (I = s.suspendedLanes, (I & E) !== E) {
                rn(), s.pingedLanes |= s.suspendedLanes & I;
                break;
              }
              s.timeoutHandle = mf(lo.bind(null, s, hn, hs), l);
              break;
            }
            lo(s, hn, hs);
            break;
          case 4:
            if (gs(s, E), (E & 4194240) === E) break;
            for (l = s.eventTimes, I = -1; 0 < E; ) {
              var G = 31 - Mr(E);
              M = 1 << G, G = l[G], G > I && (I = G), E &= ~M;
            }
            if (E = I, E = Kt() - E, E = (120 > E ? 120 : 480 > E ? 480 : 1080 > E ? 1080 : 1920 > E ? 1920 : 3e3 > E ? 3e3 : 4320 > E ? 4320 : 1960 * Dm(E / 1960)) - E, 10 < E) {
              s.timeoutHandle = mf(lo.bind(null, s, hn, hs), E);
              break;
            }
            lo(s, hn, hs);
            break;
          case 5:
            lo(s, hn, hs);
            break;
          default:
            throw Error(r(329));
        }
      }
    }
    return gn(s, Kt()), s.callbackNode === y ? Fm.bind(null, s) : null;
  }
  function ad(s, l) {
    var y = ou;
    return s.current.memoizedState.isDehydrated && (Xo(s, l).flags |= 256), s = pu(s, l), s !== 2 && (l = hn, hn = y, l !== null && Ja(l)), s;
  }
  function Ja(s) {
    hn === null ? hn = s : hn.push.apply(hn, s);
  }
  function Mb(s) {
    for (var l = s; ; ) {
      if (l.flags & 16384) {
        var y = l.updateQueue;
        if (y !== null && (y = y.stores, y !== null)) for (var E = 0; E < y.length; E++) {
          var I = y[E], M = I.getSnapshot;
          I = I.value;
          try {
            if (!kr(M(), I)) return !1;
          } catch {
            return !1;
          }
        }
      }
      if (y = l.child, l.subtreeFlags & 16384 && y !== null) y.return = l, l = y;
      else {
        if (l === s) break;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === s) return !0;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
    }
    return !0;
  }
  function gs(s, l) {
    for (l &= ~Vc, l &= ~Tn, s.suspendedLanes |= l, s.pingedLanes &= ~l, s = s.expirationTimes; 0 < l; ) {
      var y = 31 - Mr(l), E = 1 << y;
      s[y] = -1, l &= ~E;
    }
  }
  function qm(s) {
    if ((Nt & 6) !== 0) throw Error(r(327));
    el();
    var l = ss(s, 0);
    if ((l & 1) === 0) return gn(s, Kt()), null;
    var y = pu(s, l);
    if (s.tag !== 0 && y === 2) {
      var E = Ln(s);
      E !== 0 && (l = E, y = ad(s, E));
    }
    if (y === 1) throw y = su, Xo(s, 0), gs(s, l), gn(s, Kt()), y;
    if (y === 6) throw Error(r(345));
    return s.finishedWork = s.current.alternate, s.finishedLanes = l, lo(s, hn, hs), gn(s, Kt()), null;
  }
  function ld(s, l) {
    var y = Nt;
    Nt |= 1;
    try {
      return s(l);
    } finally {
      Nt = y, Nt === 0 && (Ga = Kt() + 500, zn && Ci());
    }
  }
  function ao(s) {
    so !== null && so.tag === 0 && (Nt & 6) === 0 && el();
    var l = Nt;
    Nt |= 1;
    var y = Pn.transition, E = Lt;
    try {
      if (Pn.transition = null, Lt = 1, s) return s();
    } finally {
      Lt = E, Pn.transition = y, Nt = l, (Nt & 6) === 0 && Ci();
    }
  }
  function cu() {
    dn = Ya.current, Jt(Ya);
  }
  function Xo(s, l) {
    s.finishedWork = null, s.finishedLanes = 0;
    var y = s.timeoutHandle;
    if (y !== -1 && (s.timeoutHandle = -1, Ab(y)), _r !== null) for (y = _r.return; y !== null; ) {
      var E = y;
      switch (Bo(E), E.tag) {
        case 1:
          E = E.type.childContextTypes, E != null && Do();
          break;
        case 3:
          Ho(), Jt(cn), Jt(Wr), Sc();
          break;
        case 5:
          $f(E);
          break;
        case 4:
          Ho();
          break;
        case 13:
          Jt(rr);
          break;
        case 19:
          Jt(rr);
          break;
        case 10:
          Of(E.type._context);
          break;
        case 22:
        case 23:
          cu();
      }
      y = y.return;
    }
    if ($r = s, _r = s = uo(s.current, null), Ur = dn = l, Ar = 0, su = null, Vc = Tn = Yo = 0, hn = ou = null, Ri !== null) {
      for (l = 0; l < Ri.length; l++) if (y = Ri[l], E = y.interleaved, E !== null) {
        y.interleaved = null;
        var I = E.next, M = y.pending;
        if (M !== null) {
          var G = M.next;
          M.next = I, E.next = G;
        }
        y.pending = E;
      }
      Ri = null;
    }
    return s;
  }
  function zm(s, l) {
    do {
      var y = _r;
      try {
        if (Ef(), xc.current = Xl, _c) {
          for (var E = ar.memoizedState; E !== null; ) {
            var I = E.queue;
            I !== null && (I.pending = null), E = E.next;
          }
          _c = !1;
        }
        if (Wo = 0, nr = pr = ar = null, Vl = !1, Hl = 0, id.current = null, y === null || y.return === null) {
          Ar = 1, su = l, _r = null;
          break;
        }
        e: {
          var M = s, G = y.return, de = y, be = l;
          if (l = Ur, de.flags |= 32768, be !== null && typeof be == "object" && typeof be.then == "function") {
            var Re = be, Be = de, We = Be.tag;
            if ((Be.mode & 1) === 0 && (We === 0 || We === 11 || We === 15)) {
              var Ue = Be.alternate;
              Ue ? (Be.updateQueue = Ue.updateQueue, Be.memoizedState = Ue.memoizedState, Be.lanes = Ue.lanes) : (Be.updateQueue = null, Be.memoizedState = null);
            }
            var et = _m(G);
            if (et !== null) {
              et.flags &= -257, Vf(et, G, de, M, l), et.mode & 1 && no(M, Re, l), l = et, be = Re;
              var ut = l.updateQueue;
              if (ut === null) {
                var pt = /* @__PURE__ */ new Set();
                pt.add(be), l.updateQueue = pt;
              } else ut.add(be);
              break e;
            } else {
              if ((l & 1) === 0) {
                no(M, Re, l), Za();
                break e;
              }
              be = Error(r(426));
            }
          } else if (Zt && de.mode & 1) {
            var gr = _m(G);
            if (gr !== null) {
              (gr.flags & 65536) === 0 && (gr.flags |= 256), Vf(gr, G, de, M, l), La(Ua(be, de));
              break e;
            }
          }
          M = be = Ua(be, de), Ar !== 4 && (Ar = 2), ou === null ? ou = [M] : ou.push(M), M = G;
          do {
            switch (M.tag) {
              case 3:
                M.flags |= 65536, l &= -l, M.lanes |= l;
                var Ae = Sm(M, be, l);
                cm(M, Ae);
                break e;
              case 1:
                de = be;
                var Ee = M.type, Ce = M.stateNode;
                if ((M.flags & 128) === 0 && (typeof Ee.getDerivedStateFromError == "function" || Ce !== null && typeof Ce.componentDidCatch == "function" && (zi === null || !zi.has(Ce)))) {
                  M.flags |= 65536, l &= -l, M.lanes |= l;
                  var Qe = xm(M, de, l);
                  cm(M, Qe);
                  break e;
                }
            }
            M = M.return;
          } while (M !== null);
        }
        Wc(y);
      } catch (ot) {
        l = ot, _r === y && y !== null && (_r = y = y.return);
        continue;
      }
      break;
    } while (!0);
  }
  function Jo() {
    var s = Uc.current;
    return Uc.current = Xl, s === null ? Xl : s;
  }
  function Za() {
    (Ar === 0 || Ar === 3 || Ar === 2) && (Ar = 4), $r === null || (Yo & 268435455) === 0 && (Tn & 268435455) === 0 || gs($r, Ur);
  }
  function pu(s, l) {
    var y = Nt;
    Nt |= 2;
    var E = Jo();
    ($r !== s || Ur !== l) && (hs = null, Xo(s, l));
    do
      try {
        Bm();
        break;
      } catch (I) {
        zm(s, I);
      }
    while (!0);
    if (Ef(), Nt = y, Uc.current = E, _r !== null) throw Error(r(261));
    return $r = null, Ur = 0, Ar;
  }
  function Bm() {
    for (; _r !== null; ) fu(_r);
  }
  function Um() {
    for (; _r !== null && !_l(); ) fu(_r);
  }
  function fu(s) {
    var l = Km(s.alternate, s, dn);
    s.memoizedProps = s.pendingProps, l === null ? Wc(s) : _r = l, id.current = null;
  }
  function Wc(s) {
    var l = s;
    do {
      var y = l.alternate;
      if (s = l.return, (l.flags & 32768) === 0) {
        if (y = Nb(y, l, dn), y !== null) {
          _r = y;
          return;
        }
      } else {
        if (y = jb(y, l), y !== null) {
          y.flags &= 32767, _r = y;
          return;
        }
        if (s !== null) s.flags |= 32768, s.subtreeFlags = 0, s.deletions = null;
        else {
          Ar = 6, _r = null;
          return;
        }
      }
      if (l = l.sibling, l !== null) {
        _r = l;
        return;
      }
      _r = l = s;
    } while (l !== null);
    Ar === 0 && (Ar = 5);
  }
  function lo(s, l, y) {
    var E = Lt, I = Pn.transition;
    try {
      Pn.transition = null, Lt = 1, Db(s, l, y, E);
    } finally {
      Pn.transition = I, Lt = E;
    }
    return null;
  }
  function Db(s, l, y, E) {
    do
      el();
    while (so !== null);
    if ((Nt & 6) !== 0) throw Error(r(327));
    y = s.finishedWork;
    var I = s.finishedLanes;
    if (y === null) return null;
    if (s.finishedWork = null, s.finishedLanes = 0, y === s.current) throw Error(r(177));
    s.callbackNode = null, s.callbackPriority = 0;
    var M = y.lanes | y.childLanes;
    if (os(s, M), s === $r && (_r = $r = null, Ur = 0), (y.subtreeFlags & 2064) === 0 && (y.flags & 2064) === 0 || lu || (lu = !0, Qm(jn, function() {
      return el(), null;
    })), M = (y.flags & 15990) !== 0, (y.subtreeFlags & 15990) !== 0 || M) {
      M = Pn.transition, Pn.transition = null;
      var G = Lt;
      Lt = 1;
      var de = Nt;
      Nt |= 4, id.current = null, Lb(s, y), rd(y, s), _b(Dr), ft = !!cc, Dr = cc = null, s.current = y, nd(y), Nn(), Nt = de, Lt = G, Pn.transition = M;
    } else s.current = y;
    if (lu && (lu = !1, so = s, ms = I), M = s.pendingLanes, M === 0 && (zi = null), Ku(y.stateNode), gn(s, Kt()), l !== null) for (E = s.onRecoverableError, y = 0; y < l.length; y++) I = l[y], E(I.value, { componentStack: I.stack, digest: I.digest });
    if (au) throw au = !1, s = Xa, Xa = null, s;
    return (ms & 1) !== 0 && s.tag !== 0 && el(), M = s.pendingLanes, (M & 1) !== 0 ? s === od ? uu++ : (uu = 0, od = s) : uu = 0, Ci(), null;
  }
  function el() {
    if (so !== null) {
      var s = ni(ms), l = Pn.transition, y = Lt;
      try {
        if (Pn.transition = null, Lt = 16 > s ? 16 : s, so === null) var E = !1;
        else {
          if (s = so, so = null, ms = 0, (Nt & 6) !== 0) throw Error(r(331));
          var I = Nt;
          for (Nt |= 4, nt = s.current; nt !== null; ) {
            var M = nt, G = M.child;
            if ((nt.flags & 16) !== 0) {
              var de = M.deletions;
              if (de !== null) {
                for (var be = 0; be < de.length; be++) {
                  var Re = de[be];
                  for (nt = Re; nt !== null; ) {
                    var Be = nt;
                    switch (Be.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Ka(8, Be, M);
                    }
                    var We = Be.child;
                    if (We !== null) We.return = Be, nt = We;
                    else for (; nt !== null; ) {
                      Be = nt;
                      var Ue = Be.sibling, et = Be.return;
                      if (Zf(Be), Be === Re) {
                        nt = null;
                        break;
                      }
                      if (Ue !== null) {
                        Ue.return = et, nt = Ue;
                        break;
                      }
                      nt = et;
                    }
                  }
                }
                var ut = M.alternate;
                if (ut !== null) {
                  var pt = ut.child;
                  if (pt !== null) {
                    ut.child = null;
                    do {
                      var gr = pt.sibling;
                      pt.sibling = null, pt = gr;
                    } while (pt !== null);
                  }
                }
                nt = M;
              }
            }
            if ((M.subtreeFlags & 2064) !== 0 && G !== null) G.return = M, nt = G;
            else e: for (; nt !== null; ) {
              if (M = nt, (M.flags & 2048) !== 0) switch (M.tag) {
                case 0:
                case 11:
                case 15:
                  Ka(9, M, M.return);
              }
              var Ae = M.sibling;
              if (Ae !== null) {
                Ae.return = M.return, nt = Ae;
                break e;
              }
              nt = M.return;
            }
          }
          var Ee = s.current;
          for (nt = Ee; nt !== null; ) {
            G = nt;
            var Ce = G.child;
            if ((G.subtreeFlags & 2064) !== 0 && Ce !== null) Ce.return = G, nt = Ce;
            else e: for (G = Ee; nt !== null; ) {
              if (de = nt, (de.flags & 2048) !== 0) try {
                switch (de.tag) {
                  case 0:
                  case 11:
                  case 15:
                    zc(9, de);
                }
              } catch (ot) {
                fr(de, de.return, ot);
              }
              if (de === G) {
                nt = null;
                break e;
              }
              var Qe = de.sibling;
              if (Qe !== null) {
                Qe.return = de.return, nt = Qe;
                break e;
              }
              nt = de.return;
            }
          }
          if (Nt = I, Ci(), Jr && typeof Jr.onPostCommitFiberRoot == "function") try {
            Jr.onPostCommitFiberRoot(rs, s);
          } catch {
          }
          E = !0;
        }
        return E;
      } finally {
        Lt = y, Pn.transition = l;
      }
    }
    return !1;
  }
  function Vm(s, l, y) {
    l = Ua(y, l), l = Sm(s, l, 1), s = eo(s, l, 1), l = rn(), s !== null && (xi(s, 1, l), gn(s, l));
  }
  function fr(s, l, y) {
    if (s.tag === 3) Vm(s, s, y);
    else for (; l !== null; ) {
      if (l.tag === 3) {
        Vm(l, s, y);
        break;
      } else if (l.tag === 1) {
        var E = l.stateNode;
        if (typeof l.type.getDerivedStateFromError == "function" || typeof E.componentDidCatch == "function" && (zi === null || !zi.has(E))) {
          s = Ua(y, s), s = xm(l, s, 1), l = eo(l, s, 1), s = rn(), l !== null && (xi(l, 1, s), gn(l, s));
          break;
        }
      }
      l = l.return;
    }
  }
  function Fb(s, l, y) {
    var E = s.pingCache;
    E !== null && E.delete(l), l = rn(), s.pingedLanes |= s.suspendedLanes & y, $r === s && (Ur & y) === y && (Ar === 4 || Ar === 3 && (Ur & 130023424) === Ur && 500 > Kt() - sd ? Xo(s, 0) : Vc |= y), gn(s, l);
  }
  function Hm(s, l) {
    l === 0 && ((s.mode & 1) === 0 ? l = 1 : (l = qs, qs <<= 1, (qs & 130023424) === 0 && (qs = 4194304)));
    var y = rn();
    s = Ii(s, l), s !== null && (xi(s, l, y), gn(s, y));
  }
  function qb(s) {
    var l = s.memoizedState, y = 0;
    l !== null && (y = l.retryLane), Hm(s, y);
  }
  function Wm(s, l) {
    var y = 0;
    switch (s.tag) {
      case 13:
        var E = s.stateNode, I = s.memoizedState;
        I !== null && (y = I.retryLane);
        break;
      case 19:
        E = s.stateNode;
        break;
      default:
        throw Error(r(314));
    }
    E !== null && E.delete(l), Hm(s, y);
  }
  var Km;
  Km = function(s, l, y) {
    if (s !== null) if (s.memoizedProps !== l.pendingProps || cn.current) fn = !0;
    else {
      if ((s.lanes & y) === 0 && (l.flags & 128) === 0) return fn = !1, Ha(s, l, y);
      fn = (s.flags & 131072) !== 0;
    }
    else fn = !1, Zt && (l.flags & 1048576) !== 0 && lm(l, Fl, l.index);
    switch (l.lanes = 0, l.tag) {
      case 2:
        var E = l.type;
        qc(s, l), s = l.pendingProps;
        var I = Mo(l, Wr.current);
        Js(l, y), I = kc(null, l, E, s, I, y);
        var M = If();
        return l.flags |= 1, typeof I == "object" && I !== null && typeof I.render == "function" && I.$$typeof === void 0 ? (l.tag = 1, l.memoizedState = null, l.updateQueue = null, en(E) ? (M = !0, dc(l)) : M = !1, l.memoizedState = I.state !== null && I.state !== void 0 ? I.state : null, Pf(l), I.updater = Jl, l.stateNode = I, I._reactInternals = l, Ic(l, E, s, y), l = Wf(null, l, E, !0, M, y)) : (l.tag = 0, Zt && M && ql(l), Cr(null, l, I, y), l = l.child), l;
      case 16:
        E = l.elementType;
        e: {
          switch (qc(s, l), s = l.pendingProps, I = E._init, E = I(E._payload), l.type = E, I = l.tag = cd(E), s = Hn(E, s), I) {
            case 0:
              l = Lc(null, l, E, s, y);
              break e;
            case 1:
              l = Hf(null, l, E, s, y);
              break e;
            case 11:
              l = Om(null, l, E, s, y);
              break e;
            case 14:
              l = km(null, l, E, Hn(E.type, s), y);
              break e;
          }
          throw Error(r(
            306,
            E,
            ""
          ));
        }
        return l;
      case 0:
        return E = l.type, I = l.pendingProps, I = l.elementType === E ? I : Hn(E, I), Lc(s, l, E, I, y);
      case 1:
        return E = l.type, I = l.pendingProps, I = l.elementType === E ? I : Hn(E, I), Hf(s, l, E, I, y);
      case 3:
        e: {
          if (Am(l), s === null) throw Error(r(387));
          E = l.pendingProps, M = l.memoizedState, I = M.element, Tf(s, l), Vn(l, E, null, y);
          var G = l.memoizedState;
          if (E = G.element, M.isDehydrated) if (M = { element: E, isDehydrated: !1, cache: G.cache, pendingSuspenseBoundaries: G.pendingSuspenseBoundaries, transitions: G.transitions }, l.updateQueue.baseState = M, l.memoizedState = M, l.flags & 256) {
            I = Ua(Error(r(423)), l), l = Kf(s, l, E, y, I);
            break e;
          } else if (E !== I) {
            I = Ua(Error(r(424)), l), l = Kf(s, l, E, y, I);
            break e;
          } else for (Kr = Ws(l.stateNode.containerInfo.firstChild), En = l, Zt = !0, Bn = null, y = or(l, null, E, y), l.child = y; y; ) y.flags = y.flags & -3 | 4096, y = y.sibling;
          else {
            if (Un(), E === I) {
              l = Fi(s, l, y);
              break e;
            }
            Cr(s, l, E, y);
          }
          l = l.child;
        }
        return l;
      case 5:
        return Cf(l), s === null && Sf(l), E = l.type, I = l.pendingProps, M = s !== null ? s.memoizedProps : null, G = I.children, hf(E, I) ? G = null : M !== null && hf(E, M) && (l.flags |= 32), jc(s, l), Cr(s, l, G, y), l.child;
      case 6:
        return s === null && Sf(l), null;
      case 13:
        return Gf(s, l, y);
      case 4:
        return za(l, l.stateNode.containerInfo), E = l.pendingProps, s === null ? l.child = Uo(l, null, E, y) : Cr(s, l, E, y), l.child;
      case 11:
        return E = l.type, I = l.pendingProps, I = l.elementType === E ? I : Hn(E, I), Om(s, l, E, I, y);
      case 7:
        return Cr(s, l, l.pendingProps, y), l.child;
      case 8:
        return Cr(s, l, l.pendingProps.children, y), l.child;
      case 12:
        return Cr(s, l, l.pendingProps.children, y), l.child;
      case 10:
        e: {
          if (E = l.type._context, I = l.pendingProps, M = l.memoizedProps, G = I.value, Yt(Da, E._currentValue), E._currentValue = G, M !== null) if (kr(M.value, G)) {
            if (M.children === I.children && !cn.current) {
              l = Fi(s, l, y);
              break e;
            }
          } else for (M = l.child, M !== null && (M.return = l); M !== null; ) {
            var de = M.dependencies;
            if (de !== null) {
              G = M.child;
              for (var be = de.firstContext; be !== null; ) {
                if (be.context === E) {
                  if (M.tag === 1) {
                    be = ds(-1, y & -y), be.tag = 2;
                    var Re = M.updateQueue;
                    if (Re !== null) {
                      Re = Re.shared;
                      var Be = Re.pending;
                      Be === null ? be.next = be : (be.next = Be.next, Be.next = be), Re.pending = be;
                    }
                  }
                  M.lanes |= y, be = M.alternate, be !== null && (be.lanes |= y), fs(
                    M.return,
                    y,
                    l
                  ), de.lanes |= y;
                  break;
                }
                be = be.next;
              }
            } else if (M.tag === 10) G = M.type === l.type ? null : M.child;
            else if (M.tag === 18) {
              if (G = M.return, G === null) throw Error(r(341));
              G.lanes |= y, de = G.alternate, de !== null && (de.lanes |= y), fs(G, y, l), G = M.sibling;
            } else G = M.child;
            if (G !== null) G.return = M;
            else for (G = M; G !== null; ) {
              if (G === l) {
                G = null;
                break;
              }
              if (M = G.sibling, M !== null) {
                M.return = G.return, G = M;
                break;
              }
              G = G.return;
            }
            M = G;
          }
          Cr(s, l, I.children, y), l = l.child;
        }
        return l;
      case 9:
        return I = l.type, E = l.pendingProps.children, Js(l, y), I = pn(I), E = E(I), l.flags |= 1, Cr(s, l, E, y), l.child;
      case 14:
        return E = l.type, I = Hn(E, l.pendingProps), I = Hn(E.type, I), km(s, l, E, I, y);
      case 15:
        return Va(s, l, l.type, l.pendingProps, y);
      case 17:
        return E = l.type, I = l.pendingProps, I = l.elementType === E ? I : Hn(E, I), qc(s, l), l.tag = 1, en(E) ? (s = !0, dc(l)) : s = !1, Js(l, y), Rc(l, E, I), Ic(l, E, I, y), Wf(null, l, E, !0, s, y);
      case 19:
        return Cm(s, l, y);
      case 22:
        return Nc(s, l, y);
    }
    throw Error(r(156, l.tag));
  };
  function Qm(s, l) {
    return Eo(s, l);
  }
  function zb(s, l, y, E) {
    this.tag = s, this.key = y, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = l, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = E, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Kn(s, l, y, E) {
    return new zb(s, l, y, E);
  }
  function ud(s) {
    return s = s.prototype, !(!s || !s.isReactComponent);
  }
  function cd(s) {
    if (typeof s == "function") return ud(s) ? 1 : 0;
    if (s != null) {
      if (s = s.$$typeof, s === H) return 11;
      if (s === fe) return 14;
    }
    return 2;
  }
  function uo(s, l) {
    var y = s.alternate;
    return y === null ? (y = Kn(s.tag, l, s.key, s.mode), y.elementType = s.elementType, y.type = s.type, y.stateNode = s.stateNode, y.alternate = s, s.alternate = y) : (y.pendingProps = l, y.type = s.type, y.flags = 0, y.subtreeFlags = 0, y.deletions = null), y.flags = s.flags & 14680064, y.childLanes = s.childLanes, y.lanes = s.lanes, y.child = s.child, y.memoizedProps = s.memoizedProps, y.memoizedState = s.memoizedState, y.updateQueue = s.updateQueue, l = s.dependencies, y.dependencies = l === null ? null : { lanes: l.lanes, firstContext: l.firstContext }, y.sibling = s.sibling, y.index = s.index, y.ref = s.ref, y;
  }
  function ys(s, l, y, E, I, M) {
    var G = 2;
    if (E = s, typeof s == "function") ud(s) && (G = 1);
    else if (typeof s == "string") G = 5;
    else e: switch (s) {
      case j:
        return Zo(y.children, I, M, l);
      case D:
        G = 8, I |= 8;
        break;
      case V:
        return s = Kn(12, y, l, I | 2), s.elementType = V, s.lanes = M, s;
      case ae:
        return s = Kn(13, y, l, I), s.elementType = ae, s.lanes = M, s;
      case ge:
        return s = Kn(19, y, l, I), s.elementType = ge, s.lanes = M, s;
      case $e:
        return ea(y, I, M, l);
      default:
        if (typeof s == "object" && s !== null) switch (s.$$typeof) {
          case U:
            G = 10;
            break e;
          case ne:
            G = 9;
            break e;
          case H:
            G = 11;
            break e;
          case fe:
            G = 14;
            break e;
          case ve:
            G = 16, E = null;
            break e;
        }
        throw Error(r(130, s == null ? s : typeof s, ""));
    }
    return l = Kn(G, y, l, I), l.elementType = s, l.type = E, l.lanes = M, l;
  }
  function Zo(s, l, y, E) {
    return s = Kn(7, s, E, l), s.lanes = y, s;
  }
  function ea(s, l, y, E) {
    return s = Kn(22, s, E, l), s.elementType = $e, s.lanes = y, s.stateNode = { isHidden: !1 }, s;
  }
  function Kc(s, l, y) {
    return s = Kn(6, s, null, l), s.lanes = y, s;
  }
  function Qc(s, l, y) {
    return l = Kn(4, s.children !== null ? s.children : [], s.key, l), l.lanes = y, l.stateNode = { containerInfo: s.containerInfo, pendingChildren: null, implementation: s.implementation }, l;
  }
  function Ym(s, l, y, E, I) {
    this.tag = l, this.containerInfo = s, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Dn(0), this.expirationTimes = Dn(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Dn(0), this.identifierPrefix = E, this.onRecoverableError = I, this.mutableSourceEagerHydrationData = null;
  }
  function Yc(s, l, y, E, I, M, G, de, be) {
    return s = new Ym(s, l, y, de, be), l === 1 ? (l = 1, M === !0 && (l |= 8)) : l = 0, M = Kn(3, null, null, l), s.current = M, M.stateNode = s, M.memoizedState = { element: E, isDehydrated: y, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Pf(M), s;
  }
  function Bb(s, l, y) {
    var E = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: T, key: E == null ? null : "" + E, children: s, containerInfo: l, implementation: y };
  }
  function Gm(s) {
    if (!s) return us;
    s = s._reactInternals;
    e: {
      if (Ht(s) !== s || s.tag !== 1) throw Error(r(170));
      var l = s;
      do {
        switch (l.tag) {
          case 3:
            l = l.stateNode.context;
            break e;
          case 1:
            if (en(l.type)) {
              l = l.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        l = l.return;
      } while (l !== null);
      throw Error(r(171));
    }
    if (s.tag === 1) {
      var y = s.type;
      if (en(y)) return om(s, y, l);
    }
    return l;
  }
  function Gc(s, l, y, E, I, M, G, de, be) {
    return s = Yc(y, E, !0, s, I, M, G, de, be), s.context = Gm(null), y = s.current, E = rn(), I = oo(y), M = ds(E, I), M.callback = l ?? null, eo(y, M, I), s.current.lanes = I, xi(s, I, E), gn(s, E), s;
  }
  function Xc(s, l, y, E) {
    var I = l.current, M = rn(), G = oo(I);
    return y = Gm(y), l.context === null ? l.context = y : l.pendingContext = y, l = ds(M, G), l.payload = { element: s }, E = E === void 0 ? null : E, E !== null && (l.callback = E), s = eo(I, l, G), s !== null && (mn(s, I, G, M), zl(s, I, G)), G;
  }
  function du(s) {
    if (s = s.current, !s.child) return null;
    switch (s.child.tag) {
      case 5:
        return s.child.stateNode;
      default:
        return s.child.stateNode;
    }
  }
  function pd(s, l) {
    if (s = s.memoizedState, s !== null && s.dehydrated !== null) {
      var y = s.retryLane;
      s.retryLane = y !== 0 && y < l ? y : l;
    }
  }
  function fd(s, l) {
    pd(s, l), (s = s.alternate) && pd(s, l);
  }
  function Ub() {
    return null;
  }
  var dd = typeof reportError == "function" ? reportError : function(s) {
    console.error(s);
  };
  function hd(s) {
    this._internalRoot = s;
  }
  Jc.prototype.render = hd.prototype.render = function(s) {
    var l = this._internalRoot;
    if (l === null) throw Error(r(409));
    Xc(s, l, null, null);
  }, Jc.prototype.unmount = hd.prototype.unmount = function() {
    var s = this._internalRoot;
    if (s !== null) {
      this._internalRoot = null;
      var l = s.containerInfo;
      ao(function() {
        Xc(null, s, null, null);
      }), l[Ti] = null;
    }
  };
  function Jc(s) {
    this._internalRoot = s;
  }
  Jc.prototype.unstable_scheduleHydration = function(s) {
    if (s) {
      var l = kl();
      s = { blockedOn: null, target: s, priority: l };
      for (var y = 0; y < br.length && l !== 0 && l < br[y].priority; y++) ;
      br.splice(y, 0, s), y === 0 && To(s);
    }
  };
  function md(s) {
    return !(!s || s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11);
  }
  function Zc(s) {
    return !(!s || s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11 && (s.nodeType !== 8 || s.nodeValue !== " react-mount-point-unstable "));
  }
  function gd() {
  }
  function Vb(s, l, y, E, I) {
    if (I) {
      if (typeof E == "function") {
        var M = E;
        E = function() {
          var Re = du(G);
          M.call(Re);
        };
      }
      var G = Gc(l, E, s, 0, null, !1, !1, "", gd);
      return s._reactRootContainer = G, s[Ti] = G.current, Ll(s.nodeType === 8 ? s.parentNode : s), ao(), G;
    }
    for (; I = s.lastChild; ) s.removeChild(I);
    if (typeof E == "function") {
      var de = E;
      E = function() {
        var Re = du(be);
        de.call(Re);
      };
    }
    var be = Yc(s, 0, !1, null, null, !1, !1, "", gd);
    return s._reactRootContainer = be, s[Ti] = be.current, Ll(s.nodeType === 8 ? s.parentNode : s), ao(function() {
      Xc(l, be, y, E);
    }), be;
  }
  function hu(s, l, y, E, I) {
    var M = y._reactRootContainer;
    if (M) {
      var G = M;
      if (typeof I == "function") {
        var de = I;
        I = function() {
          var be = du(G);
          de.call(be);
        };
      }
      Xc(l, G, s, I);
    } else G = Vb(y, l, s, I, E);
    return du(G);
  }
  Ol = function(s) {
    switch (s.tag) {
      case 3:
        var l = s.stateNode;
        if (l.current.memoizedState.isDehydrated) {
          var y = Si(l.pendingLanes);
          y !== 0 && (wa(l, y | 1), gn(l, Kt()), (Nt & 6) === 0 && (Ga = Kt() + 500, Ci()));
        }
        break;
      case 13:
        ao(function() {
          var E = Ii(s, 1);
          if (E !== null) {
            var I = rn();
            mn(E, s, 1, I);
          }
        }), fd(s, 1);
    }
  }, _i = function(s) {
    if (s.tag === 13) {
      var l = Ii(s, 134217728);
      if (l !== null) {
        var y = rn();
        mn(l, s, 134217728, y);
      }
      fd(s, 134217728);
    }
  }, Sa = function(s) {
    if (s.tag === 13) {
      var l = oo(s), y = Ii(s, l);
      if (y !== null) {
        var E = rn();
        mn(y, s, l, E);
      }
      fd(s, l);
    }
  }, kl = function() {
    return Lt;
  }, mr = function(s, l) {
    var y = Lt;
    try {
      return Lt = s, l();
    } finally {
      Lt = y;
    }
  }, rt = function(s, l, y) {
    switch (l) {
      case "input":
        if (Pe(s, y), l = y.name, y.type === "radio" && l != null) {
          for (y = s; y.parentNode; ) y = y.parentNode;
          for (y = y.querySelectorAll("input[name=" + JSON.stringify("" + l) + '][type="radio"]'), l = 0; l < y.length; l++) {
            var E = y[l];
            if (E !== s && E.form === s.form) {
              var I = fc(E);
              if (!I) throw Error(r(90));
              oe(E), Pe(E, I);
            }
          }
        }
        break;
      case "textarea":
        Te(s, y);
        break;
      case "select":
        l = y.value, l != null && $(s, !!y.multiple, l, !1);
    }
  }, Tt = ld, It = ao;
  var Hb = { usingClientEntryPoint: !1, Events: [Na, ja, fc, bt, kt, ld] }, mu = { findFiberByHostInstance: Ks, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, Xm = { bundleType: mu.bundleType, version: mu.version, rendererPackageName: mu.rendererPackageName, rendererConfig: mu.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: R.ReactCurrentDispatcher, findHostInstanceByFiber: function(s) {
    return s = Ms(s), s === null ? null : s.stateNode;
  }, findFiberByHostInstance: mu.findFiberByHostInstance || Ub, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var gu = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!gu.isDisabled && gu.supportsFiber) try {
      rs = gu.inject(Xm), Jr = gu;
    } catch {
    }
  }
  return Yn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Hb, Yn.createPortal = function(s, l) {
    var y = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!md(l)) throw Error(r(200));
    return Bb(s, l, null, y);
  }, Yn.createRoot = function(s, l) {
    if (!md(s)) throw Error(r(299));
    var y = !1, E = "", I = dd;
    return l != null && (l.unstable_strictMode === !0 && (y = !0), l.identifierPrefix !== void 0 && (E = l.identifierPrefix), l.onRecoverableError !== void 0 && (I = l.onRecoverableError)), l = Yc(s, 1, !1, null, null, y, !1, E, I), s[Ti] = l.current, Ll(s.nodeType === 8 ? s.parentNode : s), new hd(l);
  }, Yn.findDOMNode = function(s) {
    if (s == null) return null;
    if (s.nodeType === 1) return s;
    var l = s._reactInternals;
    if (l === void 0)
      throw typeof s.render == "function" ? Error(r(188)) : (s = Object.keys(s).join(","), Error(r(268, s)));
    return s = Ms(l), s = s === null ? null : s.stateNode, s;
  }, Yn.flushSync = function(s) {
    return ao(s);
  }, Yn.hydrate = function(s, l, y) {
    if (!Zc(l)) throw Error(r(200));
    return hu(null, s, l, !0, y);
  }, Yn.hydrateRoot = function(s, l, y) {
    if (!md(s)) throw Error(r(405));
    var E = y != null && y.hydratedSources || null, I = !1, M = "", G = dd;
    if (y != null && (y.unstable_strictMode === !0 && (I = !0), y.identifierPrefix !== void 0 && (M = y.identifierPrefix), y.onRecoverableError !== void 0 && (G = y.onRecoverableError)), l = Gc(l, null, s, 1, y ?? null, I, !1, M, G), s[Ti] = l.current, Ll(s), E) for (s = 0; s < E.length; s++) y = E[s], I = y._getVersion, I = I(y._source), l.mutableSourceEagerHydrationData == null ? l.mutableSourceEagerHydrationData = [y, I] : l.mutableSourceEagerHydrationData.push(
      y,
      I
    );
    return new Jc(l);
  }, Yn.render = function(s, l, y) {
    if (!Zc(l)) throw Error(r(200));
    return hu(null, s, l, !1, y);
  }, Yn.unmountComponentAtNode = function(s) {
    if (!Zc(s)) throw Error(r(40));
    return s._reactRootContainer ? (ao(function() {
      hu(null, null, s, !1, function() {
        s._reactRootContainer = null, s[Ti] = null;
      });
    }), !0) : !1;
  }, Yn.unstable_batchedUpdates = ld, Yn.unstable_renderSubtreeIntoContainer = function(s, l, y, E) {
    if (!Zc(y)) throw Error(r(200));
    if (s == null || s._reactInternals === void 0) throw Error(r(38));
    return hu(s, l, y, !1, E);
  }, Yn.version = "18.3.1-next-f1338f8080-20240426", Yn;
}
var c1;
function UR() {
  if (c1) return Xb.exports;
  c1 = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), Xb.exports = BR(), Xb.exports;
}
var zA = UR(), Pt = ch();
const Rt = /* @__PURE__ */ NS(Pt);
var Ty = { exports: {} }, e0 = { exports: {} };
/**
 * lunr - http://lunrjs.com - A bit like Solr, but much smaller and not as bright - 2.3.9
 * Copyright (C) 2020 Oliver Nightingale
 * @license MIT
 */
var p1;
function VR() {
  return p1 || (p1 = 1, function(e, t) {
    (function() {
      var r = function(n) {
        var o = new r.Builder();
        return o.pipeline.add(
          r.trimmer,
          r.stopWordFilter,
          r.stemmer
        ), o.searchPipeline.add(
          r.stemmer
        ), n.call(o, o), o.build();
      };
      r.version = "2.3.9";
      /*!
       * lunr.utils
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.utils = {}, r.utils.warn = /* @__PURE__ */ function(n) {
        return function(o) {
          n.console && console.warn && console.warn(o);
        };
      }(this), r.utils.asString = function(n) {
        return n == null ? "" : n.toString();
      }, r.utils.clone = function(n) {
        if (n == null)
          return n;
        for (var o = /* @__PURE__ */ Object.create(null), a = Object.keys(n), i = 0; i < a.length; i++) {
          var u = a[i], c = n[u];
          if (Array.isArray(c)) {
            o[u] = c.slice();
            continue;
          }
          if (typeof c == "string" || typeof c == "number" || typeof c == "boolean") {
            o[u] = c;
            continue;
          }
          throw new TypeError("clone is not deep and does not support nested objects");
        }
        return o;
      }, r.FieldRef = function(n, o, a) {
        this.docRef = n, this.fieldName = o, this._stringValue = a;
      }, r.FieldRef.joiner = "/", r.FieldRef.fromString = function(n) {
        var o = n.indexOf(r.FieldRef.joiner);
        if (o === -1)
          throw "malformed field ref string";
        var a = n.slice(0, o), i = n.slice(o + 1);
        return new r.FieldRef(i, a, n);
      }, r.FieldRef.prototype.toString = function() {
        return this._stringValue == null && (this._stringValue = this.fieldName + r.FieldRef.joiner + this.docRef), this._stringValue;
      };
      /*!
       * lunr.Set
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.Set = function(n) {
        if (this.elements = /* @__PURE__ */ Object.create(null), n) {
          this.length = n.length;
          for (var o = 0; o < this.length; o++)
            this.elements[n[o]] = !0;
        } else
          this.length = 0;
      }, r.Set.complete = {
        intersect: function(n) {
          return n;
        },
        union: function() {
          return this;
        },
        contains: function() {
          return !0;
        }
      }, r.Set.empty = {
        intersect: function() {
          return this;
        },
        union: function(n) {
          return n;
        },
        contains: function() {
          return !1;
        }
      }, r.Set.prototype.contains = function(n) {
        return !!this.elements[n];
      }, r.Set.prototype.intersect = function(n) {
        var o, a, i, u = [];
        if (n === r.Set.complete)
          return this;
        if (n === r.Set.empty)
          return n;
        this.length < n.length ? (o = this, a = n) : (o = n, a = this), i = Object.keys(o.elements);
        for (var c = 0; c < i.length; c++) {
          var d = i[c];
          d in a.elements && u.push(d);
        }
        return new r.Set(u);
      }, r.Set.prototype.union = function(n) {
        return n === r.Set.complete ? r.Set.complete : n === r.Set.empty ? this : new r.Set(Object.keys(this.elements).concat(Object.keys(n.elements)));
      }, r.idf = function(n, o) {
        var a = 0;
        for (var i in n)
          i != "_index" && (a += Object.keys(n[i]).length);
        var u = (o - a + 0.5) / (a + 0.5);
        return Math.log(1 + Math.abs(u));
      }, r.Token = function(n, o) {
        this.str = n || "", this.metadata = o || {};
      }, r.Token.prototype.toString = function() {
        return this.str;
      }, r.Token.prototype.update = function(n) {
        return this.str = n(this.str, this.metadata), this;
      }, r.Token.prototype.clone = function(n) {
        return n = n || function(o) {
          return o;
        }, new r.Token(n(this.str, this.metadata), this.metadata);
      };
      /*!
       * lunr.tokenizer
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.tokenizer = function(n, o) {
        if (n == null || n == null)
          return [];
        if (Array.isArray(n))
          return n.map(function(S) {
            return new r.Token(
              r.utils.asString(S).toLowerCase(),
              r.utils.clone(o)
            );
          });
        for (var a = n.toString().toLowerCase(), i = a.length, u = [], c = 0, d = 0; c <= i; c++) {
          var m = a.charAt(c), g = c - d;
          if (m.match(r.tokenizer.separator) || c == i) {
            if (g > 0) {
              var v = r.utils.clone(o) || {};
              v.position = [d, g], v.index = u.length, u.push(
                new r.Token(
                  a.slice(d, c),
                  v
                )
              );
            }
            d = c + 1;
          }
        }
        return u;
      }, r.tokenizer.separator = /[\s\-]+/;
      /*!
       * lunr.Pipeline
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.Pipeline = function() {
        this._stack = [];
      }, r.Pipeline.registeredFunctions = /* @__PURE__ */ Object.create(null), r.Pipeline.registerFunction = function(n, o) {
        o in this.registeredFunctions && r.utils.warn("Overwriting existing registered function: " + o), n.label = o, r.Pipeline.registeredFunctions[n.label] = n;
      }, r.Pipeline.warnIfFunctionNotRegistered = function(n) {
        var o = n.label && n.label in this.registeredFunctions;
        o || r.utils.warn(`Function is not registered with pipeline. This may cause problems when serialising the index.
`, n);
      }, r.Pipeline.load = function(n) {
        var o = new r.Pipeline();
        return n.forEach(function(a) {
          var i = r.Pipeline.registeredFunctions[a];
          if (i)
            o.add(i);
          else
            throw new Error("Cannot load unregistered function: " + a);
        }), o;
      }, r.Pipeline.prototype.add = function() {
        var n = Array.prototype.slice.call(arguments);
        n.forEach(function(o) {
          r.Pipeline.warnIfFunctionNotRegistered(o), this._stack.push(o);
        }, this);
      }, r.Pipeline.prototype.after = function(n, o) {
        r.Pipeline.warnIfFunctionNotRegistered(o);
        var a = this._stack.indexOf(n);
        if (a == -1)
          throw new Error("Cannot find existingFn");
        a = a + 1, this._stack.splice(a, 0, o);
      }, r.Pipeline.prototype.before = function(n, o) {
        r.Pipeline.warnIfFunctionNotRegistered(o);
        var a = this._stack.indexOf(n);
        if (a == -1)
          throw new Error("Cannot find existingFn");
        this._stack.splice(a, 0, o);
      }, r.Pipeline.prototype.remove = function(n) {
        var o = this._stack.indexOf(n);
        o != -1 && this._stack.splice(o, 1);
      }, r.Pipeline.prototype.run = function(n) {
        for (var o = this._stack.length, a = 0; a < o; a++) {
          for (var i = this._stack[a], u = [], c = 0; c < n.length; c++) {
            var d = i(n[c], c, n);
            if (!(d == null || d === ""))
              if (Array.isArray(d))
                for (var m = 0; m < d.length; m++)
                  u.push(d[m]);
              else
                u.push(d);
          }
          n = u;
        }
        return n;
      }, r.Pipeline.prototype.runString = function(n, o) {
        var a = new r.Token(n, o);
        return this.run([a]).map(function(i) {
          return i.toString();
        });
      }, r.Pipeline.prototype.reset = function() {
        this._stack = [];
      }, r.Pipeline.prototype.toJSON = function() {
        return this._stack.map(function(n) {
          return r.Pipeline.warnIfFunctionNotRegistered(n), n.label;
        });
      };
      /*!
       * lunr.Vector
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.Vector = function(n) {
        this._magnitude = 0, this.elements = n || [];
      }, r.Vector.prototype.positionForIndex = function(n) {
        if (this.elements.length == 0)
          return 0;
        for (var o = 0, a = this.elements.length / 2, i = a - o, u = Math.floor(i / 2), c = this.elements[u * 2]; i > 1 && (c < n && (o = u), c > n && (a = u), c != n); )
          i = a - o, u = o + Math.floor(i / 2), c = this.elements[u * 2];
        if (c == n || c > n)
          return u * 2;
        if (c < n)
          return (u + 1) * 2;
      }, r.Vector.prototype.insert = function(n, o) {
        this.upsert(n, o, function() {
          throw "duplicate index";
        });
      }, r.Vector.prototype.upsert = function(n, o, a) {
        this._magnitude = 0;
        var i = this.positionForIndex(n);
        this.elements[i] == n ? this.elements[i + 1] = a(this.elements[i + 1], o) : this.elements.splice(i, 0, n, o);
      }, r.Vector.prototype.magnitude = function() {
        if (this._magnitude) return this._magnitude;
        for (var n = 0, o = this.elements.length, a = 1; a < o; a += 2) {
          var i = this.elements[a];
          n += i * i;
        }
        return this._magnitude = Math.sqrt(n);
      }, r.Vector.prototype.dot = function(n) {
        for (var o = 0, a = this.elements, i = n.elements, u = a.length, c = i.length, d = 0, m = 0, g = 0, v = 0; g < u && v < c; )
          d = a[g], m = i[v], d < m ? g += 2 : d > m ? v += 2 : d == m && (o += a[g + 1] * i[v + 1], g += 2, v += 2);
        return o;
      }, r.Vector.prototype.similarity = function(n) {
        return this.dot(n) / this.magnitude() || 0;
      }, r.Vector.prototype.toArray = function() {
        for (var n = new Array(this.elements.length / 2), o = 1, a = 0; o < this.elements.length; o += 2, a++)
          n[a] = this.elements[o];
        return n;
      }, r.Vector.prototype.toJSON = function() {
        return this.elements;
      };
      /*!
       * lunr.stemmer
       * Copyright (C) 2020 Oliver Nightingale
       * Includes code from - http://tartarus.org/~martin/PorterStemmer/js.txt
       */
      r.stemmer = function() {
        var n = {
          ational: "ate",
          tional: "tion",
          enci: "ence",
          anci: "ance",
          izer: "ize",
          bli: "ble",
          alli: "al",
          entli: "ent",
          eli: "e",
          ousli: "ous",
          ization: "ize",
          ation: "ate",
          ator: "ate",
          alism: "al",
          iveness: "ive",
          fulness: "ful",
          ousness: "ous",
          aliti: "al",
          iviti: "ive",
          biliti: "ble",
          logi: "log"
        }, o = {
          icate: "ic",
          ative: "",
          alize: "al",
          iciti: "ic",
          ical: "ic",
          ful: "",
          ness: ""
        }, a = "[^aeiou]", i = "[aeiouy]", u = a + "[^aeiouy]*", c = i + "[aeiou]*", d = "^(" + u + ")?" + c + u, m = "^(" + u + ")?" + c + u + "(" + c + ")?$", g = "^(" + u + ")?" + c + u + c + u, v = "^(" + u + ")?" + i, S = new RegExp(d), k = new RegExp(g), b = new RegExp(m), x = new RegExp(v), A = /^(.+?)(ss|i)es$/, _ = /^(.+?)([^s])s$/, O = /^(.+?)eed$/, R = /^(.+?)(ed|ing)$/, C = /.$/, T = /(at|bl|iz)$/, j = new RegExp("([^aeiouylsz])\\1$"), D = new RegExp("^" + u + i + "[^aeiouwxy]$"), V = /^(.+?[^aeiou])y$/, U = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/, ne = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/, H = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/, ae = /^(.+?)(s|t)(ion)$/, ge = /^(.+?)e$/, fe = /ll$/, ve = new RegExp("^" + u + i + "[^aeiouwxy]$"), $e = function(se) {
          var te, F, J, W, q, X, Q;
          if (se.length < 3)
            return se;
          if (J = se.substr(0, 1), J == "y" && (se = J.toUpperCase() + se.substr(1)), W = A, q = _, W.test(se) ? se = se.replace(W, "$1$2") : q.test(se) && (se = se.replace(q, "$1$2")), W = O, q = R, W.test(se)) {
            var ye = W.exec(se);
            W = S, W.test(ye[1]) && (W = C, se = se.replace(W, ""));
          } else if (q.test(se)) {
            var ye = q.exec(se);
            te = ye[1], q = x, q.test(te) && (se = te, q = T, X = j, Q = D, q.test(se) ? se = se + "e" : X.test(se) ? (W = C, se = se.replace(W, "")) : Q.test(se) && (se = se + "e"));
          }
          if (W = V, W.test(se)) {
            var ye = W.exec(se);
            te = ye[1], se = te + "i";
          }
          if (W = U, W.test(se)) {
            var ye = W.exec(se);
            te = ye[1], F = ye[2], W = S, W.test(te) && (se = te + n[F]);
          }
          if (W = ne, W.test(se)) {
            var ye = W.exec(se);
            te = ye[1], F = ye[2], W = S, W.test(te) && (se = te + o[F]);
          }
          if (W = H, q = ae, W.test(se)) {
            var ye = W.exec(se);
            te = ye[1], W = k, W.test(te) && (se = te);
          } else if (q.test(se)) {
            var ye = q.exec(se);
            te = ye[1] + ye[2], q = k, q.test(te) && (se = te);
          }
          if (W = ge, W.test(se)) {
            var ye = W.exec(se);
            te = ye[1], W = k, q = b, X = ve, (W.test(te) || q.test(te) && !X.test(te)) && (se = te);
          }
          return W = fe, q = k, W.test(se) && q.test(se) && (W = C, se = se.replace(W, "")), J == "y" && (se = J.toLowerCase() + se.substr(1)), se;
        };
        return function(ce) {
          return ce.update($e);
        };
      }(), r.Pipeline.registerFunction(r.stemmer, "stemmer");
      /*!
       * lunr.stopWordFilter
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.generateStopWordFilter = function(n) {
        var o = n.reduce(function(a, i) {
          return a[i] = i, a;
        }, {});
        return function(a) {
          if (a && o[a.toString()] !== a.toString()) return a;
        };
      }, r.stopWordFilter = r.generateStopWordFilter([
        "a",
        "able",
        "about",
        "across",
        "after",
        "all",
        "almost",
        "also",
        "am",
        "among",
        "an",
        "and",
        "any",
        "are",
        "as",
        "at",
        "be",
        "because",
        "been",
        "but",
        "by",
        "can",
        "cannot",
        "could",
        "dear",
        "did",
        "do",
        "does",
        "either",
        "else",
        "ever",
        "every",
        "for",
        "from",
        "get",
        "got",
        "had",
        "has",
        "have",
        "he",
        "her",
        "hers",
        "him",
        "his",
        "how",
        "however",
        "i",
        "if",
        "in",
        "into",
        "is",
        "it",
        "its",
        "just",
        "least",
        "let",
        "like",
        "likely",
        "may",
        "me",
        "might",
        "most",
        "must",
        "my",
        "neither",
        "no",
        "nor",
        "not",
        "of",
        "off",
        "often",
        "on",
        "only",
        "or",
        "other",
        "our",
        "own",
        "rather",
        "said",
        "say",
        "says",
        "she",
        "should",
        "since",
        "so",
        "some",
        "than",
        "that",
        "the",
        "their",
        "them",
        "then",
        "there",
        "these",
        "they",
        "this",
        "tis",
        "to",
        "too",
        "twas",
        "us",
        "wants",
        "was",
        "we",
        "were",
        "what",
        "when",
        "where",
        "which",
        "while",
        "who",
        "whom",
        "why",
        "will",
        "with",
        "would",
        "yet",
        "you",
        "your"
      ]), r.Pipeline.registerFunction(r.stopWordFilter, "stopWordFilter");
      /*!
       * lunr.trimmer
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.trimmer = function(n) {
        return n.update(function(o) {
          return o.replace(/^\W+/, "").replace(/\W+$/, "");
        });
      }, r.Pipeline.registerFunction(r.trimmer, "trimmer");
      /*!
       * lunr.TokenSet
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.TokenSet = function() {
        this.final = !1, this.edges = {}, this.id = r.TokenSet._nextId, r.TokenSet._nextId += 1;
      }, r.TokenSet._nextId = 1, r.TokenSet.fromArray = function(n) {
        for (var o = new r.TokenSet.Builder(), a = 0, i = n.length; a < i; a++)
          o.insert(n[a]);
        return o.finish(), o.root;
      }, r.TokenSet.fromClause = function(n) {
        return "editDistance" in n ? r.TokenSet.fromFuzzyString(n.term, n.editDistance) : r.TokenSet.fromString(n.term);
      }, r.TokenSet.fromFuzzyString = function(n, o) {
        for (var a = new r.TokenSet(), i = [{
          node: a,
          editsRemaining: o,
          str: n
        }]; i.length; ) {
          var u = i.pop();
          if (u.str.length > 0) {
            var c = u.str.charAt(0), d;
            c in u.node.edges ? d = u.node.edges[c] : (d = new r.TokenSet(), u.node.edges[c] = d), u.str.length == 1 && (d.final = !0), i.push({
              node: d,
              editsRemaining: u.editsRemaining,
              str: u.str.slice(1)
            });
          }
          if (u.editsRemaining != 0) {
            if ("*" in u.node.edges)
              var m = u.node.edges["*"];
            else {
              var m = new r.TokenSet();
              u.node.edges["*"] = m;
            }
            if (u.str.length == 0 && (m.final = !0), i.push({
              node: m,
              editsRemaining: u.editsRemaining - 1,
              str: u.str
            }), u.str.length > 1 && i.push({
              node: u.node,
              editsRemaining: u.editsRemaining - 1,
              str: u.str.slice(1)
            }), u.str.length == 1 && (u.node.final = !0), u.str.length >= 1) {
              if ("*" in u.node.edges)
                var g = u.node.edges["*"];
              else {
                var g = new r.TokenSet();
                u.node.edges["*"] = g;
              }
              u.str.length == 1 && (g.final = !0), i.push({
                node: g,
                editsRemaining: u.editsRemaining - 1,
                str: u.str.slice(1)
              });
            }
            if (u.str.length > 1) {
              var v = u.str.charAt(0), S = u.str.charAt(1), k;
              S in u.node.edges ? k = u.node.edges[S] : (k = new r.TokenSet(), u.node.edges[S] = k), u.str.length == 1 && (k.final = !0), i.push({
                node: k,
                editsRemaining: u.editsRemaining - 1,
                str: v + u.str.slice(2)
              });
            }
          }
        }
        return a;
      }, r.TokenSet.fromString = function(n) {
        for (var o = new r.TokenSet(), a = o, i = 0, u = n.length; i < u; i++) {
          var c = n[i], d = i == u - 1;
          if (c == "*")
            o.edges[c] = o, o.final = d;
          else {
            var m = new r.TokenSet();
            m.final = d, o.edges[c] = m, o = m;
          }
        }
        return a;
      }, r.TokenSet.prototype.toArray = function() {
        for (var n = [], o = [{
          prefix: "",
          node: this
        }]; o.length; ) {
          var a = o.pop(), i = Object.keys(a.node.edges), u = i.length;
          a.node.final && (a.prefix.charAt(0), n.push(a.prefix));
          for (var c = 0; c < u; c++) {
            var d = i[c];
            o.push({
              prefix: a.prefix.concat(d),
              node: a.node.edges[d]
            });
          }
        }
        return n;
      }, r.TokenSet.prototype.toString = function() {
        if (this._str)
          return this._str;
        for (var n = this.final ? "1" : "0", o = Object.keys(this.edges).sort(), a = o.length, i = 0; i < a; i++) {
          var u = o[i], c = this.edges[u];
          n = n + u + c.id;
        }
        return n;
      }, r.TokenSet.prototype.intersect = function(n) {
        for (var o = new r.TokenSet(), a = void 0, i = [{
          qNode: n,
          output: o,
          node: this
        }]; i.length; ) {
          a = i.pop();
          for (var u = Object.keys(a.qNode.edges), c = u.length, d = Object.keys(a.node.edges), m = d.length, g = 0; g < c; g++)
            for (var v = u[g], S = 0; S < m; S++) {
              var k = d[S];
              if (k == v || v == "*") {
                var b = a.node.edges[k], x = a.qNode.edges[v], A = b.final && x.final, _ = void 0;
                k in a.output.edges ? (_ = a.output.edges[k], _.final = _.final || A) : (_ = new r.TokenSet(), _.final = A, a.output.edges[k] = _), i.push({
                  qNode: x,
                  output: _,
                  node: b
                });
              }
            }
        }
        return o;
      }, r.TokenSet.Builder = function() {
        this.previousWord = "", this.root = new r.TokenSet(), this.uncheckedNodes = [], this.minimizedNodes = {};
      }, r.TokenSet.Builder.prototype.insert = function(n) {
        var o, a = 0;
        if (n < this.previousWord)
          throw new Error("Out of order word insertion");
        for (var i = 0; i < n.length && i < this.previousWord.length && n[i] == this.previousWord[i]; i++)
          a++;
        this.minimize(a), this.uncheckedNodes.length == 0 ? o = this.root : o = this.uncheckedNodes[this.uncheckedNodes.length - 1].child;
        for (var i = a; i < n.length; i++) {
          var u = new r.TokenSet(), c = n[i];
          o.edges[c] = u, this.uncheckedNodes.push({
            parent: o,
            char: c,
            child: u
          }), o = u;
        }
        o.final = !0, this.previousWord = n;
      }, r.TokenSet.Builder.prototype.finish = function() {
        this.minimize(0);
      }, r.TokenSet.Builder.prototype.minimize = function(n) {
        for (var o = this.uncheckedNodes.length - 1; o >= n; o--) {
          var a = this.uncheckedNodes[o], i = a.child.toString();
          i in this.minimizedNodes ? a.parent.edges[a.char] = this.minimizedNodes[i] : (a.child._str = i, this.minimizedNodes[i] = a.child), this.uncheckedNodes.pop();
        }
      };
      /*!
       * lunr.Index
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.Index = function(n) {
        this.invertedIndex = n.invertedIndex, this.fieldVectors = n.fieldVectors, this.tokenSet = n.tokenSet, this.fields = n.fields, this.pipeline = n.pipeline;
      }, r.Index.prototype.search = function(n) {
        return this.query(function(o) {
          var a = new r.QueryParser(n, o);
          a.parse();
        });
      }, r.Index.prototype.query = function(n) {
        for (var o = new r.Query(this.fields), a = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), u = /* @__PURE__ */ Object.create(null), c = /* @__PURE__ */ Object.create(null), d = /* @__PURE__ */ Object.create(null), m = 0; m < this.fields.length; m++)
          i[this.fields[m]] = new r.Vector();
        n.call(o, o);
        for (var m = 0; m < o.clauses.length; m++) {
          var g = o.clauses[m], v = null, S = r.Set.empty;
          g.usePipeline ? v = this.pipeline.runString(g.term, {
            fields: g.fields
          }) : v = [g.term];
          for (var k = 0; k < v.length; k++) {
            var b = v[k];
            g.term = b;
            var x = r.TokenSet.fromClause(g), A = this.tokenSet.intersect(x).toArray();
            if (A.length === 0 && g.presence === r.Query.presence.REQUIRED) {
              for (var _ = 0; _ < g.fields.length; _++) {
                var O = g.fields[_];
                c[O] = r.Set.empty;
              }
              break;
            }
            for (var R = 0; R < A.length; R++)
              for (var C = A[R], T = this.invertedIndex[C], j = T._index, _ = 0; _ < g.fields.length; _++) {
                var O = g.fields[_], D = T[O], V = Object.keys(D), U = C + "/" + O, ne = new r.Set(V);
                if (g.presence == r.Query.presence.REQUIRED && (S = S.union(ne), c[O] === void 0 && (c[O] = r.Set.complete)), g.presence == r.Query.presence.PROHIBITED) {
                  d[O] === void 0 && (d[O] = r.Set.empty), d[O] = d[O].union(ne);
                  continue;
                }
                if (i[O].upsert(j, g.boost, function(B, oe) {
                  return B + oe;
                }), !u[U]) {
                  for (var H = 0; H < V.length; H++) {
                    var ae = V[H], ge = new r.FieldRef(ae, O), fe = D[ae], ve;
                    (ve = a[ge]) === void 0 ? a[ge] = new r.MatchData(C, O, fe) : ve.add(C, O, fe);
                  }
                  u[U] = !0;
                }
              }
          }
          if (g.presence === r.Query.presence.REQUIRED)
            for (var _ = 0; _ < g.fields.length; _++) {
              var O = g.fields[_];
              c[O] = c[O].intersect(S);
            }
        }
        for (var $e = r.Set.complete, ce = r.Set.empty, m = 0; m < this.fields.length; m++) {
          var O = this.fields[m];
          c[O] && ($e = $e.intersect(c[O])), d[O] && (ce = ce.union(d[O]));
        }
        var se = Object.keys(a), te = [], F = /* @__PURE__ */ Object.create(null);
        if (o.isNegated()) {
          se = Object.keys(this.fieldVectors);
          for (var m = 0; m < se.length; m++) {
            var ge = se[m], J = r.FieldRef.fromString(ge);
            a[ge] = new r.MatchData();
          }
        }
        for (var m = 0; m < se.length; m++) {
          var J = r.FieldRef.fromString(se[m]), W = J.docRef;
          if ($e.contains(W) && !ce.contains(W)) {
            var q = this.fieldVectors[J], X = i[J.fieldName].similarity(q), Q;
            if ((Q = F[W]) !== void 0)
              Q.score += X, Q.matchData.combine(a[J]);
            else {
              var ye = {
                ref: W,
                score: X,
                matchData: a[J]
              };
              F[W] = ye, te.push(ye);
            }
          }
        }
        return te.sort(function(Se, Ne) {
          return Ne.score - Se.score;
        });
      }, r.Index.prototype.toJSON = function() {
        var n = Object.keys(this.invertedIndex).sort().map(function(a) {
          return [a, this.invertedIndex[a]];
        }, this), o = Object.keys(this.fieldVectors).map(function(a) {
          return [a, this.fieldVectors[a].toJSON()];
        }, this);
        return {
          version: r.version,
          fields: this.fields,
          fieldVectors: o,
          invertedIndex: n,
          pipeline: this.pipeline.toJSON()
        };
      }, r.Index.load = function(n) {
        var o = {}, a = {}, i = n.fieldVectors, u = /* @__PURE__ */ Object.create(null), c = n.invertedIndex, d = new r.TokenSet.Builder(), m = r.Pipeline.load(n.pipeline);
        n.version != r.version && r.utils.warn("Version mismatch when loading serialised index. Current version of lunr '" + r.version + "' does not match serialized index '" + n.version + "'");
        for (var g = 0; g < i.length; g++) {
          var v = i[g], S = v[0], k = v[1];
          a[S] = new r.Vector(k);
        }
        for (var g = 0; g < c.length; g++) {
          var v = c[g], b = v[0], x = v[1];
          d.insert(b), u[b] = x;
        }
        return d.finish(), o.fields = n.fields, o.fieldVectors = a, o.invertedIndex = u, o.tokenSet = d.root, o.pipeline = m, new r.Index(o);
      };
      /*!
       * lunr.Builder
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.Builder = function() {
        this._ref = "id", this._fields = /* @__PURE__ */ Object.create(null), this._documents = /* @__PURE__ */ Object.create(null), this.invertedIndex = /* @__PURE__ */ Object.create(null), this.fieldTermFrequencies = {}, this.fieldLengths = {}, this.tokenizer = r.tokenizer, this.pipeline = new r.Pipeline(), this.searchPipeline = new r.Pipeline(), this.documentCount = 0, this._b = 0.75, this._k1 = 1.2, this.termIndex = 0, this.metadataWhitelist = [];
      }, r.Builder.prototype.ref = function(n) {
        this._ref = n;
      }, r.Builder.prototype.field = function(n, o) {
        if (/\//.test(n))
          throw new RangeError("Field '" + n + "' contains illegal character '/'");
        this._fields[n] = o || {};
      }, r.Builder.prototype.b = function(n) {
        n < 0 ? this._b = 0 : n > 1 ? this._b = 1 : this._b = n;
      }, r.Builder.prototype.k1 = function(n) {
        this._k1 = n;
      }, r.Builder.prototype.add = function(n, o) {
        var a = n[this._ref], i = Object.keys(this._fields);
        this._documents[a] = o || {}, this.documentCount += 1;
        for (var u = 0; u < i.length; u++) {
          var c = i[u], d = this._fields[c].extractor, m = d ? d(n) : n[c], g = this.tokenizer(m, {
            fields: [c]
          }), v = this.pipeline.run(g), S = new r.FieldRef(a, c), k = /* @__PURE__ */ Object.create(null);
          this.fieldTermFrequencies[S] = k, this.fieldLengths[S] = 0, this.fieldLengths[S] += v.length;
          for (var b = 0; b < v.length; b++) {
            var x = v[b];
            if (k[x] == null && (k[x] = 0), k[x] += 1, this.invertedIndex[x] == null) {
              var A = /* @__PURE__ */ Object.create(null);
              A._index = this.termIndex, this.termIndex += 1;
              for (var _ = 0; _ < i.length; _++)
                A[i[_]] = /* @__PURE__ */ Object.create(null);
              this.invertedIndex[x] = A;
            }
            this.invertedIndex[x][c][a] == null && (this.invertedIndex[x][c][a] = /* @__PURE__ */ Object.create(null));
            for (var O = 0; O < this.metadataWhitelist.length; O++) {
              var R = this.metadataWhitelist[O], C = x.metadata[R];
              this.invertedIndex[x][c][a][R] == null && (this.invertedIndex[x][c][a][R] = []), this.invertedIndex[x][c][a][R].push(C);
            }
          }
        }
      }, r.Builder.prototype.calculateAverageFieldLengths = function() {
        for (var n = Object.keys(this.fieldLengths), o = n.length, a = {}, i = {}, u = 0; u < o; u++) {
          var c = r.FieldRef.fromString(n[u]), d = c.fieldName;
          i[d] || (i[d] = 0), i[d] += 1, a[d] || (a[d] = 0), a[d] += this.fieldLengths[c];
        }
        for (var m = Object.keys(this._fields), u = 0; u < m.length; u++) {
          var g = m[u];
          a[g] = a[g] / i[g];
        }
        this.averageFieldLength = a;
      }, r.Builder.prototype.createFieldVectors = function() {
        for (var n = {}, o = Object.keys(this.fieldTermFrequencies), a = o.length, i = /* @__PURE__ */ Object.create(null), u = 0; u < a; u++) {
          for (var c = r.FieldRef.fromString(o[u]), d = c.fieldName, m = this.fieldLengths[c], g = new r.Vector(), v = this.fieldTermFrequencies[c], S = Object.keys(v), k = S.length, b = this._fields[d].boost || 1, x = this._documents[c.docRef].boost || 1, A = 0; A < k; A++) {
            var _ = S[A], O = v[_], R = this.invertedIndex[_]._index, C, T, j;
            i[_] === void 0 ? (C = r.idf(this.invertedIndex[_], this.documentCount), i[_] = C) : C = i[_], T = C * ((this._k1 + 1) * O) / (this._k1 * (1 - this._b + this._b * (m / this.averageFieldLength[d])) + O), T *= b, T *= x, j = Math.round(T * 1e3) / 1e3, g.insert(R, j);
          }
          n[c] = g;
        }
        this.fieldVectors = n;
      }, r.Builder.prototype.createTokenSet = function() {
        this.tokenSet = r.TokenSet.fromArray(
          Object.keys(this.invertedIndex).sort()
        );
      }, r.Builder.prototype.build = function() {
        return this.calculateAverageFieldLengths(), this.createFieldVectors(), this.createTokenSet(), new r.Index({
          invertedIndex: this.invertedIndex,
          fieldVectors: this.fieldVectors,
          tokenSet: this.tokenSet,
          fields: Object.keys(this._fields),
          pipeline: this.searchPipeline
        });
      }, r.Builder.prototype.use = function(n) {
        var o = Array.prototype.slice.call(arguments, 1);
        o.unshift(this), n.apply(this, o);
      }, r.MatchData = function(n, o, a) {
        for (var i = /* @__PURE__ */ Object.create(null), u = Object.keys(a || {}), c = 0; c < u.length; c++) {
          var d = u[c];
          i[d] = a[d].slice();
        }
        this.metadata = /* @__PURE__ */ Object.create(null), n !== void 0 && (this.metadata[n] = /* @__PURE__ */ Object.create(null), this.metadata[n][o] = i);
      }, r.MatchData.prototype.combine = function(n) {
        for (var o = Object.keys(n.metadata), a = 0; a < o.length; a++) {
          var i = o[a], u = Object.keys(n.metadata[i]);
          this.metadata[i] == null && (this.metadata[i] = /* @__PURE__ */ Object.create(null));
          for (var c = 0; c < u.length; c++) {
            var d = u[c], m = Object.keys(n.metadata[i][d]);
            this.metadata[i][d] == null && (this.metadata[i][d] = /* @__PURE__ */ Object.create(null));
            for (var g = 0; g < m.length; g++) {
              var v = m[g];
              this.metadata[i][d][v] == null ? this.metadata[i][d][v] = n.metadata[i][d][v] : this.metadata[i][d][v] = this.metadata[i][d][v].concat(n.metadata[i][d][v]);
            }
          }
        }
      }, r.MatchData.prototype.add = function(n, o, a) {
        if (!(n in this.metadata)) {
          this.metadata[n] = /* @__PURE__ */ Object.create(null), this.metadata[n][o] = a;
          return;
        }
        if (!(o in this.metadata[n])) {
          this.metadata[n][o] = a;
          return;
        }
        for (var i = Object.keys(a), u = 0; u < i.length; u++) {
          var c = i[u];
          c in this.metadata[n][o] ? this.metadata[n][o][c] = this.metadata[n][o][c].concat(a[c]) : this.metadata[n][o][c] = a[c];
        }
      }, r.Query = function(n) {
        this.clauses = [], this.allFields = n;
      }, r.Query.wildcard = new String("*"), r.Query.wildcard.NONE = 0, r.Query.wildcard.LEADING = 1, r.Query.wildcard.TRAILING = 2, r.Query.presence = {
        /**
         * Term's presence in a document is optional, this is the default value.
         */
        OPTIONAL: 1,
        /**
         * Term's presence in a document is required, documents that do not contain
         * this term will not be returned.
         */
        REQUIRED: 2,
        /**
         * Term's presence in a document is prohibited, documents that do contain
         * this term will not be returned.
         */
        PROHIBITED: 3
      }, r.Query.prototype.clause = function(n) {
        return "fields" in n || (n.fields = this.allFields), "boost" in n || (n.boost = 1), "usePipeline" in n || (n.usePipeline = !0), "wildcard" in n || (n.wildcard = r.Query.wildcard.NONE), n.wildcard & r.Query.wildcard.LEADING && n.term.charAt(0) != r.Query.wildcard && (n.term = "*" + n.term), n.wildcard & r.Query.wildcard.TRAILING && n.term.slice(-1) != r.Query.wildcard && (n.term = "" + n.term + "*"), "presence" in n || (n.presence = r.Query.presence.OPTIONAL), this.clauses.push(n), this;
      }, r.Query.prototype.isNegated = function() {
        for (var n = 0; n < this.clauses.length; n++)
          if (this.clauses[n].presence != r.Query.presence.PROHIBITED)
            return !1;
        return !0;
      }, r.Query.prototype.term = function(n, o) {
        if (Array.isArray(n))
          return n.forEach(function(i) {
            this.term(i, r.utils.clone(o));
          }, this), this;
        var a = o || {};
        return a.term = n.toString(), this.clause(a), this;
      }, r.QueryParseError = function(n, o, a) {
        this.name = "QueryParseError", this.message = n, this.start = o, this.end = a;
      }, r.QueryParseError.prototype = new Error(), r.QueryLexer = function(n) {
        this.lexemes = [], this.str = n, this.length = n.length, this.pos = 0, this.start = 0, this.escapeCharPositions = [];
      }, r.QueryLexer.prototype.run = function() {
        for (var n = r.QueryLexer.lexText; n; )
          n = n(this);
      }, r.QueryLexer.prototype.sliceString = function() {
        for (var n = [], o = this.start, a = this.pos, i = 0; i < this.escapeCharPositions.length; i++)
          a = this.escapeCharPositions[i], n.push(this.str.slice(o, a)), o = a + 1;
        return n.push(this.str.slice(o, this.pos)), this.escapeCharPositions.length = 0, n.join("");
      }, r.QueryLexer.prototype.emit = function(n) {
        this.lexemes.push({
          type: n,
          str: this.sliceString(),
          start: this.start,
          end: this.pos
        }), this.start = this.pos;
      }, r.QueryLexer.prototype.escapeCharacter = function() {
        this.escapeCharPositions.push(this.pos - 1), this.pos += 1;
      }, r.QueryLexer.prototype.next = function() {
        if (this.pos >= this.length)
          return r.QueryLexer.EOS;
        var n = this.str.charAt(this.pos);
        return this.pos += 1, n;
      }, r.QueryLexer.prototype.width = function() {
        return this.pos - this.start;
      }, r.QueryLexer.prototype.ignore = function() {
        this.start == this.pos && (this.pos += 1), this.start = this.pos;
      }, r.QueryLexer.prototype.backup = function() {
        this.pos -= 1;
      }, r.QueryLexer.prototype.acceptDigitRun = function() {
        var n, o;
        do
          n = this.next(), o = n.charCodeAt(0);
        while (o > 47 && o < 58);
        n != r.QueryLexer.EOS && this.backup();
      }, r.QueryLexer.prototype.more = function() {
        return this.pos < this.length;
      }, r.QueryLexer.EOS = "EOS", r.QueryLexer.FIELD = "FIELD", r.QueryLexer.TERM = "TERM", r.QueryLexer.EDIT_DISTANCE = "EDIT_DISTANCE", r.QueryLexer.BOOST = "BOOST", r.QueryLexer.PRESENCE = "PRESENCE", r.QueryLexer.lexField = function(n) {
        return n.backup(), n.emit(r.QueryLexer.FIELD), n.ignore(), r.QueryLexer.lexText;
      }, r.QueryLexer.lexTerm = function(n) {
        if (n.width() > 1 && (n.backup(), n.emit(r.QueryLexer.TERM)), n.ignore(), n.more())
          return r.QueryLexer.lexText;
      }, r.QueryLexer.lexEditDistance = function(n) {
        return n.ignore(), n.acceptDigitRun(), n.emit(r.QueryLexer.EDIT_DISTANCE), r.QueryLexer.lexText;
      }, r.QueryLexer.lexBoost = function(n) {
        return n.ignore(), n.acceptDigitRun(), n.emit(r.QueryLexer.BOOST), r.QueryLexer.lexText;
      }, r.QueryLexer.lexEOS = function(n) {
        n.width() > 0 && n.emit(r.QueryLexer.TERM);
      }, r.QueryLexer.termSeparator = r.tokenizer.separator, r.QueryLexer.lexText = function(n) {
        for (; ; ) {
          var o = n.next();
          if (o == r.QueryLexer.EOS)
            return r.QueryLexer.lexEOS;
          if (o.charCodeAt(0) == 92) {
            n.escapeCharacter();
            continue;
          }
          if (o == ":")
            return r.QueryLexer.lexField;
          if (o == "~")
            return n.backup(), n.width() > 0 && n.emit(r.QueryLexer.TERM), r.QueryLexer.lexEditDistance;
          if (o == "^")
            return n.backup(), n.width() > 0 && n.emit(r.QueryLexer.TERM), r.QueryLexer.lexBoost;
          if (o == "+" && n.width() === 1 || o == "-" && n.width() === 1)
            return n.emit(r.QueryLexer.PRESENCE), r.QueryLexer.lexText;
          if (o.match(r.QueryLexer.termSeparator))
            return r.QueryLexer.lexTerm;
        }
      }, r.QueryParser = function(n, o) {
        this.lexer = new r.QueryLexer(n), this.query = o, this.currentClause = {}, this.lexemeIdx = 0;
      }, r.QueryParser.prototype.parse = function() {
        this.lexer.run(), this.lexemes = this.lexer.lexemes;
        for (var n = r.QueryParser.parseClause; n; )
          n = n(this);
        return this.query;
      }, r.QueryParser.prototype.peekLexeme = function() {
        return this.lexemes[this.lexemeIdx];
      }, r.QueryParser.prototype.consumeLexeme = function() {
        var n = this.peekLexeme();
        return this.lexemeIdx += 1, n;
      }, r.QueryParser.prototype.nextClause = function() {
        var n = this.currentClause;
        this.query.clause(n), this.currentClause = {};
      }, r.QueryParser.parseClause = function(n) {
        var o = n.peekLexeme();
        if (o != null)
          switch (o.type) {
            case r.QueryLexer.PRESENCE:
              return r.QueryParser.parsePresence;
            case r.QueryLexer.FIELD:
              return r.QueryParser.parseField;
            case r.QueryLexer.TERM:
              return r.QueryParser.parseTerm;
            default:
              var a = "expected either a field or a term, found " + o.type;
              throw o.str.length >= 1 && (a += " with value '" + o.str + "'"), new r.QueryParseError(a, o.start, o.end);
          }
      }, r.QueryParser.parsePresence = function(n) {
        var o = n.consumeLexeme();
        if (o != null) {
          switch (o.str) {
            case "-":
              n.currentClause.presence = r.Query.presence.PROHIBITED;
              break;
            case "+":
              n.currentClause.presence = r.Query.presence.REQUIRED;
              break;
            default:
              var a = "unrecognised presence operator'" + o.str + "'";
              throw new r.QueryParseError(a, o.start, o.end);
          }
          var i = n.peekLexeme();
          if (i == null) {
            var a = "expecting term or field, found nothing";
            throw new r.QueryParseError(a, o.start, o.end);
          }
          switch (i.type) {
            case r.QueryLexer.FIELD:
              return r.QueryParser.parseField;
            case r.QueryLexer.TERM:
              return r.QueryParser.parseTerm;
            default:
              var a = "expecting term or field, found '" + i.type + "'";
              throw new r.QueryParseError(a, i.start, i.end);
          }
        }
      }, r.QueryParser.parseField = function(n) {
        var o = n.consumeLexeme();
        if (o != null) {
          if (n.query.allFields.indexOf(o.str) == -1) {
            var a = n.query.allFields.map(function(c) {
              return "'" + c + "'";
            }).join(", "), i = "unrecognised field '" + o.str + "', possible fields: " + a;
            throw new r.QueryParseError(i, o.start, o.end);
          }
          n.currentClause.fields = [o.str];
          var u = n.peekLexeme();
          if (u == null) {
            var i = "expecting term, found nothing";
            throw new r.QueryParseError(i, o.start, o.end);
          }
          switch (u.type) {
            case r.QueryLexer.TERM:
              return r.QueryParser.parseTerm;
            default:
              var i = "expecting term, found '" + u.type + "'";
              throw new r.QueryParseError(i, u.start, u.end);
          }
        }
      }, r.QueryParser.parseTerm = function(n) {
        var o = n.consumeLexeme();
        if (o != null) {
          n.currentClause.term = o.str.toLowerCase(), o.str.indexOf("*") != -1 && (n.currentClause.usePipeline = !1);
          var a = n.peekLexeme();
          if (a == null) {
            n.nextClause();
            return;
          }
          switch (a.type) {
            case r.QueryLexer.TERM:
              return n.nextClause(), r.QueryParser.parseTerm;
            case r.QueryLexer.FIELD:
              return n.nextClause(), r.QueryParser.parseField;
            case r.QueryLexer.EDIT_DISTANCE:
              return r.QueryParser.parseEditDistance;
            case r.QueryLexer.BOOST:
              return r.QueryParser.parseBoost;
            case r.QueryLexer.PRESENCE:
              return n.nextClause(), r.QueryParser.parsePresence;
            default:
              var i = "Unexpected lexeme type '" + a.type + "'";
              throw new r.QueryParseError(i, a.start, a.end);
          }
        }
      }, r.QueryParser.parseEditDistance = function(n) {
        var o = n.consumeLexeme();
        if (o != null) {
          var a = parseInt(o.str, 10);
          if (isNaN(a)) {
            var i = "edit distance must be numeric";
            throw new r.QueryParseError(i, o.start, o.end);
          }
          n.currentClause.editDistance = a;
          var u = n.peekLexeme();
          if (u == null) {
            n.nextClause();
            return;
          }
          switch (u.type) {
            case r.QueryLexer.TERM:
              return n.nextClause(), r.QueryParser.parseTerm;
            case r.QueryLexer.FIELD:
              return n.nextClause(), r.QueryParser.parseField;
            case r.QueryLexer.EDIT_DISTANCE:
              return r.QueryParser.parseEditDistance;
            case r.QueryLexer.BOOST:
              return r.QueryParser.parseBoost;
            case r.QueryLexer.PRESENCE:
              return n.nextClause(), r.QueryParser.parsePresence;
            default:
              var i = "Unexpected lexeme type '" + u.type + "'";
              throw new r.QueryParseError(i, u.start, u.end);
          }
        }
      }, r.QueryParser.parseBoost = function(n) {
        var o = n.consumeLexeme();
        if (o != null) {
          var a = parseInt(o.str, 10);
          if (isNaN(a)) {
            var i = "boost must be numeric";
            throw new r.QueryParseError(i, o.start, o.end);
          }
          n.currentClause.boost = a;
          var u = n.peekLexeme();
          if (u == null) {
            n.nextClause();
            return;
          }
          switch (u.type) {
            case r.QueryLexer.TERM:
              return n.nextClause(), r.QueryParser.parseTerm;
            case r.QueryLexer.FIELD:
              return n.nextClause(), r.QueryParser.parseField;
            case r.QueryLexer.EDIT_DISTANCE:
              return r.QueryParser.parseEditDistance;
            case r.QueryLexer.BOOST:
              return r.QueryParser.parseBoost;
            case r.QueryLexer.PRESENCE:
              return n.nextClause(), r.QueryParser.parsePresence;
            default:
              var i = "Unexpected lexeme type '" + u.type + "'";
              throw new r.QueryParseError(i, u.start, u.end);
          }
        }
      }, function(n, o) {
        e.exports = o();
      }(this, function() {
        return r;
      });
    })();
  }(e0)), e0.exports;
}
var t0, f1;
function HR() {
  if (f1) return t0;
  f1 = 1;
  function e() {
    return typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : typeof setImmediate == "function" ? setImmediate : function(r) {
      setTimeout(r, 0);
    };
  }
  return t0 = e(), t0;
}
var r0, d1;
function WR() {
  if (d1) return r0;
  d1 = 1;
  var e = HR();
  return r0 = function(r, n) {
    if (r) {
      n.then(function(o) {
        e(function() {
          r(null, o);
        });
      }, function(o) {
        e(function() {
          r(o);
        });
      });
      return;
    } else
      return n;
  }, r0;
}
var n0, h1;
function KR() {
  if (h1) return n0;
  h1 = 1, n0 = a, a.default = a, a.stable = d, a.stableStringify = d;
  var e = "[...]", t = "[Circular]", r = [], n = [];
  function o() {
    return {
      depthLimit: Number.MAX_SAFE_INTEGER,
      edgesLimit: Number.MAX_SAFE_INTEGER
    };
  }
  function a(v, S, k, b) {
    typeof b > "u" && (b = o()), u(v, "", 0, [], void 0, 0, b);
    var x;
    try {
      n.length === 0 ? x = JSON.stringify(v, S, k) : x = JSON.stringify(v, g(S), k);
    } catch {
      return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      for (; r.length !== 0; ) {
        var A = r.pop();
        A.length === 4 ? Object.defineProperty(A[0], A[1], A[3]) : A[0][A[1]] = A[2];
      }
    }
    return x;
  }
  function i(v, S, k, b) {
    var x = Object.getOwnPropertyDescriptor(b, k);
    x.get !== void 0 ? x.configurable ? (Object.defineProperty(b, k, { value: v }), r.push([b, k, S, x])) : n.push([S, k, v]) : (b[k] = v, r.push([b, k, S]));
  }
  function u(v, S, k, b, x, A, _) {
    A += 1;
    var O;
    if (typeof v == "object" && v !== null) {
      for (O = 0; O < b.length; O++)
        if (b[O] === v) {
          i(t, v, S, x);
          return;
        }
      if (typeof _.depthLimit < "u" && A > _.depthLimit) {
        i(e, v, S, x);
        return;
      }
      if (typeof _.edgesLimit < "u" && k + 1 > _.edgesLimit) {
        i(e, v, S, x);
        return;
      }
      if (b.push(v), Array.isArray(v))
        for (O = 0; O < v.length; O++)
          u(v[O], O, O, b, v, A, _);
      else {
        var R = Object.keys(v);
        for (O = 0; O < R.length; O++) {
          var C = R[O];
          u(v[C], C, O, b, v, A, _);
        }
      }
      b.pop();
    }
  }
  function c(v, S) {
    return v < S ? -1 : v > S ? 1 : 0;
  }
  function d(v, S, k, b) {
    typeof b > "u" && (b = o());
    var x = m(v, "", 0, [], void 0, 0, b) || v, A;
    try {
      n.length === 0 ? A = JSON.stringify(x, S, k) : A = JSON.stringify(x, g(S), k);
    } catch {
      return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      for (; r.length !== 0; ) {
        var _ = r.pop();
        _.length === 4 ? Object.defineProperty(_[0], _[1], _[3]) : _[0][_[1]] = _[2];
      }
    }
    return A;
  }
  function m(v, S, k, b, x, A, _) {
    A += 1;
    var O;
    if (typeof v == "object" && v !== null) {
      for (O = 0; O < b.length; O++)
        if (b[O] === v) {
          i(t, v, S, x);
          return;
        }
      try {
        if (typeof v.toJSON == "function")
          return;
      } catch {
        return;
      }
      if (typeof _.depthLimit < "u" && A > _.depthLimit) {
        i(e, v, S, x);
        return;
      }
      if (typeof _.edgesLimit < "u" && k + 1 > _.edgesLimit) {
        i(e, v, S, x);
        return;
      }
      if (b.push(v), Array.isArray(v))
        for (O = 0; O < v.length; O++)
          m(v[O], O, O, b, v, A, _);
      else {
        var R = {}, C = Object.keys(v).sort(c);
        for (O = 0; O < C.length; O++) {
          var T = C[O];
          m(v[T], T, O, b, v, A, _), R[T] = v[T];
        }
        if (typeof x < "u")
          r.push([x, S, v]), x[S] = R;
        else
          return R;
      }
      b.pop();
    }
  }
  function g(v) {
    return v = typeof v < "u" ? v : function(S, k) {
      return k;
    }, function(S, k) {
      if (n.length > 0)
        for (var b = 0; b < n.length; b++) {
          var x = n[b];
          if (x[1] === S && x[0] === k) {
            k = x[2], n.splice(b, 1);
            break;
          }
        }
      return v.call(this, S, k);
    };
  }
  return n0;
}
/*!
 * Stickyfill -- `position: sticky` polyfill
 * v. 1.1.1 | https://github.com/wilddeer/stickyfill
 * Copyright Oleg Korsunsky | http://wd.dizaina.net/
 *
 * MIT License
 */
var i0, m1;
function QR() {
  return m1 || (m1 = 1, i0 = function(e, t) {
    e || (e = document), t || (t = window);
    var r = [], n, o = !1, a = e.documentElement, i = function() {
    }, u, c = "hidden", d = "visibilitychange";
    e.webkitHidden !== void 0 && (c = "webkitHidden", d = "webkitvisibilitychange"), t.getComputedStyle || S();
    for (var m = ["", "-webkit-", "-moz-", "-ms-"], g = document.createElement("div"), v = m.length - 1; v >= 0; v--) {
      try {
        g.style.position = m[v] + "sticky";
      } catch {
      }
      g.style.position != "" && S();
    }
    x();
    function S() {
      se = q = te = F = J = W = i;
    }
    function k(Q, ye) {
      for (key in ye)
        ye.hasOwnProperty(key) && (Q[key] = ye[key]);
    }
    function b(Q) {
      return parseFloat(Q) || 0;
    }
    function x() {
      n = {
        top: t.pageYOffset,
        left: t.pageXOffset
      };
    }
    function A() {
      if (t.pageXOffset != n.left) {
        x(), te();
        return;
      }
      t.pageYOffset != n.top && (x(), O());
    }
    function _(Q) {
      setTimeout(function() {
        t.pageYOffset != n.top && (n.top = t.pageYOffset, O());
      }, 0);
    }
    function O() {
      for (var Q = r.length - 1; Q >= 0; Q--)
        R(r[Q]);
    }
    function R(Q) {
      if (Q.inited) {
        var ye = n.top <= Q.limit.start ? 0 : n.top >= Q.limit.end ? 2 : 1;
        Q.mode != ye && U(Q, ye);
      }
    }
    function C() {
      for (var Q = r.length - 1; Q >= 0; Q--)
        if (r[Q].inited) {
          var ye = Math.abs(ge(r[Q].clone) - r[Q].docOffsetTop), Se = Math.abs(r[Q].parent.node.offsetHeight - r[Q].parent.height);
          if (ye >= 2 || Se >= 2) return !1;
        }
      return !0;
    }
    function T(Q) {
      isNaN(parseFloat(Q.computed.top)) || Q.isCell || (Q.inited = !0, Q.clone || ne(Q), Q.parent.computed.position != "absolute" && Q.parent.computed.position != "relative" && (Q.parent.node.style.position = "relative"), R(Q), Q.parent.height = Q.parent.node.offsetHeight, Q.docOffsetTop = ge(Q.clone));
    }
    function j(Q) {
      var ye = !0;
      Q.clone && H(Q), k(Q.node.style, Q.css);
      for (var Se = r.length - 1; Se >= 0; Se--)
        if (r[Se].node !== Q.node && r[Se].parent.node === Q.parent.node) {
          ye = !1;
          break;
        }
      ye && (Q.parent.node.style.position = Q.parent.css.position), Q.mode = -1;
    }
    function D() {
      for (var Q = r.length - 1; Q >= 0; Q--)
        T(r[Q]);
    }
    function V() {
      for (var Q = r.length - 1; Q >= 0; Q--)
        j(r[Q]);
    }
    function U(Q, ye) {
      var Se = Q.node.style;
      switch (ye) {
        case 0:
          Se.position = "absolute", Se.left = Q.offset.left + "px", Se.right = Q.offset.right + "px", Se.top = Q.offset.top + "px", Se.bottom = "auto", Se.width = "auto", Se.marginLeft = 0, Se.marginRight = 0, Se.marginTop = 0;
          break;
        case 1:
          Se.position = "fixed", Se.left = Q.box.left + "px", Se.right = Q.box.right + "px", Se.top = Q.css.top, Se.bottom = "auto", Se.width = "auto", Se.marginLeft = 0, Se.marginRight = 0, Se.marginTop = 0;
          break;
        case 2:
          Se.position = "absolute", Se.left = Q.offset.left + "px", Se.right = Q.offset.right + "px", Se.top = "auto", Se.bottom = 0, Se.width = "auto", Se.marginLeft = 0, Se.marginRight = 0;
          break;
      }
      Q.mode = ye;
    }
    function ne(Q) {
      Q.clone = document.createElement("div");
      var ye = Q.node.nextSibling || Q.node, Se = Q.clone.style;
      Se.height = Q.height + "px", Se.width = Q.width + "px", Se.marginTop = Q.computed.marginTop, Se.marginBottom = Q.computed.marginBottom, Se.marginLeft = Q.computed.marginLeft, Se.marginRight = Q.computed.marginRight, Se.padding = Se.border = Se.borderSpacing = 0, Se.fontSize = "1em", Se.position = "static", Se.cssFloat = Q.computed.cssFloat, Q.node.parentNode.insertBefore(Q.clone, ye);
    }
    function H(Q) {
      Q.clone.parentNode.removeChild(Q.clone), Q.clone = void 0;
    }
    function ae(Q) {
      var ye = getComputedStyle(Q), Se = Q.parentNode, Ne = getComputedStyle(Se), N = Q.style.position;
      Q.style.position = "relative";
      var B = {
        top: ye.top,
        marginTop: ye.marginTop,
        marginBottom: ye.marginBottom,
        marginLeft: ye.marginLeft,
        marginRight: ye.marginRight,
        cssFloat: ye.cssFloat
      }, oe = {
        top: b(ye.top),
        marginBottom: b(ye.marginBottom),
        paddingLeft: b(ye.paddingLeft),
        paddingRight: b(ye.paddingRight),
        borderLeftWidth: b(ye.borderLeftWidth),
        borderRightWidth: b(ye.borderRightWidth)
      };
      Q.style.position = N;
      var ie = {
        position: Q.style.position,
        top: Q.style.top,
        bottom: Q.style.bottom,
        left: Q.style.left,
        right: Q.style.right,
        width: Q.style.width,
        marginTop: Q.style.marginTop,
        marginLeft: Q.style.marginLeft,
        marginRight: Q.style.marginRight
      }, he = fe(Q), Z = fe(Se), re = {
        node: Se,
        css: {
          position: Se.style.position
        },
        computed: {
          position: Ne.position
        },
        numeric: {
          borderLeftWidth: b(Ne.borderLeftWidth),
          borderRightWidth: b(Ne.borderRightWidth),
          borderTopWidth: b(Ne.borderTopWidth),
          borderBottomWidth: b(Ne.borderBottomWidth)
        }
      }, Pe = {
        node: Q,
        box: {
          left: he.win.left,
          right: a.clientWidth - he.win.right
        },
        offset: {
          top: he.win.top - Z.win.top - re.numeric.borderTopWidth,
          left: he.win.left - Z.win.left - re.numeric.borderLeftWidth,
          right: -he.win.right + Z.win.right - re.numeric.borderRightWidth
        },
        css: ie,
        isCell: ye.display == "table-cell",
        computed: B,
        numeric: oe,
        width: he.win.right - he.win.left,
        height: he.win.bottom - he.win.top,
        mode: -1,
        inited: !1,
        parent: re,
        limit: {
          start: he.doc.top - oe.top,
          end: Z.doc.top + Se.offsetHeight - re.numeric.borderBottomWidth - Q.offsetHeight - oe.top - oe.marginBottom
        }
      };
      return Pe;
    }
    function ge(Q) {
      for (var ye = 0; Q; )
        ye += Q.offsetTop, Q = Q.offsetParent;
      return ye;
    }
    function fe(Q) {
      var ye = Q.getBoundingClientRect();
      return {
        doc: {
          top: ye.top + t.pageYOffset,
          left: ye.left + t.pageXOffset
        },
        win: ye
      };
    }
    function ve() {
      u = setInterval(function() {
        !C() && te();
      }, 500);
    }
    function $e() {
      clearInterval(u);
    }
    function ce() {
      o && (document[c] ? $e() : ve());
    }
    function se() {
      o || (x(), D(), t.addEventListener("scroll", A), t.addEventListener("wheel", _), t.addEventListener("resize", te), t.addEventListener("orientationchange", te), e.addEventListener(d, ce), ve(), o = !0);
    }
    function te() {
      if (o) {
        V();
        for (var Q = r.length - 1; Q >= 0; Q--)
          r[Q] = ae(r[Q].node);
        D();
      }
    }
    function F() {
      t.removeEventListener("scroll", A), t.removeEventListener("wheel", _), t.removeEventListener("resize", te), t.removeEventListener("orientationchange", te), e.removeEventListener(d, ce), $e(), o = !1;
    }
    function J() {
      F(), V();
    }
    function W() {
      for (J(); r.length; )
        r.pop();
    }
    function q(Q) {
      for (var ye = r.length - 1; ye >= 0; ye--)
        if (r[ye].node === Q) return;
      var Se = ae(Q);
      r.push(Se), o ? T(Se) : se();
    }
    function X(Q) {
      for (var ye = r.length - 1; ye >= 0; ye--)
        r[ye].node === Q && (j(r[ye]), r.splice(ye, 1));
    }
    return {
      stickies: r,
      add: q,
      remove: X,
      init: se,
      rebuild: te,
      pause: F,
      stop: J,
      kill: W
    };
  }), i0;
}
const jS = Symbol.for("yaml.alias"), Vw = Symbol.for("yaml.document"), ul = Symbol.for("yaml.map"), BA = Symbol.for("yaml.pair"), So = Symbol.for("yaml.scalar"), Np = Symbol.for("yaml.seq"), Ki = Symbol.for("yaml.node.type"), yl = (e) => !!e && typeof e == "object" && e[Ki] === jS, vl = (e) => !!e && typeof e == "object" && e[Ki] === Vw, qu = (e) => !!e && typeof e == "object" && e[Ki] === ul, ur = (e) => !!e && typeof e == "object" && e[Ki] === BA, Gt = (e) => !!e && typeof e == "object" && e[Ki] === So, zu = (e) => !!e && typeof e == "object" && e[Ki] === Np;
function dr(e) {
  if (e && typeof e == "object")
    switch (e[Ki]) {
      case ul:
      case Np:
        return !0;
    }
  return !1;
}
function hr(e) {
  if (e && typeof e == "object")
    switch (e[Ki]) {
      case jS:
      case ul:
      case So:
      case Np:
        return !0;
    }
  return !1;
}
const YR = (e) => (Gt(e) || dr(e)) && !!e.anchor, Xn = Symbol("break visit"), UA = Symbol("skip children"), vo = Symbol("remove node");
function ca(e, t) {
  const r = VA(t);
  vl(e) ? pp(null, e.contents, r, Object.freeze([e])) === vo && (e.contents = null) : pp(null, e, r, Object.freeze([]));
}
ca.BREAK = Xn;
ca.SKIP = UA;
ca.REMOVE = vo;
function pp(e, t, r, n) {
  const o = HA(e, t, r, n);
  if (hr(o) || ur(o))
    return WA(e, n, o), pp(e, o, r, n);
  if (typeof o != "symbol") {
    if (dr(t)) {
      n = Object.freeze(n.concat(t));
      for (let a = 0; a < t.items.length; ++a) {
        const i = pp(a, t.items[a], r, n);
        if (typeof i == "number")
          a = i - 1;
        else {
          if (i === Xn)
            return Xn;
          i === vo && (t.items.splice(a, 1), a -= 1);
        }
      }
    } else if (ur(t)) {
      n = Object.freeze(n.concat(t));
      const a = pp("key", t.key, r, n);
      if (a === Xn)
        return Xn;
      a === vo && (t.key = null);
      const i = pp("value", t.value, r, n);
      if (i === Xn)
        return Xn;
      i === vo && (t.value = null);
    }
  }
  return o;
}
async function ph(e, t) {
  const r = VA(t);
  vl(e) ? await fp(null, e.contents, r, Object.freeze([e])) === vo && (e.contents = null) : await fp(null, e, r, Object.freeze([]));
}
ph.BREAK = Xn;
ph.SKIP = UA;
ph.REMOVE = vo;
async function fp(e, t, r, n) {
  const o = await HA(e, t, r, n);
  if (hr(o) || ur(o))
    return WA(e, n, o), fp(e, o, r, n);
  if (typeof o != "symbol") {
    if (dr(t)) {
      n = Object.freeze(n.concat(t));
      for (let a = 0; a < t.items.length; ++a) {
        const i = await fp(a, t.items[a], r, n);
        if (typeof i == "number")
          a = i - 1;
        else {
          if (i === Xn)
            return Xn;
          i === vo && (t.items.splice(a, 1), a -= 1);
        }
      }
    } else if (ur(t)) {
      n = Object.freeze(n.concat(t));
      const a = await fp("key", t.key, r, n);
      if (a === Xn)
        return Xn;
      a === vo && (t.key = null);
      const i = await fp("value", t.value, r, n);
      if (i === Xn)
        return Xn;
      i === vo && (t.value = null);
    }
  }
  return o;
}
function VA(e) {
  return typeof e == "object" && (e.Collection || e.Node || e.Value) ? Object.assign({
    Alias: e.Node,
    Map: e.Node,
    Scalar: e.Node,
    Seq: e.Node
  }, e.Value && {
    Map: e.Value,
    Scalar: e.Value,
    Seq: e.Value
  }, e.Collection && {
    Map: e.Collection,
    Seq: e.Collection
  }, e) : e;
}
function HA(e, t, r, n) {
  var o, a, i, u, c;
  if (typeof r == "function")
    return r(e, t, n);
  if (qu(t))
    return (o = r.Map) == null ? void 0 : o.call(r, e, t, n);
  if (zu(t))
    return (a = r.Seq) == null ? void 0 : a.call(r, e, t, n);
  if (ur(t))
    return (i = r.Pair) == null ? void 0 : i.call(r, e, t, n);
  if (Gt(t))
    return (u = r.Scalar) == null ? void 0 : u.call(r, e, t, n);
  if (yl(t))
    return (c = r.Alias) == null ? void 0 : c.call(r, e, t, n);
}
function WA(e, t, r) {
  const n = t[t.length - 1];
  if (dr(n))
    n.items[e] = r;
  else if (ur(n))
    e === "key" ? n.key = r : n.value = r;
  else if (vl(n))
    n.contents = r;
  else {
    const o = yl(n) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${o} parent`);
  }
}
const GR = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
}, XR = (e) => e.replace(/[!,[\]{}]/g, (t) => GR[t]);
class Cn {
  constructor(t, r) {
    this.docStart = null, this.docEnd = !1, this.yaml = Object.assign({}, Cn.defaultYaml, t), this.tags = Object.assign({}, Cn.defaultTags, r);
  }
  clone() {
    const t = new Cn(this.yaml, this.tags);
    return t.docStart = this.docStart, t;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const t = new Cn(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = !0;
        break;
      case "1.2":
        this.atNextDocument = !1, this.yaml = {
          explicit: Cn.defaultYaml.explicit,
          version: "1.2"
        }, this.tags = Object.assign({}, Cn.defaultTags);
        break;
    }
    return t;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(t, r) {
    this.atNextDocument && (this.yaml = { explicit: Cn.defaultYaml.explicit, version: "1.1" }, this.tags = Object.assign({}, Cn.defaultTags), this.atNextDocument = !1);
    const n = t.trim().split(/[ \t]+/), o = n.shift();
    switch (o) {
      case "%TAG": {
        if (n.length !== 2 && (r(0, "%TAG directive should contain exactly two parts"), n.length < 2))
          return !1;
        const [a, i] = n;
        return this.tags[a] = i, !0;
      }
      case "%YAML": {
        if (this.yaml.explicit = !0, n.length !== 1)
          return r(0, "%YAML directive should contain exactly one part"), !1;
        const [a] = n;
        if (a === "1.1" || a === "1.2")
          return this.yaml.version = a, !0;
        {
          const i = /^\d+\.\d+$/.test(a);
          return r(6, `Unsupported YAML version ${a}`, i), !1;
        }
      }
      default:
        return r(0, `Unknown directive ${o}`, !0), !1;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(t, r) {
    if (t === "!")
      return "!";
    if (t[0] !== "!")
      return r(`Not a valid tag: ${t}`), null;
    if (t[1] === "<") {
      const i = t.slice(2, -1);
      return i === "!" || i === "!!" ? (r(`Verbatim tags aren't resolved, so ${t} is invalid.`), null) : (t[t.length - 1] !== ">" && r("Verbatim tags must end with a >"), i);
    }
    const [, n, o] = t.match(/^(.*!)([^!]*)$/s);
    o || r(`The ${t} tag has no suffix`);
    const a = this.tags[n];
    if (a)
      try {
        return a + decodeURIComponent(o);
      } catch (i) {
        return r(String(i)), null;
      }
    return n === "!" ? t : (r(`Could not resolve tag: ${t}`), null);
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(t) {
    for (const [r, n] of Object.entries(this.tags))
      if (t.startsWith(n))
        return r + XR(t.substring(n.length));
    return t[0] === "!" ? t : `!<${t}>`;
  }
  toString(t) {
    const r = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [], n = Object.entries(this.tags);
    let o;
    if (t && n.length > 0 && hr(t.contents)) {
      const a = {};
      ca(t.contents, (i, u) => {
        hr(u) && u.tag && (a[u.tag] = !0);
      }), o = Object.keys(a);
    } else
      o = [];
    for (const [a, i] of n)
      a === "!!" && i === "tag:yaml.org,2002:" || (!t || o.some((u) => u.startsWith(i))) && r.push(`%TAG ${a} ${i}`);
    return r.join(`
`);
  }
}
Cn.defaultYaml = { explicit: !1, version: "1.2" };
Cn.defaultTags = { "!!": "tag:yaml.org,2002:" };
function KA(e) {
  if (/[\x00-\x19\s,[\]{}]/.test(e)) {
    const r = `Anchor must not contain whitespace or control characters: ${JSON.stringify(e)}`;
    throw new Error(r);
  }
  return !0;
}
function QA(e) {
  const t = /* @__PURE__ */ new Set();
  return ca(e, {
    Value(r, n) {
      n.anchor && t.add(n.anchor);
    }
  }), t;
}
function YA(e, t) {
  for (let r = 1; ; ++r) {
    const n = `${e}${r}`;
    if (!t.has(n))
      return n;
  }
}
function JR(e, t) {
  const r = [], n = /* @__PURE__ */ new Map();
  let o = null;
  return {
    onAnchor: (a) => {
      r.push(a), o || (o = QA(e));
      const i = YA(t, o);
      return o.add(i), i;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const a of r) {
        const i = n.get(a);
        if (typeof i == "object" && i.anchor && (Gt(i.node) || dr(i.node)))
          i.node.anchor = i.anchor;
        else {
          const u = new Error("Failed to resolve repeated object (this should not happen)");
          throw u.source = a, u;
        }
      }
    },
    sourceObjects: n
  };
}
function dp(e, t, r, n) {
  if (n && typeof n == "object")
    if (Array.isArray(n))
      for (let o = 0, a = n.length; o < a; ++o) {
        const i = n[o], u = dp(e, n, String(o), i);
        u === void 0 ? delete n[o] : u !== i && (n[o] = u);
      }
    else if (n instanceof Map)
      for (const o of Array.from(n.keys())) {
        const a = n.get(o), i = dp(e, n, o, a);
        i === void 0 ? n.delete(o) : i !== a && n.set(o, i);
      }
    else if (n instanceof Set)
      for (const o of Array.from(n)) {
        const a = dp(e, n, o, o);
        a === void 0 ? n.delete(o) : a !== o && (n.delete(o), n.add(a));
      }
    else
      for (const [o, a] of Object.entries(n)) {
        const i = dp(e, n, o, a);
        i === void 0 ? delete n[o] : i !== a && (n[o] = i);
      }
  return e.call(t, r, n);
}
function Wi(e, t, r) {
  if (Array.isArray(e))
    return e.map((n, o) => Wi(n, String(o), r));
  if (e && typeof e.toJSON == "function") {
    if (!r || !YR(e))
      return e.toJSON(t, r);
    const n = { aliasCount: 0, count: 1, res: void 0 };
    r.anchors.set(e, n), r.onCreate = (a) => {
      n.res = a, delete r.onCreate;
    };
    const o = e.toJSON(t, r);
    return r.onCreate && r.onCreate(o), o;
  }
  return typeof e == "bigint" && !(r != null && r.keep) ? Number(e) : e;
}
class LS {
  constructor(t) {
    Object.defineProperty(this, Ki, { value: t });
  }
  /** Create a copy of this node.  */
  clone() {
    const t = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return this.range && (t.range = this.range.slice()), t;
  }
  /** A plain JavaScript representation of this node. */
  toJS(t, { mapAsMap: r, maxAliasCount: n, onAnchor: o, reviver: a } = {}) {
    if (!vl(t))
      throw new TypeError("A document argument is required");
    const i = {
      anchors: /* @__PURE__ */ new Map(),
      doc: t,
      keep: !0,
      mapAsMap: r === !0,
      mapKeyWarned: !1,
      maxAliasCount: typeof n == "number" ? n : 100
    }, u = Wi(this, "", i);
    if (typeof o == "function")
      for (const { count: c, res: d } of i.anchors.values())
        o(d, c);
    return typeof a == "function" ? dp(a, { "": u }, "", u) : u;
  }
}
class fh extends LS {
  constructor(t) {
    super(jS), this.source = t, Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(t) {
    let r;
    return ca(t, {
      Node: (n, o) => {
        if (o === this)
          return ca.BREAK;
        o.anchor === this.source && (r = o);
      }
    }), r;
  }
  toJSON(t, r) {
    if (!r)
      return { source: this.source };
    const { anchors: n, doc: o, maxAliasCount: a } = r, i = this.resolve(o);
    if (!i) {
      const c = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(c);
    }
    let u = n.get(i);
    if (u || (Wi(i, null, r), u = n.get(i)), !u || u.res === void 0) {
      const c = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(c);
    }
    if (a >= 0 && (u.count += 1, u.aliasCount === 0 && (u.aliasCount = Cy(o, i, n)), u.count * u.aliasCount > a)) {
      const c = "Excessive alias count indicates a resource exhaustion attack";
      throw new ReferenceError(c);
    }
    return u.res;
  }
  toString(t, r, n) {
    const o = `*${this.source}`;
    if (t) {
      if (KA(this.source), t.options.verifyAliasOrder && !t.anchors.has(this.source)) {
        const a = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(a);
      }
      if (t.implicitKey)
        return `${o} `;
    }
    return o;
  }
}
function Cy(e, t, r) {
  if (yl(t)) {
    const n = t.resolve(e), o = r && n && r.get(n);
    return o ? o.count * o.aliasCount : 0;
  } else if (dr(t)) {
    let n = 0;
    for (const o of t.items) {
      const a = Cy(e, o, r);
      a > n && (n = a);
    }
    return n;
  } else if (ur(t)) {
    const n = Cy(e, t.key, r), o = Cy(e, t.value, r);
    return Math.max(n, o);
  }
  return 1;
}
const GA = (e) => !e || typeof e != "function" && typeof e != "object";
class Ot extends LS {
  constructor(t) {
    super(So), this.value = t;
  }
  toJSON(t, r) {
    return r != null && r.keep ? this.value : Wi(this.value, t, r);
  }
  toString() {
    return String(this.value);
  }
}
Ot.BLOCK_FOLDED = "BLOCK_FOLDED";
Ot.BLOCK_LITERAL = "BLOCK_LITERAL";
Ot.PLAIN = "PLAIN";
Ot.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Ot.QUOTE_SINGLE = "QUOTE_SINGLE";
const ZR = "tag:yaml.org,2002:";
function eI(e, t, r) {
  if (t) {
    const n = r.filter((a) => a.tag === t), o = n.find((a) => !a.format) ?? n[0];
    if (!o)
      throw new Error(`Tag ${t} not found`);
    return o;
  }
  return r.find((n) => {
    var o;
    return ((o = n.identify) == null ? void 0 : o.call(n, e)) && !n.format;
  });
}
function Xd(e, t, r) {
  var g, v, S;
  if (vl(e) && (e = e.contents), hr(e))
    return e;
  if (ur(e)) {
    const k = (v = (g = r.schema[ul]).createNode) == null ? void 0 : v.call(g, r.schema, null, r);
    return k.items.push(e), k;
  }
  (e instanceof String || e instanceof Number || e instanceof Boolean || typeof BigInt < "u" && e instanceof BigInt) && (e = e.valueOf());
  const { aliasDuplicateObjects: n, onAnchor: o, onTagObj: a, schema: i, sourceObjects: u } = r;
  let c;
  if (n && e && typeof e == "object") {
    if (c = u.get(e), c)
      return c.anchor || (c.anchor = o(e)), new fh(c.anchor);
    c = { anchor: null, node: null }, u.set(e, c);
  }
  t != null && t.startsWith("!!") && (t = ZR + t.slice(2));
  let d = eI(e, t, i.tags);
  if (!d) {
    if (e && typeof e.toJSON == "function" && (e = e.toJSON()), !e || typeof e != "object") {
      const k = new Ot(e);
      return c && (c.node = k), k;
    }
    d = e instanceof Map ? i[ul] : Symbol.iterator in Object(e) ? i[Np] : i[ul];
  }
  a && (a(d), delete r.onTagObj);
  const m = d != null && d.createNode ? d.createNode(r.schema, e, r) : typeof ((S = d == null ? void 0 : d.nodeClass) == null ? void 0 : S.from) == "function" ? d.nodeClass.from(r.schema, e, r) : new Ot(e);
  return t ? m.tag = t : d.default || (m.tag = d.tag), c && (c.node = m), m;
}
function Yy(e, t, r) {
  let n = r;
  for (let o = t.length - 1; o >= 0; --o) {
    const a = t[o];
    if (typeof a == "number" && Number.isInteger(a) && a >= 0) {
      const i = [];
      i[a] = n, n = i;
    } else
      n = /* @__PURE__ */ new Map([[a, n]]);
  }
  return Xd(n, void 0, {
    aliasDuplicateObjects: !1,
    keepUndefined: !1,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: e,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
const zd = (e) => e == null || typeof e == "object" && !!e[Symbol.iterator]().next().done;
class XA extends LS {
  constructor(t, r) {
    super(t), Object.defineProperty(this, "schema", {
      value: r,
      configurable: !0,
      enumerable: !1,
      writable: !0
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(t) {
    const r = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return t && (r.schema = t), r.items = r.items.map((n) => hr(n) || ur(n) ? n.clone(t) : n), this.range && (r.range = this.range.slice()), r;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(t, r) {
    if (zd(t))
      this.add(r);
    else {
      const [n, ...o] = t, a = this.get(n, !0);
      if (dr(a))
        a.addIn(o, r);
      else if (a === void 0 && this.schema)
        this.set(n, Yy(this.schema, o, r));
      else
        throw new Error(`Expected YAML collection at ${n}. Remaining path: ${o}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(t) {
    const [r, ...n] = t;
    if (n.length === 0)
      return this.delete(r);
    const o = this.get(r, !0);
    if (dr(o))
      return o.deleteIn(n);
    throw new Error(`Expected YAML collection at ${r}. Remaining path: ${n}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(t, r) {
    const [n, ...o] = t, a = this.get(n, !0);
    return o.length === 0 ? !r && Gt(a) ? a.value : a : dr(a) ? a.getIn(o, r) : void 0;
  }
  hasAllNullValues(t) {
    return this.items.every((r) => {
      if (!ur(r))
        return !1;
      const n = r.value;
      return n == null || t && Gt(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(t) {
    const [r, ...n] = t;
    if (n.length === 0)
      return this.has(r);
    const o = this.get(r, !0);
    return dr(o) ? o.hasIn(n) : !1;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(t, r) {
    const [n, ...o] = t;
    if (o.length === 0)
      this.set(n, r);
    else {
      const a = this.get(n, !0);
      if (dr(a))
        a.setIn(o, r);
      else if (a === void 0 && this.schema)
        this.set(n, Yy(this.schema, o, r));
      else
        throw new Error(`Expected YAML collection at ${n}. Remaining path: ${o}`);
    }
  }
}
const tI = (e) => e.replace(/^(?!$)(?: $)?/gm, "#");
function oa(e, t) {
  return /^\n+$/.test(e) ? e.substring(1) : t ? e.replace(/^(?! *$)/gm, t) : e;
}
const Pu = (e, t, r) => e.endsWith(`
`) ? oa(r, t) : r.includes(`
`) ? `
` + oa(r, t) : (e.endsWith(" ") ? "" : " ") + r, JA = "flow", Hw = "block", $y = "quoted";
function kv(e, t, r = "flow", { indentAtStart: n, lineWidth: o = 80, minContentWidth: a = 20, onFold: i, onOverflow: u } = {}) {
  if (!o || o < 0)
    return e;
  o < a && (a = 0);
  const c = Math.max(1 + a, 1 + o - t.length);
  if (e.length <= c)
    return e;
  const d = [], m = {};
  let g = o - t.length;
  typeof n == "number" && (n > o - Math.max(2, a) ? d.push(0) : g = o - n);
  let v, S, k = !1, b = -1, x = -1, A = -1;
  r === Hw && (b = g1(e, b, t.length), b !== -1 && (g = b + c));
  for (let O; O = e[b += 1]; ) {
    if (r === $y && O === "\\") {
      switch (x = b, e[b + 1]) {
        case "x":
          b += 3;
          break;
        case "u":
          b += 5;
          break;
        case "U":
          b += 9;
          break;
        default:
          b += 1;
      }
      A = b;
    }
    if (O === `
`)
      r === Hw && (b = g1(e, b, t.length)), g = b + t.length + c, v = void 0;
    else {
      if (O === " " && S && S !== " " && S !== `
` && S !== "	") {
        const R = e[b + 1];
        R && R !== " " && R !== `
` && R !== "	" && (v = b);
      }
      if (b >= g)
        if (v)
          d.push(v), g = v + c, v = void 0;
        else if (r === $y) {
          for (; S === " " || S === "	"; )
            S = O, O = e[b += 1], k = !0;
          const R = b > A + 1 ? b - 2 : x - 1;
          if (m[R])
            return e;
          d.push(R), m[R] = !0, g = R + c, v = void 0;
        } else
          k = !0;
    }
    S = O;
  }
  if (k && u && u(), d.length === 0)
    return e;
  i && i();
  let _ = e.slice(0, d[0]);
  for (let O = 0; O < d.length; ++O) {
    const R = d[O], C = d[O + 1] || e.length;
    R === 0 ? _ = `
${t}${e.slice(0, C)}` : (r === $y && m[R] && (_ += `${e[R]}\\`), _ += `
${t}${e.slice(R + 1, C)}`);
  }
  return _;
}
function g1(e, t, r) {
  let n = t, o = t + 1, a = e[o];
  for (; a === " " || a === "	"; )
    if (t < o + r)
      a = e[++t];
    else {
      do
        a = e[++t];
      while (a && a !== `
`);
      n = t, o = t + 1, a = e[o];
    }
  return n;
}
const Av = (e, t) => ({
  indentAtStart: t ? e.indent.length : e.indentAtStart,
  lineWidth: e.options.lineWidth,
  minContentWidth: e.options.minContentWidth
}), Pv = (e) => /^(%|---|\.\.\.)/m.test(e);
function rI(e, t, r) {
  if (!t || t < 0)
    return !1;
  const n = t - r, o = e.length;
  if (o <= n)
    return !1;
  for (let a = 0, i = 0; a < o; ++a)
    if (e[a] === `
`) {
      if (a - i > n)
        return !0;
      if (i = a + 1, o - i <= n)
        return !1;
    }
  return !0;
}
function Hd(e, t) {
  const r = JSON.stringify(e);
  if (t.options.doubleQuotedAsJSON)
    return r;
  const { implicitKey: n } = t, o = t.options.doubleQuotedMinMultiLineLength, a = t.indent || (Pv(e) ? "  " : "");
  let i = "", u = 0;
  for (let c = 0, d = r[c]; d; d = r[++c])
    if (d === " " && r[c + 1] === "\\" && r[c + 2] === "n" && (i += r.slice(u, c) + "\\ ", c += 1, u = c, d = "\\"), d === "\\")
      switch (r[c + 1]) {
        case "u":
          {
            i += r.slice(u, c);
            const m = r.substr(c + 2, 4);
            switch (m) {
              case "0000":
                i += "\\0";
                break;
              case "0007":
                i += "\\a";
                break;
              case "000b":
                i += "\\v";
                break;
              case "001b":
                i += "\\e";
                break;
              case "0085":
                i += "\\N";
                break;
              case "00a0":
                i += "\\_";
                break;
              case "2028":
                i += "\\L";
                break;
              case "2029":
                i += "\\P";
                break;
              default:
                m.substr(0, 2) === "00" ? i += "\\x" + m.substr(2) : i += r.substr(c, 6);
            }
            c += 5, u = c + 1;
          }
          break;
        case "n":
          if (n || r[c + 2] === '"' || r.length < o)
            c += 1;
          else {
            for (i += r.slice(u, c) + `

`; r[c + 2] === "\\" && r[c + 3] === "n" && r[c + 4] !== '"'; )
              i += `
`, c += 2;
            i += a, r[c + 2] === " " && (i += "\\"), c += 1, u = c + 1;
          }
          break;
        default:
          c += 1;
      }
  return i = u ? i + r.slice(u) : r, n ? i : kv(i, a, $y, Av(t, !1));
}
function Ww(e, t) {
  if (t.options.singleQuote === !1 || t.implicitKey && e.includes(`
`) || /[ \t]\n|\n[ \t]/.test(e))
    return Hd(e, t);
  const r = t.indent || (Pv(e) ? "  " : ""), n = "'" + e.replace(/'/g, "''").replace(/\n+/g, `$&
${r}`) + "'";
  return t.implicitKey ? n : kv(n, r, JA, Av(t, !1));
}
function hp(e, t) {
  const { singleQuote: r } = t.options;
  let n;
  if (r === !1)
    n = Hd;
  else {
    const o = e.includes('"'), a = e.includes("'");
    o && !a ? n = Ww : a && !o ? n = Hd : n = r ? Ww : Hd;
  }
  return n(e, t);
}
let Kw;
try {
  Kw = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
} catch {
  Kw = /\n+(?!\n|$)/g;
}
function Ry({ comment: e, type: t, value: r }, n, o, a) {
  const { blockQuote: i, commentString: u, lineWidth: c } = n.options;
  if (!i || /\n[\t ]+$/.test(r) || /^\s*$/.test(r))
    return hp(r, n);
  const d = n.indent || (n.forceBlockIndent || Pv(r) ? "  " : ""), m = i === "literal" ? !0 : i === "folded" || t === Ot.BLOCK_FOLDED ? !1 : t === Ot.BLOCK_LITERAL ? !0 : !rI(r, c, d.length);
  if (!r)
    return m ? `|
` : `>
`;
  let g, v;
  for (v = r.length; v > 0; --v) {
    const C = r[v - 1];
    if (C !== `
` && C !== "	" && C !== " ")
      break;
  }
  let S = r.substring(v);
  const k = S.indexOf(`
`);
  k === -1 ? g = "-" : r === S || k !== S.length - 1 ? (g = "+", a && a()) : g = "", S && (r = r.slice(0, -S.length), S[S.length - 1] === `
` && (S = S.slice(0, -1)), S = S.replace(Kw, `$&${d}`));
  let b = !1, x, A = -1;
  for (x = 0; x < r.length; ++x) {
    const C = r[x];
    if (C === " ")
      b = !0;
    else if (C === `
`)
      A = x;
    else
      break;
  }
  let _ = r.substring(0, A < x ? A + 1 : x);
  _ && (r = r.substring(_.length), _ = _.replace(/\n+/g, `$&${d}`));
  let R = (b ? d ? "2" : "1" : "") + g;
  if (e && (R += " " + u(e.replace(/ ?[\r\n]+/g, " ")), o && o()), !m) {
    const C = r.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${d}`);
    let T = !1;
    const j = Av(n, !0);
    i !== "folded" && t !== Ot.BLOCK_FOLDED && (j.onOverflow = () => {
      T = !0;
    });
    const D = kv(`${_}${C}${S}`, d, Hw, j);
    if (!T)
      return `>${R}
${d}${D}`;
  }
  return r = r.replace(/\n+/g, `$&${d}`), `|${R}
${d}${_}${r}${S}`;
}
function nI(e, t, r, n) {
  const { type: o, value: a } = e, { actualString: i, implicitKey: u, indent: c, indentStep: d, inFlow: m } = t;
  if (u && a.includes(`
`) || m && /[[\]{},]/.test(a))
    return hp(a, t);
  if (!a || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(a))
    return u || m || !a.includes(`
`) ? hp(a, t) : Ry(e, t, r, n);
  if (!u && !m && o !== Ot.PLAIN && a.includes(`
`))
    return Ry(e, t, r, n);
  if (Pv(a)) {
    if (c === "")
      return t.forceBlockIndent = !0, Ry(e, t, r, n);
    if (u && c === d)
      return hp(a, t);
  }
  const g = a.replace(/\n+/g, `$&
${c}`);
  if (i) {
    const v = (b) => {
      var x;
      return b.default && b.tag !== "tag:yaml.org,2002:str" && ((x = b.test) == null ? void 0 : x.test(g));
    }, { compat: S, tags: k } = t.doc.schema;
    if (k.some(v) || S != null && S.some(v))
      return hp(a, t);
  }
  return u ? g : kv(g, c, JA, Av(t, !1));
}
function dh(e, t, r, n) {
  const { implicitKey: o, inFlow: a } = t, i = typeof e.value == "string" ? e : Object.assign({}, e, { value: String(e.value) });
  let { type: u } = e;
  u !== Ot.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(i.value) && (u = Ot.QUOTE_DOUBLE);
  const c = (m) => {
    switch (m) {
      case Ot.BLOCK_FOLDED:
      case Ot.BLOCK_LITERAL:
        return o || a ? hp(i.value, t) : Ry(i, t, r, n);
      case Ot.QUOTE_DOUBLE:
        return Hd(i.value, t);
      case Ot.QUOTE_SINGLE:
        return Ww(i.value, t);
      case Ot.PLAIN:
        return nI(i, t, r, n);
      default:
        return null;
    }
  };
  let d = c(u);
  if (d === null) {
    const { defaultKeyType: m, defaultStringType: g } = t.options, v = o && m || g;
    if (d = c(v), d === null)
      throw new Error(`Unsupported default string type ${v}`);
  }
  return d;
}
function ZA(e, t) {
  const r = Object.assign({
    blockQuote: !0,
    commentString: tI,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: !1,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: !0,
    indentSeq: !0,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: !1,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: !0
  }, e.schema.toStringOptions, t);
  let n;
  switch (r.collectionStyle) {
    case "block":
      n = !1;
      break;
    case "flow":
      n = !0;
      break;
    default:
      n = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc: e,
    flowCollectionPadding: r.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof r.indent == "number" ? " ".repeat(r.indent) : "  ",
    inFlow: n,
    options: r
  };
}
function iI(e, t) {
  var o;
  if (t.tag) {
    const a = e.filter((i) => i.tag === t.tag);
    if (a.length > 0)
      return a.find((i) => i.format === t.format) ?? a[0];
  }
  let r, n;
  if (Gt(t)) {
    n = t.value;
    let a = e.filter((i) => {
      var u;
      return (u = i.identify) == null ? void 0 : u.call(i, n);
    });
    if (a.length > 1) {
      const i = a.filter((u) => u.test);
      i.length > 0 && (a = i);
    }
    r = a.find((i) => i.format === t.format) ?? a.find((i) => !i.format);
  } else
    n = t, r = e.find((a) => a.nodeClass && n instanceof a.nodeClass);
  if (!r) {
    const a = ((o = n == null ? void 0 : n.constructor) == null ? void 0 : o.name) ?? typeof n;
    throw new Error(`Tag not resolved for ${a} value`);
  }
  return r;
}
function sI(e, t, { anchors: r, doc: n }) {
  if (!n.directives)
    return "";
  const o = [], a = (Gt(e) || dr(e)) && e.anchor;
  a && KA(a) && (r.add(a), o.push(`&${a}`));
  const i = e.tag ? e.tag : t.default ? null : t.tag;
  return i && o.push(n.directives.tagString(i)), o.join(" ");
}
function xp(e, t, r, n) {
  var c;
  if (ur(e))
    return e.toString(t, r, n);
  if (yl(e)) {
    if (t.doc.directives)
      return e.toString(t);
    if ((c = t.resolvedAliases) != null && c.has(e))
      throw new TypeError("Cannot stringify circular structure without alias nodes");
    t.resolvedAliases ? t.resolvedAliases.add(e) : t.resolvedAliases = /* @__PURE__ */ new Set([e]), e = e.resolve(t.doc);
  }
  let o;
  const a = hr(e) ? e : t.doc.createNode(e, { onTagObj: (d) => o = d });
  o || (o = iI(t.doc.schema.tags, a));
  const i = sI(a, o, t);
  i.length > 0 && (t.indentAtStart = (t.indentAtStart ?? 0) + i.length + 1);
  const u = typeof o.stringify == "function" ? o.stringify(a, t, r, n) : Gt(a) ? dh(a, t, r, n) : a.toString(t, r, n);
  return i ? Gt(a) || u[0] === "{" || u[0] === "[" ? `${i} ${u}` : `${i}
${t.indent}${u}` : u;
}
function oI({ key: e, value: t }, r, n, o) {
  const { allNullValues: a, doc: i, indent: u, indentStep: c, options: { commentString: d, indentSeq: m, simpleKeys: g } } = r;
  let v = hr(e) && e.comment || null;
  if (g) {
    if (v)
      throw new Error("With simple keys, key nodes cannot have comments");
    if (dr(e) || !hr(e) && typeof e == "object") {
      const j = "With simple keys, collection cannot be used as a key value";
      throw new Error(j);
    }
  }
  let S = !g && (!e || v && t == null && !r.inFlow || dr(e) || (Gt(e) ? e.type === Ot.BLOCK_FOLDED || e.type === Ot.BLOCK_LITERAL : typeof e == "object"));
  r = Object.assign({}, r, {
    allNullValues: !1,
    implicitKey: !S && (g || !a),
    indent: u + c
  });
  let k = !1, b = !1, x = xp(e, r, () => k = !0, () => b = !0);
  if (!S && !r.inFlow && x.length > 1024) {
    if (g)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    S = !0;
  }
  if (r.inFlow) {
    if (a || t == null)
      return k && n && n(), x === "" ? "?" : S ? `? ${x}` : x;
  } else if (a && !g || t == null && S)
    return x = `? ${x}`, v && !k ? x += Pu(x, r.indent, d(v)) : b && o && o(), x;
  k && (v = null), S ? (v && (x += Pu(x, r.indent, d(v))), x = `? ${x}
${u}:`) : (x = `${x}:`, v && (x += Pu(x, r.indent, d(v))));
  let A, _, O;
  hr(t) ? (A = !!t.spaceBefore, _ = t.commentBefore, O = t.comment) : (A = !1, _ = null, O = null, t && typeof t == "object" && (t = i.createNode(t))), r.implicitKey = !1, !S && !v && Gt(t) && (r.indentAtStart = x.length + 1), b = !1, !m && c.length >= 2 && !r.inFlow && !S && zu(t) && !t.flow && !t.tag && !t.anchor && (r.indent = r.indent.substring(2));
  let R = !1;
  const C = xp(t, r, () => R = !0, () => b = !0);
  let T = " ";
  if (v || A || _) {
    if (T = A ? `
` : "", _) {
      const j = d(_);
      T += `
${oa(j, r.indent)}`;
    }
    C === "" && !r.inFlow ? T === `
` && (T = `

`) : T += `
${r.indent}`;
  } else if (!S && dr(t)) {
    const j = C[0], D = C.indexOf(`
`), V = D !== -1, U = r.inFlow ?? t.flow ?? t.items.length === 0;
    if (V || !U) {
      let ne = !1;
      if (V && (j === "&" || j === "!")) {
        let H = C.indexOf(" ");
        j === "&" && H !== -1 && H < D && C[H + 1] === "!" && (H = C.indexOf(" ", H + 1)), (H === -1 || D < H) && (ne = !0);
      }
      ne || (T = `
${r.indent}`);
    }
  } else (C === "" || C[0] === `
`) && (T = "");
  return x += T + C, r.inFlow ? R && n && n() : O && !R ? x += Pu(x, r.indent, d(O)) : b && o && o(), x;
}
function eP(e, t) {
  (e === "debug" || e === "warn") && console.warn(t);
}
const ag = "<<", aa = {
  identify: (e) => e === ag || typeof e == "symbol" && e.description === ag,
  default: "key",
  tag: "tag:yaml.org,2002:merge",
  test: /^<<$/,
  resolve: () => Object.assign(new Ot(Symbol(ag)), {
    addToJSMap: tP
  }),
  stringify: () => ag
}, aI = (e, t) => (aa.identify(t) || Gt(t) && (!t.type || t.type === Ot.PLAIN) && aa.identify(t.value)) && (e == null ? void 0 : e.doc.schema.tags.some((r) => r.tag === aa.tag && r.default));
function tP(e, t, r) {
  if (r = e && yl(r) ? r.resolve(e.doc) : r, zu(r))
    for (const n of r.items)
      s0(e, t, n);
  else if (Array.isArray(r))
    for (const n of r)
      s0(e, t, n);
  else
    s0(e, t, r);
}
function s0(e, t, r) {
  const n = e && yl(r) ? r.resolve(e.doc) : r;
  if (!qu(n))
    throw new Error("Merge sources must be maps or map aliases");
  const o = n.toJSON(null, e, Map);
  for (const [a, i] of o)
    t instanceof Map ? t.has(a) || t.set(a, i) : t instanceof Set ? t.add(a) : Object.prototype.hasOwnProperty.call(t, a) || Object.defineProperty(t, a, {
      value: i,
      writable: !0,
      enumerable: !0,
      configurable: !0
    });
  return t;
}
function rP(e, t, { key: r, value: n }) {
  if (hr(r) && r.addToJSMap)
    r.addToJSMap(e, t, n);
  else if (aI(e, r))
    tP(e, t, n);
  else {
    const o = Wi(r, "", e);
    if (t instanceof Map)
      t.set(o, Wi(n, o, e));
    else if (t instanceof Set)
      t.add(o);
    else {
      const a = lI(r, o, e), i = Wi(n, a, e);
      a in t ? Object.defineProperty(t, a, {
        value: i,
        writable: !0,
        enumerable: !0,
        configurable: !0
      }) : t[a] = i;
    }
  }
  return t;
}
function lI(e, t, r) {
  if (t === null)
    return "";
  if (typeof t != "object")
    return String(t);
  if (hr(e) && (r != null && r.doc)) {
    const n = ZA(r.doc, {});
    n.anchors = /* @__PURE__ */ new Set();
    for (const a of r.anchors.keys())
      n.anchors.add(a.anchor);
    n.inFlow = !0, n.inStringifyKey = !0;
    const o = e.toString(n);
    if (!r.mapKeyWarned) {
      let a = JSON.stringify(o);
      a.length > 40 && (a = a.substring(0, 36) + '..."'), eP(r.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${a}. Set mapAsMap: true to use object keys.`), r.mapKeyWarned = !0;
    }
    return o;
  }
  return JSON.stringify(t);
}
function MS(e, t, r) {
  const n = Xd(e, void 0, r), o = Xd(t, void 0, r);
  return new an(n, o);
}
class an {
  constructor(t, r = null) {
    Object.defineProperty(this, Ki, { value: BA }), this.key = t, this.value = r;
  }
  clone(t) {
    let { key: r, value: n } = this;
    return hr(r) && (r = r.clone(t)), hr(n) && (n = n.clone(t)), new an(r, n);
  }
  toJSON(t, r) {
    const n = r != null && r.mapAsMap ? /* @__PURE__ */ new Map() : {};
    return rP(r, n, this);
  }
  toString(t, r, n) {
    return t != null && t.doc ? oI(this, t, r, n) : JSON.stringify(this);
  }
}
function nP(e, t, r) {
  return (t.inFlow ?? e.flow ? cI : uI)(e, t, r);
}
function uI({ comment: e, items: t }, r, { blockItemPrefix: n, flowChars: o, itemIndent: a, onChompKeep: i, onComment: u }) {
  const { indent: c, options: { commentString: d } } = r, m = Object.assign({}, r, { indent: a, type: null });
  let g = !1;
  const v = [];
  for (let k = 0; k < t.length; ++k) {
    const b = t[k];
    let x = null;
    if (hr(b))
      !g && b.spaceBefore && v.push(""), Gy(r, v, b.commentBefore, g), b.comment && (x = b.comment);
    else if (ur(b)) {
      const _ = hr(b.key) ? b.key : null;
      _ && (!g && _.spaceBefore && v.push(""), Gy(r, v, _.commentBefore, g));
    }
    g = !1;
    let A = xp(b, m, () => x = null, () => g = !0);
    x && (A += Pu(A, a, d(x))), g && x && (g = !1), v.push(n + A);
  }
  let S;
  if (v.length === 0)
    S = o.start + o.end;
  else {
    S = v[0];
    for (let k = 1; k < v.length; ++k) {
      const b = v[k];
      S += b ? `
${c}${b}` : `
`;
    }
  }
  return e ? (S += `
` + oa(d(e), c), u && u()) : g && i && i(), S;
}
function cI({ items: e }, t, { flowChars: r, itemIndent: n }) {
  const { indent: o, indentStep: a, flowCollectionPadding: i, options: { commentString: u } } = t;
  n += a;
  const c = Object.assign({}, t, {
    indent: n,
    inFlow: !0,
    type: null
  });
  let d = !1, m = 0;
  const g = [];
  for (let k = 0; k < e.length; ++k) {
    const b = e[k];
    let x = null;
    if (hr(b))
      b.spaceBefore && g.push(""), Gy(t, g, b.commentBefore, !1), b.comment && (x = b.comment);
    else if (ur(b)) {
      const _ = hr(b.key) ? b.key : null;
      _ && (_.spaceBefore && g.push(""), Gy(t, g, _.commentBefore, !1), _.comment && (d = !0));
      const O = hr(b.value) ? b.value : null;
      O ? (O.comment && (x = O.comment), O.commentBefore && (d = !0)) : b.value == null && (_ != null && _.comment) && (x = _.comment);
    }
    x && (d = !0);
    let A = xp(b, c, () => x = null);
    k < e.length - 1 && (A += ","), x && (A += Pu(A, n, u(x))), !d && (g.length > m || A.includes(`
`)) && (d = !0), g.push(A), m = g.length;
  }
  const { start: v, end: S } = r;
  if (g.length === 0)
    return v + S;
  if (!d) {
    const k = g.reduce((b, x) => b + x.length + 2, 2);
    d = t.options.lineWidth > 0 && k > t.options.lineWidth;
  }
  if (d) {
    let k = v;
    for (const b of g)
      k += b ? `
${a}${o}${b}` : `
`;
    return `${k}
${o}${S}`;
  } else
    return `${v}${i}${g.join(" ")}${i}${S}`;
}
function Gy({ indent: e, options: { commentString: t } }, r, n, o) {
  if (n && o && (n = n.replace(/^\n+/, "")), n) {
    const a = oa(t(n), e);
    r.push(a.trimStart());
  }
}
function Tu(e, t) {
  const r = Gt(t) ? t.value : t;
  for (const n of e)
    if (ur(n) && (n.key === t || n.key === r || Gt(n.key) && n.key.value === r))
      return n;
}
class Zn extends XA {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(t) {
    super(ul, t), this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(t, r, n) {
    const { keepUndefined: o, replacer: a } = n, i = new this(t), u = (c, d) => {
      if (typeof a == "function")
        d = a.call(r, c, d);
      else if (Array.isArray(a) && !a.includes(c))
        return;
      (d !== void 0 || o) && i.items.push(MS(c, d, n));
    };
    if (r instanceof Map)
      for (const [c, d] of r)
        u(c, d);
    else if (r && typeof r == "object")
      for (const c of Object.keys(r))
        u(c, r[c]);
    return typeof t.sortMapEntries == "function" && i.items.sort(t.sortMapEntries), i;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(t, r) {
    var i;
    let n;
    ur(t) ? n = t : !t || typeof t != "object" || !("key" in t) ? n = new an(t, t == null ? void 0 : t.value) : n = new an(t.key, t.value);
    const o = Tu(this.items, n.key), a = (i = this.schema) == null ? void 0 : i.sortMapEntries;
    if (o) {
      if (!r)
        throw new Error(`Key ${n.key} already set`);
      Gt(o.value) && GA(n.value) ? o.value.value = n.value : o.value = n.value;
    } else if (a) {
      const u = this.items.findIndex((c) => a(n, c) < 0);
      u === -1 ? this.items.push(n) : this.items.splice(u, 0, n);
    } else
      this.items.push(n);
  }
  delete(t) {
    const r = Tu(this.items, t);
    return r ? this.items.splice(this.items.indexOf(r), 1).length > 0 : !1;
  }
  get(t, r) {
    const n = Tu(this.items, t), o = n == null ? void 0 : n.value;
    return (!r && Gt(o) ? o.value : o) ?? void 0;
  }
  has(t) {
    return !!Tu(this.items, t);
  }
  set(t, r) {
    this.add(new an(t, r), !0);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(t, r, n) {
    const o = n ? new n() : r != null && r.mapAsMap ? /* @__PURE__ */ new Map() : {};
    r != null && r.onCreate && r.onCreate(o);
    for (const a of this.items)
      rP(r, o, a);
    return o;
  }
  toString(t, r, n) {
    if (!t)
      return JSON.stringify(this);
    for (const o of this.items)
      if (!ur(o))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(o)} instead`);
    return !t.allNullValues && this.hasAllNullValues(!1) && (t = Object.assign({}, t, { allNullValues: !0 })), nP(this, t, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: t.indent || "",
      onChompKeep: n,
      onComment: r
    });
  }
}
const jp = {
  collection: "map",
  default: !0,
  nodeClass: Zn,
  tag: "tag:yaml.org,2002:map",
  resolve(e, t) {
    return qu(e) || t("Expected a mapping for this tag"), e;
  },
  createNode: (e, t, r) => Zn.from(e, t, r)
};
class pa extends XA {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(t) {
    super(Np, t), this.items = [];
  }
  add(t) {
    this.items.push(t);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(t) {
    const r = lg(t);
    return typeof r != "number" ? !1 : this.items.splice(r, 1).length > 0;
  }
  get(t, r) {
    const n = lg(t);
    if (typeof n != "number")
      return;
    const o = this.items[n];
    return !r && Gt(o) ? o.value : o;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(t) {
    const r = lg(t);
    return typeof r == "number" && r < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(t, r) {
    const n = lg(t);
    if (typeof n != "number")
      throw new Error(`Expected a valid index, not ${t}.`);
    const o = this.items[n];
    Gt(o) && GA(r) ? o.value = r : this.items[n] = r;
  }
  toJSON(t, r) {
    const n = [];
    r != null && r.onCreate && r.onCreate(n);
    let o = 0;
    for (const a of this.items)
      n.push(Wi(a, String(o++), r));
    return n;
  }
  toString(t, r, n) {
    return t ? nP(this, t, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (t.indent || "") + "  ",
      onChompKeep: n,
      onComment: r
    }) : JSON.stringify(this);
  }
  static from(t, r, n) {
    const { replacer: o } = n, a = new this(t);
    if (r && Symbol.iterator in Object(r)) {
      let i = 0;
      for (let u of r) {
        if (typeof o == "function") {
          const c = r instanceof Set ? u : String(i++);
          u = o.call(r, c, u);
        }
        a.items.push(Xd(u, void 0, n));
      }
    }
    return a;
  }
}
function lg(e) {
  let t = Gt(e) ? e.value : e;
  return t && typeof t == "string" && (t = Number(t)), typeof t == "number" && Number.isInteger(t) && t >= 0 ? t : null;
}
const Lp = {
  collection: "seq",
  default: !0,
  nodeClass: pa,
  tag: "tag:yaml.org,2002:seq",
  resolve(e, t) {
    return zu(e) || t("Expected a sequence for this tag"), e;
  },
  createNode: (e, t, r) => pa.from(e, t, r)
}, Tv = {
  identify: (e) => typeof e == "string",
  default: !0,
  tag: "tag:yaml.org,2002:str",
  resolve: (e) => e,
  stringify(e, t, r, n) {
    return t = Object.assign({ actualString: !0 }, t), dh(e, t, r, n);
  }
}, Cv = {
  identify: (e) => e == null,
  createNode: () => new Ot(null),
  default: !0,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Ot(null),
  stringify: ({ source: e }, t) => typeof e == "string" && Cv.test.test(e) ? e : t.options.nullStr
}, DS = {
  identify: (e) => typeof e == "boolean",
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (e) => new Ot(e[0] === "t" || e[0] === "T"),
  stringify({ source: e, value: t }, r) {
    if (e && DS.test.test(e)) {
      const n = e[0] === "t" || e[0] === "T";
      if (t === n)
        return e;
    }
    return t ? r.options.trueStr : r.options.falseStr;
  }
};
function Ts({ format: e, minFractionDigits: t, tag: r, value: n }) {
  if (typeof n == "bigint")
    return String(n);
  const o = typeof n == "number" ? n : Number(n);
  if (!isFinite(o))
    return isNaN(o) ? ".nan" : o < 0 ? "-.inf" : ".inf";
  let a = JSON.stringify(n);
  if (!e && t && (!r || r === "tag:yaml.org,2002:float") && /^\d/.test(a)) {
    let i = a.indexOf(".");
    i < 0 && (i = a.length, a += ".");
    let u = t - (a.length - i - 1);
    for (; u-- > 0; )
      a += "0";
  }
  return a;
}
const iP = {
  identify: (e) => typeof e == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (e) => e.slice(-3).toLowerCase() === "nan" ? NaN : e[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: Ts
}, sP = {
  identify: (e) => typeof e == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (e) => parseFloat(e),
  stringify(e) {
    const t = Number(e.value);
    return isFinite(t) ? t.toExponential() : Ts(e);
  }
}, oP = {
  identify: (e) => typeof e == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(e) {
    const t = new Ot(parseFloat(e)), r = e.indexOf(".");
    return r !== -1 && e[e.length - 1] === "0" && (t.minFractionDigits = e.length - r - 1), t;
  },
  stringify: Ts
}, $v = (e) => typeof e == "bigint" || Number.isInteger(e), FS = (e, t, r, { intAsBigInt: n }) => n ? BigInt(e) : parseInt(e.substring(t), r);
function aP(e, t, r) {
  const { value: n } = e;
  return $v(n) && n >= 0 ? r + n.toString(t) : Ts(e);
}
const lP = {
  identify: (e) => $v(e) && e >= 0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (e, t, r) => FS(e, 2, 8, r),
  stringify: (e) => aP(e, 8, "0o")
}, uP = {
  identify: $v,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (e, t, r) => FS(e, 0, 10, r),
  stringify: Ts
}, cP = {
  identify: (e) => $v(e) && e >= 0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (e, t, r) => FS(e, 2, 16, r),
  stringify: (e) => aP(e, 16, "0x")
}, pI = [
  jp,
  Lp,
  Tv,
  Cv,
  DS,
  lP,
  uP,
  cP,
  iP,
  sP,
  oP
];
function y1(e) {
  return typeof e == "bigint" || Number.isInteger(e);
}
const ug = ({ value: e }) => JSON.stringify(e), fI = [
  {
    identify: (e) => typeof e == "string",
    default: !0,
    tag: "tag:yaml.org,2002:str",
    resolve: (e) => e,
    stringify: ug
  },
  {
    identify: (e) => e == null,
    createNode: () => new Ot(null),
    default: !0,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: ug
  },
  {
    identify: (e) => typeof e == "boolean",
    default: !0,
    tag: "tag:yaml.org,2002:bool",
    test: /^true$|^false$/,
    resolve: (e) => e === "true",
    stringify: ug
  },
  {
    identify: y1,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (e, t, { intAsBigInt: r }) => r ? BigInt(e) : parseInt(e, 10),
    stringify: ({ value: e }) => y1(e) ? e.toString() : JSON.stringify(e)
  },
  {
    identify: (e) => typeof e == "number",
    default: !0,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (e) => parseFloat(e),
    stringify: ug
  }
], dI = {
  default: !0,
  tag: "",
  test: /^/,
  resolve(e, t) {
    return t(`Unresolved plain scalar ${JSON.stringify(e)}`), e;
  }
}, hI = [jp, Lp].concat(fI, dI), qS = {
  identify: (e) => e instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: !1,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(e, t) {
    if (typeof atob == "function") {
      const r = atob(e.replace(/[\n\r]/g, "")), n = new Uint8Array(r.length);
      for (let o = 0; o < r.length; ++o)
        n[o] = r.charCodeAt(o);
      return n;
    } else
      return t("This environment does not support reading binary tags; either Buffer or atob is required"), e;
  },
  stringify({ comment: e, type: t, value: r }, n, o, a) {
    if (!r)
      return "";
    const i = r;
    let u;
    if (typeof btoa == "function") {
      let c = "";
      for (let d = 0; d < i.length; ++d)
        c += String.fromCharCode(i[d]);
      u = btoa(c);
    } else
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    if (t || (t = Ot.BLOCK_LITERAL), t !== Ot.QUOTE_DOUBLE) {
      const c = Math.max(n.options.lineWidth - n.indent.length, n.options.minContentWidth), d = Math.ceil(u.length / c), m = new Array(d);
      for (let g = 0, v = 0; g < d; ++g, v += c)
        m[g] = u.substr(v, c);
      u = m.join(t === Ot.BLOCK_LITERAL ? `
` : " ");
    }
    return dh({ comment: e, type: t, value: u }, n, o, a);
  }
};
function pP(e, t) {
  if (zu(e))
    for (let r = 0; r < e.items.length; ++r) {
      let n = e.items[r];
      if (!ur(n)) {
        if (qu(n)) {
          n.items.length > 1 && t("Each pair must have its own sequence indicator");
          const o = n.items[0] || new an(new Ot(null));
          if (n.commentBefore && (o.key.commentBefore = o.key.commentBefore ? `${n.commentBefore}
${o.key.commentBefore}` : n.commentBefore), n.comment) {
            const a = o.value ?? o.key;
            a.comment = a.comment ? `${n.comment}
${a.comment}` : n.comment;
          }
          n = o;
        }
        e.items[r] = ur(n) ? n : new an(n);
      }
    }
  else
    t("Expected a sequence for this tag");
  return e;
}
function fP(e, t, r) {
  const { replacer: n } = r, o = new pa(e);
  o.tag = "tag:yaml.org,2002:pairs";
  let a = 0;
  if (t && Symbol.iterator in Object(t))
    for (let i of t) {
      typeof n == "function" && (i = n.call(t, String(a++), i));
      let u, c;
      if (Array.isArray(i))
        if (i.length === 2)
          u = i[0], c = i[1];
        else
          throw new TypeError(`Expected [key, value] tuple: ${i}`);
      else if (i && i instanceof Object) {
        const d = Object.keys(i);
        if (d.length === 1)
          u = d[0], c = i[u];
        else
          throw new TypeError(`Expected tuple with one key, not ${d.length} keys`);
      } else
        u = i;
      o.items.push(MS(u, c, r));
    }
  return o;
}
const zS = {
  collection: "seq",
  default: !1,
  tag: "tag:yaml.org,2002:pairs",
  resolve: pP,
  createNode: fP
};
class bp extends pa {
  constructor() {
    super(), this.add = Zn.prototype.add.bind(this), this.delete = Zn.prototype.delete.bind(this), this.get = Zn.prototype.get.bind(this), this.has = Zn.prototype.has.bind(this), this.set = Zn.prototype.set.bind(this), this.tag = bp.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(t, r) {
    if (!r)
      return super.toJSON(t);
    const n = /* @__PURE__ */ new Map();
    r != null && r.onCreate && r.onCreate(n);
    for (const o of this.items) {
      let a, i;
      if (ur(o) ? (a = Wi(o.key, "", r), i = Wi(o.value, a, r)) : a = Wi(o, "", r), n.has(a))
        throw new Error("Ordered maps must not include duplicate keys");
      n.set(a, i);
    }
    return n;
  }
  static from(t, r, n) {
    const o = fP(t, r, n), a = new this();
    return a.items = o.items, a;
  }
}
bp.tag = "tag:yaml.org,2002:omap";
const BS = {
  collection: "seq",
  identify: (e) => e instanceof Map,
  nodeClass: bp,
  default: !1,
  tag: "tag:yaml.org,2002:omap",
  resolve(e, t) {
    const r = pP(e, t), n = [];
    for (const { key: o } of r.items)
      Gt(o) && (n.includes(o.value) ? t(`Ordered maps must not include duplicate keys: ${o.value}`) : n.push(o.value));
    return Object.assign(new bp(), r);
  },
  createNode: (e, t, r) => bp.from(e, t, r)
};
function dP({ value: e, source: t }, r) {
  return t && (e ? hP : mP).test.test(t) ? t : e ? r.options.trueStr : r.options.falseStr;
}
const hP = {
  identify: (e) => e === !0,
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Ot(!0),
  stringify: dP
}, mP = {
  identify: (e) => e === !1,
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
  resolve: () => new Ot(!1),
  stringify: dP
}, mI = {
  identify: (e) => typeof e == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (e) => e.slice(-3).toLowerCase() === "nan" ? NaN : e[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: Ts
}, gI = {
  identify: (e) => typeof e == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (e) => parseFloat(e.replace(/_/g, "")),
  stringify(e) {
    const t = Number(e.value);
    return isFinite(t) ? t.toExponential() : Ts(e);
  }
}, yI = {
  identify: (e) => typeof e == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(e) {
    const t = new Ot(parseFloat(e.replace(/_/g, ""))), r = e.indexOf(".");
    if (r !== -1) {
      const n = e.substring(r + 1).replace(/_/g, "");
      n[n.length - 1] === "0" && (t.minFractionDigits = n.length);
    }
    return t;
  },
  stringify: Ts
}, hh = (e) => typeof e == "bigint" || Number.isInteger(e);
function Rv(e, t, r, { intAsBigInt: n }) {
  const o = e[0];
  if ((o === "-" || o === "+") && (t += 1), e = e.substring(t).replace(/_/g, ""), n) {
    switch (r) {
      case 2:
        e = `0b${e}`;
        break;
      case 8:
        e = `0o${e}`;
        break;
      case 16:
        e = `0x${e}`;
        break;
    }
    const i = BigInt(e);
    return o === "-" ? BigInt(-1) * i : i;
  }
  const a = parseInt(e, r);
  return o === "-" ? -1 * a : a;
}
function US(e, t, r) {
  const { value: n } = e;
  if (hh(n)) {
    const o = n.toString(t);
    return n < 0 ? "-" + r + o.substr(1) : r + o;
  }
  return Ts(e);
}
const vI = {
  identify: hh,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (e, t, r) => Rv(e, 2, 2, r),
  stringify: (e) => US(e, 2, "0b")
}, bI = {
  identify: hh,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (e, t, r) => Rv(e, 1, 8, r),
  stringify: (e) => US(e, 8, "0")
}, wI = {
  identify: hh,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (e, t, r) => Rv(e, 0, 10, r),
  stringify: Ts
}, SI = {
  identify: hh,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (e, t, r) => Rv(e, 2, 16, r),
  stringify: (e) => US(e, 16, "0x")
};
class wp extends Zn {
  constructor(t) {
    super(t), this.tag = wp.tag;
  }
  add(t) {
    let r;
    ur(t) ? r = t : t && typeof t == "object" && "key" in t && "value" in t && t.value === null ? r = new an(t.key, null) : r = new an(t, null), Tu(this.items, r.key) || this.items.push(r);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(t, r) {
    const n = Tu(this.items, t);
    return !r && ur(n) ? Gt(n.key) ? n.key.value : n.key : n;
  }
  set(t, r) {
    if (typeof r != "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof r}`);
    const n = Tu(this.items, t);
    n && !r ? this.items.splice(this.items.indexOf(n), 1) : !n && r && this.items.push(new an(t));
  }
  toJSON(t, r) {
    return super.toJSON(t, r, Set);
  }
  toString(t, r, n) {
    if (!t)
      return JSON.stringify(this);
    if (this.hasAllNullValues(!0))
      return super.toString(Object.assign({}, t, { allNullValues: !0 }), r, n);
    throw new Error("Set items must all have null values");
  }
  static from(t, r, n) {
    const { replacer: o } = n, a = new this(t);
    if (r && Symbol.iterator in Object(r))
      for (let i of r)
        typeof o == "function" && (i = o.call(r, i, i)), a.items.push(MS(i, null, n));
    return a;
  }
}
wp.tag = "tag:yaml.org,2002:set";
const VS = {
  collection: "map",
  identify: (e) => e instanceof Set,
  nodeClass: wp,
  default: !1,
  tag: "tag:yaml.org,2002:set",
  createNode: (e, t, r) => wp.from(e, t, r),
  resolve(e, t) {
    if (qu(e)) {
      if (e.hasAllNullValues(!0))
        return Object.assign(new wp(), e);
      t("Set items must all have null values");
    } else
      t("Expected a mapping for this tag");
    return e;
  }
};
function HS(e, t) {
  const r = e[0], n = r === "-" || r === "+" ? e.substring(1) : e, o = (i) => t ? BigInt(i) : Number(i), a = n.replace(/_/g, "").split(":").reduce((i, u) => i * o(60) + o(u), o(0));
  return r === "-" ? o(-1) * a : a;
}
function gP(e) {
  let { value: t } = e, r = (i) => i;
  if (typeof t == "bigint")
    r = (i) => BigInt(i);
  else if (isNaN(t) || !isFinite(t))
    return Ts(e);
  let n = "";
  t < 0 && (n = "-", t *= r(-1));
  const o = r(60), a = [t % o];
  return t < 60 ? a.unshift(0) : (t = (t - a[0]) / o, a.unshift(t % o), t >= 60 && (t = (t - a[0]) / o, a.unshift(t))), n + a.map((i) => String(i).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
const yP = {
  identify: (e) => typeof e == "bigint" || Number.isInteger(e),
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (e, t, { intAsBigInt: r }) => HS(e, r),
  stringify: gP
}, vP = {
  identify: (e) => typeof e == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (e) => HS(e, !1),
  stringify: gP
}, Iv = {
  identify: (e) => e instanceof Date,
  default: !0,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(e) {
    const t = e.match(Iv.test);
    if (!t)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, r, n, o, a, i, u] = t.map(Number), c = t[7] ? Number((t[7] + "00").substr(1, 3)) : 0;
    let d = Date.UTC(r, n - 1, o, a || 0, i || 0, u || 0, c);
    const m = t[8];
    if (m && m !== "Z") {
      let g = HS(m, !1);
      Math.abs(g) < 30 && (g *= 60), d -= 6e4 * g;
    }
    return new Date(d);
  },
  stringify: ({ value: e }) => (e == null ? void 0 : e.toISOString().replace(/(T00:00:00)?\.000Z$/, "")) ?? ""
}, v1 = [
  jp,
  Lp,
  Tv,
  Cv,
  hP,
  mP,
  vI,
  bI,
  wI,
  SI,
  mI,
  gI,
  yI,
  qS,
  aa,
  BS,
  zS,
  VS,
  yP,
  vP,
  Iv
], b1 = /* @__PURE__ */ new Map([
  ["core", pI],
  ["failsafe", [jp, Lp, Tv]],
  ["json", hI],
  ["yaml11", v1],
  ["yaml-1.1", v1]
]), w1 = {
  binary: qS,
  bool: DS,
  float: oP,
  floatExp: sP,
  floatNaN: iP,
  floatTime: vP,
  int: uP,
  intHex: cP,
  intOct: lP,
  intTime: yP,
  map: jp,
  merge: aa,
  null: Cv,
  omap: BS,
  pairs: zS,
  seq: Lp,
  set: VS,
  timestamp: Iv
}, xI = {
  "tag:yaml.org,2002:binary": qS,
  "tag:yaml.org,2002:merge": aa,
  "tag:yaml.org,2002:omap": BS,
  "tag:yaml.org,2002:pairs": zS,
  "tag:yaml.org,2002:set": VS,
  "tag:yaml.org,2002:timestamp": Iv
};
function o0(e, t, r) {
  const n = b1.get(t);
  if (n && !e)
    return r && !n.includes(aa) ? n.concat(aa) : n.slice();
  let o = n;
  if (!o)
    if (Array.isArray(e))
      o = [];
    else {
      const a = Array.from(b1.keys()).filter((i) => i !== "yaml11").map((i) => JSON.stringify(i)).join(", ");
      throw new Error(`Unknown schema "${t}"; use one of ${a} or define customTags array`);
    }
  if (Array.isArray(e))
    for (const a of e)
      o = o.concat(a);
  else typeof e == "function" && (o = e(o.slice()));
  return r && (o = o.concat(aa)), o.reduce((a, i) => {
    const u = typeof i == "string" ? w1[i] : i;
    if (!u) {
      const c = JSON.stringify(i), d = Object.keys(w1).map((m) => JSON.stringify(m)).join(", ");
      throw new Error(`Unknown custom tag ${c}; use one of ${d}`);
    }
    return a.includes(u) || a.push(u), a;
  }, []);
}
const _I = (e, t) => e.key < t.key ? -1 : e.key > t.key ? 1 : 0;
class mh {
  constructor({ compat: t, customTags: r, merge: n, resolveKnownTags: o, schema: a, sortMapEntries: i, toStringDefaults: u }) {
    this.compat = Array.isArray(t) ? o0(t, "compat") : t ? o0(null, t) : null, this.name = typeof a == "string" && a || "core", this.knownTags = o ? xI : {}, this.tags = o0(r, this.name, n), this.toStringOptions = u ?? null, Object.defineProperty(this, ul, { value: jp }), Object.defineProperty(this, So, { value: Tv }), Object.defineProperty(this, Np, { value: Lp }), this.sortMapEntries = typeof i == "function" ? i : i === !0 ? _I : null;
  }
  clone() {
    const t = Object.create(mh.prototype, Object.getOwnPropertyDescriptors(this));
    return t.tags = this.tags.slice(), t;
  }
}
function EI(e, t) {
  var c;
  const r = [];
  let n = t.directives === !0;
  if (t.directives !== !1 && e.directives) {
    const d = e.directives.toString(e);
    d ? (r.push(d), n = !0) : e.directives.docStart && (n = !0);
  }
  n && r.push("---");
  const o = ZA(e, t), { commentString: a } = o.options;
  if (e.commentBefore) {
    r.length !== 1 && r.unshift("");
    const d = a(e.commentBefore);
    r.unshift(oa(d, ""));
  }
  let i = !1, u = null;
  if (e.contents) {
    if (hr(e.contents)) {
      if (e.contents.spaceBefore && n && r.push(""), e.contents.commentBefore) {
        const g = a(e.contents.commentBefore);
        r.push(oa(g, ""));
      }
      o.forceBlockIndent = !!e.comment, u = e.contents.comment;
    }
    const d = u ? void 0 : () => i = !0;
    let m = xp(e.contents, o, () => u = null, d);
    u && (m += Pu(m, "", a(u))), (m[0] === "|" || m[0] === ">") && r[r.length - 1] === "---" ? r[r.length - 1] = `--- ${m}` : r.push(m);
  } else
    r.push(xp(e.contents, o));
  if ((c = e.directives) != null && c.docEnd)
    if (e.comment) {
      const d = a(e.comment);
      d.includes(`
`) ? (r.push("..."), r.push(oa(d, ""))) : r.push(`... ${d}`);
    } else
      r.push("...");
  else {
    let d = e.comment;
    d && i && (d = d.replace(/^\n+/, "")), d && ((!i || u) && r[r.length - 1] !== "" && r.push(""), r.push(oa(a(d), "")));
  }
  return r.join(`
`) + `
`;
}
class Bu {
  constructor(t, r, n) {
    this.commentBefore = null, this.comment = null, this.errors = [], this.warnings = [], Object.defineProperty(this, Ki, { value: Vw });
    let o = null;
    typeof r == "function" || Array.isArray(r) ? o = r : n === void 0 && r && (n = r, r = void 0);
    const a = Object.assign({
      intAsBigInt: !1,
      keepSourceTokens: !1,
      logLevel: "warn",
      prettyErrors: !0,
      strict: !0,
      stringKeys: !1,
      uniqueKeys: !0,
      version: "1.2"
    }, n);
    this.options = a;
    let { version: i } = a;
    n != null && n._directives ? (this.directives = n._directives.atDocument(), this.directives.yaml.explicit && (i = this.directives.yaml.version)) : this.directives = new Cn({ version: i }), this.setSchema(i, n), this.contents = t === void 0 ? null : this.createNode(t, o, n);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const t = Object.create(Bu.prototype, {
      [Ki]: { value: Vw }
    });
    return t.commentBefore = this.commentBefore, t.comment = this.comment, t.errors = this.errors.slice(), t.warnings = this.warnings.slice(), t.options = Object.assign({}, this.options), this.directives && (t.directives = this.directives.clone()), t.schema = this.schema.clone(), t.contents = hr(this.contents) ? this.contents.clone(t.schema) : this.contents, this.range && (t.range = this.range.slice()), t;
  }
  /** Adds a value to the document. */
  add(t) {
    ep(this.contents) && this.contents.add(t);
  }
  /** Adds a value to the document. */
  addIn(t, r) {
    ep(this.contents) && this.contents.addIn(t, r);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(t, r) {
    if (!t.anchor) {
      const n = QA(this);
      t.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !r || n.has(r) ? YA(r || "a", n) : r;
    }
    return new fh(t.anchor);
  }
  createNode(t, r, n) {
    let o;
    if (typeof r == "function")
      t = r.call({ "": t }, "", t), o = r;
    else if (Array.isArray(r)) {
      const x = (_) => typeof _ == "number" || _ instanceof String || _ instanceof Number, A = r.filter(x).map(String);
      A.length > 0 && (r = r.concat(A)), o = r;
    } else n === void 0 && r && (n = r, r = void 0);
    const { aliasDuplicateObjects: a, anchorPrefix: i, flow: u, keepUndefined: c, onTagObj: d, tag: m } = n ?? {}, { onAnchor: g, setAnchors: v, sourceObjects: S } = JR(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      i || "a"
    ), k = {
      aliasDuplicateObjects: a ?? !0,
      keepUndefined: c ?? !1,
      onAnchor: g,
      onTagObj: d,
      replacer: o,
      schema: this.schema,
      sourceObjects: S
    }, b = Xd(t, m, k);
    return u && dr(b) && (b.flow = !0), v(), b;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(t, r, n = {}) {
    const o = this.createNode(t, null, n), a = this.createNode(r, null, n);
    return new an(o, a);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(t) {
    return ep(this.contents) ? this.contents.delete(t) : !1;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(t) {
    return zd(t) ? this.contents == null ? !1 : (this.contents = null, !0) : ep(this.contents) ? this.contents.deleteIn(t) : !1;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(t, r) {
    return dr(this.contents) ? this.contents.get(t, r) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(t, r) {
    return zd(t) ? !r && Gt(this.contents) ? this.contents.value : this.contents : dr(this.contents) ? this.contents.getIn(t, r) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(t) {
    return dr(this.contents) ? this.contents.has(t) : !1;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(t) {
    return zd(t) ? this.contents !== void 0 : dr(this.contents) ? this.contents.hasIn(t) : !1;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(t, r) {
    this.contents == null ? this.contents = Yy(this.schema, [t], r) : ep(this.contents) && this.contents.set(t, r);
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(t, r) {
    zd(t) ? this.contents = r : this.contents == null ? this.contents = Yy(this.schema, Array.from(t), r) : ep(this.contents) && this.contents.setIn(t, r);
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(t, r = {}) {
    typeof t == "number" && (t = String(t));
    let n;
    switch (t) {
      case "1.1":
        this.directives ? this.directives.yaml.version = "1.1" : this.directives = new Cn({ version: "1.1" }), n = { resolveKnownTags: !1, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        this.directives ? this.directives.yaml.version = t : this.directives = new Cn({ version: t }), n = { resolveKnownTags: !0, schema: "core" };
        break;
      case null:
        this.directives && delete this.directives, n = null;
        break;
      default: {
        const o = JSON.stringify(t);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${o}`);
      }
    }
    if (r.schema instanceof Object)
      this.schema = r.schema;
    else if (n)
      this.schema = new mh(Object.assign(n, r));
    else
      throw new Error("With a null YAML version, the { schema: Schema } option is required");
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json: t, jsonArg: r, mapAsMap: n, maxAliasCount: o, onAnchor: a, reviver: i } = {}) {
    const u = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !t,
      mapAsMap: n === !0,
      mapKeyWarned: !1,
      maxAliasCount: typeof o == "number" ? o : 100
    }, c = Wi(this.contents, r ?? "", u);
    if (typeof a == "function")
      for (const { count: d, res: m } of u.anchors.values())
        a(m, d);
    return typeof i == "function" ? dp(i, { "": c }, "", c) : c;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(t, r) {
    return this.toJS({ json: !0, jsonArg: t, mapAsMap: !1, onAnchor: r });
  }
  /** A YAML representation of the document. */
  toString(t = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in t && (!Number.isInteger(t.indent) || Number(t.indent) <= 0)) {
      const r = JSON.stringify(t.indent);
      throw new Error(`"indent" option must be a positive integer, not ${r}`);
    }
    return EI(this, t);
  }
}
function ep(e) {
  if (dr(e))
    return !0;
  throw new Error("Expected a YAML collection as document contents");
}
class Nv extends Error {
  constructor(t, r, n, o) {
    super(), this.name = t, this.code = n, this.message = o, this.pos = r;
  }
}
class sl extends Nv {
  constructor(t, r, n) {
    super("YAMLParseError", t, r, n);
  }
}
class WS extends Nv {
  constructor(t, r, n) {
    super("YAMLWarning", t, r, n);
  }
}
const Xy = (e, t) => (r) => {
  if (r.pos[0] === -1)
    return;
  r.linePos = r.pos.map((u) => t.linePos(u));
  const { line: n, col: o } = r.linePos[0];
  r.message += ` at line ${n}, column ${o}`;
  let a = o - 1, i = e.substring(t.lineStarts[n - 1], t.lineStarts[n]).replace(/[\n\r]+$/, "");
  if (a >= 60 && i.length > 80) {
    const u = Math.min(a - 39, i.length - 79);
    i = "…" + i.substring(u), a -= u - 1;
  }
  if (i.length > 80 && (i = i.substring(0, 79) + "…"), n > 1 && /^ *$/.test(i.substring(0, a))) {
    let u = e.substring(t.lineStarts[n - 2], t.lineStarts[n - 1]);
    u.length > 80 && (u = u.substring(0, 79) + `…
`), i = u + i;
  }
  if (/[^ ]/.test(i)) {
    let u = 1;
    const c = r.linePos[1];
    c && c.line === n && c.col > o && (u = Math.max(1, Math.min(c.col - o, 80 - a)));
    const d = " ".repeat(a) + "^".repeat(u);
    r.message += `:

${i}
${d}
`;
  }
};
function _p(e, { flow: t, indicator: r, next: n, offset: o, onError: a, parentIndent: i, startOnNewline: u }) {
  let c = !1, d = u, m = u, g = "", v = "", S = !1, k = !1, b = null, x = null, A = null, _ = null, O = null, R = null, C = null;
  for (const D of e)
    switch (k && (D.type !== "space" && D.type !== "newline" && D.type !== "comma" && a(D.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), k = !1), b && (d && D.type !== "comment" && D.type !== "newline" && a(b, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), b = null), D.type) {
      case "space":
        !t && (r !== "doc-start" || (n == null ? void 0 : n.type) !== "flow-collection") && D.source.includes("	") && (b = D), m = !0;
        break;
      case "comment": {
        m || a(D, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const V = D.source.substring(1) || " ";
        g ? g += v + V : g = V, v = "", d = !1;
        break;
      }
      case "newline":
        d ? g ? g += D.source : (!R || r !== "seq-item-ind") && (c = !0) : v += D.source, d = !0, S = !0, (x || A) && (_ = D), m = !0;
        break;
      case "anchor":
        x && a(D, "MULTIPLE_ANCHORS", "A node can have at most one anchor"), D.source.endsWith(":") && a(D.offset + D.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", !0), x = D, C === null && (C = D.offset), d = !1, m = !1, k = !0;
        break;
      case "tag": {
        A && a(D, "MULTIPLE_TAGS", "A node can have at most one tag"), A = D, C === null && (C = D.offset), d = !1, m = !1, k = !0;
        break;
      }
      case r:
        (x || A) && a(D, "BAD_PROP_ORDER", `Anchors and tags must be after the ${D.source} indicator`), R && a(D, "UNEXPECTED_TOKEN", `Unexpected ${D.source} in ${t ?? "collection"}`), R = D, d = r === "seq-item-ind" || r === "explicit-key-ind", m = !1;
        break;
      case "comma":
        if (t) {
          O && a(D, "UNEXPECTED_TOKEN", `Unexpected , in ${t}`), O = D, d = !1, m = !1;
          break;
        }
      // else fallthrough
      default:
        a(D, "UNEXPECTED_TOKEN", `Unexpected ${D.type} token`), d = !1, m = !1;
    }
  const T = e[e.length - 1], j = T ? T.offset + T.source.length : o;
  return k && n && n.type !== "space" && n.type !== "newline" && n.type !== "comma" && (n.type !== "scalar" || n.source !== "") && a(n.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), b && (d && b.indent <= i || (n == null ? void 0 : n.type) === "block-map" || (n == null ? void 0 : n.type) === "block-seq") && a(b, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), {
    comma: O,
    found: R,
    spaceBefore: c,
    comment: g,
    hasNewline: S,
    anchor: x,
    tag: A,
    newlineAfterProp: _,
    end: j,
    start: C ?? j
  };
}
function Jd(e) {
  if (!e)
    return null;
  switch (e.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (e.source.includes(`
`))
        return !0;
      if (e.end) {
        for (const t of e.end)
          if (t.type === "newline")
            return !0;
      }
      return !1;
    case "flow-collection":
      for (const t of e.items) {
        for (const r of t.start)
          if (r.type === "newline")
            return !0;
        if (t.sep) {
          for (const r of t.sep)
            if (r.type === "newline")
              return !0;
        }
        if (Jd(t.key) || Jd(t.value))
          return !0;
      }
      return !1;
    default:
      return !0;
  }
}
function Qw(e, t, r) {
  if ((t == null ? void 0 : t.type) === "flow-collection") {
    const n = t.end[0];
    n.indent === e && (n.source === "]" || n.source === "}") && Jd(t) && r(n, "BAD_INDENT", "Flow end indicator should be more indented than parent", !0);
  }
}
function bP(e, t, r) {
  const { uniqueKeys: n } = e.options;
  if (n === !1)
    return !1;
  const o = typeof n == "function" ? n : (a, i) => a === i || Gt(a) && Gt(i) && a.value === i.value;
  return t.some((a) => o(a.key, r));
}
const S1 = "All mapping items must start at the same column";
function OI({ composeNode: e, composeEmptyNode: t }, r, n, o, a) {
  var m;
  const i = (a == null ? void 0 : a.nodeClass) ?? Zn, u = new i(r.schema);
  r.atRoot && (r.atRoot = !1);
  let c = n.offset, d = null;
  for (const g of n.items) {
    const { start: v, key: S, sep: k, value: b } = g, x = _p(v, {
      indicator: "explicit-key-ind",
      next: S ?? (k == null ? void 0 : k[0]),
      offset: c,
      onError: o,
      parentIndent: n.indent,
      startOnNewline: !0
    }), A = !x.found;
    if (A) {
      if (S && (S.type === "block-seq" ? o(c, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key") : "indent" in S && S.indent !== n.indent && o(c, "BAD_INDENT", S1)), !x.anchor && !x.tag && !k) {
        d = x.end, x.comment && (u.comment ? u.comment += `
` + x.comment : u.comment = x.comment);
        continue;
      }
      (x.newlineAfterProp || Jd(S)) && o(S ?? v[v.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
    } else ((m = x.found) == null ? void 0 : m.indent) !== n.indent && o(c, "BAD_INDENT", S1);
    r.atKey = !0;
    const _ = x.end, O = S ? e(r, S, x, o) : t(r, _, v, null, x, o);
    r.schema.compat && Qw(n.indent, S, o), r.atKey = !1, bP(r, u.items, O) && o(_, "DUPLICATE_KEY", "Map keys must be unique");
    const R = _p(k ?? [], {
      indicator: "map-value-ind",
      next: b,
      offset: O.range[2],
      onError: o,
      parentIndent: n.indent,
      startOnNewline: !S || S.type === "block-scalar"
    });
    if (c = R.end, R.found) {
      A && ((b == null ? void 0 : b.type) === "block-map" && !R.hasNewline && o(c, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings"), r.options.strict && x.start < R.found.offset - 1024 && o(O.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));
      const C = b ? e(r, b, R, o) : t(r, c, k, null, R, o);
      r.schema.compat && Qw(n.indent, b, o), c = C.range[2];
      const T = new an(O, C);
      r.options.keepSourceTokens && (T.srcToken = g), u.items.push(T);
    } else {
      A && o(O.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values"), R.comment && (O.comment ? O.comment += `
` + R.comment : O.comment = R.comment);
      const C = new an(O);
      r.options.keepSourceTokens && (C.srcToken = g), u.items.push(C);
    }
  }
  return d && d < c && o(d, "IMPOSSIBLE", "Map comment with trailing content"), u.range = [n.offset, c, d ?? c], u;
}
function kI({ composeNode: e, composeEmptyNode: t }, r, n, o, a) {
  const i = (a == null ? void 0 : a.nodeClass) ?? pa, u = new i(r.schema);
  r.atRoot && (r.atRoot = !1), r.atKey && (r.atKey = !1);
  let c = n.offset, d = null;
  for (const { start: m, value: g } of n.items) {
    const v = _p(m, {
      indicator: "seq-item-ind",
      next: g,
      offset: c,
      onError: o,
      parentIndent: n.indent,
      startOnNewline: !0
    });
    if (!v.found)
      if (v.anchor || v.tag || g)
        g && g.type === "block-seq" ? o(v.end, "BAD_INDENT", "All sequence items must start at the same column") : o(c, "MISSING_CHAR", "Sequence item without - indicator");
      else {
        d = v.end, v.comment && (u.comment = v.comment);
        continue;
      }
    const S = g ? e(r, g, v, o) : t(r, v.end, m, null, v, o);
    r.schema.compat && Qw(n.indent, g, o), c = S.range[2], u.items.push(S);
  }
  return u.range = [n.offset, c, d ?? c], u;
}
function gh(e, t, r, n) {
  let o = "";
  if (e) {
    let a = !1, i = "";
    for (const u of e) {
      const { source: c, type: d } = u;
      switch (d) {
        case "space":
          a = !0;
          break;
        case "comment": {
          r && !a && n(u, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const m = c.substring(1) || " ";
          o ? o += i + m : o = m, i = "";
          break;
        }
        case "newline":
          o && (i += c), a = !0;
          break;
        default:
          n(u, "UNEXPECTED_TOKEN", `Unexpected ${d} at node end`);
      }
      t += c.length;
    }
  }
  return { comment: o, offset: t };
}
const a0 = "Block collections are not allowed within flow collections", l0 = (e) => e && (e.type === "block-map" || e.type === "block-seq");
function AI({ composeNode: e, composeEmptyNode: t }, r, n, o, a) {
  const i = n.start.source === "{", u = i ? "flow map" : "flow sequence", c = (a == null ? void 0 : a.nodeClass) ?? (i ? Zn : pa), d = new c(r.schema);
  d.flow = !0;
  const m = r.atRoot;
  m && (r.atRoot = !1), r.atKey && (r.atKey = !1);
  let g = n.offset + n.start.source.length;
  for (let x = 0; x < n.items.length; ++x) {
    const A = n.items[x], { start: _, key: O, sep: R, value: C } = A, T = _p(_, {
      flow: u,
      indicator: "explicit-key-ind",
      next: O ?? (R == null ? void 0 : R[0]),
      offset: g,
      onError: o,
      parentIndent: n.indent,
      startOnNewline: !1
    });
    if (!T.found) {
      if (!T.anchor && !T.tag && !R && !C) {
        x === 0 && T.comma ? o(T.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${u}`) : x < n.items.length - 1 && o(T.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${u}`), T.comment && (d.comment ? d.comment += `
` + T.comment : d.comment = T.comment), g = T.end;
        continue;
      }
      !i && r.options.strict && Jd(O) && o(
        O,
        // checked by containsNewline()
        "MULTILINE_IMPLICIT_KEY",
        "Implicit keys of flow sequence pairs need to be on a single line"
      );
    }
    if (x === 0)
      T.comma && o(T.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${u}`);
    else if (T.comma || o(T.start, "MISSING_CHAR", `Missing , between ${u} items`), T.comment) {
      let j = "";
      e: for (const D of _)
        switch (D.type) {
          case "comma":
          case "space":
            break;
          case "comment":
            j = D.source.substring(1);
            break e;
          default:
            break e;
        }
      if (j) {
        let D = d.items[d.items.length - 1];
        ur(D) && (D = D.value ?? D.key), D.comment ? D.comment += `
` + j : D.comment = j, T.comment = T.comment.substring(j.length + 1);
      }
    }
    if (!i && !R && !T.found) {
      const j = C ? e(r, C, T, o) : t(r, T.end, R, null, T, o);
      d.items.push(j), g = j.range[2], l0(C) && o(j.range, "BLOCK_IN_FLOW", a0);
    } else {
      r.atKey = !0;
      const j = T.end, D = O ? e(r, O, T, o) : t(r, j, _, null, T, o);
      l0(O) && o(D.range, "BLOCK_IN_FLOW", a0), r.atKey = !1;
      const V = _p(R ?? [], {
        flow: u,
        indicator: "map-value-ind",
        next: C,
        offset: D.range[2],
        onError: o,
        parentIndent: n.indent,
        startOnNewline: !1
      });
      if (V.found) {
        if (!i && !T.found && r.options.strict) {
          if (R)
            for (const H of R) {
              if (H === V.found)
                break;
              if (H.type === "newline") {
                o(H, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          T.start < V.found.offset - 1024 && o(V.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else C && ("source" in C && C.source && C.source[0] === ":" ? o(C, "MISSING_CHAR", `Missing space after : in ${u}`) : o(V.start, "MISSING_CHAR", `Missing , or : between ${u} items`));
      const U = C ? e(r, C, V, o) : V.found ? t(r, V.end, R, null, V, o) : null;
      U ? l0(C) && o(U.range, "BLOCK_IN_FLOW", a0) : V.comment && (D.comment ? D.comment += `
` + V.comment : D.comment = V.comment);
      const ne = new an(D, U);
      if (r.options.keepSourceTokens && (ne.srcToken = A), i) {
        const H = d;
        bP(r, H.items, D) && o(j, "DUPLICATE_KEY", "Map keys must be unique"), H.items.push(ne);
      } else {
        const H = new Zn(r.schema);
        H.flow = !0, H.items.push(ne);
        const ae = (U ?? D).range;
        H.range = [D.range[0], ae[1], ae[2]], d.items.push(H);
      }
      g = U ? U.range[2] : V.end;
    }
  }
  const v = i ? "}" : "]", [S, ...k] = n.end;
  let b = g;
  if (S && S.source === v)
    b = S.offset + S.source.length;
  else {
    const x = u[0].toUpperCase() + u.substring(1), A = m ? `${x} must end with a ${v}` : `${x} in block collection must be sufficiently indented and end with a ${v}`;
    o(g, m ? "MISSING_CHAR" : "BAD_INDENT", A), S && S.source.length !== 1 && k.unshift(S);
  }
  if (k.length > 0) {
    const x = gh(k, b, r.options.strict, o);
    x.comment && (d.comment ? d.comment += `
` + x.comment : d.comment = x.comment), d.range = [n.offset, b, x.offset];
  } else
    d.range = [n.offset, b, b];
  return d;
}
function u0(e, t, r, n, o, a) {
  const i = r.type === "block-map" ? OI(e, t, r, n, a) : r.type === "block-seq" ? kI(e, t, r, n, a) : AI(e, t, r, n, a), u = i.constructor;
  return o === "!" || o === u.tagName ? (i.tag = u.tagName, i) : (o && (i.tag = o), i);
}
function PI(e, t, r, n, o) {
  var v;
  const a = n.tag, i = a ? t.directives.tagName(a.source, (S) => o(a, "TAG_RESOLVE_FAILED", S)) : null;
  if (r.type === "block-seq") {
    const { anchor: S, newlineAfterProp: k } = n, b = S && a ? S.offset > a.offset ? S : a : S ?? a;
    b && (!k || k.offset < b.offset) && o(b, "MISSING_CHAR", "Missing newline after block sequence props");
  }
  const u = r.type === "block-map" ? "map" : r.type === "block-seq" ? "seq" : r.start.source === "{" ? "map" : "seq";
  if (!a || !i || i === "!" || i === Zn.tagName && u === "map" || i === pa.tagName && u === "seq")
    return u0(e, t, r, o, i);
  let c = t.schema.tags.find((S) => S.tag === i && S.collection === u);
  if (!c) {
    const S = t.schema.knownTags[i];
    if (S && S.collection === u)
      t.schema.tags.push(Object.assign({}, S, { default: !1 })), c = S;
    else
      return S ? o(a, "BAD_COLLECTION_TYPE", `${S.tag} used for ${u} collection, but expects ${S.collection ?? "scalar"}`, !0) : o(a, "TAG_RESOLVE_FAILED", `Unresolved tag: ${i}`, !0), u0(e, t, r, o, i);
  }
  const d = u0(e, t, r, o, i, c), m = ((v = c.resolve) == null ? void 0 : v.call(c, d, (S) => o(a, "TAG_RESOLVE_FAILED", S), t.options)) ?? d, g = hr(m) ? m : new Ot(m);
  return g.range = d.range, g.tag = i, c != null && c.format && (g.format = c.format), g;
}
function wP(e, t, r) {
  const n = t.offset, o = TI(t, e.options.strict, r);
  if (!o)
    return { value: "", type: null, comment: "", range: [n, n, n] };
  const a = o.mode === ">" ? Ot.BLOCK_FOLDED : Ot.BLOCK_LITERAL, i = t.source ? CI(t.source) : [];
  let u = i.length;
  for (let b = i.length - 1; b >= 0; --b) {
    const x = i[b][1];
    if (x === "" || x === "\r")
      u = b;
    else
      break;
  }
  if (u === 0) {
    const b = o.chomp === "+" && i.length > 0 ? `
`.repeat(Math.max(1, i.length - 1)) : "";
    let x = n + o.length;
    return t.source && (x += t.source.length), { value: b, type: a, comment: o.comment, range: [n, x, x] };
  }
  let c = t.indent + o.indent, d = t.offset + o.length, m = 0;
  for (let b = 0; b < u; ++b) {
    const [x, A] = i[b];
    if (A === "" || A === "\r")
      o.indent === 0 && x.length > c && (c = x.length);
    else {
      x.length < c && r(d + x.length, "MISSING_CHAR", "Block scalars with more-indented leading empty lines must use an explicit indentation indicator"), o.indent === 0 && (c = x.length), m = b, c === 0 && !e.atRoot && r(d, "BAD_INDENT", "Block scalar values in collections must be indented");
      break;
    }
    d += x.length + A.length + 1;
  }
  for (let b = i.length - 1; b >= u; --b)
    i[b][0].length > c && (u = b + 1);
  let g = "", v = "", S = !1;
  for (let b = 0; b < m; ++b)
    g += i[b][0].slice(c) + `
`;
  for (let b = m; b < u; ++b) {
    let [x, A] = i[b];
    d += x.length + A.length + 1;
    const _ = A[A.length - 1] === "\r";
    if (_ && (A = A.slice(0, -1)), A && x.length < c) {
      const R = `Block scalar lines must not be less indented than their ${o.indent ? "explicit indentation indicator" : "first line"}`;
      r(d - A.length - (_ ? 2 : 1), "BAD_INDENT", R), x = "";
    }
    a === Ot.BLOCK_LITERAL ? (g += v + x.slice(c) + A, v = `
`) : x.length > c || A[0] === "	" ? (v === " " ? v = `
` : !S && v === `
` && (v = `

`), g += v + x.slice(c) + A, v = `
`, S = !0) : A === "" ? v === `
` ? g += `
` : v = `
` : (g += v + A, v = " ", S = !1);
  }
  switch (o.chomp) {
    case "-":
      break;
    case "+":
      for (let b = u; b < i.length; ++b)
        g += `
` + i[b][0].slice(c);
      g[g.length - 1] !== `
` && (g += `
`);
      break;
    default:
      g += `
`;
  }
  const k = n + o.length + t.source.length;
  return { value: g, type: a, comment: o.comment, range: [n, k, k] };
}
function TI({ offset: e, props: t }, r, n) {
  if (t[0].type !== "block-scalar-header")
    return n(t[0], "IMPOSSIBLE", "Block scalar header not found"), null;
  const { source: o } = t[0], a = o[0];
  let i = 0, u = "", c = -1;
  for (let v = 1; v < o.length; ++v) {
    const S = o[v];
    if (!u && (S === "-" || S === "+"))
      u = S;
    else {
      const k = Number(S);
      !i && k ? i = k : c === -1 && (c = e + v);
    }
  }
  c !== -1 && n(c, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${o}`);
  let d = !1, m = "", g = o.length;
  for (let v = 1; v < t.length; ++v) {
    const S = t[v];
    switch (S.type) {
      case "space":
        d = !0;
      // fallthrough
      case "newline":
        g += S.source.length;
        break;
      case "comment":
        r && !d && n(S, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters"), g += S.source.length, m = S.source.substring(1);
        break;
      case "error":
        n(S, "UNEXPECTED_TOKEN", S.message), g += S.source.length;
        break;
      /* istanbul ignore next should not happen */
      default: {
        const k = `Unexpected token in block scalar header: ${S.type}`;
        n(S, "UNEXPECTED_TOKEN", k);
        const b = S.source;
        b && typeof b == "string" && (g += b.length);
      }
    }
  }
  return { mode: a, indent: i, chomp: u, comment: m, length: g };
}
function CI(e) {
  const t = e.split(/\n( *)/), r = t[0], n = r.match(/^( *)/), a = [n != null && n[1] ? [n[1], r.slice(n[1].length)] : ["", r]];
  for (let i = 1; i < t.length; i += 2)
    a.push([t[i], t[i + 1]]);
  return a;
}
function SP(e, t, r) {
  const { offset: n, type: o, source: a, end: i } = e;
  let u, c;
  const d = (v, S, k) => r(n + v, S, k);
  switch (o) {
    case "scalar":
      u = Ot.PLAIN, c = $I(a, d);
      break;
    case "single-quoted-scalar":
      u = Ot.QUOTE_SINGLE, c = RI(a, d);
      break;
    case "double-quoted-scalar":
      u = Ot.QUOTE_DOUBLE, c = II(a, d);
      break;
    /* istanbul ignore next should not happen */
    default:
      return r(e, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${o}`), {
        value: "",
        type: null,
        comment: "",
        range: [n, n + a.length, n + a.length]
      };
  }
  const m = n + a.length, g = gh(i, m, t, r);
  return {
    value: c,
    type: u,
    comment: g.comment,
    range: [n, m, g.offset]
  };
}
function $I(e, t) {
  let r = "";
  switch (e[0]) {
    /* istanbul ignore next should not happen */
    case "	":
      r = "a tab character";
      break;
    case ",":
      r = "flow indicator character ,";
      break;
    case "%":
      r = "directive indicator character %";
      break;
    case "|":
    case ">": {
      r = `block scalar indicator ${e[0]}`;
      break;
    }
    case "@":
    case "`": {
      r = `reserved character ${e[0]}`;
      break;
    }
  }
  return r && t(0, "BAD_SCALAR_START", `Plain value cannot start with ${r}`), xP(e);
}
function RI(e, t) {
  return (e[e.length - 1] !== "'" || e.length === 1) && t(e.length, "MISSING_CHAR", "Missing closing 'quote"), xP(e.slice(1, -1)).replace(/''/g, "'");
}
function xP(e) {
  let t, r;
  try {
    t = new RegExp(`(.*?)(?<![ 	])[ 	]*\r?
`, "sy"), r = new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?
`, "sy");
  } catch {
    t = /(.*?)[ \t]*\r?\n/sy, r = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let n = t.exec(e);
  if (!n)
    return e;
  let o = n[1], a = " ", i = t.lastIndex;
  for (r.lastIndex = i; n = r.exec(e); )
    n[1] === "" ? a === `
` ? o += a : a = `
` : (o += a + n[1], a = " "), i = r.lastIndex;
  const u = /[ \t]*(.*)/sy;
  return u.lastIndex = i, n = u.exec(e), o + a + ((n == null ? void 0 : n[1]) ?? "");
}
function II(e, t) {
  let r = "";
  for (let n = 1; n < e.length - 1; ++n) {
    const o = e[n];
    if (!(o === "\r" && e[n + 1] === `
`))
      if (o === `
`) {
        const { fold: a, offset: i } = NI(e, n);
        r += a, n = i;
      } else if (o === "\\") {
        let a = e[++n];
        const i = jI[a];
        if (i)
          r += i;
        else if (a === `
`)
          for (a = e[n + 1]; a === " " || a === "	"; )
            a = e[++n + 1];
        else if (a === "\r" && e[n + 1] === `
`)
          for (a = e[++n + 1]; a === " " || a === "	"; )
            a = e[++n + 1];
        else if (a === "x" || a === "u" || a === "U") {
          const u = { x: 2, u: 4, U: 8 }[a];
          r += LI(e, n + 1, u, t), n += u;
        } else {
          const u = e.substr(n - 1, 2);
          t(n - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${u}`), r += u;
        }
      } else if (o === " " || o === "	") {
        const a = n;
        let i = e[n + 1];
        for (; i === " " || i === "	"; )
          i = e[++n + 1];
        i !== `
` && !(i === "\r" && e[n + 2] === `
`) && (r += n > a ? e.slice(a, n + 1) : o);
      } else
        r += o;
  }
  return (e[e.length - 1] !== '"' || e.length === 1) && t(e.length, "MISSING_CHAR", 'Missing closing "quote'), r;
}
function NI(e, t) {
  let r = "", n = e[t + 1];
  for (; (n === " " || n === "	" || n === `
` || n === "\r") && !(n === "\r" && e[t + 2] !== `
`); )
    n === `
` && (r += `
`), t += 1, n = e[t + 1];
  return r || (r = " "), { fold: r, offset: t };
}
const jI = {
  0: "\0",
  // null character
  a: "\x07",
  // bell character
  b: "\b",
  // backspace
  e: "\x1B",
  // escape character
  f: "\f",
  // form feed
  n: `
`,
  // line feed
  r: "\r",
  // carriage return
  t: "	",
  // horizontal tab
  v: "\v",
  // vertical tab
  N: "",
  // Unicode next line
  _: " ",
  // Unicode non-breaking space
  L: "\u2028",
  // Unicode line separator
  P: "\u2029",
  // Unicode paragraph separator
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function LI(e, t, r, n) {
  const o = e.substr(t, r), i = o.length === r && /^[0-9a-fA-F]+$/.test(o) ? parseInt(o, 16) : NaN;
  if (isNaN(i)) {
    const u = e.substr(t - 2, r + 2);
    return n(t - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${u}`), u;
  }
  return String.fromCodePoint(i);
}
function _P(e, t, r, n) {
  const { value: o, type: a, comment: i, range: u } = t.type === "block-scalar" ? wP(e, t, n) : SP(t, e.options.strict, n), c = r ? e.directives.tagName(r.source, (g) => n(r, "TAG_RESOLVE_FAILED", g)) : null;
  let d;
  e.options.stringKeys && e.atKey ? d = e.schema[So] : c ? d = MI(e.schema, o, c, r, n) : t.type === "scalar" ? d = DI(e, o, t, n) : d = e.schema[So];
  let m;
  try {
    const g = d.resolve(o, (v) => n(r ?? t, "TAG_RESOLVE_FAILED", v), e.options);
    m = Gt(g) ? g : new Ot(g);
  } catch (g) {
    const v = g instanceof Error ? g.message : String(g);
    n(r ?? t, "TAG_RESOLVE_FAILED", v), m = new Ot(o);
  }
  return m.range = u, m.source = o, a && (m.type = a), c && (m.tag = c), d.format && (m.format = d.format), i && (m.comment = i), m;
}
function MI(e, t, r, n, o) {
  var u;
  if (r === "!")
    return e[So];
  const a = [];
  for (const c of e.tags)
    if (!c.collection && c.tag === r)
      if (c.default && c.test)
        a.push(c);
      else
        return c;
  for (const c of a)
    if ((u = c.test) != null && u.test(t))
      return c;
  const i = e.knownTags[r];
  return i && !i.collection ? (e.tags.push(Object.assign({}, i, { default: !1, test: void 0 })), i) : (o(n, "TAG_RESOLVE_FAILED", `Unresolved tag: ${r}`, r !== "tag:yaml.org,2002:str"), e[So]);
}
function DI({ atKey: e, directives: t, schema: r }, n, o, a) {
  const i = r.tags.find((u) => {
    var c;
    return (u.default === !0 || e && u.default === "key") && ((c = u.test) == null ? void 0 : c.test(n));
  }) || r[So];
  if (r.compat) {
    const u = r.compat.find((c) => {
      var d;
      return c.default && ((d = c.test) == null ? void 0 : d.test(n));
    }) ?? r[So];
    if (i.tag !== u.tag) {
      const c = t.tagString(i.tag), d = t.tagString(u.tag), m = `Value may be parsed as either ${c} or ${d}`;
      a(o, "TAG_RESOLVE_FAILED", m, !0);
    }
  }
  return i;
}
function FI(e, t, r) {
  if (t) {
    r === null && (r = t.length);
    for (let n = r - 1; n >= 0; --n) {
      let o = t[n];
      switch (o.type) {
        case "space":
        case "comment":
        case "newline":
          e -= o.source.length;
          continue;
      }
      for (o = t[++n]; (o == null ? void 0 : o.type) === "space"; )
        e += o.source.length, o = t[++n];
      break;
    }
  }
  return e;
}
const qI = { composeNode: EP, composeEmptyNode: KS };
function EP(e, t, r, n) {
  const o = e.atKey, { spaceBefore: a, comment: i, anchor: u, tag: c } = r;
  let d, m = !0;
  switch (t.type) {
    case "alias":
      d = zI(e, t, n), (u || c) && n(t, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      d = _P(e, t, c, n), u && (d.anchor = u.source.substring(1));
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      d = PI(qI, e, t, r, n), u && (d.anchor = u.source.substring(1));
      break;
    default: {
      const g = t.type === "error" ? t.message : `Unsupported token (type: ${t.type})`;
      n(t, "UNEXPECTED_TOKEN", g), d = KS(e, t.offset, void 0, null, r, n), m = !1;
    }
  }
  return u && d.anchor === "" && n(u, "BAD_ALIAS", "Anchor cannot be an empty string"), o && e.options.stringKeys && (!Gt(d) || typeof d.value != "string" || d.tag && d.tag !== "tag:yaml.org,2002:str") && n(c ?? t, "NON_STRING_KEY", "With stringKeys, all keys must be strings"), a && (d.spaceBefore = !0), i && (t.type === "scalar" && t.source === "" ? d.comment = i : d.commentBefore = i), e.options.keepSourceTokens && m && (d.srcToken = t), d;
}
function KS(e, t, r, n, { spaceBefore: o, comment: a, anchor: i, tag: u, end: c }, d) {
  const m = {
    type: "scalar",
    offset: FI(t, r, n),
    indent: -1,
    source: ""
  }, g = _P(e, m, u, d);
  return i && (g.anchor = i.source.substring(1), g.anchor === "" && d(i, "BAD_ALIAS", "Anchor cannot be an empty string")), o && (g.spaceBefore = !0), a && (g.comment = a, g.range[2] = c), g;
}
function zI({ options: e }, { offset: t, source: r, end: n }, o) {
  const a = new fh(r.substring(1));
  a.source === "" && o(t, "BAD_ALIAS", "Alias cannot be an empty string"), a.source.endsWith(":") && o(t + r.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", !0);
  const i = t + r.length, u = gh(n, i, e.strict, o);
  return a.range = [t, i, u.offset], u.comment && (a.comment = u.comment), a;
}
function BI(e, t, { offset: r, start: n, value: o, end: a }, i) {
  const u = Object.assign({ _directives: t }, e), c = new Bu(void 0, u), d = {
    atKey: !1,
    atRoot: !0,
    directives: c.directives,
    options: c.options,
    schema: c.schema
  }, m = _p(n, {
    indicator: "doc-start",
    next: o ?? (a == null ? void 0 : a[0]),
    offset: r,
    onError: i,
    parentIndent: 0,
    startOnNewline: !0
  });
  m.found && (c.directives.docStart = !0, o && (o.type === "block-map" || o.type === "block-seq") && !m.hasNewline && i(m.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker")), c.contents = o ? EP(d, o, m, i) : KS(d, m.end, n, null, m, i);
  const g = c.contents.range[2], v = gh(a, g, !1, i);
  return v.comment && (c.comment = v.comment), c.range = [r, g, v.offset], c;
}
function _d(e) {
  if (typeof e == "number")
    return [e, e + 1];
  if (Array.isArray(e))
    return e.length === 2 ? e : [e[0], e[1]];
  const { offset: t, source: r } = e;
  return [t, t + (typeof r == "string" ? r.length : 1)];
}
function x1(e) {
  var o;
  let t = "", r = !1, n = !1;
  for (let a = 0; a < e.length; ++a) {
    const i = e[a];
    switch (i[0]) {
      case "#":
        t += (t === "" ? "" : n ? `

` : `
`) + (i.substring(1) || " "), r = !0, n = !1;
        break;
      case "%":
        ((o = e[a + 1]) == null ? void 0 : o[0]) !== "#" && (a += 1), r = !1;
        break;
      default:
        r || (n = !0), r = !1;
    }
  }
  return { comment: t, afterEmptyLine: n };
}
class jv {
  constructor(t = {}) {
    this.doc = null, this.atDirectives = !1, this.prelude = [], this.errors = [], this.warnings = [], this.onError = (r, n, o, a) => {
      const i = _d(r);
      a ? this.warnings.push(new WS(i, n, o)) : this.errors.push(new sl(i, n, o));
    }, this.directives = new Cn({ version: t.version || "1.2" }), this.options = t;
  }
  decorate(t, r) {
    const { comment: n, afterEmptyLine: o } = x1(this.prelude);
    if (n) {
      const a = t.contents;
      if (r)
        t.comment = t.comment ? `${t.comment}
${n}` : n;
      else if (o || t.directives.docStart || !a)
        t.commentBefore = n;
      else if (dr(a) && !a.flow && a.items.length > 0) {
        let i = a.items[0];
        ur(i) && (i = i.key);
        const u = i.commentBefore;
        i.commentBefore = u ? `${n}
${u}` : n;
      } else {
        const i = a.commentBefore;
        a.commentBefore = i ? `${n}
${i}` : n;
      }
    }
    r ? (Array.prototype.push.apply(t.errors, this.errors), Array.prototype.push.apply(t.warnings, this.warnings)) : (t.errors = this.errors, t.warnings = this.warnings), this.prelude = [], this.errors = [], this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: x1(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(t, r = !1, n = -1) {
    for (const o of t)
      yield* this.next(o);
    yield* this.end(r, n);
  }
  /** Advance the composer by one CST token. */
  *next(t) {
    switch (t.type) {
      case "directive":
        this.directives.add(t.source, (r, n, o) => {
          const a = _d(t);
          a[0] += r, this.onError(a, "BAD_DIRECTIVE", n, o);
        }), this.prelude.push(t.source), this.atDirectives = !0;
        break;
      case "document": {
        const r = BI(this.options, this.directives, t, this.onError);
        this.atDirectives && !r.directives.docStart && this.onError(t, "MISSING_CHAR", "Missing directives-end/doc-start indicator line"), this.decorate(r, !1), this.doc && (yield this.doc), this.doc = r, this.atDirectives = !1;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(t.source);
        break;
      case "error": {
        const r = t.source ? `${t.message}: ${JSON.stringify(t.source)}` : t.message, n = new sl(_d(t), "UNEXPECTED_TOKEN", r);
        this.atDirectives || !this.doc ? this.errors.push(n) : this.doc.errors.push(n);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const n = "Unexpected doc-end without preceding document";
          this.errors.push(new sl(_d(t), "UNEXPECTED_TOKEN", n));
          break;
        }
        this.doc.directives.docEnd = !0;
        const r = gh(t.end, t.offset + t.source.length, this.doc.options.strict, this.onError);
        if (this.decorate(this.doc, !0), r.comment) {
          const n = this.doc.comment;
          this.doc.comment = n ? `${n}
${r.comment}` : r.comment;
        }
        this.doc.range[2] = r.offset;
        break;
      }
      default:
        this.errors.push(new sl(_d(t), "UNEXPECTED_TOKEN", `Unsupported token ${t.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(t = !1, r = -1) {
    if (this.doc)
      this.decorate(this.doc, !0), yield this.doc, this.doc = null;
    else if (t) {
      const n = Object.assign({ _directives: this.directives }, this.options), o = new Bu(void 0, n);
      this.atDirectives && this.onError(r, "MISSING_CHAR", "Missing directives-end indicator line"), o.range = [0, r, r], this.decorate(o, !1), yield o;
    }
  }
}
function UI(e, t = !0, r) {
  if (e) {
    const n = (o, a, i) => {
      const u = typeof o == "number" ? o : Array.isArray(o) ? o[0] : o.offset;
      if (r)
        r(u, a, i);
      else
        throw new sl([u, u + 1], a, i);
    };
    switch (e.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return SP(e, t, n);
      case "block-scalar":
        return wP({ options: { strict: t } }, e, n);
    }
  }
  return null;
}
function VI(e, t) {
  const { implicitKey: r = !1, indent: n, inFlow: o = !1, offset: a = -1, type: i = "PLAIN" } = t, u = dh({ type: i, value: e }, {
    implicitKey: r,
    indent: n > 0 ? " ".repeat(n) : "",
    inFlow: o,
    options: { blockQuote: !0, lineWidth: -1 }
  }), c = t.end ?? [
    { type: "newline", offset: -1, indent: n, source: `
` }
  ];
  switch (u[0]) {
    case "|":
    case ">": {
      const d = u.indexOf(`
`), m = u.substring(0, d), g = u.substring(d + 1) + `
`, v = [
        { type: "block-scalar-header", offset: a, indent: n, source: m }
      ];
      return OP(v, c) || v.push({ type: "newline", offset: -1, indent: n, source: `
` }), { type: "block-scalar", offset: a, indent: n, props: v, source: g };
    }
    case '"':
      return { type: "double-quoted-scalar", offset: a, indent: n, source: u, end: c };
    case "'":
      return { type: "single-quoted-scalar", offset: a, indent: n, source: u, end: c };
    default:
      return { type: "scalar", offset: a, indent: n, source: u, end: c };
  }
}
function HI(e, t, r = {}) {
  let { afterKey: n = !1, implicitKey: o = !1, inFlow: a = !1, type: i } = r, u = "indent" in e ? e.indent : null;
  if (n && typeof u == "number" && (u += 2), !i)
    switch (e.type) {
      case "single-quoted-scalar":
        i = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        i = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const d = e.props[0];
        if (d.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        i = d.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        i = "PLAIN";
    }
  const c = dh({ type: i, value: t }, {
    implicitKey: o || u === null,
    indent: u !== null && u > 0 ? " ".repeat(u) : "",
    inFlow: a,
    options: { blockQuote: !0, lineWidth: -1 }
  });
  switch (c[0]) {
    case "|":
    case ">":
      WI(e, c);
      break;
    case '"':
      c0(e, c, "double-quoted-scalar");
      break;
    case "'":
      c0(e, c, "single-quoted-scalar");
      break;
    default:
      c0(e, c, "scalar");
  }
}
function WI(e, t) {
  const r = t.indexOf(`
`), n = t.substring(0, r), o = t.substring(r + 1) + `
`;
  if (e.type === "block-scalar") {
    const a = e.props[0];
    if (a.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    a.source = n, e.source = o;
  } else {
    const { offset: a } = e, i = "indent" in e ? e.indent : -1, u = [
      { type: "block-scalar-header", offset: a, indent: i, source: n }
    ];
    OP(u, "end" in e ? e.end : void 0) || u.push({ type: "newline", offset: -1, indent: i, source: `
` });
    for (const c of Object.keys(e))
      c !== "type" && c !== "offset" && delete e[c];
    Object.assign(e, { type: "block-scalar", indent: i, props: u, source: o });
  }
}
function OP(e, t) {
  if (t)
    for (const r of t)
      switch (r.type) {
        case "space":
        case "comment":
          e.push(r);
          break;
        case "newline":
          return e.push(r), !0;
      }
  return !1;
}
function c0(e, t, r) {
  switch (e.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      e.type = r, e.source = t;
      break;
    case "block-scalar": {
      const n = e.props.slice(1);
      let o = t.length;
      e.props[0].type === "block-scalar-header" && (o -= e.props[0].source.length);
      for (const a of n)
        a.offset += o;
      delete e.props, Object.assign(e, { type: r, source: t, end: n });
      break;
    }
    case "block-map":
    case "block-seq": {
      const o = { type: "newline", offset: e.offset + t.length, indent: e.indent, source: `
` };
      delete e.items, Object.assign(e, { type: r, source: t, end: [o] });
      break;
    }
    default: {
      const n = "indent" in e ? e.indent : -1, o = "end" in e && Array.isArray(e.end) ? e.end.filter((a) => a.type === "space" || a.type === "comment" || a.type === "newline") : [];
      for (const a of Object.keys(e))
        a !== "type" && a !== "offset" && delete e[a];
      Object.assign(e, { type: r, indent: n, source: t, end: o });
    }
  }
}
const KI = (e) => "type" in e ? Jy(e) : Iy(e);
function Jy(e) {
  switch (e.type) {
    case "block-scalar": {
      let t = "";
      for (const r of e.props)
        t += Jy(r);
      return t + e.source;
    }
    case "block-map":
    case "block-seq": {
      let t = "";
      for (const r of e.items)
        t += Iy(r);
      return t;
    }
    case "flow-collection": {
      let t = e.start.source;
      for (const r of e.items)
        t += Iy(r);
      for (const r of e.end)
        t += r.source;
      return t;
    }
    case "document": {
      let t = Iy(e);
      if (e.end)
        for (const r of e.end)
          t += r.source;
      return t;
    }
    default: {
      let t = e.source;
      if ("end" in e && e.end)
        for (const r of e.end)
          t += r.source;
      return t;
    }
  }
}
function Iy({ start: e, key: t, sep: r, value: n }) {
  let o = "";
  for (const a of e)
    o += a.source;
  if (t && (o += Jy(t)), r)
    for (const a of r)
      o += a.source;
  return n && (o += Jy(n)), o;
}
const Yw = Symbol("break visit"), QI = Symbol("skip children"), kP = Symbol("remove item");
function Ru(e, t) {
  "type" in e && e.type === "document" && (e = { start: e.start, value: e.value }), AP(Object.freeze([]), e, t);
}
Ru.BREAK = Yw;
Ru.SKIP = QI;
Ru.REMOVE = kP;
Ru.itemAtPath = (e, t) => {
  let r = e;
  for (const [n, o] of t) {
    const a = r == null ? void 0 : r[n];
    if (a && "items" in a)
      r = a.items[o];
    else
      return;
  }
  return r;
};
Ru.parentCollection = (e, t) => {
  const r = Ru.itemAtPath(e, t.slice(0, -1)), n = t[t.length - 1][0], o = r == null ? void 0 : r[n];
  if (o && "items" in o)
    return o;
  throw new Error("Parent collection not found");
};
function AP(e, t, r) {
  let n = r(t, e);
  if (typeof n == "symbol")
    return n;
  for (const o of ["key", "value"]) {
    const a = t[o];
    if (a && "items" in a) {
      for (let i = 0; i < a.items.length; ++i) {
        const u = AP(Object.freeze(e.concat([[o, i]])), a.items[i], r);
        if (typeof u == "number")
          i = u - 1;
        else {
          if (u === Yw)
            return Yw;
          u === kP && (a.items.splice(i, 1), i -= 1);
        }
      }
      typeof n == "function" && o === "key" && (n = n(t, e));
    }
  }
  return typeof n == "function" ? n(t, e) : n;
}
const Lv = "\uFEFF", Mv = "", Dv = "", Zd = "", YI = (e) => !!e && "items" in e, GI = (e) => !!e && (e.type === "scalar" || e.type === "single-quoted-scalar" || e.type === "double-quoted-scalar" || e.type === "block-scalar");
function XI(e) {
  switch (e) {
    case Lv:
      return "<BOM>";
    case Mv:
      return "<DOC>";
    case Dv:
      return "<FLOW_END>";
    case Zd:
      return "<SCALAR>";
    default:
      return JSON.stringify(e);
  }
}
function PP(e) {
  switch (e) {
    case Lv:
      return "byte-order-mark";
    case Mv:
      return "doc-mode";
    case Dv:
      return "flow-error-end";
    case Zd:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case `
`:
    case `\r
`:
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (e[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
const TP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BOM: Lv,
  DOCUMENT: Mv,
  FLOW_END: Dv,
  SCALAR: Zd,
  createScalarToken: VI,
  isCollection: YI,
  isScalar: GI,
  prettyToken: XI,
  resolveAsScalar: UI,
  setScalarValue: HI,
  stringify: KI,
  tokenType: PP,
  visit: Ru
}, Symbol.toStringTag, { value: "Module" }));
function bs(e) {
  switch (e) {
    case void 0:
    case " ":
    case `
`:
    case "\r":
    case "	":
      return !0;
    default:
      return !1;
  }
}
const _1 = new Set("0123456789ABCDEFabcdef"), JI = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()"), cg = new Set(",[]{}"), ZI = new Set(` ,[]{}
\r	`), p0 = (e) => !e || ZI.has(e);
class QS {
  constructor() {
    this.atEnd = !1, this.blockScalarIndent = -1, this.blockScalarKeep = !1, this.buffer = "", this.flowKey = !1, this.flowLevel = 0, this.indentNext = 0, this.indentValue = 0, this.lineEndPos = null, this.next = null, this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(t, r = !1) {
    if (t) {
      if (typeof t != "string")
        throw TypeError("source is not a string");
      this.buffer = this.buffer ? this.buffer + t : t, this.lineEndPos = null;
    }
    this.atEnd = !r;
    let n = this.next ?? "stream";
    for (; n && (r || this.hasChars(1)); )
      n = yield* this.parseNext(n);
  }
  atLineEnd() {
    let t = this.pos, r = this.buffer[t];
    for (; r === " " || r === "	"; )
      r = this.buffer[++t];
    return !r || r === "#" || r === `
` ? !0 : r === "\r" ? this.buffer[t + 1] === `
` : !1;
  }
  charAt(t) {
    return this.buffer[this.pos + t];
  }
  continueScalar(t) {
    let r = this.buffer[t];
    if (this.indentNext > 0) {
      let n = 0;
      for (; r === " "; )
        r = this.buffer[++n + t];
      if (r === "\r") {
        const o = this.buffer[n + t + 1];
        if (o === `
` || !o && !this.atEnd)
          return t + n + 1;
      }
      return r === `
` || n >= this.indentNext || !r && !this.atEnd ? t + n : -1;
    }
    if (r === "-" || r === ".") {
      const n = this.buffer.substr(t, 3);
      if ((n === "---" || n === "...") && bs(this.buffer[t + 3]))
        return -1;
    }
    return t;
  }
  getLine() {
    let t = this.lineEndPos;
    return (typeof t != "number" || t !== -1 && t < this.pos) && (t = this.buffer.indexOf(`
`, this.pos), this.lineEndPos = t), t === -1 ? this.atEnd ? this.buffer.substring(this.pos) : null : (this.buffer[t - 1] === "\r" && (t -= 1), this.buffer.substring(this.pos, t));
  }
  hasChars(t) {
    return this.pos + t <= this.buffer.length;
  }
  setNext(t) {
    return this.buffer = this.buffer.substring(this.pos), this.pos = 0, this.lineEndPos = null, this.next = t, null;
  }
  peek(t) {
    return this.buffer.substr(this.pos, t);
  }
  *parseNext(t) {
    switch (t) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let t = this.getLine();
    if (t === null)
      return this.setNext("stream");
    if (t[0] === Lv && (yield* this.pushCount(1), t = t.substring(1)), t[0] === "%") {
      let r = t.length, n = t.indexOf("#");
      for (; n !== -1; ) {
        const a = t[n - 1];
        if (a === " " || a === "	") {
          r = n - 1;
          break;
        } else
          n = t.indexOf("#", n + 1);
      }
      for (; ; ) {
        const a = t[r - 1];
        if (a === " " || a === "	")
          r -= 1;
        else
          break;
      }
      const o = (yield* this.pushCount(r)) + (yield* this.pushSpaces(!0));
      return yield* this.pushCount(t.length - o), this.pushNewline(), "stream";
    }
    if (this.atLineEnd()) {
      const r = yield* this.pushSpaces(!0);
      return yield* this.pushCount(t.length - r), yield* this.pushNewline(), "stream";
    }
    return yield Mv, yield* this.parseLineStart();
  }
  *parseLineStart() {
    const t = this.charAt(0);
    if (!t && !this.atEnd)
      return this.setNext("line-start");
    if (t === "-" || t === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const r = this.peek(3);
      if ((r === "---" || r === "...") && bs(this.charAt(3)))
        return yield* this.pushCount(3), this.indentValue = 0, this.indentNext = 0, r === "---" ? "doc" : "stream";
    }
    return this.indentValue = yield* this.pushSpaces(!1), this.indentNext > this.indentValue && !bs(this.charAt(1)) && (this.indentNext = this.indentValue), yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [t, r] = this.peek(2);
    if (!r && !this.atEnd)
      return this.setNext("block-start");
    if ((t === "-" || t === "?" || t === ":") && bs(r)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0));
      return this.indentNext = this.indentValue + 1, this.indentValue += n, yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(!0);
    const t = this.getLine();
    if (t === null)
      return this.setNext("doc");
    let r = yield* this.pushIndicators();
    switch (t[r]) {
      case "#":
        yield* this.pushCount(t.length - r);
      // fallthrough
      case void 0:
        return yield* this.pushNewline(), yield* this.parseLineStart();
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel = 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), "doc";
      case "*":
        return yield* this.pushUntil(p0), "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        return r += yield* this.parseBlockScalarHeader(), r += yield* this.pushSpaces(!0), yield* this.pushCount(t.length - r), yield* this.pushNewline(), yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let t, r, n = -1;
    do
      t = yield* this.pushNewline(), t > 0 ? (r = yield* this.pushSpaces(!1), this.indentValue = n = r) : r = 0, r += yield* this.pushSpaces(!0);
    while (t + r > 0);
    const o = this.getLine();
    if (o === null)
      return this.setNext("flow");
    if ((n !== -1 && n < this.indentNext && o[0] !== "#" || n === 0 && (o.startsWith("---") || o.startsWith("...")) && bs(o[3])) && !(n === this.indentNext - 1 && this.flowLevel === 1 && (o[0] === "]" || o[0] === "}")))
      return this.flowLevel = 0, yield Dv, yield* this.parseLineStart();
    let a = 0;
    for (; o[a] === ","; )
      a += yield* this.pushCount(1), a += yield* this.pushSpaces(!0), this.flowKey = !1;
    switch (a += yield* this.pushIndicators(), o[a]) {
      case void 0:
        return "flow";
      case "#":
        return yield* this.pushCount(o.length - a), "flow";
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel += 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), this.flowKey = !0, this.flowLevel -= 1, this.flowLevel ? "flow" : "doc";
      case "*":
        return yield* this.pushUntil(p0), "flow";
      case '"':
      case "'":
        return this.flowKey = !0, yield* this.parseQuotedScalar();
      case ":": {
        const i = this.charAt(1);
        if (this.flowKey || bs(i) || i === ",")
          return this.flowKey = !1, yield* this.pushCount(1), yield* this.pushSpaces(!0), "flow";
      }
      // fallthrough
      default:
        return this.flowKey = !1, yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const t = this.charAt(0);
    let r = this.buffer.indexOf(t, this.pos + 1);
    if (t === "'")
      for (; r !== -1 && this.buffer[r + 1] === "'"; )
        r = this.buffer.indexOf("'", r + 2);
    else
      for (; r !== -1; ) {
        let a = 0;
        for (; this.buffer[r - 1 - a] === "\\"; )
          a += 1;
        if (a % 2 === 0)
          break;
        r = this.buffer.indexOf('"', r + 1);
      }
    const n = this.buffer.substring(0, r);
    let o = n.indexOf(`
`, this.pos);
    if (o !== -1) {
      for (; o !== -1; ) {
        const a = this.continueScalar(o + 1);
        if (a === -1)
          break;
        o = n.indexOf(`
`, a);
      }
      o !== -1 && (r = o - (n[o - 1] === "\r" ? 2 : 1));
    }
    if (r === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      r = this.buffer.length;
    }
    return yield* this.pushToIndex(r + 1, !1), this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1, this.blockScalarKeep = !1;
    let t = this.pos;
    for (; ; ) {
      const r = this.buffer[++t];
      if (r === "+")
        this.blockScalarKeep = !0;
      else if (r > "0" && r <= "9")
        this.blockScalarIndent = Number(r) - 1;
      else if (r !== "-")
        break;
    }
    return yield* this.pushUntil((r) => bs(r) || r === "#");
  }
  *parseBlockScalar() {
    let t = this.pos - 1, r = 0, n;
    e: for (let a = this.pos; n = this.buffer[a]; ++a)
      switch (n) {
        case " ":
          r += 1;
          break;
        case `
`:
          t = a, r = 0;
          break;
        case "\r": {
          const i = this.buffer[a + 1];
          if (!i && !this.atEnd)
            return this.setNext("block-scalar");
          if (i === `
`)
            break;
        }
        // fallthrough
        default:
          break e;
      }
    if (!n && !this.atEnd)
      return this.setNext("block-scalar");
    if (r >= this.indentNext) {
      this.blockScalarIndent === -1 ? this.indentNext = r : this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
      do {
        const a = this.continueScalar(t + 1);
        if (a === -1)
          break;
        t = this.buffer.indexOf(`
`, a);
      } while (t !== -1);
      if (t === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        t = this.buffer.length;
      }
    }
    let o = t + 1;
    for (n = this.buffer[o]; n === " "; )
      n = this.buffer[++o];
    if (n === "	") {
      for (; n === "	" || n === " " || n === "\r" || n === `
`; )
        n = this.buffer[++o];
      t = o - 1;
    } else if (!this.blockScalarKeep)
      do {
        let a = t - 1, i = this.buffer[a];
        i === "\r" && (i = this.buffer[--a]);
        const u = a;
        for (; i === " "; )
          i = this.buffer[--a];
        if (i === `
` && a >= this.pos && a + 1 + r > u)
          t = a;
        else
          break;
      } while (!0);
    return yield Zd, yield* this.pushToIndex(t + 1, !0), yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const t = this.flowLevel > 0;
    let r = this.pos - 1, n = this.pos - 1, o;
    for (; o = this.buffer[++n]; )
      if (o === ":") {
        const a = this.buffer[n + 1];
        if (bs(a) || t && cg.has(a))
          break;
        r = n;
      } else if (bs(o)) {
        let a = this.buffer[n + 1];
        if (o === "\r" && (a === `
` ? (n += 1, o = `
`, a = this.buffer[n + 1]) : r = n), a === "#" || t && cg.has(a))
          break;
        if (o === `
`) {
          const i = this.continueScalar(n + 1);
          if (i === -1)
            break;
          n = Math.max(n, i - 2);
        }
      } else {
        if (t && cg.has(o))
          break;
        r = n;
      }
    return !o && !this.atEnd ? this.setNext("plain-scalar") : (yield Zd, yield* this.pushToIndex(r + 1, !0), t ? "flow" : "doc");
  }
  *pushCount(t) {
    return t > 0 ? (yield this.buffer.substr(this.pos, t), this.pos += t, t) : 0;
  }
  *pushToIndex(t, r) {
    const n = this.buffer.slice(this.pos, t);
    return n ? (yield n, this.pos += n.length, n.length) : (r && (yield ""), 0);
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(p0)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      case "-":
      // this is an error
      case "?":
      // this is an error outside flow collections
      case ":": {
        const t = this.flowLevel > 0, r = this.charAt(1);
        if (bs(r) || t && cg.has(r))
          return t ? this.flowKey && (this.flowKey = !1) : this.indentNext = this.indentValue + 1, (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let t = this.pos + 2, r = this.buffer[t];
      for (; !bs(r) && r !== ">"; )
        r = this.buffer[++t];
      return yield* this.pushToIndex(r === ">" ? t + 1 : t, !1);
    } else {
      let t = this.pos + 1, r = this.buffer[t];
      for (; r; )
        if (JI.has(r))
          r = this.buffer[++t];
        else if (r === "%" && _1.has(this.buffer[t + 1]) && _1.has(this.buffer[t + 2]))
          r = this.buffer[t += 3];
        else
          break;
      return yield* this.pushToIndex(t, !1);
    }
  }
  *pushNewline() {
    const t = this.buffer[this.pos];
    return t === `
` ? yield* this.pushCount(1) : t === "\r" && this.charAt(1) === `
` ? yield* this.pushCount(2) : 0;
  }
  *pushSpaces(t) {
    let r = this.pos - 1, n;
    do
      n = this.buffer[++r];
    while (n === " " || t && n === "	");
    const o = r - this.pos;
    return o > 0 && (yield this.buffer.substr(this.pos, o), this.pos = r), o;
  }
  *pushUntil(t) {
    let r = this.pos, n = this.buffer[r];
    for (; !t(n); )
      n = this.buffer[++r];
    return yield* this.pushToIndex(r, !1);
  }
}
class YS {
  constructor() {
    this.lineStarts = [], this.addNewLine = (t) => this.lineStarts.push(t), this.linePos = (t) => {
      let r = 0, n = this.lineStarts.length;
      for (; r < n; ) {
        const a = r + n >> 1;
        this.lineStarts[a] < t ? r = a + 1 : n = a;
      }
      if (this.lineStarts[r] === t)
        return { line: r + 1, col: 1 };
      if (r === 0)
        return { line: 0, col: t };
      const o = this.lineStarts[r - 1];
      return { line: r, col: t - o + 1 };
    };
  }
}
function il(e, t) {
  for (let r = 0; r < e.length; ++r)
    if (e[r].type === t)
      return !0;
  return !1;
}
function E1(e) {
  for (let t = 0; t < e.length; ++t)
    switch (e[t].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return t;
    }
  return -1;
}
function CP(e) {
  switch (e == null ? void 0 : e.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return !0;
    default:
      return !1;
  }
}
function pg(e) {
  switch (e.type) {
    case "document":
      return e.start;
    case "block-map": {
      const t = e.items[e.items.length - 1];
      return t.sep ?? t.start;
    }
    case "block-seq":
      return e.items[e.items.length - 1].start;
    /* istanbul ignore next should not happen */
    default:
      return [];
  }
}
function tp(e) {
  var r;
  if (e.length === 0)
    return [];
  let t = e.length;
  e: for (; --t >= 0; )
    switch (e[t].type) {
      case "doc-start":
      case "explicit-key-ind":
      case "map-value-ind":
      case "seq-item-ind":
      case "newline":
        break e;
    }
  for (; ((r = e[++t]) == null ? void 0 : r.type) === "space"; )
    ;
  return e.splice(t, e.length);
}
function O1(e) {
  if (e.start.type === "flow-seq-start")
    for (const t of e.items)
      t.sep && !t.value && !il(t.start, "explicit-key-ind") && !il(t.sep, "map-value-ind") && (t.key && (t.value = t.key), delete t.key, CP(t.value) ? t.value.end ? Array.prototype.push.apply(t.value.end, t.sep) : t.value.end = t.sep : Array.prototype.push.apply(t.start, t.sep), delete t.sep);
}
class Fv {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(t) {
    this.atNewLine = !0, this.atScalar = !1, this.indent = 0, this.offset = 0, this.onKeyLine = !1, this.stack = [], this.source = "", this.type = "", this.lexer = new QS(), this.onNewLine = t;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(t, r = !1) {
    this.onNewLine && this.offset === 0 && this.onNewLine(0);
    for (const n of this.lexer.lex(t, r))
      yield* this.next(n);
    r || (yield* this.end());
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(t) {
    if (this.source = t, this.atScalar) {
      this.atScalar = !1, yield* this.step(), this.offset += t.length;
      return;
    }
    const r = PP(t);
    if (r)
      if (r === "scalar")
        this.atNewLine = !1, this.atScalar = !0, this.type = "scalar";
      else {
        switch (this.type = r, yield* this.step(), r) {
          case "newline":
            this.atNewLine = !0, this.indent = 0, this.onNewLine && this.onNewLine(this.offset + t.length);
            break;
          case "space":
            this.atNewLine && t[0] === " " && (this.indent += t.length);
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            this.atNewLine && (this.indent += t.length);
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = !1;
        }
        this.offset += t.length;
      }
    else {
      const n = `Not a YAML token: ${t}`;
      yield* this.pop({ type: "error", offset: this.offset, message: n, source: t }), this.offset += t.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    for (; this.stack.length > 0; )
      yield* this.pop();
  }
  get sourceToken() {
    return {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  *step() {
    const t = this.peek(1);
    if (this.type === "doc-end" && (!t || t.type !== "doc-end")) {
      for (; this.stack.length > 0; )
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!t)
      return yield* this.stream();
    switch (t.type) {
      case "document":
        return yield* this.document(t);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(t);
      case "block-scalar":
        return yield* this.blockScalar(t);
      case "block-map":
        return yield* this.blockMap(t);
      case "block-seq":
        return yield* this.blockSequence(t);
      case "flow-collection":
        return yield* this.flowCollection(t);
      case "doc-end":
        return yield* this.documentEnd(t);
    }
    yield* this.pop();
  }
  peek(t) {
    return this.stack[this.stack.length - t];
  }
  *pop(t) {
    const r = t ?? this.stack.pop();
    if (!r)
      yield { type: "error", offset: this.offset, source: "", message: "Tried to pop an empty stack" };
    else if (this.stack.length === 0)
      yield r;
    else {
      const n = this.peek(1);
      switch (r.type === "block-scalar" ? r.indent = "indent" in n ? n.indent : 0 : r.type === "flow-collection" && n.type === "document" && (r.indent = 0), r.type === "flow-collection" && O1(r), n.type) {
        case "document":
          n.value = r;
          break;
        case "block-scalar":
          n.props.push(r);
          break;
        case "block-map": {
          const o = n.items[n.items.length - 1];
          if (o.value) {
            n.items.push({ start: [], key: r, sep: [] }), this.onKeyLine = !0;
            return;
          } else if (o.sep)
            o.value = r;
          else {
            Object.assign(o, { key: r, sep: [] }), this.onKeyLine = !o.explicitKey;
            return;
          }
          break;
        }
        case "block-seq": {
          const o = n.items[n.items.length - 1];
          o.value ? n.items.push({ start: [], value: r }) : o.value = r;
          break;
        }
        case "flow-collection": {
          const o = n.items[n.items.length - 1];
          !o || o.value ? n.items.push({ start: [], key: r, sep: [] }) : o.sep ? o.value = r : Object.assign(o, { key: r, sep: [] });
          return;
        }
        /* istanbul ignore next should not happen */
        default:
          yield* this.pop(), yield* this.pop(r);
      }
      if ((n.type === "document" || n.type === "block-map" || n.type === "block-seq") && (r.type === "block-map" || r.type === "block-seq")) {
        const o = r.items[r.items.length - 1];
        o && !o.sep && !o.value && o.start.length > 0 && E1(o.start) === -1 && (r.indent === 0 || o.start.every((a) => a.type !== "comment" || a.indent < r.indent)) && (n.type === "document" ? n.end = o.start : n.items.push({ start: o.start }), r.items.splice(-1, 1));
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const t = {
          type: "document",
          offset: this.offset,
          start: []
        };
        this.type === "doc-start" && t.start.push(this.sourceToken), this.stack.push(t);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(t) {
    if (t.value)
      return yield* this.lineEnd(t);
    switch (this.type) {
      case "doc-start": {
        E1(t.start) !== -1 ? (yield* this.pop(), yield* this.step()) : t.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        t.start.push(this.sourceToken);
        return;
    }
    const r = this.startBlockValue(t);
    r ? this.stack.push(r) : yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML document`,
      source: this.source
    };
  }
  *scalar(t) {
    if (this.type === "map-value-ind") {
      const r = pg(this.peek(2)), n = tp(r);
      let o;
      t.end ? (o = t.end, o.push(this.sourceToken), delete t.end) : o = [this.sourceToken];
      const a = {
        type: "block-map",
        offset: t.offset,
        indent: t.indent,
        items: [{ start: n, key: t, sep: o }]
      };
      this.onKeyLine = !0, this.stack[this.stack.length - 1] = a;
    } else
      yield* this.lineEnd(t);
  }
  *blockScalar(t) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        t.props.push(this.sourceToken);
        return;
      case "scalar":
        if (t.source = this.source, this.atNewLine = !0, this.indent = 0, this.onNewLine) {
          let r = this.source.indexOf(`
`) + 1;
          for (; r !== 0; )
            this.onNewLine(this.offset + r), r = this.source.indexOf(`
`, r) + 1;
        }
        yield* this.pop();
        break;
      /* istanbul ignore next should not happen */
      default:
        yield* this.pop(), yield* this.step();
    }
  }
  *blockMap(t) {
    var n;
    const r = t.items[t.items.length - 1];
    switch (this.type) {
      case "newline":
        if (this.onKeyLine = !1, r.value) {
          const o = "end" in r.value ? r.value.end : void 0, a = Array.isArray(o) ? o[o.length - 1] : void 0;
          (a == null ? void 0 : a.type) === "comment" ? o == null || o.push(this.sourceToken) : t.items.push({ start: [this.sourceToken] });
        } else r.sep ? r.sep.push(this.sourceToken) : r.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (r.value)
          t.items.push({ start: [this.sourceToken] });
        else if (r.sep)
          r.sep.push(this.sourceToken);
        else {
          if (this.atIndentedComment(r.start, t.indent)) {
            const o = t.items[t.items.length - 2], a = (n = o == null ? void 0 : o.value) == null ? void 0 : n.end;
            if (Array.isArray(a)) {
              Array.prototype.push.apply(a, r.start), a.push(this.sourceToken), t.items.pop();
              return;
            }
          }
          r.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= t.indent) {
      const o = !this.onKeyLine && this.indent === t.indent, a = o && (r.sep || r.explicitKey) && this.type !== "seq-item-ind";
      let i = [];
      if (a && r.sep && !r.value) {
        const u = [];
        for (let c = 0; c < r.sep.length; ++c) {
          const d = r.sep[c];
          switch (d.type) {
            case "newline":
              u.push(c);
              break;
            case "space":
              break;
            case "comment":
              d.indent > t.indent && (u.length = 0);
              break;
            default:
              u.length = 0;
          }
        }
        u.length >= 2 && (i = r.sep.splice(u[1]));
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          a || r.value ? (i.push(this.sourceToken), t.items.push({ start: i }), this.onKeyLine = !0) : r.sep ? r.sep.push(this.sourceToken) : r.start.push(this.sourceToken);
          return;
        case "explicit-key-ind":
          !r.sep && !r.explicitKey ? (r.start.push(this.sourceToken), r.explicitKey = !0) : a || r.value ? (i.push(this.sourceToken), t.items.push({ start: i, explicitKey: !0 })) : this.stack.push({
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken], explicitKey: !0 }]
          }), this.onKeyLine = !0;
          return;
        case "map-value-ind":
          if (r.explicitKey)
            if (r.sep)
              if (r.value)
                t.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (il(r.sep, "map-value-ind"))
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: i, key: null, sep: [this.sourceToken] }]
                });
              else if (CP(r.key) && !il(r.sep, "newline")) {
                const u = tp(r.start), c = r.key, d = r.sep;
                d.push(this.sourceToken), delete r.key, delete r.sep, this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: u, key: c, sep: d }]
                });
              } else i.length > 0 ? r.sep = r.sep.concat(i, this.sourceToken) : r.sep.push(this.sourceToken);
            else if (il(r.start, "newline"))
              Object.assign(r, { key: null, sep: [this.sourceToken] });
            else {
              const u = tp(r.start);
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: u, key: null, sep: [this.sourceToken] }]
              });
            }
          else
            r.sep ? r.value || a ? t.items.push({ start: i, key: null, sep: [this.sourceToken] }) : il(r.sep, "map-value-ind") ? this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [], key: null, sep: [this.sourceToken] }]
            }) : r.sep.push(this.sourceToken) : Object.assign(r, { key: null, sep: [this.sourceToken] });
          this.onKeyLine = !0;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const u = this.flowScalar(this.type);
          a || r.value ? (t.items.push({ start: i, key: u, sep: [] }), this.onKeyLine = !0) : r.sep ? this.stack.push(u) : (Object.assign(r, { key: u, sep: [] }), this.onKeyLine = !0);
          return;
        }
        default: {
          const u = this.startBlockValue(t);
          if (u) {
            if (u.type === "block-seq") {
              if (!r.explicitKey && r.sep && !il(r.sep, "newline")) {
                yield* this.pop({
                  type: "error",
                  offset: this.offset,
                  message: "Unexpected block-seq-ind on same line with key",
                  source: this.source
                });
                return;
              }
            } else o && t.items.push({ start: i });
            this.stack.push(u);
            return;
          }
        }
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *blockSequence(t) {
    var n;
    const r = t.items[t.items.length - 1];
    switch (this.type) {
      case "newline":
        if (r.value) {
          const o = "end" in r.value ? r.value.end : void 0, a = Array.isArray(o) ? o[o.length - 1] : void 0;
          (a == null ? void 0 : a.type) === "comment" ? o == null || o.push(this.sourceToken) : t.items.push({ start: [this.sourceToken] });
        } else
          r.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (r.value)
          t.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(r.start, t.indent)) {
            const o = t.items[t.items.length - 2], a = (n = o == null ? void 0 : o.value) == null ? void 0 : n.end;
            if (Array.isArray(a)) {
              Array.prototype.push.apply(a, r.start), a.push(this.sourceToken), t.items.pop();
              return;
            }
          }
          r.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (r.value || this.indent <= t.indent)
          break;
        r.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== t.indent)
          break;
        r.value || il(r.start, "seq-item-ind") ? t.items.push({ start: [this.sourceToken] }) : r.start.push(this.sourceToken);
        return;
    }
    if (this.indent > t.indent) {
      const o = this.startBlockValue(t);
      if (o) {
        this.stack.push(o);
        return;
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *flowCollection(t) {
    const r = t.items[t.items.length - 1];
    if (this.type === "flow-error-end") {
      let n;
      do
        yield* this.pop(), n = this.peek(1);
      while (n && n.type === "flow-collection");
    } else if (t.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          !r || r.sep ? t.items.push({ start: [this.sourceToken] }) : r.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          !r || r.value ? t.items.push({ start: [], key: null, sep: [this.sourceToken] }) : r.sep ? r.sep.push(this.sourceToken) : Object.assign(r, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          !r || r.value ? t.items.push({ start: [this.sourceToken] }) : r.sep ? r.sep.push(this.sourceToken) : r.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const o = this.flowScalar(this.type);
          !r || r.value ? t.items.push({ start: [], key: o, sep: [] }) : r.sep ? this.stack.push(o) : Object.assign(r, { key: o, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          t.end.push(this.sourceToken);
          return;
      }
      const n = this.startBlockValue(t);
      n ? this.stack.push(n) : (yield* this.pop(), yield* this.step());
    } else {
      const n = this.peek(2);
      if (n.type === "block-map" && (this.type === "map-value-ind" && n.indent === t.indent || this.type === "newline" && !n.items[n.items.length - 1].sep))
        yield* this.pop(), yield* this.step();
      else if (this.type === "map-value-ind" && n.type !== "flow-collection") {
        const o = pg(n), a = tp(o);
        O1(t);
        const i = t.end.splice(1, t.end.length);
        i.push(this.sourceToken);
        const u = {
          type: "block-map",
          offset: t.offset,
          indent: t.indent,
          items: [{ start: a, key: t, sep: i }]
        };
        this.onKeyLine = !0, this.stack[this.stack.length - 1] = u;
      } else
        yield* this.lineEnd(t);
    }
  }
  flowScalar(t) {
    if (this.onNewLine) {
      let r = this.source.indexOf(`
`) + 1;
      for (; r !== 0; )
        this.onNewLine(this.offset + r), r = this.source.indexOf(`
`, r) + 1;
    }
    return {
      type: t,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(t) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = !0;
        const r = pg(t), n = tp(r);
        return n.push(this.sourceToken), {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: n, explicitKey: !0 }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = !0;
        const r = pg(t), n = tp(r);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: n, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(t, r) {
    return this.type !== "comment" || this.indent <= r ? !1 : t.every((n) => n.type === "newline" || n.type === "space");
  }
  *documentEnd(t) {
    this.type !== "doc-mode" && (t.end ? t.end.push(this.sourceToken) : t.end = [this.sourceToken], this.type === "newline" && (yield* this.pop()));
  }
  *lineEnd(t) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop(), yield* this.step();
        break;
      case "newline":
        this.onKeyLine = !1;
      // fallthrough
      case "space":
      case "comment":
      default:
        t.end ? t.end.push(this.sourceToken) : t.end = [this.sourceToken], this.type === "newline" && (yield* this.pop());
    }
  }
}
function $P(e) {
  const t = e.prettyErrors !== !1;
  return { lineCounter: e.lineCounter || t && new YS() || null, prettyErrors: t };
}
function RP(e, t = {}) {
  const { lineCounter: r, prettyErrors: n } = $P(t), o = new Fv(r == null ? void 0 : r.addNewLine), a = new jv(t), i = Array.from(a.compose(o.parse(e)));
  if (n && r)
    for (const u of i)
      u.errors.forEach(Xy(e, r)), u.warnings.forEach(Xy(e, r));
  return i.length > 0 ? i : Object.assign([], { empty: !0 }, a.streamInfo());
}
function GS(e, t = {}) {
  const { lineCounter: r, prettyErrors: n } = $P(t), o = new Fv(r == null ? void 0 : r.addNewLine), a = new jv(t);
  let i = null;
  for (const u of a.compose(o.parse(e), !0, e.length))
    if (!i)
      i = u;
    else if (i.options.logLevel !== "silent") {
      i.errors.push(new sl(u.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  return n && r && (i.errors.forEach(Xy(e, r)), i.warnings.forEach(Xy(e, r))), i;
}
function IP(e, t, r) {
  let n;
  typeof t == "function" ? n = t : r === void 0 && t && typeof t == "object" && (r = t);
  const o = GS(e, r);
  if (!o)
    return null;
  if (o.warnings.forEach((a) => eP(o.options.logLevel, a)), o.errors.length > 0) {
    if (o.options.logLevel !== "silent")
      throw o.errors[0];
    o.errors = [];
  }
  return o.toJS(Object.assign({ reviver: n }, r));
}
function NP(e, t, r) {
  let n = null;
  if (typeof t == "function" || Array.isArray(t) ? n = t : r === void 0 && t && (r = t), typeof r == "string" && (r = r.length), typeof r == "number") {
    const o = Math.round(r);
    r = o < 1 ? void 0 : o > 8 ? { indent: 8 } : { indent: o };
  }
  if (e === void 0) {
    const { keepUndefined: o } = r ?? t ?? {};
    if (!o)
      return;
  }
  return vl(e) && !n ? e.toString(r) : new Bu(e, n, r).toString(r);
}
const eN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Alias: fh,
  CST: TP,
  Composer: jv,
  Document: Bu,
  Lexer: QS,
  LineCounter: YS,
  Pair: an,
  Parser: Fv,
  Scalar: Ot,
  Schema: mh,
  YAMLError: Nv,
  YAMLMap: Zn,
  YAMLParseError: sl,
  YAMLSeq: pa,
  YAMLWarning: WS,
  isAlias: yl,
  isCollection: dr,
  isDocument: vl,
  isMap: qu,
  isNode: hr,
  isPair: ur,
  isScalar: Gt,
  isSeq: zu,
  parse: IP,
  parseAllDocuments: RP,
  parseDocument: GS,
  stringify: NP,
  visit: ca,
  visitAsync: ph
}, Symbol.toStringTag, { value: "Module" })), tN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Alias: fh,
  CST: TP,
  Composer: jv,
  Document: Bu,
  Lexer: QS,
  LineCounter: YS,
  Pair: an,
  Parser: Fv,
  Scalar: Ot,
  Schema: mh,
  YAMLError: Nv,
  YAMLMap: Zn,
  YAMLParseError: sl,
  YAMLSeq: pa,
  YAMLWarning: WS,
  default: eN,
  isAlias: yl,
  isCollection: dr,
  isDocument: vl,
  isMap: qu,
  isNode: hr,
  isPair: ur,
  isScalar: Gt,
  isSeq: zu,
  parse: IP,
  parseAllDocuments: RP,
  parseDocument: GS,
  stringify: NP,
  visit: ca,
  visitAsync: ph
}, Symbol.toStringTag, { value: "Module" })), rN = /* @__PURE__ */ _o(tN);
function ir() {
  return ir = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r) ({}).hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, ir.apply(null, arguments);
}
function nN(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function eh(e, t) {
  return eh = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, n) {
    return r.__proto__ = n, r;
  }, eh(e, t);
}
function iN(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, eh(e, t);
}
function Gw(e) {
  return Gw = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Gw(e);
}
function sN(e) {
  try {
    return Function.toString.call(e).indexOf("[native code]") !== -1;
  } catch {
    return typeof e == "function";
  }
}
function jP() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (jP = function() {
    return !!e;
  })();
}
function oN(e, t, r) {
  if (jP()) return Reflect.construct.apply(null, arguments);
  var n = [null];
  n.push.apply(n, t);
  var o = new (e.bind.apply(e, n))();
  return r && eh(o, r.prototype), o;
}
function Xw(e) {
  var t = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return Xw = function(n) {
    if (n === null || !sN(n)) return n;
    if (typeof n != "function") throw new TypeError("Super expression must either be null or a function");
    if (t !== void 0) {
      if (t.has(n)) return t.get(n);
      t.set(n, o);
    }
    function o() {
      return oN(n, arguments, Gw(this).constructor);
    }
    return o.prototype = Object.create(n.prototype, {
      constructor: {
        value: o,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), eh(o, n);
  }, Xw(e);
}
function LP(e, t) {
  return t || (t = e.slice(0)), e.raw = t, e;
}
function k1() {
  var e;
  return e = arguments.length - 1, e < 0 || arguments.length <= e ? void 0 : arguments[e];
}
function aN(e) {
  return -e;
}
function lN(e, t) {
  return e + t;
}
function uN(e, t) {
  return e - t;
}
function cN(e, t) {
  return e * t;
}
function pN(e, t) {
  return e / t;
}
function fN() {
  return Math.max.apply(Math, arguments);
}
function dN() {
  return Math.min.apply(Math, arguments);
}
function hN() {
  return Array.of.apply(Array, arguments);
}
var mN = {
  symbols: {
    "*": {
      infix: {
        symbol: "*",
        f: cN,
        notation: "infix",
        precedence: 4,
        rightToLeft: 0,
        argCount: 2
      },
      symbol: "*",
      regSymbol: "\\*"
    },
    "/": {
      infix: {
        symbol: "/",
        f: pN,
        notation: "infix",
        precedence: 4,
        rightToLeft: 0,
        argCount: 2
      },
      symbol: "/",
      regSymbol: "/"
    },
    "+": {
      infix: {
        symbol: "+",
        f: lN,
        notation: "infix",
        precedence: 2,
        rightToLeft: 0,
        argCount: 2
      },
      prefix: {
        symbol: "+",
        f: k1,
        notation: "prefix",
        precedence: 3,
        rightToLeft: 0,
        argCount: 1
      },
      symbol: "+",
      regSymbol: "\\+"
    },
    "-": {
      infix: {
        symbol: "-",
        f: uN,
        notation: "infix",
        precedence: 2,
        rightToLeft: 0,
        argCount: 2
      },
      prefix: {
        symbol: "-",
        f: aN,
        notation: "prefix",
        precedence: 3,
        rightToLeft: 0,
        argCount: 1
      },
      symbol: "-",
      regSymbol: "-"
    },
    ",": {
      infix: {
        symbol: ",",
        f: hN,
        notation: "infix",
        precedence: 1,
        rightToLeft: 0,
        argCount: 2
      },
      symbol: ",",
      regSymbol: ","
    },
    "(": {
      prefix: {
        symbol: "(",
        f: k1,
        notation: "prefix",
        precedence: 0,
        rightToLeft: 0,
        argCount: 1
      },
      symbol: "(",
      regSymbol: "\\("
    },
    ")": {
      postfix: {
        symbol: ")",
        f: void 0,
        notation: "postfix",
        precedence: 0,
        rightToLeft: 0,
        argCount: 1
      },
      symbol: ")",
      regSymbol: "\\)"
    },
    min: {
      func: {
        symbol: "min",
        f: dN,
        notation: "func",
        precedence: 0,
        rightToLeft: 0,
        argCount: 1
      },
      symbol: "min",
      regSymbol: "min\\b"
    },
    max: {
      func: {
        symbol: "max",
        f: fN,
        notation: "func",
        precedence: 0,
        rightToLeft: 0,
        argCount: 1
      },
      symbol: "max",
      regSymbol: "max\\b"
    }
  }
}, A1 = mN, St = /* @__PURE__ */ function(e) {
  iN(t, e);
  function t(r) {
    var n;
    return n = e.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + r + " for more information.") || this, nN(n);
  }
  return t;
}(/* @__PURE__ */ Xw(Error)), P1 = /((?!\w)a|na|hc|mc|dg|me[r]?|xe|ni(?![a-zA-Z])|mm|cp|tp|xp|q(?!s)|hv|xamv|nimv|wv|sm|s(?!\D|$)|ged|darg?|nrut)/g;
function gN(e) {
  var t = {};
  return t.symbols = e ? ir({}, A1.symbols, e.symbols) : ir({}, A1.symbols), t;
}
function T1(e, t) {
  var r, n = e.pop();
  return t.push(n.f.apply(n, (r = []).concat.apply(r, t.splice(-n.argCount)))), n.precedence;
}
function yN(e, t) {
  var r = gN(t), n, o = [r.symbols["("].prefix], a = [], i = new RegExp(
    // Pattern for numbers
    "\\d+(?:\\.\\d+)?|" + // ...and patterns for individual operators/function names
    Object.keys(r.symbols).map(function(x) {
      return r.symbols[x];
    }).sort(function(x, A) {
      return A.symbol.length - x.symbol.length;
    }).map(function(x) {
      return x.regSymbol;
    }).join("|") + "|(\\S)",
    "g"
  );
  i.lastIndex = 0;
  var u = !1;
  do {
    n = i.exec(e);
    var c = n || [")", void 0], d = c[0], m = c[1], g = r.symbols[d], v = g && !g.prefix && !g.func, S = !g || !g.postfix && !g.infix;
    if (m || (u ? S : v))
      throw new St(37, n ? n.index : e.length, e);
    if (u) {
      var k = g.postfix || g.infix;
      do {
        var b = o[o.length - 1];
        if ((k.precedence - b.precedence || b.rightToLeft) > 0) break;
      } while (T1(o, a));
      u = k.notation === "postfix", k.symbol !== ")" && (o.push(k), u && T1(o, a));
    } else if (g) {
      if (o.push(g.prefix || g.func), g.func && (n = i.exec(e), !n || n[0] !== "("))
        throw new St(38, n ? n.index : e.length, e);
    } else
      a.push(+d), u = !0;
  } while (n && o.length);
  if (o.length)
    throw new St(39, n ? n.index : e.length, e);
  if (n)
    throw new St(40, n ? n.index : e.length, e);
  return a.pop();
}
function f0(e) {
  return e.split("").reverse().join("");
}
function vN(e, t) {
  var r = f0(e), n = r.match(P1);
  if (n && !n.every(function(a) {
    return a === n[0];
  }))
    throw new St(41);
  var o = f0(r.replace(P1, ""));
  return "" + yN(o, t) + (n ? f0(n[0]) : "");
}
var bN = /--[\S]*/g;
function wN(e, t) {
  if (!e || !e.match(bN))
    throw new St(73);
  var r;
  if (typeof document < "u" && document.documentElement !== null && (r = getComputedStyle(document.documentElement).getPropertyValue(e)), r)
    return r.trim();
  if (t)
    return t;
  throw new St(74);
}
function Wd(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
var SN = ["Top", "Right", "Bottom", "Left"];
function xN(e, t) {
  if (!e) return t.toLowerCase();
  var r = e.split("-");
  if (r.length > 1)
    return r.splice(1, 0, t), r.reduce(function(o, a) {
      return "" + o + Wd(a);
    });
  var n = e.replace(/([a-z])([A-Z])/g, "$1" + t + "$2");
  return e === n ? "" + e + t : n;
}
function _N(e, t) {
  for (var r = {}, n = 0; n < t.length; n += 1)
    (t[n] || t[n] === 0) && (r[xN(e, SN[n])] = t[n]);
  return r;
}
function fl(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    r[n - 1] = arguments[n];
  var o = r[0], a = r[1], i = a === void 0 ? o : a, u = r[2], c = u === void 0 ? o : u, d = r[3], m = d === void 0 ? i : d, g = [o, i, c, m];
  return _N(e, g);
}
function C1(e, t) {
  return e.substr(-t.length) === t;
}
var EN = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/;
function Jw(e) {
  if (typeof e != "string") return e;
  var t = e.match(EN);
  return t ? parseFloat(e) : e;
}
var ON = function(t) {
  return function(r, n) {
    n === void 0 && (n = "16px");
    var o = r, a = n;
    if (typeof r == "string") {
      if (!C1(r, "px"))
        throw new St(69, t, r);
      o = Jw(r);
    }
    if (typeof n == "string") {
      if (!C1(n, "px"))
        throw new St(70, t, n);
      a = Jw(n);
    }
    if (typeof o == "string")
      throw new St(71, r, t);
    if (typeof a == "string")
      throw new St(72, n, t);
    return "" + o / a + t;
  };
}, MP = ON, kN = MP("em"), AN = kN, PN = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/;
function mo(e) {
  if (typeof e != "string") return [e, ""];
  var t = e.match(PN);
  return t ? [parseFloat(e), t[2]] : [e, void 0];
}
function DP(e, t) {
  if (typeof e != "object" || e === null)
    throw new St(75, typeof e);
  var r = {};
  return Object.keys(e).forEach(function(n) {
    typeof e[n] == "object" && e[n] !== null ? r[n] = DP(e[n], t) : !t || t && (t === n || t.indexOf(n) >= 0) ? r[n] = e[n] + " !important" : r[n] = e[n];
  }), r;
}
var FP = {
  minorSecond: 1.067,
  majorSecond: 1.125,
  minorThird: 1.2,
  majorThird: 1.25,
  perfectFourth: 1.333,
  augFourth: 1.414,
  perfectFifth: 1.5,
  minorSixth: 1.6,
  goldenSection: 1.618,
  majorSixth: 1.667,
  minorSeventh: 1.778,
  majorSeventh: 1.875,
  octave: 2,
  majorTenth: 2.5,
  majorEleventh: 2.667,
  majorTwelfth: 3,
  doubleOctave: 4
};
function TN(e) {
  return FP[e];
}
function CN(e, t, r) {
  if (t === void 0 && (t = "1em"), r === void 0 && (r = 1.333), typeof e != "number")
    throw new St(42);
  if (typeof r == "string" && !FP[r])
    throw new St(43);
  var n = typeof t == "string" ? mo(t) : [t, ""], o = n[0], a = n[1], i = typeof r == "string" ? TN(r) : r;
  if (typeof o == "string")
    throw new St(44, t);
  return "" + o * Math.pow(i, e) + (a || "");
}
var $N = MP("rem"), RN = $N, Zw = 16;
function qP(e) {
  var t = mo(e);
  if (t[1] === "px")
    return parseFloat(e);
  if (t[1] === "%")
    return parseFloat(e) / 100 * Zw;
  throw new St(78, t[1]);
}
function IN() {
  if (typeof document < "u" && document.documentElement !== null) {
    var e = getComputedStyle(document.documentElement).fontSize;
    return e ? qP(e) : Zw;
  }
  return Zw;
}
function NN(e, t) {
  var r = mo(e);
  if (r[1] !== "rem" && r[1] !== "")
    throw new St(77, r[1]);
  var n = t ? qP(t) : IN();
  return r[0] * n + "px";
}
var jN = {
  back: "cubic-bezier(0.600, -0.280, 0.735, 0.045)",
  circ: "cubic-bezier(0.600,  0.040, 0.980, 0.335)",
  cubic: "cubic-bezier(0.550,  0.055, 0.675, 0.190)",
  expo: "cubic-bezier(0.950,  0.050, 0.795, 0.035)",
  quad: "cubic-bezier(0.550,  0.085, 0.680, 0.530)",
  quart: "cubic-bezier(0.895,  0.030, 0.685, 0.220)",
  quint: "cubic-bezier(0.755,  0.050, 0.855, 0.060)",
  sine: "cubic-bezier(0.470,  0.000, 0.745, 0.715)"
};
function LN(e) {
  return jN[e.toLowerCase().trim()];
}
var MN = {
  back: "cubic-bezier(0.680, -0.550, 0.265, 1.550)",
  circ: "cubic-bezier(0.785,  0.135, 0.150, 0.860)",
  cubic: "cubic-bezier(0.645,  0.045, 0.355, 1.000)",
  expo: "cubic-bezier(1.000,  0.000, 0.000, 1.000)",
  quad: "cubic-bezier(0.455,  0.030, 0.515, 0.955)",
  quart: "cubic-bezier(0.770,  0.000, 0.175, 1.000)",
  quint: "cubic-bezier(0.860,  0.000, 0.070, 1.000)",
  sine: "cubic-bezier(0.445,  0.050, 0.550, 0.950)"
};
function DN(e) {
  return MN[e.toLowerCase().trim()];
}
var FN = {
  back: "cubic-bezier(0.175,  0.885, 0.320, 1.275)",
  cubic: "cubic-bezier(0.215,  0.610, 0.355, 1.000)",
  circ: "cubic-bezier(0.075,  0.820, 0.165, 1.000)",
  expo: "cubic-bezier(0.190,  1.000, 0.220, 1.000)",
  quad: "cubic-bezier(0.250,  0.460, 0.450, 0.940)",
  quart: "cubic-bezier(0.165,  0.840, 0.440, 1.000)",
  quint: "cubic-bezier(0.230,  1.000, 0.320, 1.000)",
  sine: "cubic-bezier(0.390,  0.575, 0.565, 1.000)"
};
function qN(e) {
  return FN[e.toLowerCase().trim()];
}
function eS(e, t, r, n) {
  r === void 0 && (r = "320px"), n === void 0 && (n = "1200px");
  var o = mo(e), a = o[0], i = o[1], u = mo(t), c = u[0], d = u[1], m = mo(r), g = m[0], v = m[1], S = mo(n), k = S[0], b = S[1];
  if (typeof g != "number" || typeof k != "number" || !v || !b || v !== b)
    throw new St(47);
  if (typeof a != "number" || typeof c != "number" || i !== d)
    throw new St(48);
  if (i !== v || d !== b)
    throw new St(76);
  var x = (a - c) / (g - k), A = c - x * k;
  return "calc(" + A.toFixed(2) + (i || "") + " + " + (100 * x).toFixed(2) + "vw)";
}
function zN(e) {
  var t;
  e === void 0 && (e = "&");
  var r = e + "::after";
  return t = {}, t[r] = {
    clear: "both",
    content: '""',
    display: "table"
  }, t;
}
function BN(e) {
  return e === void 0 && (e = 0), {
    position: "absolute",
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function UN(e, t) {
  t === void 0 && (t = 1);
  var r = {
    display: "inline-block",
    maxWidth: e || "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    wordWrap: "normal"
  };
  return t > 1 ? ir({}, r, {
    WebkitBoxOrient: "vertical",
    WebkitLineClamp: t,
    display: "-webkit-box",
    whiteSpace: "normal"
  }) : r;
}
function VN(e, t) {
  var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r) return (r = r.call(e)).next.bind(r);
  if (Array.isArray(e) || (r = HN(e)) || t) {
    r && (e = r);
    var n = 0;
    return function() {
      return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
    };
  }
  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function HN(e, t) {
  if (e) {
    if (typeof e == "string") return $1(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return $1(e, t);
  }
}
function $1(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function WN(e, t, r) {
  if (t === void 0 && (t = "320px"), r === void 0 && (r = "1200px"), !Array.isArray(e) && typeof e != "object" || e === null)
    throw new St(49);
  if (Array.isArray(e)) {
    for (var n = {}, o = {}, a = VN(e), i; !(i = a()).done; ) {
      var u, c, d = i.value;
      if (!d.prop || !d.fromSize || !d.toSize)
        throw new St(50);
      o[d.prop] = d.fromSize, n["@media (min-width: " + t + ")"] = ir({}, n["@media (min-width: " + t + ")"], (u = {}, u[d.prop] = eS(d.fromSize, d.toSize, t, r), u)), n["@media (min-width: " + r + ")"] = ir({}, n["@media (min-width: " + r + ")"], (c = {}, c[d.prop] = d.toSize, c));
    }
    return ir({}, o, n);
  } else {
    var m, g, v;
    if (!e.prop || !e.fromSize || !e.toSize)
      throw new St(51);
    return v = {}, v[e.prop] = e.fromSize, v["@media (min-width: " + t + ")"] = (m = {}, m[e.prop] = eS(e.fromSize, e.toSize, t, r), m), v["@media (min-width: " + r + ")"] = (g = {}, g[e.prop] = e.toSize, g), v;
  }
}
var KN = /^\s*data:([a-z]+\/[a-z-]+(;[a-z-]+=[a-z-]+)?)?(;charset=[a-z0-9-]+)?(;base64)?,[a-z0-9!$&',()*+,;=\-._~:@/?%\s]*\s*$/i, QN = {
  woff: "woff",
  woff2: "woff2",
  ttf: "truetype",
  otf: "opentype",
  eot: "embedded-opentype",
  svg: "svg",
  svgz: "svg"
};
function R1(e, t) {
  return t ? ' format("' + QN[e] + '")' : "";
}
function YN(e) {
  return !!e.replace(/\s+/g, " ").match(KN);
}
function GN(e, t, r) {
  if (YN(e))
    return 'url("' + e + '")' + R1(t[0], r);
  var n = t.map(function(o) {
    return 'url("' + e + "." + o + '")' + R1(o, r);
  });
  return n.join(", ");
}
function XN(e) {
  var t = e.map(function(r) {
    return 'local("' + r + '")';
  });
  return t.join(", ");
}
function JN(e, t, r, n) {
  var o = [];
  return t && o.push(XN(t)), e && o.push(GN(e, r, n)), o.join(", ");
}
function ZN(e) {
  var t = e.fontFamily, r = e.fontFilePath, n = e.fontStretch, o = e.fontStyle, a = e.fontVariant, i = e.fontWeight, u = e.fileFormats, c = u === void 0 ? ["eot", "woff2", "woff", "ttf", "svg"] : u, d = e.formatHint, m = d === void 0 ? !1 : d, g = e.localFonts, v = g === void 0 ? [t] : g, S = e.unicodeRange, k = e.fontDisplay, b = e.fontVariationSettings, x = e.fontFeatureSettings;
  if (!t) throw new St(55);
  if (!r && !v)
    throw new St(52);
  if (v && !Array.isArray(v))
    throw new St(53);
  if (!Array.isArray(c))
    throw new St(54);
  var A = {
    "@font-face": {
      fontFamily: t,
      src: JN(r, v, c, m),
      unicodeRange: S,
      fontStretch: n,
      fontStyle: o,
      fontVariant: a,
      fontWeight: i,
      fontDisplay: k,
      fontVariationSettings: b,
      fontFeatureSettings: x
    }
  };
  return JSON.parse(JSON.stringify(A));
}
function ej() {
  return {
    textIndent: "101%",
    overflow: "hidden",
    whiteSpace: "nowrap"
  };
}
function tj() {
  return {
    border: "0",
    clip: "rect(0 0 0 0)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: "0",
    position: "absolute",
    whiteSpace: "nowrap",
    width: "1px"
  };
}
function zP(e) {
  return e === void 0 && (e = 1.3), `
    @media only screen and (-webkit-min-device-pixel-ratio: ` + e + `),
    only screen and (min--moz-device-pixel-ratio: ` + e + `),
    only screen and (-o-min-device-pixel-ratio: ` + e + `/1),
    only screen and (min-resolution: ` + Math.round(e * 96) + `dpi),
    only screen and (min-resolution: ` + e + `dppx)
  `;
}
function BP(e) {
  for (var t = "", r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)
    n[o - 1] = arguments[o];
  for (var a = 0; a < e.length; a += 1)
    if (t += e[a], a === n.length - 1 && n[a]) {
      var i = n.filter(function(u) {
        return !!u;
      });
      i.length > 1 ? (t = t.slice(0, -1), t += ", " + n[a]) : i.length === 1 && (t += "" + n[a]);
    } else n[a] && (t += n[a] + " ");
  return t.trim();
}
var I1;
function rj(e) {
  var t = e.colorStops, r = e.fallback, n = e.toDirection, o = n === void 0 ? "" : n;
  if (!t || t.length < 2)
    throw new St(56);
  return {
    backgroundColor: r || t[0].replace(/,\s+/g, ",").split(" ")[0].replace(/,(?=\S)/g, ", "),
    backgroundImage: BP(I1 || (I1 = LP(["linear-gradient(", "", ")"])), o, t.join(", ").replace(/,(?=\S)/g, ", "))
  };
}
function nj() {
  var e;
  return [(e = {
    html: {
      lineHeight: "1.15",
      textSizeAdjust: "100%"
    },
    body: {
      margin: "0"
    },
    main: {
      display: "block"
    },
    h1: {
      fontSize: "2em",
      margin: "0.67em 0"
    },
    hr: {
      boxSizing: "content-box",
      height: "0",
      overflow: "visible"
    },
    pre: {
      fontFamily: "monospace, monospace",
      fontSize: "1em"
    },
    a: {
      backgroundColor: "transparent"
    },
    "abbr[title]": {
      borderBottom: "none",
      textDecoration: "underline"
    }
  }, e[`b,
    strong`] = {
    fontWeight: "bolder"
  }, e[`code,
    kbd,
    samp`] = {
    fontFamily: "monospace, monospace",
    fontSize: "1em"
  }, e.small = {
    fontSize: "80%"
  }, e[`sub,
    sup`] = {
    fontSize: "75%",
    lineHeight: "0",
    position: "relative",
    verticalAlign: "baseline"
  }, e.sub = {
    bottom: "-0.25em"
  }, e.sup = {
    top: "-0.5em"
  }, e.img = {
    borderStyle: "none"
  }, e[`button,
    input,
    optgroup,
    select,
    textarea`] = {
    fontFamily: "inherit",
    fontSize: "100%",
    lineHeight: "1.15",
    margin: "0"
  }, e[`button,
    input`] = {
    overflow: "visible"
  }, e[`button,
    select`] = {
    textTransform: "none"
  }, e[`button,
    html [type="button"],
    [type="reset"],
    [type="submit"]`] = {
    WebkitAppearance: "button"
  }, e[`button::-moz-focus-inner,
    [type="button"]::-moz-focus-inner,
    [type="reset"]::-moz-focus-inner,
    [type="submit"]::-moz-focus-inner`] = {
    borderStyle: "none",
    padding: "0"
  }, e[`button:-moz-focusring,
    [type="button"]:-moz-focusring,
    [type="reset"]:-moz-focusring,
    [type="submit"]:-moz-focusring`] = {
    outline: "1px dotted ButtonText"
  }, e.fieldset = {
    padding: "0.35em 0.625em 0.75em"
  }, e.legend = {
    boxSizing: "border-box",
    color: "inherit",
    display: "table",
    maxWidth: "100%",
    padding: "0",
    whiteSpace: "normal"
  }, e.progress = {
    verticalAlign: "baseline"
  }, e.textarea = {
    overflow: "auto"
  }, e[`[type="checkbox"],
    [type="radio"]`] = {
    boxSizing: "border-box",
    padding: "0"
  }, e[`[type="number"]::-webkit-inner-spin-button,
    [type="number"]::-webkit-outer-spin-button`] = {
    height: "auto"
  }, e['[type="search"]'] = {
    WebkitAppearance: "textfield",
    outlineOffset: "-2px"
  }, e['[type="search"]::-webkit-search-decoration'] = {
    WebkitAppearance: "none"
  }, e["::-webkit-file-upload-button"] = {
    WebkitAppearance: "button",
    font: "inherit"
  }, e.details = {
    display: "block"
  }, e.summary = {
    display: "list-item"
  }, e.template = {
    display: "none"
  }, e["[hidden]"] = {
    display: "none"
  }, e), {
    "abbr[title]": {
      textDecoration: "underline dotted"
    }
  }];
}
var N1;
function ij(e) {
  var t = e.colorStops, r = e.extent, n = r === void 0 ? "" : r, o = e.fallback, a = e.position, i = a === void 0 ? "" : a, u = e.shape, c = u === void 0 ? "" : u;
  if (!t || t.length < 2)
    throw new St(57);
  return {
    backgroundColor: o || t[0].split(" ")[0],
    backgroundImage: BP(N1 || (N1 = LP(["radial-gradient(", "", "", "", ")"])), i, c, n, t.join(", "))
  };
}
function sj(e, t, r, n, o) {
  var a;
  if (r === void 0 && (r = "png"), o === void 0 && (o = "_2x"), !e)
    throw new St(58);
  var i = r.replace(/^\./, ""), u = n ? n + "." + i : "" + e + o + "." + i;
  return a = {
    backgroundImage: "url(" + e + "." + i + ")"
  }, a[zP()] = ir({
    backgroundImage: "url(" + u + ")"
  }, t ? {
    backgroundSize: t
  } : {}), a;
}
var oj = {
  easeInBack: "cubic-bezier(0.600, -0.280, 0.735, 0.045)",
  easeInCirc: "cubic-bezier(0.600,  0.040, 0.980, 0.335)",
  easeInCubic: "cubic-bezier(0.550,  0.055, 0.675, 0.190)",
  easeInExpo: "cubic-bezier(0.950,  0.050, 0.795, 0.035)",
  easeInQuad: "cubic-bezier(0.550,  0.085, 0.680, 0.530)",
  easeInQuart: "cubic-bezier(0.895,  0.030, 0.685, 0.220)",
  easeInQuint: "cubic-bezier(0.755,  0.050, 0.855, 0.060)",
  easeInSine: "cubic-bezier(0.470,  0.000, 0.745, 0.715)",
  easeOutBack: "cubic-bezier(0.175,  0.885, 0.320, 1.275)",
  easeOutCubic: "cubic-bezier(0.215,  0.610, 0.355, 1.000)",
  easeOutCirc: "cubic-bezier(0.075,  0.820, 0.165, 1.000)",
  easeOutExpo: "cubic-bezier(0.190,  1.000, 0.220, 1.000)",
  easeOutQuad: "cubic-bezier(0.250,  0.460, 0.450, 0.940)",
  easeOutQuart: "cubic-bezier(0.165,  0.840, 0.440, 1.000)",
  easeOutQuint: "cubic-bezier(0.230,  1.000, 0.320, 1.000)",
  easeOutSine: "cubic-bezier(0.390,  0.575, 0.565, 1.000)",
  easeInOutBack: "cubic-bezier(0.680, -0.550, 0.265, 1.550)",
  easeInOutCirc: "cubic-bezier(0.785,  0.135, 0.150, 0.860)",
  easeInOutCubic: "cubic-bezier(0.645,  0.045, 0.355, 1.000)",
  easeInOutExpo: "cubic-bezier(1.000,  0.000, 0.000, 1.000)",
  easeInOutQuad: "cubic-bezier(0.455,  0.030, 0.515, 0.955)",
  easeInOutQuart: "cubic-bezier(0.770,  0.000, 0.175, 1.000)",
  easeInOutQuint: "cubic-bezier(0.860,  0.000, 0.070, 1.000)",
  easeInOutSine: "cubic-bezier(0.445,  0.050, 0.550, 0.950)"
};
function aj(e) {
  return oj[e];
}
function lj(e) {
  return aj(e);
}
var uj = function(t, r, n) {
  var o = "" + n[0] + (n[1] || ""), a = "" + n[0] / 2 + (n[1] || ""), i = "" + r[0] + (r[1] || ""), u = "" + r[0] / 2 + (r[1] || "");
  switch (t) {
    case "top":
      return "0 " + a + " " + i + " " + a;
    case "topLeft":
      return o + " " + i + " 0 0";
    case "left":
      return u + " " + o + " " + u + " 0";
    case "bottomLeft":
      return o + " 0 0 " + i;
    case "bottom":
      return i + " " + a + " 0 " + a;
    case "bottomRight":
      return "0 0 " + o + " " + i;
    case "right":
      return u + " 0 " + u + " " + o;
    case "topRight":
    default:
      return "0 " + o + " " + i + " 0";
  }
}, cj = function(t, r) {
  switch (t) {
    case "top":
    case "bottomRight":
      return {
        borderBottomColor: r
      };
    case "right":
    case "bottomLeft":
      return {
        borderLeftColor: r
      };
    case "bottom":
    case "topLeft":
      return {
        borderTopColor: r
      };
    case "left":
    case "topRight":
      return {
        borderRightColor: r
      };
    default:
      throw new St(59);
  }
};
function pj(e) {
  var t = e.pointingDirection, r = e.height, n = e.width, o = e.foregroundColor, a = e.backgroundColor, i = a === void 0 ? "transparent" : a, u = mo(n), c = mo(r);
  if (isNaN(c[0]) || isNaN(u[0]))
    throw new St(60);
  return ir({
    width: "0",
    height: "0",
    borderColor: i
  }, cj(t, o), {
    borderStyle: "solid",
    borderWidth: uj(t, c, u)
  });
}
function fj(e) {
  e === void 0 && (e = "break-word");
  var t = e === "break-word" ? "break-all" : e;
  return {
    overflowWrap: e,
    wordWrap: e,
    wordBreak: t
  };
}
function d0(e) {
  return Math.round(e * 255);
}
function dj(e, t, r) {
  return d0(e) + "," + d0(t) + "," + d0(r);
}
function th(e, t, r, n) {
  if (n === void 0 && (n = dj), t === 0)
    return n(r, r, r);
  var o = (e % 360 + 360) % 360 / 60, a = (1 - Math.abs(2 * r - 1)) * t, i = a * (1 - Math.abs(o % 2 - 1)), u = 0, c = 0, d = 0;
  o >= 0 && o < 1 ? (u = a, c = i) : o >= 1 && o < 2 ? (u = i, c = a) : o >= 2 && o < 3 ? (c = a, d = i) : o >= 3 && o < 4 ? (c = i, d = a) : o >= 4 && o < 5 ? (u = i, d = a) : o >= 5 && o < 6 && (u = a, d = i);
  var m = r - a / 2, g = u + m, v = c + m, S = d + m;
  return n(g, v, S);
}
var j1 = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "00ffff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "0000ff",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "00ffff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "ff00ff",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "639",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
function hj(e) {
  if (typeof e != "string") return e;
  var t = e.toLowerCase();
  return j1[t] ? "#" + j1[t] : e;
}
var mj = /^#[a-fA-F0-9]{6}$/, gj = /^#[a-fA-F0-9]{8}$/, yj = /^#[a-fA-F0-9]{3}$/, vj = /^#[a-fA-F0-9]{4}$/, h0 = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i, bj = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i, wj = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i, Sj = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
function fa(e) {
  if (typeof e != "string")
    throw new St(3);
  var t = hj(e);
  if (t.match(mj))
    return {
      red: parseInt("" + t[1] + t[2], 16),
      green: parseInt("" + t[3] + t[4], 16),
      blue: parseInt("" + t[5] + t[6], 16)
    };
  if (t.match(gj)) {
    var r = parseFloat((parseInt("" + t[7] + t[8], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + t[1] + t[2], 16),
      green: parseInt("" + t[3] + t[4], 16),
      blue: parseInt("" + t[5] + t[6], 16),
      alpha: r
    };
  }
  if (t.match(yj))
    return {
      red: parseInt("" + t[1] + t[1], 16),
      green: parseInt("" + t[2] + t[2], 16),
      blue: parseInt("" + t[3] + t[3], 16)
    };
  if (t.match(vj)) {
    var n = parseFloat((parseInt("" + t[4] + t[4], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + t[1] + t[1], 16),
      green: parseInt("" + t[2] + t[2], 16),
      blue: parseInt("" + t[3] + t[3], 16),
      alpha: n
    };
  }
  var o = h0.exec(t);
  if (o)
    return {
      red: parseInt("" + o[1], 10),
      green: parseInt("" + o[2], 10),
      blue: parseInt("" + o[3], 10)
    };
  var a = bj.exec(t.substring(0, 50));
  if (a)
    return {
      red: parseInt("" + a[1], 10),
      green: parseInt("" + a[2], 10),
      blue: parseInt("" + a[3], 10),
      alpha: parseFloat("" + a[4]) > 1 ? parseFloat("" + a[4]) / 100 : parseFloat("" + a[4])
    };
  var i = wj.exec(t);
  if (i) {
    var u = parseInt("" + i[1], 10), c = parseInt("" + i[2], 10) / 100, d = parseInt("" + i[3], 10) / 100, m = "rgb(" + th(u, c, d) + ")", g = h0.exec(m);
    if (!g)
      throw new St(4, t, m);
    return {
      red: parseInt("" + g[1], 10),
      green: parseInt("" + g[2], 10),
      blue: parseInt("" + g[3], 10)
    };
  }
  var v = Sj.exec(t.substring(0, 50));
  if (v) {
    var S = parseInt("" + v[1], 10), k = parseInt("" + v[2], 10) / 100, b = parseInt("" + v[3], 10) / 100, x = "rgb(" + th(S, k, b) + ")", A = h0.exec(x);
    if (!A)
      throw new St(4, t, x);
    return {
      red: parseInt("" + A[1], 10),
      green: parseInt("" + A[2], 10),
      blue: parseInt("" + A[3], 10),
      alpha: parseFloat("" + v[4]) > 1 ? parseFloat("" + v[4]) / 100 : parseFloat("" + v[4])
    };
  }
  throw new St(5);
}
function xj(e) {
  var t = e.red / 255, r = e.green / 255, n = e.blue / 255, o = Math.max(t, r, n), a = Math.min(t, r, n), i = (o + a) / 2;
  if (o === a)
    return e.alpha !== void 0 ? {
      hue: 0,
      saturation: 0,
      lightness: i,
      alpha: e.alpha
    } : {
      hue: 0,
      saturation: 0,
      lightness: i
    };
  var u, c = o - a, d = i > 0.5 ? c / (2 - o - a) : c / (o + a);
  switch (o) {
    case t:
      u = (r - n) / c + (r < n ? 6 : 0);
      break;
    case r:
      u = (n - t) / c + 2;
      break;
    default:
      u = (t - r) / c + 4;
      break;
  }
  return u *= 60, e.alpha !== void 0 ? {
    hue: u,
    saturation: d,
    lightness: i,
    alpha: e.alpha
  } : {
    hue: u,
    saturation: d,
    lightness: i
  };
}
function Cs(e) {
  return xj(fa(e));
}
var _j = function(t) {
  return t.length === 7 && t[1] === t[2] && t[3] === t[4] && t[5] === t[6] ? "#" + t[1] + t[3] + t[5] : t;
}, tS = _j;
function ku(e) {
  var t = e.toString(16);
  return t.length === 1 ? "0" + t : t;
}
function m0(e) {
  return ku(Math.round(e * 255));
}
function Ej(e, t, r) {
  return tS("#" + m0(e) + m0(t) + m0(r));
}
function Zy(e, t, r) {
  return th(e, t, r, Ej);
}
function XS(e, t, r) {
  if (typeof e == "number" && typeof t == "number" && typeof r == "number")
    return Zy(e, t, r);
  if (typeof e == "object" && t === void 0 && r === void 0)
    return Zy(e.hue, e.saturation, e.lightness);
  throw new St(1);
}
function JS(e, t, r, n) {
  if (typeof e == "number" && typeof t == "number" && typeof r == "number" && typeof n == "number")
    return n >= 1 ? Zy(e, t, r) : "rgba(" + th(e, t, r) + "," + n + ")";
  if (typeof e == "object" && t === void 0 && r === void 0 && n === void 0)
    return e.alpha >= 1 ? Zy(e.hue, e.saturation, e.lightness) : "rgba(" + th(e.hue, e.saturation, e.lightness) + "," + e.alpha + ")";
  throw new St(2);
}
function rh(e, t, r) {
  if (typeof e == "number" && typeof t == "number" && typeof r == "number")
    return tS("#" + ku(e) + ku(t) + ku(r));
  if (typeof e == "object" && t === void 0 && r === void 0)
    return tS("#" + ku(e.red) + ku(e.green) + ku(e.blue));
  throw new St(6);
}
function Mp(e, t, r, n) {
  if (typeof e == "string" && typeof t == "number") {
    var o = fa(e);
    return "rgba(" + o.red + "," + o.green + "," + o.blue + "," + t + ")";
  } else {
    if (typeof e == "number" && typeof t == "number" && typeof r == "number" && typeof n == "number")
      return n >= 1 ? rh(e, t, r) : "rgba(" + e + "," + t + "," + r + "," + n + ")";
    if (typeof e == "object" && t === void 0 && r === void 0 && n === void 0)
      return e.alpha >= 1 ? rh(e.red, e.green, e.blue) : "rgba(" + e.red + "," + e.green + "," + e.blue + "," + e.alpha + ")";
  }
  throw new St(7);
}
var Oj = function(t) {
  return typeof t.red == "number" && typeof t.green == "number" && typeof t.blue == "number" && (typeof t.alpha != "number" || typeof t.alpha > "u");
}, kj = function(t) {
  return typeof t.red == "number" && typeof t.green == "number" && typeof t.blue == "number" && typeof t.alpha == "number";
}, Aj = function(t) {
  return typeof t.hue == "number" && typeof t.saturation == "number" && typeof t.lightness == "number" && (typeof t.alpha != "number" || typeof t.alpha > "u");
}, Pj = function(t) {
  return typeof t.hue == "number" && typeof t.saturation == "number" && typeof t.lightness == "number" && typeof t.alpha == "number";
};
function Gi(e) {
  if (typeof e != "object") throw new St(8);
  if (kj(e)) return Mp(e);
  if (Oj(e)) return rh(e);
  if (Pj(e)) return JS(e);
  if (Aj(e)) return XS(e);
  throw new St(8);
}
function UP(e, t, r) {
  return function() {
    var o = r.concat(Array.prototype.slice.call(arguments));
    return o.length >= t ? e.apply(this, o) : UP(e, t, o);
  };
}
function gi(e) {
  return UP(e, e.length, []);
}
function Tj(e, t) {
  if (t === "transparent") return t;
  var r = Cs(t);
  return Gi(ir({}, r, {
    hue: r.hue + parseFloat(e)
  }));
}
var Cj = gi(Tj), $j = Cj;
function Rj(e) {
  if (e === "transparent") return e;
  var t = Cs(e);
  return Gi(ir({}, t, {
    hue: (t.hue + 180) % 360
  }));
}
function Dp(e, t, r) {
  return Math.max(e, Math.min(t, r));
}
function Ij(e, t) {
  if (t === "transparent") return t;
  var r = Cs(t);
  return Gi(ir({}, r, {
    lightness: Dp(0, 1, r.lightness - parseFloat(e))
  }));
}
var Nj = gi(Ij), jj = Nj;
function Lj(e, t) {
  if (t === "transparent") return t;
  var r = Cs(t);
  return Gi(ir({}, r, {
    saturation: Dp(0, 1, r.saturation - parseFloat(e))
  }));
}
var Mj = gi(Lj), Dj = Mj;
function ev(e) {
  if (e === "transparent") return 0;
  var t = fa(e), r = Object.keys(t).map(function(i) {
    var u = t[i] / 255;
    return u <= 0.03928 ? u / 12.92 : Math.pow((u + 0.055) / 1.055, 2.4);
  }), n = r[0], o = r[1], a = r[2];
  return parseFloat((0.2126 * n + 0.7152 * o + 0.0722 * a).toFixed(3));
}
function ZS(e, t) {
  var r = ev(e), n = ev(t);
  return parseFloat((r > n ? (r + 0.05) / (n + 0.05) : (n + 0.05) / (r + 0.05)).toFixed(2));
}
function Fj(e) {
  return e === "transparent" ? e : Gi(ir({}, Cs(e), {
    saturation: 0
  }));
}
function qj(e) {
  if (typeof e == "object" && typeof e.hue == "number" && typeof e.saturation == "number" && typeof e.lightness == "number")
    return e.alpha && typeof e.alpha == "number" ? JS({
      hue: e.hue,
      saturation: e.saturation,
      lightness: e.lightness,
      alpha: e.alpha
    }) : XS({
      hue: e.hue,
      saturation: e.saturation,
      lightness: e.lightness
    });
  throw new St(45);
}
function zj(e) {
  if (e === "transparent") return e;
  var t = fa(e);
  return Gi(ir({}, t, {
    red: 255 - t.red,
    green: 255 - t.green,
    blue: 255 - t.blue
  }));
}
function Bj(e, t) {
  if (t === "transparent") return t;
  var r = Cs(t);
  return Gi(ir({}, r, {
    lightness: Dp(0, 1, r.lightness + parseFloat(e))
  }));
}
var Uj = gi(Bj), Vj = Uj;
function Hj(e, t) {
  var r = ZS(e, t);
  return {
    AA: r >= 4.5,
    AALarge: r >= 3,
    AAA: r >= 7,
    AAALarge: r >= 4.5
  };
}
function Wj(e, t, r) {
  if (t === "transparent") return r;
  if (r === "transparent") return t;
  if (e === 0) return r;
  var n = fa(t), o = ir({}, n, {
    alpha: typeof n.alpha == "number" ? n.alpha : 1
  }), a = fa(r), i = ir({}, a, {
    alpha: typeof a.alpha == "number" ? a.alpha : 1
  }), u = o.alpha - i.alpha, c = parseFloat(e) * 2 - 1, d = c * u === -1 ? c : c + u, m = 1 + c * u, g = (d / m + 1) / 2, v = 1 - g, S = {
    red: Math.floor(o.red * g + i.red * v),
    green: Math.floor(o.green * g + i.green * v),
    blue: Math.floor(o.blue * g + i.blue * v),
    alpha: o.alpha * parseFloat(e) + i.alpha * (1 - parseFloat(e))
  };
  return Mp(S);
}
var Kj = gi(Wj), ex = Kj;
function Qj(e, t) {
  if (t === "transparent") return t;
  var r = fa(t), n = typeof r.alpha == "number" ? r.alpha : 1, o = ir({}, r, {
    alpha: Dp(0, 1, (n * 100 + parseFloat(e) * 100) / 100)
  });
  return Mp(o);
}
var Yj = gi(Qj), Gj = Yj, L1 = "#000", M1 = "#fff";
function Xj(e, t, r, n) {
  t === void 0 && (t = L1), r === void 0 && (r = M1), n === void 0 && (n = !0);
  var o = ev(e) > 0.179, a = o ? t : r;
  return !n || ZS(e, a) >= 4.5 ? a : o ? L1 : M1;
}
function Jj(e) {
  if (typeof e == "object" && typeof e.red == "number" && typeof e.green == "number" && typeof e.blue == "number")
    return typeof e.alpha == "number" ? Mp({
      red: e.red,
      green: e.green,
      blue: e.blue,
      alpha: e.alpha
    }) : rh({
      red: e.red,
      green: e.green,
      blue: e.blue
    });
  throw new St(46);
}
function Zj(e, t) {
  if (t === "transparent") return t;
  var r = Cs(t);
  return Gi(ir({}, r, {
    saturation: Dp(0, 1, r.saturation + parseFloat(e))
  }));
}
var eL = gi(Zj), tL = eL;
function rL(e, t) {
  return t === "transparent" ? t : Gi(ir({}, Cs(t), {
    hue: parseFloat(e)
  }));
}
var nL = gi(rL), iL = nL;
function sL(e, t) {
  return t === "transparent" ? t : Gi(ir({}, Cs(t), {
    lightness: parseFloat(e)
  }));
}
var oL = gi(sL), aL = oL;
function lL(e, t) {
  return t === "transparent" ? t : Gi(ir({}, Cs(t), {
    saturation: parseFloat(e)
  }));
}
var uL = gi(lL), cL = uL;
function pL(e, t) {
  return t === "transparent" ? t : ex(parseFloat(e), "rgb(0, 0, 0)", t);
}
var fL = gi(pL), dL = fL;
function hL(e, t) {
  return t === "transparent" ? t : ex(parseFloat(e), "rgb(255, 255, 255)", t);
}
var mL = gi(hL), gL = mL;
function yL(e, t) {
  if (t === "transparent") return t;
  var r = fa(t), n = typeof r.alpha == "number" ? r.alpha : 1, o = ir({}, r, {
    alpha: Dp(0, 1, +(n * 100 - parseFloat(e) * 100).toFixed(2) / 100)
  });
  return Mp(o);
}
var vL = gi(yL), bL = vL;
function wL() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  var n = Array.isArray(t[0]);
  if (!n && t.length > 8)
    throw new St(64);
  var o = t.map(function(a) {
    if (n && !Array.isArray(a) || !n && Array.isArray(a))
      throw new St(65);
    if (Array.isArray(a) && a.length > 8)
      throw new St(66);
    return Array.isArray(a) ? a.join(" ") : a;
  }).join(", ");
  return {
    animation: o
  };
}
function SL() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return {
    backgroundImage: t.join(", ")
  };
}
function xL() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return {
    background: t.join(", ")
  };
}
var _L = ["top", "right", "bottom", "left"];
function EL(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    r[n - 1] = arguments[n];
  if (typeof e == "string" && _L.indexOf(e) >= 0) {
    var o;
    return o = {}, o["border" + Wd(e) + "Width"] = r[0], o["border" + Wd(e) + "Style"] = r[1], o["border" + Wd(e) + "Color"] = r[2], o;
  } else
    return r.unshift(e), {
      borderWidth: r[0],
      borderStyle: r[1],
      borderColor: r[2]
    };
}
function OL() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return fl.apply(void 0, ["borderColor"].concat(t));
}
function kL(e, t) {
  var r = Wd(e);
  if (!t && t !== 0)
    throw new St(62);
  if (r === "Top" || r === "Bottom") {
    var n;
    return n = {}, n["border" + r + "RightRadius"] = t, n["border" + r + "LeftRadius"] = t, n;
  }
  if (r === "Left" || r === "Right") {
    var o;
    return o = {}, o["borderTop" + r + "Radius"] = t, o["borderBottom" + r + "Radius"] = t, o;
  }
  throw new St(63);
}
function AL() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return fl.apply(void 0, ["borderStyle"].concat(t));
}
function PL() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return fl.apply(void 0, ["borderWidth"].concat(t));
}
function D1(e, t) {
  var r = t ? ":" + t : "";
  return e(r);
}
function VP(e, t, r) {
  if (!t) throw new St(67);
  if (e.length === 0) return D1(t, null);
  for (var n = [], o = 0; o < e.length; o += 1) {
    if (r && r.indexOf(e[o]) < 0)
      throw new St(68);
    n.push(D1(t, e[o]));
  }
  return n = n.join(","), n;
}
var TL = [void 0, null, "active", "focus", "hover"];
function CL(e) {
  return "button" + e + `,
  input[type="button"]` + e + `,
  input[type="reset"]` + e + `,
  input[type="submit"]` + e;
}
function $L() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return VP(t, CL, TL);
}
function RL() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return fl.apply(void 0, ["margin"].concat(t));
}
function IL() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return fl.apply(void 0, ["padding"].concat(t));
}
var NL = ["absolute", "fixed", "relative", "static", "sticky"];
function jL(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    r[n - 1] = arguments[n];
  return NL.indexOf(e) >= 0 && e ? ir({}, fl.apply(void 0, [""].concat(r)), {
    position: e
  }) : fl.apply(void 0, ["", e].concat(r));
}
function LL(e, t) {
  return t === void 0 && (t = e), {
    height: e,
    width: t
  };
}
var ML = [void 0, null, "active", "focus", "hover"];
function DL(e) {
  return 'input[type="color"]' + e + `,
    input[type="date"]` + e + `,
    input[type="datetime"]` + e + `,
    input[type="datetime-local"]` + e + `,
    input[type="email"]` + e + `,
    input[type="month"]` + e + `,
    input[type="number"]` + e + `,
    input[type="password"]` + e + `,
    input[type="search"]` + e + `,
    input[type="tel"]` + e + `,
    input[type="text"]` + e + `,
    input[type="time"]` + e + `,
    input[type="url"]` + e + `,
    input[type="week"]` + e + `,
    input:not([type])` + e + `,
    textarea` + e;
}
function FL() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return VP(t, DL, ML);
}
function qL() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  if (Array.isArray(t[0]) && t.length === 2) {
    var n = t[1];
    if (typeof n != "string")
      throw new St(61);
    var o = t[0].map(function(a) {
      return a + " " + n;
    }).join(", ");
    return {
      transition: o
    };
  } else
    return {
      transition: t.join(", ")
    };
}
const zL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  adjustHue: $j,
  animation: wL,
  backgroundImages: SL,
  backgrounds: xL,
  between: eS,
  border: EL,
  borderColor: OL,
  borderRadius: kL,
  borderStyle: AL,
  borderWidth: PL,
  buttons: $L,
  clearFix: zN,
  complement: Rj,
  cover: BN,
  cssVar: wN,
  darken: jj,
  desaturate: Dj,
  directionalProperty: fl,
  easeIn: LN,
  easeInOut: DN,
  easeOut: qN,
  ellipsis: UN,
  em: AN,
  fluidRange: WN,
  fontFace: ZN,
  getContrast: ZS,
  getLuminance: ev,
  getValueAndUnit: mo,
  grayscale: Fj,
  hiDPI: zP,
  hideText: ej,
  hideVisually: tj,
  hsl: XS,
  hslToColorString: qj,
  hsla: JS,
  important: DP,
  invert: zj,
  lighten: Vj,
  linearGradient: rj,
  margin: RL,
  math: vN,
  meetsContrastGuidelines: Hj,
  mix: ex,
  modularScale: CN,
  normalize: nj,
  opacify: Gj,
  padding: IL,
  parseToHsl: Cs,
  parseToRgb: fa,
  position: jL,
  radialGradient: ij,
  readableColor: Xj,
  rem: RN,
  remToPx: NN,
  retinaImage: sj,
  rgb: rh,
  rgbToColorString: Jj,
  rgba: Mp,
  saturate: tL,
  setHue: iL,
  setLightness: aL,
  setSaturation: cL,
  shade: dL,
  size: LL,
  stripUnit: Jw,
  textInputs: FL,
  timingFunctions: lj,
  tint: gL,
  toColorString: Gi,
  transitions: qL,
  transparentize: bL,
  triangle: pj,
  wordWrap: fj
}, Symbol.toStringTag, { value: "Module" })), BL = /* @__PURE__ */ _o(zL);
var Ny = { exports: {} }, UL = Ny.exports, F1;
function VL() {
  return F1 || (F1 = 1, function(e, t) {
    (function(r, n, o) {
      e.exports = o(), e.exports.default = o();
    })("slugify", UL, function() {
      var r = JSON.parse(`{"$":"dollar","%":"percent","&":"and","<":"less",">":"greater","|":"or","¢":"cent","£":"pound","¤":"currency","¥":"yen","©":"(c)","ª":"a","®":"(r)","º":"o","À":"A","Á":"A","Â":"A","Ã":"A","Ä":"A","Å":"A","Æ":"AE","Ç":"C","È":"E","É":"E","Ê":"E","Ë":"E","Ì":"I","Í":"I","Î":"I","Ï":"I","Ð":"D","Ñ":"N","Ò":"O","Ó":"O","Ô":"O","Õ":"O","Ö":"O","Ø":"O","Ù":"U","Ú":"U","Û":"U","Ü":"U","Ý":"Y","Þ":"TH","ß":"ss","à":"a","á":"a","â":"a","ã":"a","ä":"a","å":"a","æ":"ae","ç":"c","è":"e","é":"e","ê":"e","ë":"e","ì":"i","í":"i","î":"i","ï":"i","ð":"d","ñ":"n","ò":"o","ó":"o","ô":"o","õ":"o","ö":"o","ø":"o","ù":"u","ú":"u","û":"u","ü":"u","ý":"y","þ":"th","ÿ":"y","Ā":"A","ā":"a","Ă":"A","ă":"a","Ą":"A","ą":"a","Ć":"C","ć":"c","Č":"C","č":"c","Ď":"D","ď":"d","Đ":"DJ","đ":"dj","Ē":"E","ē":"e","Ė":"E","ė":"e","Ę":"e","ę":"e","Ě":"E","ě":"e","Ğ":"G","ğ":"g","Ģ":"G","ģ":"g","Ĩ":"I","ĩ":"i","Ī":"i","ī":"i","Į":"I","į":"i","İ":"I","ı":"i","Ķ":"k","ķ":"k","Ļ":"L","ļ":"l","Ľ":"L","ľ":"l","Ł":"L","ł":"l","Ń":"N","ń":"n","Ņ":"N","ņ":"n","Ň":"N","ň":"n","Ō":"O","ō":"o","Ő":"O","ő":"o","Œ":"OE","œ":"oe","Ŕ":"R","ŕ":"r","Ř":"R","ř":"r","Ś":"S","ś":"s","Ş":"S","ş":"s","Š":"S","š":"s","Ţ":"T","ţ":"t","Ť":"T","ť":"t","Ũ":"U","ũ":"u","Ū":"u","ū":"u","Ů":"U","ů":"u","Ű":"U","ű":"u","Ų":"U","ų":"u","Ŵ":"W","ŵ":"w","Ŷ":"Y","ŷ":"y","Ÿ":"Y","Ź":"Z","ź":"z","Ż":"Z","ż":"z","Ž":"Z","ž":"z","Ə":"E","ƒ":"f","Ơ":"O","ơ":"o","Ư":"U","ư":"u","ǈ":"LJ","ǉ":"lj","ǋ":"NJ","ǌ":"nj","Ș":"S","ș":"s","Ț":"T","ț":"t","ə":"e","˚":"o","Ά":"A","Έ":"E","Ή":"H","Ί":"I","Ό":"O","Ύ":"Y","Ώ":"W","ΐ":"i","Α":"A","Β":"B","Γ":"G","Δ":"D","Ε":"E","Ζ":"Z","Η":"H","Θ":"8","Ι":"I","Κ":"K","Λ":"L","Μ":"M","Ν":"N","Ξ":"3","Ο":"O","Π":"P","Ρ":"R","Σ":"S","Τ":"T","Υ":"Y","Φ":"F","Χ":"X","Ψ":"PS","Ω":"W","Ϊ":"I","Ϋ":"Y","ά":"a","έ":"e","ή":"h","ί":"i","ΰ":"y","α":"a","β":"b","γ":"g","δ":"d","ε":"e","ζ":"z","η":"h","θ":"8","ι":"i","κ":"k","λ":"l","μ":"m","ν":"n","ξ":"3","ο":"o","π":"p","ρ":"r","ς":"s","σ":"s","τ":"t","υ":"y","φ":"f","χ":"x","ψ":"ps","ω":"w","ϊ":"i","ϋ":"y","ό":"o","ύ":"y","ώ":"w","Ё":"Yo","Ђ":"DJ","Є":"Ye","І":"I","Ї":"Yi","Ј":"J","Љ":"LJ","Њ":"NJ","Ћ":"C","Џ":"DZ","А":"A","Б":"B","В":"V","Г":"G","Д":"D","Е":"E","Ж":"Zh","З":"Z","И":"I","Й":"J","К":"K","Л":"L","М":"M","Н":"N","О":"O","П":"P","Р":"R","С":"S","Т":"T","У":"U","Ф":"F","Х":"H","Ц":"C","Ч":"Ch","Ш":"Sh","Щ":"Sh","Ъ":"U","Ы":"Y","Ь":"","Э":"E","Ю":"Yu","Я":"Ya","а":"a","б":"b","в":"v","г":"g","д":"d","е":"e","ж":"zh","з":"z","и":"i","й":"j","к":"k","л":"l","м":"m","н":"n","о":"o","п":"p","р":"r","с":"s","т":"t","у":"u","ф":"f","х":"h","ц":"c","ч":"ch","ш":"sh","щ":"sh","ъ":"u","ы":"y","ь":"","э":"e","ю":"yu","я":"ya","ё":"yo","ђ":"dj","є":"ye","і":"i","ї":"yi","ј":"j","љ":"lj","њ":"nj","ћ":"c","ѝ":"u","џ":"dz","Ґ":"G","ґ":"g","Ғ":"GH","ғ":"gh","Қ":"KH","қ":"kh","Ң":"NG","ң":"ng","Ү":"UE","ү":"ue","Ұ":"U","ұ":"u","Һ":"H","һ":"h","Ә":"AE","ә":"ae","Ө":"OE","ө":"oe","฿":"baht","ა":"a","ბ":"b","გ":"g","დ":"d","ე":"e","ვ":"v","ზ":"z","თ":"t","ი":"i","კ":"k","ლ":"l","მ":"m","ნ":"n","ო":"o","პ":"p","ჟ":"zh","რ":"r","ს":"s","ტ":"t","უ":"u","ფ":"f","ქ":"k","ღ":"gh","ყ":"q","შ":"sh","ჩ":"ch","ც":"ts","ძ":"dz","წ":"ts","ჭ":"ch","ხ":"kh","ჯ":"j","ჰ":"h","Ẁ":"W","ẁ":"w","Ẃ":"W","ẃ":"w","Ẅ":"W","ẅ":"w","ẞ":"SS","Ạ":"A","ạ":"a","Ả":"A","ả":"a","Ấ":"A","ấ":"a","Ầ":"A","ầ":"a","Ẩ":"A","ẩ":"a","Ẫ":"A","ẫ":"a","Ậ":"A","ậ":"a","Ắ":"A","ắ":"a","Ằ":"A","ằ":"a","Ẳ":"A","ẳ":"a","Ẵ":"A","ẵ":"a","Ặ":"A","ặ":"a","Ẹ":"E","ẹ":"e","Ẻ":"E","ẻ":"e","Ẽ":"E","ẽ":"e","Ế":"E","ế":"e","Ề":"E","ề":"e","Ể":"E","ể":"e","Ễ":"E","ễ":"e","Ệ":"E","ệ":"e","Ỉ":"I","ỉ":"i","Ị":"I","ị":"i","Ọ":"O","ọ":"o","Ỏ":"O","ỏ":"o","Ố":"O","ố":"o","Ồ":"O","ồ":"o","Ổ":"O","ổ":"o","Ỗ":"O","ỗ":"o","Ộ":"O","ộ":"o","Ớ":"O","ớ":"o","Ờ":"O","ờ":"o","Ở":"O","ở":"o","Ỡ":"O","ỡ":"o","Ợ":"O","ợ":"o","Ụ":"U","ụ":"u","Ủ":"U","ủ":"u","Ứ":"U","ứ":"u","Ừ":"U","ừ":"u","Ử":"U","ử":"u","Ữ":"U","ữ":"u","Ự":"U","ự":"u","Ỳ":"Y","ỳ":"y","Ỵ":"Y","ỵ":"y","Ỷ":"Y","ỷ":"y","Ỹ":"Y","ỹ":"y","‘":"'","’":"'","“":"\\"","”":"\\"","†":"+","•":"*","…":"...","₠":"ecu","₢":"cruzeiro","₣":"french franc","₤":"lira","₥":"mill","₦":"naira","₧":"peseta","₨":"rupee","₩":"won","₪":"new shequel","₫":"dong","€":"euro","₭":"kip","₮":"tugrik","₯":"drachma","₰":"penny","₱":"peso","₲":"guarani","₳":"austral","₴":"hryvnia","₵":"cedi","₸":"kazakhstani tenge","₹":"indian rupee","₺":"turkish lira","₽":"russian ruble","₿":"bitcoin","℠":"sm","™":"tm","∂":"d","∆":"delta","∑":"sum","∞":"infinity","♥":"love","元":"yuan","円":"yen","﷼":"rial"}`), n = JSON.parse('{"de":{"Ä":"AE","ä":"ae","Ö":"OE","ö":"oe","Ü":"UE","ü":"ue","%":"prozent","&":"und","|":"oder","∑":"summe","∞":"unendlich","♥":"liebe"},"vi":{"Đ":"D","đ":"d"},"fr":{"%":"pourcent","&":"et","<":"plus petit",">":"plus grand","|":"ou","¢":"centime","£":"livre","¤":"devise","₣":"franc","∑":"somme","∞":"infini","♥":"amour"}}');
      function o(a, i) {
        if (typeof a != "string")
          throw new Error("slugify: string argument expected");
        i = typeof i == "string" ? { replacement: i } : i || {};
        var u = n[i.locale] || {}, c = i.replacement === void 0 ? "-" : i.replacement, d = a.split("").reduce(function(m, g) {
          return m + (u[g] || r[g] || g).replace(i.remove || /[^\w\s$*_+~.()'"!\-:@]+/g, "");
        }, "").trim().replace(new RegExp("[\\s" + c + "]+", "g"), c);
        return i.lower && (d = d.toLowerCase()), i.strict && (d = d.replace(new RegExp("[^a-zA-Z0-9" + c + "]", "g"), "").replace(new RegExp("[\\s" + c + "]+", "g"), c)), d;
      }
      return o.extend = function(a) {
        for (var i in a)
          r[i] = a[i];
      }, o;
    });
  }(Ny)), Ny.exports;
}
var Lr = function() {
  return Lr = Object.assign || function(t) {
    for (var r, n = 1, o = arguments.length; n < o; n++) {
      r = arguments[n];
      for (var a in r) Object.prototype.hasOwnProperty.call(r, a) && (t[a] = r[a]);
    }
    return t;
  }, Lr.apply(this, arguments);
};
function Ep(e, t, r) {
  if (r || arguments.length === 2) for (var n = 0, o = t.length, a; n < o; n++)
    (a || !(n in t)) && (a || (a = Array.prototype.slice.call(t, 0, n)), a[n] = t[n]);
  return e.concat(a || Array.prototype.slice.call(t));
}
var g0, q1;
function HL() {
  return q1 || (q1 = 1, g0 = function(t, r, n, o) {
    var a = n ? n.call(o, t, r) : void 0;
    if (a !== void 0)
      return !!a;
    if (t === r)
      return !0;
    if (typeof t != "object" || !t || typeof r != "object" || !r)
      return !1;
    var i = Object.keys(t), u = Object.keys(r);
    if (i.length !== u.length)
      return !1;
    for (var c = Object.prototype.hasOwnProperty.bind(r), d = 0; d < i.length; d++) {
      var m = i[d];
      if (!c(m))
        return !1;
      var g = t[m], v = r[m];
      if (a = n ? n.call(o, g, v, m) : void 0, a === !1 || a === void 0 && g !== v)
        return !1;
    }
    return !0;
  }), g0;
}
var WL = HL();
const KL = /* @__PURE__ */ NS(WL);
var lr = "-ms-", Kd = "-moz-", Wt = "-webkit-", HP = "comm", qv = "rule", tx = "decl", QL = "@import", WP = "@keyframes", YL = "@layer", KP = Math.abs, rx = String.fromCharCode, rS = Object.assign;
function GL(e, t) {
  return Qr(e, 0) ^ 45 ? (((t << 2 ^ Qr(e, 0)) << 2 ^ Qr(e, 1)) << 2 ^ Qr(e, 2)) << 2 ^ Qr(e, 3) : 0;
}
function QP(e) {
  return e.trim();
}
function ia(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function $t(e, t, r) {
  return e.replace(t, r);
}
function jy(e, t, r) {
  return e.indexOf(t, r);
}
function Qr(e, t) {
  return e.charCodeAt(t) | 0;
}
function Op(e, t, r) {
  return e.slice(t, r);
}
function fo(e) {
  return e.length;
}
function YP(e) {
  return e.length;
}
function Bd(e, t) {
  return t.push(e), e;
}
function XL(e, t) {
  return e.map(t).join("");
}
function z1(e, t) {
  return e.filter(function(r) {
    return !ia(r, t);
  });
}
var zv = 1, kp = 1, GP = 0, Qi = 0, jr = 0, Fp = "";
function Bv(e, t, r, n, o, a, i, u) {
  return { value: e, root: t, parent: r, type: n, props: o, children: a, line: zv, column: kp, length: i, return: "", siblings: u };
}
function nl(e, t) {
  return rS(Bv("", null, null, "", null, null, 0, e.siblings), e, { length: -e.length }, t);
}
function rp(e) {
  for (; e.root; )
    e = nl(e.root, { children: [e] });
  Bd(e, e.siblings);
}
function JL() {
  return jr;
}
function ZL() {
  return jr = Qi > 0 ? Qr(Fp, --Qi) : 0, kp--, jr === 10 && (kp = 1, zv--), jr;
}
function Es() {
  return jr = Qi < GP ? Qr(Fp, Qi++) : 0, kp++, jr === 10 && (kp = 1, zv++), jr;
}
function $u() {
  return Qr(Fp, Qi);
}
function Ly() {
  return Qi;
}
function Uv(e, t) {
  return Op(Fp, e, t);
}
function nS(e) {
  switch (e) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function e2(e) {
  return zv = kp = 1, GP = fo(Fp = e), Qi = 0, [];
}
function t2(e) {
  return Fp = "", e;
}
function y0(e) {
  return QP(Uv(Qi - 1, iS(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function r2(e) {
  for (; (jr = $u()) && jr < 33; )
    Es();
  return nS(e) > 2 || nS(jr) > 3 ? "" : " ";
}
function n2(e, t) {
  for (; --t && Es() && !(jr < 48 || jr > 102 || jr > 57 && jr < 65 || jr > 70 && jr < 97); )
    ;
  return Uv(e, Ly() + (t < 6 && $u() == 32 && Es() == 32));
}
function iS(e) {
  for (; Es(); )
    switch (jr) {
      // ] ) " '
      case e:
        return Qi;
      // " '
      case 34:
      case 39:
        e !== 34 && e !== 39 && iS(jr);
        break;
      // (
      case 40:
        e === 41 && iS(e);
        break;
      // \
      case 92:
        Es();
        break;
    }
  return Qi;
}
function i2(e, t) {
  for (; Es() && e + jr !== 57; )
    if (e + jr === 84 && $u() === 47)
      break;
  return "/*" + Uv(t, Qi - 1) + "*" + rx(e === 47 ? e : Es());
}
function s2(e) {
  for (; !nS($u()); )
    Es();
  return Uv(e, Qi);
}
function o2(e) {
  return t2(My("", null, null, null, [""], e = e2(e), 0, [0], e));
}
function My(e, t, r, n, o, a, i, u, c) {
  for (var d = 0, m = 0, g = i, v = 0, S = 0, k = 0, b = 1, x = 1, A = 1, _ = 0, O = "", R = o, C = a, T = n, j = O; x; )
    switch (k = _, _ = Es()) {
      // (
      case 40:
        if (k != 108 && Qr(j, g - 1) == 58) {
          jy(j += $t(y0(_), "&", "&\f"), "&\f", KP(d ? u[d - 1] : 0)) != -1 && (A = -1);
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        j += y0(_);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        j += r2(k);
        break;
      // \
      case 92:
        j += n2(Ly() - 1, 7);
        continue;
      // /
      case 47:
        switch ($u()) {
          case 42:
          case 47:
            Bd(a2(i2(Es(), Ly()), t, r, c), c);
            break;
          default:
            j += "/";
        }
        break;
      // {
      case 123 * b:
        u[d++] = fo(j) * A;
      // } ; \0
      case 125 * b:
      case 59:
      case 0:
        switch (_) {
          // \0 }
          case 0:
          case 125:
            x = 0;
          // ;
          case 59 + m:
            A == -1 && (j = $t(j, /\f/g, "")), S > 0 && fo(j) - g && Bd(S > 32 ? U1(j + ";", n, r, g - 1, c) : U1($t(j, " ", "") + ";", n, r, g - 2, c), c);
            break;
          // @ ;
          case 59:
            j += ";";
          // { rule/at-rule
          default:
            if (Bd(T = B1(j, t, r, d, m, o, u, O, R = [], C = [], g, a), a), _ === 123)
              if (m === 0)
                My(j, t, T, T, R, a, g, u, C);
              else
                switch (v === 99 && Qr(j, 3) === 110 ? 100 : v) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    My(e, T, T, n && Bd(B1(e, T, T, 0, 0, o, u, O, o, R = [], g, C), C), o, C, g, u, n ? R : C);
                    break;
                  default:
                    My(j, T, T, T, [""], C, 0, u, C);
                }
        }
        d = m = S = 0, b = A = 1, O = j = "", g = i;
        break;
      // :
      case 58:
        g = 1 + fo(j), S = k;
      default:
        if (b < 1) {
          if (_ == 123)
            --b;
          else if (_ == 125 && b++ == 0 && ZL() == 125)
            continue;
        }
        switch (j += rx(_), _ * b) {
          // &
          case 38:
            A = m > 0 ? 1 : (j += "\f", -1);
            break;
          // ,
          case 44:
            u[d++] = (fo(j) - 1) * A, A = 1;
            break;
          // @
          case 64:
            $u() === 45 && (j += y0(Es())), v = $u(), m = g = fo(O = j += s2(Ly())), _++;
            break;
          // -
          case 45:
            k === 45 && fo(j) == 2 && (b = 0);
        }
    }
  return a;
}
function B1(e, t, r, n, o, a, i, u, c, d, m, g) {
  for (var v = o - 1, S = o === 0 ? a : [""], k = YP(S), b = 0, x = 0, A = 0; b < n; ++b)
    for (var _ = 0, O = Op(e, v + 1, v = KP(x = i[b])), R = e; _ < k; ++_)
      (R = QP(x > 0 ? S[_] + " " + O : $t(O, /&\f/g, S[_]))) && (c[A++] = R);
  return Bv(e, t, r, o === 0 ? qv : u, c, d, m, g);
}
function a2(e, t, r, n) {
  return Bv(e, t, r, HP, rx(JL()), Op(e, 2, -2), 0, n);
}
function U1(e, t, r, n, o) {
  return Bv(e, t, r, tx, Op(e, 0, n), Op(e, n + 1, -1), n, o);
}
function XP(e, t, r) {
  switch (GL(e, t)) {
    // color-adjust
    case 5103:
      return Wt + "print-" + e + e;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return Wt + e + e;
    // tab-size
    case 4789:
      return Kd + e + e;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return Wt + e + Kd + e + lr + e + e;
    // writing-mode
    case 5936:
      switch (Qr(e, t + 11)) {
        // vertical-l(r)
        case 114:
          return Wt + e + lr + $t(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        // vertical-r(l)
        case 108:
          return Wt + e + lr + $t(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        // horizontal(-)tb
        case 45:
          return Wt + e + lr + $t(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
    // flex, flex-direction, scroll-snap-type, writing-mode
    case 6828:
    case 4268:
    case 2903:
      return Wt + e + lr + e + e;
    // order
    case 6165:
      return Wt + e + lr + "flex-" + e + e;
    // align-items
    case 5187:
      return Wt + e + $t(e, /(\w+).+(:[^]+)/, Wt + "box-$1$2" + lr + "flex-$1$2") + e;
    // align-self
    case 5443:
      return Wt + e + lr + "flex-item-" + $t(e, /flex-|-self/g, "") + (ia(e, /flex-|baseline/) ? "" : lr + "grid-row-" + $t(e, /flex-|-self/g, "")) + e;
    // align-content
    case 4675:
      return Wt + e + lr + "flex-line-pack" + $t(e, /align-content|flex-|-self/g, "") + e;
    // flex-shrink
    case 5548:
      return Wt + e + lr + $t(e, "shrink", "negative") + e;
    // flex-basis
    case 5292:
      return Wt + e + lr + $t(e, "basis", "preferred-size") + e;
    // flex-grow
    case 6060:
      return Wt + "box-" + $t(e, "-grow", "") + Wt + e + lr + $t(e, "grow", "positive") + e;
    // transition
    case 4554:
      return Wt + $t(e, /([^-])(transform)/g, "$1" + Wt + "$2") + e;
    // cursor
    case 6187:
      return $t($t($t(e, /(zoom-|grab)/, Wt + "$1"), /(image-set)/, Wt + "$1"), e, "") + e;
    // background, background-image
    case 5495:
    case 3959:
      return $t(e, /(image-set\([^]*)/, Wt + "$1$`$1");
    // justify-content
    case 4968:
      return $t($t(e, /(.+:)(flex-)?(.*)/, Wt + "box-pack:$3" + lr + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + Wt + e + e;
    // justify-self
    case 4200:
      if (!ia(e, /flex-|baseline/)) return lr + "grid-column-align" + Op(e, t) + e;
      break;
    // grid-template-(columns|rows)
    case 2592:
    case 3360:
      return lr + $t(e, "template-", "") + e;
    // grid-(row|column)-start
    case 4384:
    case 3616:
      return r && r.some(function(n, o) {
        return t = o, ia(n.props, /grid-\w+-end/);
      }) ? ~jy(e + (r = r[t].value), "span", 0) ? e : lr + $t(e, "-start", "") + e + lr + "grid-row-span:" + (~jy(r, "span", 0) ? ia(r, /\d+/) : +ia(r, /\d+/) - +ia(e, /\d+/)) + ";" : lr + $t(e, "-start", "") + e;
    // grid-(row|column)-end
    case 4896:
    case 4128:
      return r && r.some(function(n) {
        return ia(n.props, /grid-\w+-start/);
      }) ? e : lr + $t($t(e, "-end", "-span"), "span ", "") + e;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return $t(e, /(.+)-inline(.+)/, Wt + "$1$2") + e;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (fo(e) - 1 - t > 6)
        switch (Qr(e, t + 1)) {
          // (m)ax-content, (m)in-content
          case 109:
            if (Qr(e, t + 4) !== 45)
              break;
          // (f)ill-available, (f)it-content
          case 102:
            return $t(e, /(.+:)(.+)-([^]+)/, "$1" + Wt + "$2-$3$1" + Kd + (Qr(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
          // (s)tretch
          case 115:
            return ~jy(e, "stretch", 0) ? XP($t(e, "stretch", "fill-available"), t, r) + e : e;
        }
      break;
    // grid-(column|row)
    case 5152:
    case 5920:
      return $t(e, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(n, o, a, i, u, c, d) {
        return lr + o + ":" + a + d + (i ? lr + o + "-span:" + (u ? c : +c - +a) + d : "") + e;
      });
    // position: sticky
    case 4949:
      if (Qr(e, t + 6) === 121)
        return $t(e, ":", ":" + Wt) + e;
      break;
    // display: (flex|inline-flex|grid|inline-grid)
    case 6444:
      switch (Qr(e, Qr(e, 14) === 45 ? 18 : 11)) {
        // (inline-)?fle(x)
        case 120:
          return $t(e, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + Wt + (Qr(e, 14) === 45 ? "inline-" : "") + "box$3$1" + Wt + "$2$3$1" + lr + "$2box$3") + e;
        // (inline-)?gri(d)
        case 100:
          return $t(e, ":", ":" + lr) + e;
      }
      break;
    // scroll-margin, scroll-margin-(top|right|bottom|left)
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return $t(e, "scroll-", "scroll-snap-") + e;
  }
  return e;
}
function tv(e, t) {
  for (var r = "", n = 0; n < e.length; n++)
    r += t(e[n], n, e, t) || "";
  return r;
}
function l2(e, t, r, n) {
  switch (e.type) {
    case YL:
      if (e.children.length) break;
    case QL:
    case tx:
      return e.return = e.return || e.value;
    case HP:
      return "";
    case WP:
      return e.return = e.value + "{" + tv(e.children, n) + "}";
    case qv:
      if (!fo(e.value = e.props.join(","))) return "";
  }
  return fo(r = tv(e.children, n)) ? e.return = e.value + "{" + r + "}" : "";
}
function u2(e) {
  var t = YP(e);
  return function(r, n, o, a) {
    for (var i = "", u = 0; u < t; u++)
      i += e[u](r, n, o, a) || "";
    return i;
  };
}
function c2(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function p2(e, t, r, n) {
  if (e.length > -1 && !e.return)
    switch (e.type) {
      case tx:
        e.return = XP(e.value, e.length, r);
        return;
      case WP:
        return tv([nl(e, { value: $t(e.value, "@", "@" + Wt) })], n);
      case qv:
        if (e.length)
          return XL(r = e.props, function(o) {
            switch (ia(o, n = /(::plac\w+|:read-\w+)/)) {
              // :read-(only|write)
              case ":read-only":
              case ":read-write":
                rp(nl(e, { props: [$t(o, /:(read-\w+)/, ":" + Kd + "$1")] })), rp(nl(e, { props: [o] })), rS(e, { props: z1(r, n) });
                break;
              // :placeholder
              case "::placeholder":
                rp(nl(e, { props: [$t(o, /:(plac\w+)/, ":" + Wt + "input-$1")] })), rp(nl(e, { props: [$t(o, /:(plac\w+)/, ":" + Kd + "$1")] })), rp(nl(e, { props: [$t(o, /:(plac\w+)/, lr + "input-$1")] })), rp(nl(e, { props: [o] })), rS(e, { props: z1(r, n) });
                break;
            }
            return "";
          });
    }
}
var f2 = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, dl = typeof process < "u" && process.env !== void 0 && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled", JP = "active", rv = "data-styled-version", Iu = "6.1.18", nx = `/*!sc*/
`, nv = typeof window < "u" && typeof document < "u", d2 = !!(typeof SC_DISABLE_SPEEDY == "boolean" ? SC_DISABLE_SPEEDY : typeof process < "u" && process.env !== void 0 && process.env.REACT_APP_SC_DISABLE_SPEEDY !== void 0 && process.env.REACT_APP_SC_DISABLE_SPEEDY !== "" ? process.env.REACT_APP_SC_DISABLE_SPEEDY !== "false" && process.env.REACT_APP_SC_DISABLE_SPEEDY : typeof process < "u" && process.env !== void 0 && process.env.SC_DISABLE_SPEEDY !== void 0 && process.env.SC_DISABLE_SPEEDY !== "" && process.env.SC_DISABLE_SPEEDY !== "false" && process.env.SC_DISABLE_SPEEDY), h2 = {}, Vv = Object.freeze([]), Ap = Object.freeze({});
function ix(e, t, r) {
  return r === void 0 && (r = Ap), e.theme !== r.theme && e.theme || t || r.theme;
}
var ZP = /* @__PURE__ */ new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]), m2 = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, g2 = /(^-|-$)/g;
function V1(e) {
  return e.replace(m2, "-").replace(g2, "");
}
var y2 = /(a)(d)/gi, fg = 52, H1 = function(e) {
  return String.fromCharCode(e + (e > 25 ? 39 : 97));
};
function sS(e) {
  var t, r = "";
  for (t = Math.abs(e); t > fg; t = t / fg | 0) r = H1(t % fg) + r;
  return (H1(t % fg) + r).replace(y2, "$1-$2");
}
var v0, eT = 5381, mp = function(e, t) {
  for (var r = t.length; r; ) e = 33 * e ^ t.charCodeAt(--r);
  return e;
}, tT = function(e) {
  return mp(eT, e);
};
function sx(e) {
  return sS(tT(e) >>> 0);
}
function rT(e) {
  return e.displayName || e.name || "Component";
}
function b0(e) {
  return typeof e == "string" && !0;
}
var nT = typeof Symbol == "function" && Symbol.for, iT = nT ? Symbol.for("react.memo") : 60115, v2 = nT ? Symbol.for("react.forward_ref") : 60112, b2 = { childContextTypes: !0, contextType: !0, contextTypes: !0, defaultProps: !0, displayName: !0, getDefaultProps: !0, getDerivedStateFromError: !0, getDerivedStateFromProps: !0, mixins: !0, propTypes: !0, type: !0 }, w2 = { name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0 }, sT = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 }, S2 = ((v0 = {})[v2] = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 }, v0[iT] = sT, v0);
function W1(e) {
  return ("type" in (t = e) && t.type.$$typeof) === iT ? sT : "$$typeof" in e ? S2[e.$$typeof] : b2;
  var t;
}
var x2 = Object.defineProperty, _2 = Object.getOwnPropertyNames, K1 = Object.getOwnPropertySymbols, E2 = Object.getOwnPropertyDescriptor, O2 = Object.getPrototypeOf, Q1 = Object.prototype;
function ox(e, t, r) {
  if (typeof t != "string") {
    if (Q1) {
      var n = O2(t);
      n && n !== Q1 && ox(e, n, r);
    }
    var o = _2(t);
    K1 && (o = o.concat(K1(t)));
    for (var a = W1(e), i = W1(t), u = 0; u < o.length; ++u) {
      var c = o[u];
      if (!(c in w2 || r && r[c] || i && c in i || a && c in a)) {
        var d = E2(t, c);
        try {
          x2(e, c, d);
        } catch {
        }
      }
    }
  }
  return e;
}
function Nu(e) {
  return typeof e == "function";
}
function Hv(e) {
  return typeof e == "object" && "styledComponentId" in e;
}
function Cu(e, t) {
  return e && t ? "".concat(e, " ").concat(t) : e || t || "";
}
function nh(e, t) {
  if (e.length === 0) return "";
  for (var r = e[0], n = 1; n < e.length; n++) r += t ? t + e[n] : e[n];
  return r;
}
function ih(e) {
  return e !== null && typeof e == "object" && e.constructor.name === Object.name && !("props" in e && e.$$typeof);
}
function oS(e, t, r) {
  if (r === void 0 && (r = !1), !r && !ih(e) && !Array.isArray(e)) return t;
  if (Array.isArray(t)) for (var n = 0; n < t.length; n++) e[n] = oS(e[n], t[n]);
  else if (ih(t)) for (var n in t) e[n] = oS(e[n], t[n]);
  return e;
}
function ax(e, t) {
  Object.defineProperty(e, "toString", { value: t });
}
function Hi(e) {
  for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
  return new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(e, " for more information.").concat(t.length > 0 ? " Args: ".concat(t.join(", ")) : ""));
}
var k2 = function() {
  function e(t) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = t;
  }
  return e.prototype.indexOfGroup = function(t) {
    for (var r = 0, n = 0; n < t; n++) r += this.groupSizes[n];
    return r;
  }, e.prototype.insertRules = function(t, r) {
    if (t >= this.groupSizes.length) {
      for (var n = this.groupSizes, o = n.length, a = o; t >= a; ) if ((a <<= 1) < 0) throw Hi(16, "".concat(t));
      this.groupSizes = new Uint32Array(a), this.groupSizes.set(n), this.length = a;
      for (var i = o; i < a; i++) this.groupSizes[i] = 0;
    }
    for (var u = this.indexOfGroup(t + 1), c = (i = 0, r.length); i < c; i++) this.tag.insertRule(u, r[i]) && (this.groupSizes[t]++, u++);
  }, e.prototype.clearGroup = function(t) {
    if (t < this.length) {
      var r = this.groupSizes[t], n = this.indexOfGroup(t), o = n + r;
      this.groupSizes[t] = 0;
      for (var a = n; a < o; a++) this.tag.deleteRule(n);
    }
  }, e.prototype.getGroup = function(t) {
    var r = "";
    if (t >= this.length || this.groupSizes[t] === 0) return r;
    for (var n = this.groupSizes[t], o = this.indexOfGroup(t), a = o + n, i = o; i < a; i++) r += "".concat(this.tag.getRule(i)).concat(nx);
    return r;
  }, e;
}(), Dy = /* @__PURE__ */ new Map(), iv = /* @__PURE__ */ new Map(), Fy = 1, dg = function(e) {
  if (Dy.has(e)) return Dy.get(e);
  for (; iv.has(Fy); ) Fy++;
  var t = Fy++;
  return Dy.set(e, t), iv.set(t, e), t;
}, A2 = function(e, t) {
  Fy = t + 1, Dy.set(e, t), iv.set(t, e);
}, P2 = "style[".concat(dl, "][").concat(rv, '="').concat(Iu, '"]'), T2 = new RegExp("^".concat(dl, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')), C2 = function(e, t, r) {
  for (var n, o = r.split(","), a = 0, i = o.length; a < i; a++) (n = o[a]) && e.registerName(t, n);
}, $2 = function(e, t) {
  for (var r, n = ((r = t.textContent) !== null && r !== void 0 ? r : "").split(nx), o = [], a = 0, i = n.length; a < i; a++) {
    var u = n[a].trim();
    if (u) {
      var c = u.match(T2);
      if (c) {
        var d = 0 | parseInt(c[1], 10), m = c[2];
        d !== 0 && (A2(m, d), C2(e, m, c[3]), e.getTag().insertRules(d, o)), o.length = 0;
      } else o.push(u);
    }
  }
}, Y1 = function(e) {
  for (var t = document.querySelectorAll(P2), r = 0, n = t.length; r < n; r++) {
    var o = t[r];
    o && o.getAttribute(dl) !== JP && ($2(e, o), o.parentNode && o.parentNode.removeChild(o));
  }
};
function aS() {
  return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : null;
}
var oT = function(e) {
  var t = document.head, r = e || t, n = document.createElement("style"), o = function(u) {
    var c = Array.from(u.querySelectorAll("style[".concat(dl, "]")));
    return c[c.length - 1];
  }(r), a = o !== void 0 ? o.nextSibling : null;
  n.setAttribute(dl, JP), n.setAttribute(rv, Iu);
  var i = aS();
  return i && n.setAttribute("nonce", i), r.insertBefore(n, a), n;
}, R2 = function() {
  function e(t) {
    this.element = oT(t), this.element.appendChild(document.createTextNode("")), this.sheet = function(r) {
      if (r.sheet) return r.sheet;
      for (var n = document.styleSheets, o = 0, a = n.length; o < a; o++) {
        var i = n[o];
        if (i.ownerNode === r) return i;
      }
      throw Hi(17);
    }(this.element), this.length = 0;
  }
  return e.prototype.insertRule = function(t, r) {
    try {
      return this.sheet.insertRule(r, t), this.length++, !0;
    } catch {
      return !1;
    }
  }, e.prototype.deleteRule = function(t) {
    this.sheet.deleteRule(t), this.length--;
  }, e.prototype.getRule = function(t) {
    var r = this.sheet.cssRules[t];
    return r && r.cssText ? r.cssText : "";
  }, e;
}(), I2 = function() {
  function e(t) {
    this.element = oT(t), this.nodes = this.element.childNodes, this.length = 0;
  }
  return e.prototype.insertRule = function(t, r) {
    if (t <= this.length && t >= 0) {
      var n = document.createTextNode(r);
      return this.element.insertBefore(n, this.nodes[t] || null), this.length++, !0;
    }
    return !1;
  }, e.prototype.deleteRule = function(t) {
    this.element.removeChild(this.nodes[t]), this.length--;
  }, e.prototype.getRule = function(t) {
    return t < this.length ? this.nodes[t].textContent : "";
  }, e;
}(), N2 = function() {
  function e(t) {
    this.rules = [], this.length = 0;
  }
  return e.prototype.insertRule = function(t, r) {
    return t <= this.length && (this.rules.splice(t, 0, r), this.length++, !0);
  }, e.prototype.deleteRule = function(t) {
    this.rules.splice(t, 1), this.length--;
  }, e.prototype.getRule = function(t) {
    return t < this.length ? this.rules[t] : "";
  }, e;
}(), G1 = nv, j2 = { isServer: !nv, useCSSOMInjection: !d2 }, Pp = function() {
  function e(t, r, n) {
    t === void 0 && (t = Ap), r === void 0 && (r = {});
    var o = this;
    this.options = Lr(Lr({}, j2), t), this.gs = r, this.names = new Map(n), this.server = !!t.isServer, !this.server && nv && G1 && (G1 = !1, Y1(this)), ax(this, function() {
      return function(a) {
        for (var i = a.getTag(), u = i.length, c = "", d = function(g) {
          var v = function(A) {
            return iv.get(A);
          }(g);
          if (v === void 0) return "continue";
          var S = a.names.get(v), k = i.getGroup(g);
          if (S === void 0 || !S.size || k.length === 0) return "continue";
          var b = "".concat(dl, ".g").concat(g, '[id="').concat(v, '"]'), x = "";
          S !== void 0 && S.forEach(function(A) {
            A.length > 0 && (x += "".concat(A, ","));
          }), c += "".concat(k).concat(b, '{content:"').concat(x, '"}').concat(nx);
        }, m = 0; m < u; m++) d(m);
        return c;
      }(o);
    });
  }
  return e.registerId = function(t) {
    return dg(t);
  }, e.prototype.rehydrate = function() {
    !this.server && nv && Y1(this);
  }, e.prototype.reconstructWithOptions = function(t, r) {
    return r === void 0 && (r = !0), new e(Lr(Lr({}, this.options), t), this.gs, r && this.names || void 0);
  }, e.prototype.allocateGSInstance = function(t) {
    return this.gs[t] = (this.gs[t] || 0) + 1;
  }, e.prototype.getTag = function() {
    return this.tag || (this.tag = (t = function(r) {
      var n = r.useCSSOMInjection, o = r.target;
      return r.isServer ? new N2(o) : n ? new R2(o) : new I2(o);
    }(this.options), new k2(t)));
    var t;
  }, e.prototype.hasNameForId = function(t, r) {
    return this.names.has(t) && this.names.get(t).has(r);
  }, e.prototype.registerName = function(t, r) {
    if (dg(t), this.names.has(t)) this.names.get(t).add(r);
    else {
      var n = /* @__PURE__ */ new Set();
      n.add(r), this.names.set(t, n);
    }
  }, e.prototype.insertRules = function(t, r, n) {
    this.registerName(t, r), this.getTag().insertRules(dg(t), n);
  }, e.prototype.clearNames = function(t) {
    this.names.has(t) && this.names.get(t).clear();
  }, e.prototype.clearRules = function(t) {
    this.getTag().clearGroup(dg(t)), this.clearNames(t);
  }, e.prototype.clearTag = function() {
    this.tag = void 0;
  }, e;
}(), L2 = /&/g, M2 = /^\s*\/\/.*$/gm;
function aT(e, t) {
  return e.map(function(r) {
    return r.type === "rule" && (r.value = "".concat(t, " ").concat(r.value), r.value = r.value.replaceAll(",", ",".concat(t, " ")), r.props = r.props.map(function(n) {
      return "".concat(t, " ").concat(n);
    })), Array.isArray(r.children) && r.type !== "@keyframes" && (r.children = aT(r.children, t)), r;
  });
}
function lT(e) {
  var t, r, n, o = e === void 0 ? Ap : e, a = o.options, i = a === void 0 ? Ap : a, u = o.plugins, c = u === void 0 ? Vv : u, d = function(v, S, k) {
    return k.startsWith(r) && k.endsWith(r) && k.replaceAll(r, "").length > 0 ? ".".concat(t) : v;
  }, m = c.slice();
  m.push(function(v) {
    v.type === qv && v.value.includes("&") && (v.props[0] = v.props[0].replace(L2, r).replace(n, d));
  }), i.prefix && m.push(p2), m.push(l2);
  var g = function(v, S, k, b) {
    S === void 0 && (S = ""), k === void 0 && (k = ""), b === void 0 && (b = "&"), t = b, r = S, n = new RegExp("\\".concat(r, "\\b"), "g");
    var x = v.replace(M2, ""), A = o2(k || S ? "".concat(k, " ").concat(S, " { ").concat(x, " }") : x);
    i.namespace && (A = aT(A, i.namespace));
    var _ = [];
    return tv(A, u2(m.concat(c2(function(O) {
      return _.push(O);
    })))), _;
  };
  return g.hash = c.length ? c.reduce(function(v, S) {
    return S.name || Hi(15), mp(v, S.name);
  }, eT).toString() : "", g;
}
var uT = new Pp(), lS = lT(), Wv = Rt.createContext({ shouldForwardProp: void 0, styleSheet: uT, stylis: lS }), D2 = Wv.Consumer, F2 = Rt.createContext(void 0);
function sv() {
  return Pt.useContext(Wv);
}
function cT(e) {
  var t = Pt.useState(e.stylisPlugins), r = t[0], n = t[1], o = sv().styleSheet, a = Pt.useMemo(function() {
    var c = o;
    return e.sheet ? c = e.sheet : e.target && (c = c.reconstructWithOptions({ target: e.target }, !1)), e.disableCSSOMInjection && (c = c.reconstructWithOptions({ useCSSOMInjection: !1 })), c;
  }, [e.disableCSSOMInjection, e.sheet, e.target, o]), i = Pt.useMemo(function() {
    return lT({ options: { namespace: e.namespace, prefix: e.enableVendorPrefixes }, plugins: r });
  }, [e.enableVendorPrefixes, e.namespace, r]);
  Pt.useEffect(function() {
    KL(r, e.stylisPlugins) || n(e.stylisPlugins);
  }, [e.stylisPlugins]);
  var u = Pt.useMemo(function() {
    return { shouldForwardProp: e.shouldForwardProp, styleSheet: a, stylis: i };
  }, [e.shouldForwardProp, a, i]);
  return Rt.createElement(Wv.Provider, { value: u }, Rt.createElement(F2.Provider, { value: i }, e.children));
}
var pT = function() {
  function e(t, r) {
    var n = this;
    this.inject = function(o, a) {
      a === void 0 && (a = lS);
      var i = n.name + a.hash;
      o.hasNameForId(n.id, i) || o.insertRules(n.id, i, a(n.rules, i, "@keyframes"));
    }, this.name = t, this.id = "sc-keyframes-".concat(t), this.rules = r, ax(this, function() {
      throw Hi(12, String(n.name));
    });
  }
  return e.prototype.getName = function(t) {
    return t === void 0 && (t = lS), this.name + t.hash;
  }, e;
}(), q2 = function(e) {
  return e >= "A" && e <= "Z";
};
function X1(e) {
  for (var t = "", r = 0; r < e.length; r++) {
    var n = e[r];
    if (r === 1 && n === "-" && e[0] === "-") return e;
    q2(n) ? t += "-" + n.toLowerCase() : t += n;
  }
  return t.startsWith("ms-") ? "-" + t : t;
}
var fT = function(e) {
  return e == null || e === !1 || e === "";
}, dT = function(e) {
  var t, r, n = [];
  for (var o in e) {
    var a = e[o];
    e.hasOwnProperty(o) && !fT(a) && (Array.isArray(a) && a.isCss || Nu(a) ? n.push("".concat(X1(o), ":"), a, ";") : ih(a) ? n.push.apply(n, Ep(Ep(["".concat(o, " {")], dT(a), !1), ["}"], !1)) : n.push("".concat(X1(o), ": ").concat((t = o, (r = a) == null || typeof r == "boolean" || r === "" ? "" : typeof r != "number" || r === 0 || t in f2 || t.startsWith("--") ? String(r).trim() : "".concat(r, "px")), ";")));
  }
  return n;
};
function cl(e, t, r, n) {
  if (fT(e)) return [];
  if (Hv(e)) return [".".concat(e.styledComponentId)];
  if (Nu(e)) {
    if (!Nu(a = e) || a.prototype && a.prototype.isReactComponent || !t) return [e];
    var o = e(t);
    return cl(o, t, r, n);
  }
  var a;
  return e instanceof pT ? r ? (e.inject(r, n), [e.getName(n)]) : [e] : ih(e) ? dT(e) : Array.isArray(e) ? Array.prototype.concat.apply(Vv, e.map(function(i) {
    return cl(i, t, r, n);
  })) : [e.toString()];
}
function hT(e) {
  for (var t = 0; t < e.length; t += 1) {
    var r = e[t];
    if (Nu(r) && !Hv(r)) return !1;
  }
  return !0;
}
var z2 = tT(Iu), B2 = function() {
  function e(t, r, n) {
    this.rules = t, this.staticRulesId = "", this.isStatic = (n === void 0 || n.isStatic) && hT(t), this.componentId = r, this.baseHash = mp(z2, r), this.baseStyle = n, Pp.registerId(r);
  }
  return e.prototype.generateAndInjectStyles = function(t, r, n) {
    var o = this.baseStyle ? this.baseStyle.generateAndInjectStyles(t, r, n) : "";
    if (this.isStatic && !n.hash) if (this.staticRulesId && r.hasNameForId(this.componentId, this.staticRulesId)) o = Cu(o, this.staticRulesId);
    else {
      var a = nh(cl(this.rules, t, r, n)), i = sS(mp(this.baseHash, a) >>> 0);
      if (!r.hasNameForId(this.componentId, i)) {
        var u = n(a, ".".concat(i), void 0, this.componentId);
        r.insertRules(this.componentId, i, u);
      }
      o = Cu(o, i), this.staticRulesId = i;
    }
    else {
      for (var c = mp(this.baseHash, n.hash), d = "", m = 0; m < this.rules.length; m++) {
        var g = this.rules[m];
        if (typeof g == "string") d += g;
        else if (g) {
          var v = nh(cl(g, t, r, n));
          c = mp(c, v + m), d += v;
        }
      }
      if (d) {
        var S = sS(c >>> 0);
        r.hasNameForId(this.componentId, S) || r.insertRules(this.componentId, S, n(d, ".".concat(S), void 0, this.componentId)), o = Cu(o, S);
      }
    }
    return o;
  }, e;
}(), hl = Rt.createContext(void 0), U2 = hl.Consumer;
function V2() {
  var e = Pt.useContext(hl);
  if (!e) throw Hi(18);
  return e;
}
function H2(e) {
  var t = Rt.useContext(hl), r = Pt.useMemo(function() {
    return function(n, o) {
      if (!n) throw Hi(14);
      if (Nu(n)) {
        var a = n(o);
        return a;
      }
      if (Array.isArray(n) || typeof n != "object") throw Hi(8);
      return o ? Lr(Lr({}, o), n) : n;
    }(e.theme, t);
  }, [e.theme, t]);
  return e.children ? Rt.createElement(hl.Provider, { value: r }, e.children) : null;
}
var w0 = {};
function W2(e, t, r) {
  var n = Hv(e), o = e, a = !b0(e), i = t.attrs, u = i === void 0 ? Vv : i, c = t.componentId, d = c === void 0 ? function(R, C) {
    var T = typeof R != "string" ? "sc" : V1(R);
    w0[T] = (w0[T] || 0) + 1;
    var j = "".concat(T, "-").concat(sx(Iu + T + w0[T]));
    return C ? "".concat(C, "-").concat(j) : j;
  }(t.displayName, t.parentComponentId) : c, m = t.displayName, g = m === void 0 ? function(R) {
    return b0(R) ? "styled.".concat(R) : "Styled(".concat(rT(R), ")");
  }(e) : m, v = t.displayName && t.componentId ? "".concat(V1(t.displayName), "-").concat(t.componentId) : t.componentId || d, S = n && o.attrs ? o.attrs.concat(u).filter(Boolean) : u, k = t.shouldForwardProp;
  if (n && o.shouldForwardProp) {
    var b = o.shouldForwardProp;
    if (t.shouldForwardProp) {
      var x = t.shouldForwardProp;
      k = function(R, C) {
        return b(R, C) && x(R, C);
      };
    } else k = b;
  }
  var A = new B2(r, v, n ? o.componentStyle : void 0);
  function _(R, C) {
    return function(T, j, D) {
      var V = T.attrs, U = T.componentStyle, ne = T.defaultProps, H = T.foldedComponentIds, ae = T.styledComponentId, ge = T.target, fe = Rt.useContext(hl), ve = sv(), $e = T.shouldForwardProp || ve.shouldForwardProp, ce = ix(j, fe, ne) || Ap, se = function(X, Q, ye) {
        for (var Se, Ne = Lr(Lr({}, Q), { className: void 0, theme: ye }), N = 0; N < X.length; N += 1) {
          var B = Nu(Se = X[N]) ? Se(Ne) : Se;
          for (var oe in B) Ne[oe] = oe === "className" ? Cu(Ne[oe], B[oe]) : oe === "style" ? Lr(Lr({}, Ne[oe]), B[oe]) : B[oe];
        }
        return Q.className && (Ne.className = Cu(Ne.className, Q.className)), Ne;
      }(V, j, ce), te = se.as || ge, F = {};
      for (var J in se) se[J] === void 0 || J[0] === "$" || J === "as" || J === "theme" && se.theme === ce || (J === "forwardedAs" ? F.as = se.forwardedAs : $e && !$e(J, te) || (F[J] = se[J]));
      var W = function(X, Q) {
        var ye = sv(), Se = X.generateAndInjectStyles(Q, ye.styleSheet, ye.stylis);
        return Se;
      }(U, se), q = Cu(H, ae);
      return W && (q += " " + W), se.className && (q += " " + se.className), F[b0(te) && !ZP.has(te) ? "class" : "className"] = q, D && (F.ref = D), Pt.createElement(te, F);
    }(O, R, C);
  }
  _.displayName = g;
  var O = Rt.forwardRef(_);
  return O.attrs = S, O.componentStyle = A, O.displayName = g, O.shouldForwardProp = k, O.foldedComponentIds = n ? Cu(o.foldedComponentIds, o.styledComponentId) : "", O.styledComponentId = v, O.target = n ? o.target : e, Object.defineProperty(O, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(R) {
    this._foldedDefaultProps = n ? function(C) {
      for (var T = [], j = 1; j < arguments.length; j++) T[j - 1] = arguments[j];
      for (var D = 0, V = T; D < V.length; D++) oS(C, V[D], !0);
      return C;
    }({}, o.defaultProps, R) : R;
  } }), ax(O, function() {
    return ".".concat(O.styledComponentId);
  }), a && ox(O, e, { attrs: !0, componentStyle: !0, displayName: !0, foldedComponentIds: !0, shouldForwardProp: !0, styledComponentId: !0, target: !0 }), O;
}
function J1(e, t) {
  for (var r = [e[0]], n = 0, o = t.length; n < o; n += 1) r.push(t[n], e[n + 1]);
  return r;
}
var Z1 = function(e) {
  return Object.assign(e, { isCss: !0 });
};
function Kv(e) {
  for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
  if (Nu(e) || ih(e)) return Z1(cl(J1(Vv, Ep([e], t, !0))));
  var n = e;
  return t.length === 0 && n.length === 1 && typeof n[0] == "string" ? cl(n) : Z1(cl(J1(n, t)));
}
function uS(e, t, r) {
  if (r === void 0 && (r = Ap), !t) throw Hi(1, t);
  var n = function(o) {
    for (var a = [], i = 1; i < arguments.length; i++) a[i - 1] = arguments[i];
    return e(t, r, Kv.apply(void 0, Ep([o], a, !1)));
  };
  return n.attrs = function(o) {
    return uS(e, t, Lr(Lr({}, r), { attrs: Array.prototype.concat(r.attrs, o).filter(Boolean) }));
  }, n.withConfig = function(o) {
    return uS(e, t, Lr(Lr({}, r), o));
  }, n;
}
var mT = function(e) {
  return uS(W2, e);
}, cS = mT;
ZP.forEach(function(e) {
  cS[e] = mT(e);
});
var K2 = function() {
  function e(t, r) {
    this.rules = t, this.componentId = r, this.isStatic = hT(t), Pp.registerId(this.componentId + 1);
  }
  return e.prototype.createStyles = function(t, r, n, o) {
    var a = o(nh(cl(this.rules, r, n, o)), ""), i = this.componentId + t;
    n.insertRules(i, i, a);
  }, e.prototype.removeStyles = function(t, r) {
    r.clearRules(this.componentId + t);
  }, e.prototype.renderStyles = function(t, r, n, o) {
    t > 2 && Pp.registerId(this.componentId + t), this.removeStyles(t, n), this.createStyles(t, r, n, o);
  }, e;
}();
function Q2(e) {
  for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
  var n = Kv.apply(void 0, Ep([e], t, !1)), o = "sc-global-".concat(sx(JSON.stringify(n))), a = new K2(n, o), i = function(c) {
    var d = sv(), m = Rt.useContext(hl), g = Rt.useRef(d.styleSheet.allocateGSInstance(o)).current;
    return d.styleSheet.server && u(g, c, d.styleSheet, m, d.stylis), Rt.useLayoutEffect(function() {
      if (!d.styleSheet.server) return u(g, c, d.styleSheet, m, d.stylis), function() {
        return a.removeStyles(g, d.styleSheet);
      };
    }, [g, c, d.styleSheet, m, d.stylis]), null;
  };
  function u(c, d, m, g, v) {
    if (a.isStatic) a.renderStyles(c, h2, m, v);
    else {
      var S = Lr(Lr({}, d), { theme: ix(d, g, i.defaultProps) });
      a.renderStyles(c, S, m, v);
    }
  }
  return Rt.memo(i);
}
function Y2(e) {
  for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
  var n = nh(Kv.apply(void 0, Ep([e], t, !1))), o = sx(n);
  return new pT(o, n);
}
function G2(e) {
  var t = Rt.forwardRef(function(r, n) {
    var o = ix(r, Rt.useContext(hl), e.defaultProps);
    return Rt.createElement(e, Lr({}, r, { theme: o, ref: n }));
  });
  return t.displayName = "WithTheme(".concat(rT(e), ")"), ox(t, e);
}
var X2 = function() {
  function e() {
    var t = this;
    this._emitSheetCSS = function() {
      var r = t.instance.toString();
      if (!r) return "";
      var n = aS(), o = nh([n && 'nonce="'.concat(n, '"'), "".concat(dl, '="true"'), "".concat(rv, '="').concat(Iu, '"')].filter(Boolean), " ");
      return "<style ".concat(o, ">").concat(r, "</style>");
    }, this.getStyleTags = function() {
      if (t.sealed) throw Hi(2);
      return t._emitSheetCSS();
    }, this.getStyleElement = function() {
      var r;
      if (t.sealed) throw Hi(2);
      var n = t.instance.toString();
      if (!n) return [];
      var o = ((r = {})[dl] = "", r[rv] = Iu, r.dangerouslySetInnerHTML = { __html: n }, r), a = aS();
      return a && (o.nonce = a), [Rt.createElement("style", Lr({}, o, { key: "sc-0-0" }))];
    }, this.seal = function() {
      t.sealed = !0;
    }, this.instance = new Pp({ isServer: !0 }), this.sealed = !1;
  }
  return e.prototype.collectStyles = function(t) {
    if (this.sealed) throw Hi(2);
    return Rt.createElement(cT, { sheet: this.instance }, t);
  }, e.prototype.interleaveWithNodeStream = function(t) {
    throw Hi(3);
  }, e;
}(), J2 = { StyleSheet: Pp, mainSheet: uT };
const Z2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ServerStyleSheet: X2,
  StyleSheetConsumer: D2,
  StyleSheetContext: Wv,
  StyleSheetManager: cT,
  ThemeConsumer: U2,
  ThemeContext: hl,
  ThemeProvider: H2,
  __PRIVATE__: J2,
  createGlobalStyle: Q2,
  css: Kv,
  default: cS,
  isStyledComponent: Hv,
  keyframes: Y2,
  styled: cS,
  useTheme: V2,
  version: Iu,
  withTheme: G2
}, Symbol.toStringTag, { value: "Module" })), eM = /* @__PURE__ */ _o(Z2);
var S0 = { exports: {} }, x0, e_;
function tM() {
  if (e_) return x0;
  e_ = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return x0 = e, x0;
}
var _0, t_;
function rM() {
  if (t_) return _0;
  t_ = 1;
  var e = /* @__PURE__ */ tM();
  function t() {
  }
  function r() {
  }
  return r.resetWarningCache = t, _0 = function() {
    function n(i, u, c, d, m, g) {
      if (g !== e) {
        var v = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw v.name = "Invariant Violation", v;
      }
    }
    n.isRequired = n;
    function o() {
      return n;
    }
    var a = {
      array: n,
      bigint: n,
      bool: n,
      func: n,
      number: n,
      object: n,
      string: n,
      symbol: n,
      any: n,
      arrayOf: o,
      element: n,
      elementType: n,
      instanceOf: o,
      node: n,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: r,
      resetWarningCache: t
    };
    return a.PropTypes = a, a;
  }, _0;
}
var r_;
function gT() {
  return r_ || (r_ = 1, S0.exports = /* @__PURE__ */ rM()()), S0.exports;
}
function At(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    r[n - 1] = arguments[n];
  throw new Error(typeof e == "number" ? "[MobX] minified error nr: " + e + (r.length ? " " + r.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + e);
}
var nM = {};
function Qv() {
  return typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : nM;
}
var yT = Object.assign, ov = Object.getOwnPropertyDescriptor, bo = Object.defineProperty, yh = Object.prototype, pS = [];
Object.freeze(pS);
var lx = {};
Object.freeze(lx);
var iM = typeof Proxy < "u", sM = /* @__PURE__ */ Object.toString();
function vT() {
  iM || At("Proxy not available");
}
function bT(e) {
  var t = !1;
  return function() {
    if (!t)
      return t = !0, e.apply(this, arguments);
  };
}
var gp = function() {
};
function hi(e) {
  return typeof e == "function";
}
function ju(e) {
  var t = typeof e;
  switch (t) {
    case "string":
    case "symbol":
    case "number":
      return !0;
  }
  return !1;
}
function Yv(e) {
  return e !== null && typeof e == "object";
}
function da(e) {
  if (!Yv(e))
    return !1;
  var t = Object.getPrototypeOf(e);
  if (t == null)
    return !0;
  var r = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return typeof r == "function" && r.toString() === sM;
}
function wT(e) {
  var t = e == null ? void 0 : e.constructor;
  return t ? t.name === "GeneratorFunction" || t.displayName === "GeneratorFunction" : !1;
}
function vh(e, t, r) {
  bo(e, t, {
    enumerable: !1,
    writable: !0,
    configurable: !0,
    value: r
  });
}
function ST(e, t, r) {
  bo(e, t, {
    enumerable: !1,
    writable: !1,
    configurable: !0,
    value: r
  });
}
function bl(e, t) {
  var r = "isMobX" + e;
  return t.prototype[r] = !0, function(n) {
    return Yv(n) && n[r] === !0;
  };
}
function qp(e) {
  return e != null && Object.prototype.toString.call(e) === "[object Map]";
}
function oM(e) {
  var t = Object.getPrototypeOf(e), r = Object.getPrototypeOf(t), n = Object.getPrototypeOf(r);
  return n === null;
}
function sa(e) {
  return e != null && Object.prototype.toString.call(e) === "[object Set]";
}
var xT = typeof Object.getOwnPropertySymbols < "u";
function aM(e) {
  var t = Object.keys(e);
  if (!xT)
    return t;
  var r = Object.getOwnPropertySymbols(e);
  return r.length ? [].concat(t, r.filter(function(n) {
    return yh.propertyIsEnumerable.call(e, n);
  })) : t;
}
var Tp = typeof Reflect < "u" && Reflect.ownKeys ? Reflect.ownKeys : xT ? function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : (
  /* istanbul ignore next */
  Object.getOwnPropertyNames
);
function _T(e) {
  return e === null ? null : typeof e == "object" ? "" + e : e;
}
function la(e, t) {
  return yh.hasOwnProperty.call(e, t);
}
var lM = Object.getOwnPropertyDescriptors || function(t) {
  var r = {};
  return Tp(t).forEach(function(n) {
    r[n] = ov(t, n);
  }), r;
};
function fi(e, t) {
  return !!(e & t);
}
function di(e, t, r) {
  return r ? e |= t : e &= ~t, e;
}
function n_(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function uM(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, pM(n.key), n);
  }
}
function zp(e, t, r) {
  return t && uM(e.prototype, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function yp(e, t) {
  var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r) return (r = r.call(e)).next.bind(r);
  if (Array.isArray(e) || (r = fM(e)) || t) {
    r && (e = r);
    var n = 0;
    return function() {
      return n >= e.length ? {
        done: !0
      } : {
        done: !1,
        value: e[n++]
      };
    };
  }
  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ml() {
  return ml = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r) ({}).hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, ml.apply(null, arguments);
}
function ET(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, fS(e, t);
}
function fS(e, t) {
  return fS = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, n) {
    return r.__proto__ = n, r;
  }, fS(e, t);
}
function cM(e, t) {
  if (typeof e != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
function pM(e) {
  var t = cM(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function fM(e, t) {
  if (e) {
    if (typeof e == "string") return n_(e, t);
    var r = {}.toString.call(e).slice(8, -1);
    return r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set" ? Array.from(e) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? n_(e, t) : void 0;
  }
}
var go = /* @__PURE__ */ Symbol("mobx-stored-annotations");
function Os(e) {
  function t(r, n) {
    if (wh(n))
      return e.decorate_20223_(r, n);
    bh(r, n, e);
  }
  return Object.assign(t, e);
}
function bh(e, t, r) {
  la(e, go) || vh(e, go, ml({}, e[go])), SM(r) || (e[go][t] = r);
}
function dM(e) {
  return la(e, go) || vh(e, go, ml({}, e[go])), e[go];
}
function wh(e) {
  return typeof e == "object" && typeof e.kind == "string";
}
var dt = /* @__PURE__ */ Symbol("mobx administration"), wl = /* @__PURE__ */ function() {
  function e(r) {
    r === void 0 && (r = "Atom"), this.name_ = void 0, this.flags_ = 0, this.observers_ = /* @__PURE__ */ new Set(), this.lastAccessedBy_ = 0, this.lowestObserverState_ = Bt.NOT_TRACKING_, this.onBOL = void 0, this.onBUOL = void 0, this.name_ = r;
  }
  var t = e.prototype;
  return t.onBO = function() {
    this.onBOL && this.onBOL.forEach(function(n) {
      return n();
    });
  }, t.onBUO = function() {
    this.onBUOL && this.onBUOL.forEach(function(n) {
      return n();
    });
  }, t.reportObserved = function() {
    return BT(this);
  }, t.reportChanged = function() {
    ei(), UT(this), ti();
  }, t.toString = function() {
    return this.name_;
  }, zp(e, [{
    key: "isBeingObserved",
    get: function() {
      return fi(this.flags_, e.isBeingObservedMask_);
    },
    set: function(n) {
      this.flags_ = di(this.flags_, e.isBeingObservedMask_, n);
    }
  }, {
    key: "isPendingUnobservation",
    get: function() {
      return fi(this.flags_, e.isPendingUnobservationMask_);
    },
    set: function(n) {
      this.flags_ = di(this.flags_, e.isPendingUnobservationMask_, n);
    }
  }, {
    key: "diffValue",
    get: function() {
      return fi(this.flags_, e.diffValueMask_) ? 1 : 0;
    },
    set: function(n) {
      this.flags_ = di(this.flags_, e.diffValueMask_, n === 1);
    }
  }]);
}();
wl.isBeingObservedMask_ = 1;
wl.isPendingUnobservationMask_ = 2;
wl.diffValueMask_ = 4;
var ux = /* @__PURE__ */ bl("Atom", wl);
function cx(e, t, r) {
  t === void 0 && (t = gp), r === void 0 && (r = gp);
  var n = new wl(e);
  return t !== gp && XT(n, t), r !== gp && hx(n, r), n;
}
function hM(e, t) {
  return e === t;
}
function mM(e, t) {
  return wx(e, t);
}
function gM(e, t) {
  return wx(e, t, 1);
}
function yM(e, t) {
  return Object.is ? Object.is(e, t) : e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
var Lu = {
  identity: hM,
  structural: mM,
  default: yM,
  shallow: gM
};
function Mu(e, t, r) {
  return nb(e) ? e : Array.isArray(e) ? Er.array(e, {
    name: r
  }) : da(e) ? Er.object(e, void 0, {
    name: r
  }) : qp(e) ? Er.map(e, {
    name: r
  }) : sa(e) ? Er.set(e, {
    name: r
  }) : typeof e == "function" && !$p(e) && !Rp(e) ? wT(e) ? Fu(e) : Cp(r, e) : e;
}
function vM(e, t, r) {
  if (e == null || Yr(e) || $n(e) || Gr(e) || Vr(e))
    return e;
  if (Array.isArray(e))
    return Er.array(e, {
      name: r,
      deep: !1
    });
  if (da(e))
    return Er.object(e, void 0, {
      name: r,
      deep: !1
    });
  if (qp(e))
    return Er.map(e, {
      name: r,
      deep: !1
    });
  if (sa(e))
    return Er.set(e, {
      name: r,
      deep: !1
    });
}
function Gv(e) {
  return e;
}
function bM(e, t) {
  return wx(e, t) ? t : e;
}
var OT = "override", wM = /* @__PURE__ */ Os({
  annotationType_: OT,
  make_: xM,
  extend_: _M,
  decorate_20223_: EM
});
function SM(e) {
  return e.annotationType_ === OT;
}
function xM(e, t) {
  return 0;
}
function _M(e, t, r, n) {
  At("'" + this.annotationType_ + "' can only be used with 'makeObservable'");
}
function EM(e, t) {
  console.warn("'" + this.annotationType_ + "' cannot be used with decorators - this is a no-op");
}
function Sh(e, t) {
  return {
    annotationType_: e,
    options_: t,
    make_: OM,
    extend_: kM,
    decorate_20223_: AM
  };
}
function OM(e, t, r, n) {
  var o;
  if ((o = this.options_) != null && o.bound)
    return this.extend_(e, t, r, !1) === null ? 0 : 1;
  if (n === e.target_)
    return this.extend_(e, t, r, !1) === null ? 0 : 2;
  if ($p(r.value))
    return 1;
  var a = kT(e, this, t, r, !1);
  return bo(n, t, a), 2;
}
function kM(e, t, r, n) {
  var o = kT(e, this, t, r);
  return e.defineProperty_(t, o, n);
}
function AM(e, t) {
  var r = t.kind, n = t.name, o = t.addInitializer, a = this, i = function(d) {
    var m, g, v, S;
    return gl((m = (g = a.options_) == null ? void 0 : g.name) != null ? m : n.toString(), d, (v = (S = a.options_) == null ? void 0 : S.autoAction) != null ? v : !1);
  };
  if (r == "field")
    return function(c) {
      var d, m = c;
      return $p(m) || (m = i(m)), (d = a.options_) != null && d.bound && (m = m.bind(this), m.isMobxAction = !0), m;
    };
  if (r == "method") {
    var u;
    return $p(e) || (e = i(e)), (u = this.options_) != null && u.bound && o(function() {
      var c = this, d = c[n].bind(c);
      d.isMobxAction = !0, c[n] = d;
    }), e;
  }
  At("Cannot apply '" + a.annotationType_ + "' to '" + String(n) + "' (kind: " + r + "):" + (`
'` + a.annotationType_ + "' can only be used on properties with a function value."));
}
function PM(e, t, r, n) {
  t.annotationType_, n.value;
}
function kT(e, t, r, n, o) {
  var a, i, u, c, d, m, g;
  o === void 0 && (o = Je.safeDescriptors), PM(e, t, r, n);
  var v = n.value;
  if ((a = t.options_) != null && a.bound) {
    var S;
    v = v.bind((S = e.proxy_) != null ? S : e.target_);
  }
  return {
    value: gl(
      (i = (u = t.options_) == null ? void 0 : u.name) != null ? i : r.toString(),
      v,
      (c = (d = t.options_) == null ? void 0 : d.autoAction) != null ? c : !1,
      // https://github.com/mobxjs/mobx/discussions/3140
      (m = t.options_) != null && m.bound ? (g = e.proxy_) != null ? g : e.target_ : void 0
    ),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: o ? e.isPlainObject_ : !0,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: !1,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: !o
  };
}
function AT(e, t) {
  return {
    annotationType_: e,
    options_: t,
    make_: TM,
    extend_: CM,
    decorate_20223_: $M
  };
}
function TM(e, t, r, n) {
  var o;
  if (n === e.target_)
    return this.extend_(e, t, r, !1) === null ? 0 : 2;
  if ((o = this.options_) != null && o.bound && (!la(e.target_, t) || !Rp(e.target_[t])) && this.extend_(e, t, r, !1) === null)
    return 0;
  if (Rp(r.value))
    return 1;
  var a = PT(e, this, t, r, !1, !1);
  return bo(n, t, a), 2;
}
function CM(e, t, r, n) {
  var o, a = PT(e, this, t, r, (o = this.options_) == null ? void 0 : o.bound);
  return e.defineProperty_(t, a, n);
}
function $M(e, t) {
  var r, n = t.name, o = t.addInitializer;
  return Rp(e) || (e = Fu(e)), (r = this.options_) != null && r.bound && o(function() {
    var a = this, i = a[n].bind(a);
    i.isMobXFlow = !0, a[n] = i;
  }), e;
}
function RM(e, t, r, n) {
  t.annotationType_, n.value;
}
function PT(e, t, r, n, o, a) {
  a === void 0 && (a = Je.safeDescriptors), RM(e, t, r, n);
  var i = n.value;
  if (Rp(i) || (i = Fu(i)), o) {
    var u;
    i = i.bind((u = e.proxy_) != null ? u : e.target_), i.isMobXFlow = !0;
  }
  return {
    value: i,
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: a ? e.isPlainObject_ : !0,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: !1,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: !a
  };
}
function px(e, t) {
  return {
    annotationType_: e,
    options_: t,
    make_: IM,
    extend_: NM,
    decorate_20223_: jM
  };
}
function IM(e, t, r) {
  return this.extend_(e, t, r, !1) === null ? 0 : 1;
}
function NM(e, t, r, n) {
  return LM(e, this, t, r), e.defineComputedProperty_(t, ml({}, this.options_, {
    get: r.get,
    set: r.set
  }), n);
}
function jM(e, t) {
  var r = this, n = t.name, o = t.addInitializer;
  return o(function() {
    var a = Vu(this)[dt], i = ml({}, r.options_, {
      get: e,
      context: this
    });
    i.name || (i.name = "ObservableObject." + n.toString()), a.values_.set(n, new Ps(i));
  }), function() {
    return this[dt].getObservablePropValue_(n);
  };
}
function LM(e, t, r, n) {
  t.annotationType_, n.get;
}
function Xv(e, t) {
  return {
    annotationType_: e,
    options_: t,
    make_: MM,
    extend_: DM,
    decorate_20223_: FM
  };
}
function MM(e, t, r) {
  return this.extend_(e, t, r, !1) === null ? 0 : 1;
}
function DM(e, t, r, n) {
  var o, a;
  return qM(e, this), e.defineObservableProperty_(t, r.value, (o = (a = this.options_) == null ? void 0 : a.enhancer) != null ? o : Mu, n);
}
function FM(e, t) {
  var r = this, n = t.kind, o = t.name, a = /* @__PURE__ */ new WeakSet();
  function i(u, c) {
    var d, m, g = Vu(u)[dt], v = new pl(c, (d = (m = r.options_) == null ? void 0 : m.enhancer) != null ? d : Mu, "ObservableObject." + o.toString(), !1);
    g.values_.set(o, v), a.add(u);
  }
  if (n == "accessor")
    return {
      get: function() {
        return a.has(this) || i(this, e.get.call(this)), this[dt].getObservablePropValue_(o);
      },
      set: function(c) {
        return a.has(this) || i(this, c), this[dt].setObservablePropValue_(o, c);
      },
      init: function(c) {
        return a.has(this) || i(this, c), c;
      }
    };
}
function qM(e, t, r, n) {
  t.annotationType_;
}
var zM = "true", BM = /* @__PURE__ */ TT();
function TT(e) {
  return {
    annotationType_: zM,
    options_: e,
    make_: UM,
    extend_: VM,
    decorate_20223_: HM
  };
}
function UM(e, t, r, n) {
  var o, a;
  if (r.get)
    return xh.make_(e, t, r, n);
  if (r.set) {
    var i = gl(t.toString(), r.set);
    return n === e.target_ ? e.defineProperty_(t, {
      configurable: Je.safeDescriptors ? e.isPlainObject_ : !0,
      set: i
    }) === null ? 0 : 2 : (bo(n, t, {
      configurable: !0,
      set: i
    }), 2);
  }
  if (n !== e.target_ && typeof r.value == "function") {
    var u;
    if (wT(r.value)) {
      var c, d = (c = this.options_) != null && c.autoBind ? Fu.bound : Fu;
      return d.make_(e, t, r, n);
    }
    var m = (u = this.options_) != null && u.autoBind ? Cp.bound : Cp;
    return m.make_(e, t, r, n);
  }
  var g = ((o = this.options_) == null ? void 0 : o.deep) === !1 ? Er.ref : Er;
  if (typeof r.value == "function" && (a = this.options_) != null && a.autoBind) {
    var v;
    r.value = r.value.bind((v = e.proxy_) != null ? v : e.target_);
  }
  return g.make_(e, t, r, n);
}
function VM(e, t, r, n) {
  var o, a;
  if (r.get)
    return xh.extend_(e, t, r, n);
  if (r.set)
    return e.defineProperty_(t, {
      configurable: Je.safeDescriptors ? e.isPlainObject_ : !0,
      set: gl(t.toString(), r.set)
    }, n);
  if (typeof r.value == "function" && (o = this.options_) != null && o.autoBind) {
    var i;
    r.value = r.value.bind((i = e.proxy_) != null ? i : e.target_);
  }
  var u = ((a = this.options_) == null ? void 0 : a.deep) === !1 ? Er.ref : Er;
  return u.extend_(e, t, r, n);
}
function HM(e, t) {
  At("'" + this.annotationType_ + "' cannot be used as a decorator");
}
var WM = "observable", KM = "observable.ref", QM = "observable.shallow", YM = "observable.struct", CT = {
  deep: !0,
  name: void 0,
  defaultDecorator: void 0,
  proxy: !0
};
Object.freeze(CT);
function hg(e) {
  return e || CT;
}
var dS = /* @__PURE__ */ Xv(WM), GM = /* @__PURE__ */ Xv(KM, {
  enhancer: Gv
}), XM = /* @__PURE__ */ Xv(QM, {
  enhancer: vM
}), JM = /* @__PURE__ */ Xv(YM, {
  enhancer: bM
}), $T = /* @__PURE__ */ Os(dS);
function mg(e) {
  return e.deep === !0 ? Mu : e.deep === !1 ? Gv : eD(e.defaultDecorator);
}
function ZM(e) {
  var t;
  return e ? (t = e.defaultDecorator) != null ? t : TT(e) : void 0;
}
function eD(e) {
  var t, r;
  return e && (t = (r = e.options_) == null ? void 0 : r.enhancer) != null ? t : Mu;
}
function RT(e, t, r) {
  if (wh(t))
    return dS.decorate_20223_(e, t);
  if (ju(t)) {
    bh(e, t, dS);
    return;
  }
  return nb(e) ? e : da(e) ? Er.object(e, t, r) : Array.isArray(e) ? Er.array(e, t) : qp(e) ? Er.map(e, t) : sa(e) ? Er.set(e, t) : typeof e == "object" && e !== null ? e : Er.box(e, t);
}
yT(RT, $T);
var tD = {
  box: function(t, r) {
    var n = hg(r);
    return new pl(t, mg(n), n.name, !0, n.equals);
  },
  array: function(t, r) {
    var n = hg(r);
    return (Je.useProxies === !1 || n.proxy === !1 ? vF : lF)(t, mg(n), n.name);
  },
  map: function(t, r) {
    var n = hg(r);
    return new yx(t, mg(n), n.name);
  },
  set: function(t, r) {
    var n = hg(r);
    return new vx(t, mg(n), n.name);
  },
  object: function(t, r, n) {
    return Sl(function() {
      return mx(Je.useProxies === !1 || (n == null ? void 0 : n.proxy) === !1 ? Vu({}, n) : iF({}, n), t, r);
    });
  },
  ref: /* @__PURE__ */ Os(GM),
  shallow: /* @__PURE__ */ Os(XM),
  deep: $T,
  struct: /* @__PURE__ */ Os(JM)
}, Er = /* @__PURE__ */ yT(RT, tD), IT = "computed", rD = "computed.struct", hS = /* @__PURE__ */ px(IT), nD = /* @__PURE__ */ px(rD, {
  equals: Lu.structural
}), xh = function(t, r) {
  if (wh(r))
    return hS.decorate_20223_(t, r);
  if (ju(r))
    return bh(t, r, hS);
  if (da(t))
    return Os(px(IT, t));
  var n = da(r) ? r : {};
  return n.get = t, n.name || (n.name = t.name || ""), new Ps(n);
};
Object.assign(xh, hS);
xh.struct = /* @__PURE__ */ Os(nD);
var i_, s_, av = 0, iD = 1, sD = (i_ = (s_ = /* @__PURE__ */ ov(function() {
}, "name")) == null ? void 0 : s_.configurable) != null ? i_ : !1, o_ = {
  value: "action",
  configurable: !0,
  writable: !1,
  enumerable: !1
};
function gl(e, t, r, n) {
  r === void 0 && (r = !1);
  function o() {
    return NT(e, r, t, n || this, arguments);
  }
  return o.isMobxAction = !0, o.toString = function() {
    return t.toString();
  }, sD && (o_.value = e, bo(o, "name", o_)), o;
}
function NT(e, t, r, n, o) {
  var a = jT(e, t);
  try {
    return r.apply(n, o);
  } catch (i) {
    throw a.error_ = i, i;
  } finally {
    LT(a);
  }
}
function jT(e, t, r, n) {
  var o = !1, a = 0, i = Je.trackingDerivation, u = !t || !i;
  ei();
  var c = Je.allowStateChanges;
  u && (Uu(), c = Zv(!0));
  var d = tb(!0), m = {
    runAsAction_: u,
    prevDerivation_: i,
    prevAllowStateChanges_: c,
    prevAllowStateReads_: d,
    notifySpy_: o,
    startTime_: a,
    actionId_: iD++,
    parentActionId_: av
  };
  return av = m.actionId_, m;
}
function LT(e) {
  av !== e.actionId_ && At(30), av = e.parentActionId_, e.error_ !== void 0 && (Je.suppressReactionErrors = !0), eb(e.prevAllowStateChanges_), Sp(e.prevAllowStateReads_), ti(), e.runAsAction_ && ua(e.prevDerivation_), Je.suppressReactionErrors = !1;
}
function Jv(e, t) {
  var r = Zv(e);
  try {
    return t();
  } finally {
    eb(r);
  }
}
function Zv(e) {
  var t = Je.allowStateChanges;
  return Je.allowStateChanges = e, t;
}
function eb(e) {
  Je.allowStateChanges = e;
}
var pl = /* @__PURE__ */ function(e) {
  function t(n, o, a, i, u) {
    var c;
    return a === void 0 && (a = "ObservableValue"), u === void 0 && (u = Lu.default), c = e.call(this, a) || this, c.enhancer = void 0, c.name_ = void 0, c.equals = void 0, c.hasUnreportedChange_ = !1, c.interceptors_ = void 0, c.changeListeners_ = void 0, c.value_ = void 0, c.dehancer = void 0, c.enhancer = o, c.name_ = a, c.equals = u, c.value_ = o(n, void 0, a), c;
  }
  ET(t, e);
  var r = t.prototype;
  return r.dehanceValue = function(o) {
    return this.dehancer !== void 0 ? this.dehancer(o) : o;
  }, r.set = function(o) {
    this.value_, o = this.prepareNewValue_(o), o !== Je.UNCHANGED && this.setNewValue_(o);
  }, r.prepareNewValue_ = function(o) {
    if (Ui(this)) {
      var a = Vi(this, {
        object: this,
        type: wo,
        newValue: o
      });
      if (!a)
        return Je.UNCHANGED;
      o = a.newValue;
    }
    return o = this.enhancer(o, this.value_, this.name_), this.equals(this.value_, o) ? Je.UNCHANGED : o;
  }, r.setNewValue_ = function(o) {
    var a = this.value_;
    this.value_ = o, this.reportChanged(), ks(this) && As(this, {
      type: wo,
      object: this,
      newValue: o,
      oldValue: a
    });
  }, r.get = function() {
    return this.reportObserved(), this.dehanceValue(this.value_);
  }, r.intercept_ = function(o) {
    return _h(this, o);
  }, r.observe_ = function(o, a) {
    return a && o({
      observableKind: "value",
      debugObjectName: this.name_,
      object: this,
      type: wo,
      newValue: this.value_,
      oldValue: void 0
    }), Eh(this, o);
  }, r.raw = function() {
    return this.value_;
  }, r.toJSON = function() {
    return this.get();
  }, r.toString = function() {
    return this.name_ + "[" + this.value_ + "]";
  }, r.valueOf = function() {
    return _T(this.get());
  }, r[Symbol.toPrimitive] = function() {
    return this.valueOf();
  }, t;
}(wl), fx = /* @__PURE__ */ bl("ObservableValue", pl), Ps = /* @__PURE__ */ function() {
  function e(r) {
    this.dependenciesState_ = Bt.NOT_TRACKING_, this.observing_ = [], this.newObserving_ = null, this.observers_ = /* @__PURE__ */ new Set(), this.runId_ = 0, this.lastAccessedBy_ = 0, this.lowestObserverState_ = Bt.UP_TO_DATE_, this.unboundDepsCount_ = 0, this.value_ = new uv(null), this.name_ = void 0, this.triggeredBy_ = void 0, this.flags_ = 0, this.derivation = void 0, this.setter_ = void 0, this.isTracing_ = lv.NONE, this.scope_ = void 0, this.equals_ = void 0, this.requiresReaction_ = void 0, this.keepAlive_ = void 0, this.onBOL = void 0, this.onBUOL = void 0, r.get || At(31), this.derivation = r.get, this.name_ = r.name || "ComputedValue", r.set && (this.setter_ = gl("ComputedValue-setter", r.set)), this.equals_ = r.equals || (r.compareStructural || r.struct ? Lu.structural : Lu.default), this.scope_ = r.context, this.requiresReaction_ = r.requiresReaction, this.keepAlive_ = !!r.keepAlive;
  }
  var t = e.prototype;
  return t.onBecomeStale_ = function() {
    gD(this);
  }, t.onBO = function() {
    this.onBOL && this.onBOL.forEach(function(n) {
      return n();
    });
  }, t.onBUO = function() {
    this.onBUOL && this.onBUOL.forEach(function(n) {
      return n();
    });
  }, t.get = function() {
    if (this.isComputing && At(32, this.name_, this.derivation), Je.inBatch === 0 && // !globalState.trackingDerivatpion &&
    this.observers_.size === 0 && !this.keepAlive_)
      mS(this) && (this.warnAboutUntrackedRead_(), ei(), this.value_ = this.computeValue_(!1), ti());
    else if (BT(this), mS(this)) {
      var n = Je.trackingContext;
      this.keepAlive_ && !n && (Je.trackingContext = this), this.trackAndCompute() && mD(this), Je.trackingContext = n;
    }
    var o = this.value_;
    if (qy(o))
      throw o.cause;
    return o;
  }, t.set = function(n) {
    if (this.setter_) {
      this.isRunningSetter && At(33, this.name_), this.isRunningSetter = !0;
      try {
        this.setter_.call(this.scope_, n);
      } finally {
        this.isRunningSetter = !1;
      }
    } else
      At(34, this.name_);
  }, t.trackAndCompute = function() {
    var n = this.value_, o = (
      /* see #1208 */
      this.dependenciesState_ === Bt.NOT_TRACKING_
    ), a = this.computeValue_(!0), i = o || qy(n) || qy(a) || !this.equals_(n, a);
    return i && (this.value_ = a), i;
  }, t.computeValue_ = function(n) {
    this.isComputing = !0;
    var o = Zv(!1), a;
    if (n)
      a = MT(this, this.derivation, this.scope_);
    else if (Je.disableErrorBoundaries === !0)
      a = this.derivation.call(this.scope_);
    else
      try {
        a = this.derivation.call(this.scope_);
      } catch (i) {
        a = new uv(i);
      }
    return eb(o), this.isComputing = !1, a;
  }, t.suspend_ = function() {
    this.keepAlive_ || (gS(this), this.value_ = void 0);
  }, t.observe_ = function(n, o) {
    var a = this, i = !0, u = void 0;
    return dx(function() {
      var c = a.get();
      if (!i || o) {
        var d = Uu();
        n({
          observableKind: "computed",
          debugObjectName: a.name_,
          type: wo,
          object: a,
          newValue: c,
          oldValue: u
        }), ua(d);
      }
      i = !1, u = c;
    });
  }, t.warnAboutUntrackedRead_ = function() {
  }, t.toString = function() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  }, t.valueOf = function() {
    return _T(this.get());
  }, t[Symbol.toPrimitive] = function() {
    return this.valueOf();
  }, zp(e, [{
    key: "isComputing",
    get: function() {
      return fi(this.flags_, e.isComputingMask_);
    },
    set: function(n) {
      this.flags_ = di(this.flags_, e.isComputingMask_, n);
    }
  }, {
    key: "isRunningSetter",
    get: function() {
      return fi(this.flags_, e.isRunningSetterMask_);
    },
    set: function(n) {
      this.flags_ = di(this.flags_, e.isRunningSetterMask_, n);
    }
  }, {
    key: "isBeingObserved",
    get: function() {
      return fi(this.flags_, e.isBeingObservedMask_);
    },
    set: function(n) {
      this.flags_ = di(this.flags_, e.isBeingObservedMask_, n);
    }
  }, {
    key: "isPendingUnobservation",
    get: function() {
      return fi(this.flags_, e.isPendingUnobservationMask_);
    },
    set: function(n) {
      this.flags_ = di(this.flags_, e.isPendingUnobservationMask_, n);
    }
  }, {
    key: "diffValue",
    get: function() {
      return fi(this.flags_, e.diffValueMask_) ? 1 : 0;
    },
    set: function(n) {
      this.flags_ = di(this.flags_, e.diffValueMask_, n === 1);
    }
  }]);
}();
Ps.isComputingMask_ = 1;
Ps.isRunningSetterMask_ = 2;
Ps.isBeingObservedMask_ = 4;
Ps.isPendingUnobservationMask_ = 8;
Ps.diffValueMask_ = 16;
var Du = /* @__PURE__ */ bl("ComputedValue", Ps), Bt;
(function(e) {
  e[e.NOT_TRACKING_ = -1] = "NOT_TRACKING_", e[e.UP_TO_DATE_ = 0] = "UP_TO_DATE_", e[e.POSSIBLY_STALE_ = 1] = "POSSIBLY_STALE_", e[e.STALE_ = 2] = "STALE_";
})(Bt || (Bt = {}));
var lv;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.LOG = 1] = "LOG", e[e.BREAK = 2] = "BREAK";
})(lv || (lv = {}));
var uv = function(t) {
  this.cause = void 0, this.cause = t;
};
function qy(e) {
  return e instanceof uv;
}
function mS(e) {
  switch (e.dependenciesState_) {
    case Bt.UP_TO_DATE_:
      return !1;
    case Bt.NOT_TRACKING_:
    case Bt.STALE_:
      return !0;
    case Bt.POSSIBLY_STALE_: {
      for (var t = tb(!0), r = Uu(), n = e.observing_, o = n.length, a = 0; a < o; a++) {
        var i = n[a];
        if (Du(i)) {
          if (Je.disableErrorBoundaries)
            i.get();
          else
            try {
              i.get();
            } catch {
              return ua(r), Sp(t), !0;
            }
          if (e.dependenciesState_ === Bt.STALE_)
            return ua(r), Sp(t), !0;
        }
      }
      return DT(e), ua(r), Sp(t), !1;
    }
  }
}
function oD() {
  return Je.trackingDerivation !== null;
}
function MT(e, t, r) {
  var n = tb(!0);
  DT(e), e.newObserving_ = new Array(
    // Reserve constant space for initial dependencies, dynamic space otherwise.
    // See https://github.com/mobxjs/mobx/pull/3833
    e.runId_ === 0 ? 100 : e.observing_.length
  ), e.unboundDepsCount_ = 0, e.runId_ = ++Je.runId;
  var o = Je.trackingDerivation;
  Je.trackingDerivation = e, Je.inBatch++;
  var a;
  if (Je.disableErrorBoundaries === !0)
    a = t.call(r);
  else
    try {
      a = t.call(r);
    } catch (i) {
      a = new uv(i);
    }
  return Je.inBatch--, Je.trackingDerivation = o, aD(e), Sp(n), a;
}
function aD(e) {
  for (var t = e.observing_, r = e.observing_ = e.newObserving_, n = Bt.UP_TO_DATE_, o = 0, a = e.unboundDepsCount_, i = 0; i < a; i++) {
    var u = r[i];
    u.diffValue === 0 && (u.diffValue = 1, o !== i && (r[o] = u), o++), u.dependenciesState_ > n && (n = u.dependenciesState_);
  }
  for (r.length = o, e.newObserving_ = null, a = t.length; a--; ) {
    var c = t[a];
    c.diffValue === 0 && qT(c, e), c.diffValue = 0;
  }
  for (; o--; ) {
    var d = r[o];
    d.diffValue === 1 && (d.diffValue = 0, hD(d, e));
  }
  n !== Bt.UP_TO_DATE_ && (e.dependenciesState_ = n, e.onBecomeStale_());
}
function gS(e) {
  var t = e.observing_;
  e.observing_ = [];
  for (var r = t.length; r--; )
    qT(t[r], e);
  e.dependenciesState_ = Bt.NOT_TRACKING_;
}
function Bp(e) {
  var t = Uu();
  try {
    return e();
  } finally {
    ua(t);
  }
}
function Uu() {
  var e = Je.trackingDerivation;
  return Je.trackingDerivation = null, e;
}
function ua(e) {
  Je.trackingDerivation = e;
}
function tb(e) {
  var t = Je.allowStateReads;
  return Je.allowStateReads = e, t;
}
function Sp(e) {
  Je.allowStateReads = e;
}
function DT(e) {
  if (e.dependenciesState_ !== Bt.UP_TO_DATE_) {
    e.dependenciesState_ = Bt.UP_TO_DATE_;
    for (var t = e.observing_, r = t.length; r--; )
      t[r].lowestObserverState_ = Bt.UP_TO_DATE_;
  }
}
var lD = ["mobxGuid", "spyListeners", "enforceActions", "computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "allowStateReads", "disableErrorBoundaries", "runId", "UNCHANGED", "useProxies"], Qd = function() {
  this.version = 6, this.UNCHANGED = {}, this.trackingDerivation = null, this.trackingContext = null, this.runId = 0, this.mobxGuid = 0, this.inBatch = 0, this.pendingUnobservations = [], this.pendingReactions = [], this.isRunningReactions = !1, this.allowStateChanges = !1, this.allowStateReads = !0, this.enforceActions = !0, this.spyListeners = [], this.globalReactionErrorHandlers = [], this.computedRequiresReaction = !1, this.reactionRequiresObservable = !1, this.observableRequiresReaction = !1, this.disableErrorBoundaries = !1, this.suppressReactionErrors = !1, this.useProxies = !0, this.verifyProxies = !1, this.safeDescriptors = !0;
}, zy = !0, FT = !1, Je = /* @__PURE__ */ function() {
  var e = /* @__PURE__ */ Qv();
  return e.__mobxInstanceCount > 0 && !e.__mobxGlobals && (zy = !1), e.__mobxGlobals && e.__mobxGlobals.version !== new Qd().version && (zy = !1), zy ? e.__mobxGlobals ? (e.__mobxInstanceCount += 1, e.__mobxGlobals.UNCHANGED || (e.__mobxGlobals.UNCHANGED = {}), e.__mobxGlobals) : (e.__mobxInstanceCount = 1, e.__mobxGlobals = /* @__PURE__ */ new Qd()) : (setTimeout(function() {
    FT || At(35);
  }, 1), new Qd());
}();
function uD() {
  if ((Je.pendingReactions.length || Je.inBatch || Je.isRunningReactions) && At(36), FT = !0, zy) {
    var e = Qv();
    --e.__mobxInstanceCount === 0 && (e.__mobxGlobals = void 0), Je = new Qd();
  }
}
function cD() {
  return Je;
}
function pD() {
  var e = new Qd();
  for (var t in e)
    lD.indexOf(t) === -1 && (Je[t] = e[t]);
  Je.allowStateChanges = !Je.enforceActions;
}
function fD(e) {
  return e.observers_ && e.observers_.size > 0;
}
function dD(e) {
  return e.observers_;
}
function hD(e, t) {
  e.observers_.add(t), e.lowestObserverState_ > t.dependenciesState_ && (e.lowestObserverState_ = t.dependenciesState_);
}
function qT(e, t) {
  e.observers_.delete(t), e.observers_.size === 0 && zT(e);
}
function zT(e) {
  e.isPendingUnobservation === !1 && (e.isPendingUnobservation = !0, Je.pendingUnobservations.push(e));
}
function ei() {
  Je.inBatch++;
}
function ti() {
  if (--Je.inBatch === 0) {
    VT();
    for (var e = Je.pendingUnobservations, t = 0; t < e.length; t++) {
      var r = e[t];
      r.isPendingUnobservation = !1, r.observers_.size === 0 && (r.isBeingObserved && (r.isBeingObserved = !1, r.onBUO()), r instanceof Ps && r.suspend_());
    }
    Je.pendingUnobservations = [];
  }
}
function BT(e) {
  var t = Je.trackingDerivation;
  return t !== null ? (t.runId_ !== e.lastAccessedBy_ && (e.lastAccessedBy_ = t.runId_, t.newObserving_[t.unboundDepsCount_++] = e, !e.isBeingObserved && Je.trackingContext && (e.isBeingObserved = !0, e.onBO())), e.isBeingObserved) : (e.observers_.size === 0 && Je.inBatch > 0 && zT(e), !1);
}
function UT(e) {
  e.lowestObserverState_ !== Bt.STALE_ && (e.lowestObserverState_ = Bt.STALE_, e.observers_.forEach(function(t) {
    t.dependenciesState_ === Bt.UP_TO_DATE_ && t.onBecomeStale_(), t.dependenciesState_ = Bt.STALE_;
  }));
}
function mD(e) {
  e.lowestObserverState_ !== Bt.STALE_ && (e.lowestObserverState_ = Bt.STALE_, e.observers_.forEach(function(t) {
    t.dependenciesState_ === Bt.POSSIBLY_STALE_ ? t.dependenciesState_ = Bt.STALE_ : t.dependenciesState_ === Bt.UP_TO_DATE_ && (e.lowestObserverState_ = Bt.UP_TO_DATE_);
  }));
}
function gD(e) {
  e.lowestObserverState_ === Bt.UP_TO_DATE_ && (e.lowestObserverState_ = Bt.POSSIBLY_STALE_, e.observers_.forEach(function(t) {
    t.dependenciesState_ === Bt.UP_TO_DATE_ && (t.dependenciesState_ = Bt.POSSIBLY_STALE_, t.onBecomeStale_());
  }));
}
var Yi = /* @__PURE__ */ function() {
  function e(r, n, o, a) {
    r === void 0 && (r = "Reaction"), this.name_ = void 0, this.onInvalidate_ = void 0, this.errorHandler_ = void 0, this.requiresObservable_ = void 0, this.observing_ = [], this.newObserving_ = [], this.dependenciesState_ = Bt.NOT_TRACKING_, this.runId_ = 0, this.unboundDepsCount_ = 0, this.flags_ = 0, this.isTracing_ = lv.NONE, this.name_ = r, this.onInvalidate_ = n, this.errorHandler_ = o, this.requiresObservable_ = a;
  }
  var t = e.prototype;
  return t.onBecomeStale_ = function() {
    this.schedule_();
  }, t.schedule_ = function() {
    this.isScheduled || (this.isScheduled = !0, Je.pendingReactions.push(this), VT());
  }, t.runReaction_ = function() {
    if (!this.isDisposed) {
      ei(), this.isScheduled = !1;
      var n = Je.trackingContext;
      if (Je.trackingContext = this, mS(this)) {
        this.isTrackPending = !0;
        try {
          this.onInvalidate_();
        } catch (o) {
          this.reportExceptionInDerivation_(o);
        }
      }
      Je.trackingContext = n, ti();
    }
  }, t.track = function(n) {
    if (!this.isDisposed) {
      ei(), this.isRunning = !0;
      var o = Je.trackingContext;
      Je.trackingContext = this;
      var a = MT(this, n, void 0);
      Je.trackingContext = o, this.isRunning = !1, this.isTrackPending = !1, this.isDisposed && gS(this), qy(a) && this.reportExceptionInDerivation_(a.cause), ti();
    }
  }, t.reportExceptionInDerivation_ = function(n) {
    var o = this;
    if (this.errorHandler_) {
      this.errorHandler_(n, this);
      return;
    }
    if (Je.disableErrorBoundaries)
      throw n;
    var a = "[mobx] uncaught error in '" + this + "'";
    Je.suppressReactionErrors || console.error(a, n), Je.globalReactionErrorHandlers.forEach(function(i) {
      return i(n, o);
    });
  }, t.dispose = function() {
    this.isDisposed || (this.isDisposed = !0, this.isRunning || (ei(), gS(this), ti()));
  }, t.getDisposer_ = function(n) {
    var o = this, a = function i() {
      o.dispose(), n == null || n.removeEventListener == null || n.removeEventListener("abort", i);
    };
    return n == null || n.addEventListener == null || n.addEventListener("abort", a), a[dt] = this, a;
  }, t.toString = function() {
    return "Reaction[" + this.name_ + "]";
  }, t.trace = function(n) {
  }, zp(e, [{
    key: "isDisposed",
    get: function() {
      return fi(this.flags_, e.isDisposedMask_);
    },
    set: function(n) {
      this.flags_ = di(this.flags_, e.isDisposedMask_, n);
    }
  }, {
    key: "isScheduled",
    get: function() {
      return fi(this.flags_, e.isScheduledMask_);
    },
    set: function(n) {
      this.flags_ = di(this.flags_, e.isScheduledMask_, n);
    }
  }, {
    key: "isTrackPending",
    get: function() {
      return fi(this.flags_, e.isTrackPendingMask_);
    },
    set: function(n) {
      this.flags_ = di(this.flags_, e.isTrackPendingMask_, n);
    }
  }, {
    key: "isRunning",
    get: function() {
      return fi(this.flags_, e.isRunningMask_);
    },
    set: function(n) {
      this.flags_ = di(this.flags_, e.isRunningMask_, n);
    }
  }, {
    key: "diffValue",
    get: function() {
      return fi(this.flags_, e.diffValueMask_) ? 1 : 0;
    },
    set: function(n) {
      this.flags_ = di(this.flags_, e.diffValueMask_, n === 1);
    }
  }]);
}();
Yi.isDisposedMask_ = 1;
Yi.isScheduledMask_ = 2;
Yi.isTrackPendingMask_ = 4;
Yi.isRunningMask_ = 8;
Yi.diffValueMask_ = 16;
function yD(e) {
  return Je.globalReactionErrorHandlers.push(e), function() {
    var t = Je.globalReactionErrorHandlers.indexOf(e);
    t >= 0 && Je.globalReactionErrorHandlers.splice(t, 1);
  };
}
var vD = 100, yS = function(t) {
  return t();
};
function VT() {
  Je.inBatch > 0 || Je.isRunningReactions || yS(bD);
}
function bD() {
  Je.isRunningReactions = !0;
  for (var e = Je.pendingReactions, t = 0; e.length > 0; ) {
    ++t === vD && (console.error("[mobx] cycle in reaction: " + e[0]), e.splice(0));
    for (var r = e.splice(0), n = 0, o = r.length; n < o; n++)
      r[n].runReaction_();
  }
  Je.isRunningReactions = !1;
}
var cv = /* @__PURE__ */ bl("Reaction", Yi);
function wD(e) {
  var t = yS;
  yS = function(n) {
    return e(function() {
      return t(n);
    });
  };
}
function Yd() {
  return !1;
}
function HT(e) {
  return console.warn("[mobx.spy] Is a no-op in production builds"), function() {
  };
}
var WT = "action", SD = "action.bound", KT = "autoAction", xD = "autoAction.bound", QT = "<unnamed action>", vS = /* @__PURE__ */ Sh(WT), _D = /* @__PURE__ */ Sh(SD, {
  bound: !0
}), bS = /* @__PURE__ */ Sh(KT, {
  autoAction: !0
}), ED = /* @__PURE__ */ Sh(xD, {
  autoAction: !0,
  bound: !0
});
function YT(e) {
  var t = function(n, o) {
    if (hi(n))
      return gl(n.name || QT, n, e);
    if (hi(o))
      return gl(n, o, e);
    if (wh(o))
      return (e ? bS : vS).decorate_20223_(n, o);
    if (ju(o))
      return bh(n, o, e ? bS : vS);
    if (ju(n))
      return Os(Sh(e ? KT : WT, {
        name: n,
        autoAction: e
      }));
  };
  return t;
}
var ol = /* @__PURE__ */ YT(!1);
Object.assign(ol, vS);
var Cp = /* @__PURE__ */ YT(!0);
Object.assign(Cp, bS);
ol.bound = /* @__PURE__ */ Os(_D);
Cp.bound = /* @__PURE__ */ Os(ED);
function wS(e) {
  return NT(e.name || QT, !1, e, this, void 0);
}
function $p(e) {
  return hi(e) && e.isMobxAction === !0;
}
function dx(e, t) {
  var r, n, o, a;
  t === void 0 && (t = lx);
  var i = (r = (n = t) == null ? void 0 : n.name) != null ? r : "Autorun", u = !t.scheduler && !t.delay, c;
  if (u)
    c = new Yi(i, function() {
      this.track(g);
    }, t.onError, t.requiresObservable);
  else {
    var d = GT(t), m = !1;
    c = new Yi(i, function() {
      m || (m = !0, d(function() {
        m = !1, c.isDisposed || c.track(g);
      }));
    }, t.onError, t.requiresObservable);
  }
  function g() {
    e(c);
  }
  return (o = t) != null && (o = o.signal) != null && o.aborted || c.schedule_(), c.getDisposer_((a = t) == null ? void 0 : a.signal);
}
var OD = function(t) {
  return t();
};
function GT(e) {
  return e.scheduler ? e.scheduler : e.delay ? function(t) {
    return setTimeout(t, e.delay);
  } : OD;
}
function kD(e, t, r) {
  var n, o, a;
  r === void 0 && (r = lx);
  var i = (n = r.name) != null ? n : "Reaction", u = ol(i, r.onError ? AD(r.onError, t) : t), c = !r.scheduler && !r.delay, d = GT(r), m = !0, g = !1, v, S = r.compareStructural ? Lu.structural : r.equals || Lu.default, k = new Yi(i, function() {
    m || c ? b() : g || (g = !0, d(b));
  }, r.onError, r.requiresObservable);
  function b() {
    if (g = !1, !k.isDisposed) {
      var x = !1, A = v;
      k.track(function() {
        var _ = Jv(!1, function() {
          return e(k);
        });
        x = m || !S(v, _), v = _;
      }), (m && r.fireImmediately || !m && x) && u(v, A, k), m = !1;
    }
  }
  return (o = r) != null && (o = o.signal) != null && o.aborted || k.schedule_(), k.getDisposer_((a = r) == null ? void 0 : a.signal);
}
function AD(e, t) {
  return function() {
    try {
      return t.apply(this, arguments);
    } catch (r) {
      e.call(this, r);
    }
  };
}
var PD = "onBO", TD = "onBUO";
function XT(e, t, r) {
  return JT(PD, e, t, r);
}
function hx(e, t, r) {
  return JT(TD, e, t, r);
}
function JT(e, t, r, n) {
  var o = typeof n == "function" ? ha(t, r) : ha(t), a = hi(n) ? n : r, i = e + "L";
  return o[i] ? o[i].add(a) : o[i] = /* @__PURE__ */ new Set([a]), function() {
    var u = o[i];
    u && (u.delete(a), u.size === 0 && delete o[i]);
  };
}
var CD = "never", gg = "always", $D = "observed";
function ZT(e) {
  e.isolateGlobalState === !0 && uD();
  var t = e.useProxies, r = e.enforceActions;
  if (t !== void 0 && (Je.useProxies = t === gg ? !0 : t === CD ? !1 : typeof Proxy < "u"), t === "ifavailable" && (Je.verifyProxies = !0), r !== void 0) {
    var n = r === gg ? gg : r === $D;
    Je.enforceActions = n, Je.allowStateChanges = !(n === !0 || n === gg);
  }
  ["computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "disableErrorBoundaries", "safeDescriptors"].forEach(function(o) {
    o in e && (Je[o] = !!e[o]);
  }), Je.allowStateReads = !Je.observableRequiresReaction, e.reactionScheduler && wD(e.reactionScheduler);
}
function mx(e, t, r, n) {
  var o = lM(t);
  return Sl(function() {
    var a = Vu(e, n)[dt];
    Tp(o).forEach(function(i) {
      a.extend_(
        i,
        o[i],
        // must pass "undefined" for { key: undefined }
        r && i in r ? r[i] : !0
      );
    });
  }), e;
}
function eC(e, t) {
  return tC(ha(e, t));
}
function tC(e) {
  var t = {
    name: e.name_
  };
  return e.observing_ && e.observing_.length > 0 && (t.dependencies = ID(e.observing_).map(tC)), t;
}
function RD(e, t) {
  return rC(ha(e, t));
}
function rC(e) {
  var t = {
    name: e.name_
  };
  return fD(e) && (t.observers = Array.from(dD(e)).map(rC)), t;
}
function ID(e) {
  return Array.from(new Set(e));
}
var ND = 0;
function rb() {
  this.message = "FLOW_CANCELLED";
}
rb.prototype = /* @__PURE__ */ Object.create(Error.prototype);
function jD(e) {
  return e instanceof rb;
}
var E0 = /* @__PURE__ */ AT("flow"), LD = /* @__PURE__ */ AT("flow.bound", {
  bound: !0
}), Fu = /* @__PURE__ */ Object.assign(function(t, r) {
  if (wh(r))
    return E0.decorate_20223_(t, r);
  if (ju(r))
    return bh(t, r, E0);
  var n = t, o = n.name || "<unnamed flow>", a = function() {
    var u = this, c = arguments, d = ++ND, m = ol(o + " - runid: " + d + " - init", n).apply(u, c), g, v = void 0, S = new Promise(function(k, b) {
      var x = 0;
      g = b;
      function A(R) {
        v = void 0;
        var C;
        try {
          C = ol(o + " - runid: " + d + " - yield " + x++, m.next).call(m, R);
        } catch (T) {
          return b(T);
        }
        O(C);
      }
      function _(R) {
        v = void 0;
        var C;
        try {
          C = ol(o + " - runid: " + d + " - yield " + x++, m.throw).call(m, R);
        } catch (T) {
          return b(T);
        }
        O(C);
      }
      function O(R) {
        if (hi(R == null ? void 0 : R.then)) {
          R.then(O, b);
          return;
        }
        return R.done ? k(R.value) : (v = Promise.resolve(R.value), v.then(A, _));
      }
      A(void 0);
    });
    return S.cancel = ol(o + " - runid: " + d + " - cancel", function() {
      try {
        v && a_(v);
        var k = m.return(void 0), b = Promise.resolve(k.value);
        b.then(gp, gp), a_(b), g(new rb());
      } catch (x) {
        g(x);
      }
    }), S;
  };
  return a.isMobXFlow = !0, a;
}, E0);
Fu.bound = /* @__PURE__ */ Os(LD);
function a_(e) {
  hi(e.cancel) && e.cancel();
}
function MD(e) {
  return e;
}
function Rp(e) {
  return (e == null ? void 0 : e.isMobXFlow) === !0;
}
function DD(e, t, r) {
  var n;
  return Gr(e) || $n(e) || fx(e) ? n = ma(e) : Yr(e) && (n = ma(e, t)), n.dehancer = typeof t == "function" ? t : r, function() {
    n.dehancer = void 0;
  };
}
function FD(e, t, r) {
  return hi(r) ? zD(e, t, r) : qD(e, t);
}
function qD(e, t) {
  return ma(e).intercept_(t);
}
function zD(e, t, r) {
  return ma(e, t).intercept_(r);
}
function nC(e, t) {
  if (t === void 0)
    return Du(e);
  if (Yr(e) === !1 || !e[dt].values_.has(t))
    return !1;
  var r = ha(e, t);
  return Du(r);
}
function BD(e) {
  return nC(e);
}
function UD(e, t) {
  return nC(e, t);
}
function iC(e, t) {
  return e ? t !== void 0 ? Yr(e) ? e[dt].values_.has(t) : !1 : Yr(e) || !!e[dt] || ux(e) || cv(e) || Du(e) : !1;
}
function nb(e) {
  return iC(e);
}
function VD(e, t) {
  return iC(e, t);
}
function sh(e) {
  if (Yr(e))
    return e[dt].keys_();
  if (Gr(e) || Vr(e))
    return Array.from(e.keys());
  if ($n(e))
    return e.map(function(t, r) {
      return r;
    });
  At(5);
}
function HD(e) {
  if (Yr(e))
    return sh(e).map(function(t) {
      return e[t];
    });
  if (Gr(e))
    return sh(e).map(function(t) {
      return e.get(t);
    });
  if (Vr(e))
    return Array.from(e.values());
  if ($n(e))
    return e.slice();
  At(6);
}
function WD(e) {
  if (Yr(e))
    return sh(e).map(function(t) {
      return [t, e[t]];
    });
  if (Gr(e))
    return sh(e).map(function(t) {
      return [t, e.get(t)];
    });
  if (Vr(e))
    return Array.from(e.entries());
  if ($n(e))
    return e.map(function(t, r) {
      return [r, t];
    });
  At(7);
}
function sC(e, t, r) {
  if (arguments.length === 2 && !Vr(e)) {
    ei();
    var n = t;
    try {
      for (var o in n)
        sC(e, o, n[o]);
    } finally {
      ti();
    }
    return;
  }
  Yr(e) ? e[dt].set_(t, r) : Gr(e) ? e.set(t, r) : Vr(e) ? e.add(t) : $n(e) ? (typeof t != "number" && (t = parseInt(t, 10)), t < 0 && At("Invalid index: '" + t + "'"), ei(), t >= e.length && (e.length = t + 1), e[t] = r, ti()) : At(8);
}
function KD(e, t) {
  Yr(e) ? e[dt].delete_(t) : Gr(e) || Vr(e) ? e.delete(t) : $n(e) ? (typeof t != "number" && (t = parseInt(t, 10)), e.splice(t, 1)) : At(9);
}
function oC(e, t) {
  if (Yr(e))
    return e[dt].has_(t);
  if (Gr(e))
    return e.has(t);
  if (Vr(e))
    return e.has(t);
  if ($n(e))
    return t >= 0 && t < e.length;
  At(10);
}
function QD(e, t) {
  if (oC(e, t)) {
    if (Yr(e))
      return e[dt].get_(t);
    if (Gr(e))
      return e.get(t);
    if ($n(e))
      return e[t];
    At(11);
  }
}
function YD(e, t, r) {
  if (Yr(e))
    return e[dt].defineProperty_(t, r);
  At(39);
}
function aC(e) {
  if (Yr(e))
    return e[dt].ownKeys_();
  At(38);
}
function GD(e, t, r, n) {
  return hi(r) ? JD(e, t, r, n) : XD(e, t, r);
}
function XD(e, t, r) {
  return ma(e).observe_(t, r);
}
function JD(e, t, r, n) {
  return ma(e, t).observe_(r, n);
}
function yg(e, t, r) {
  return e.set(t, r), r;
}
function up(e, t) {
  if (e == null || typeof e != "object" || e instanceof Date || !nb(e))
    return e;
  if (fx(e) || Du(e))
    return up(e.get(), t);
  if (t.has(e))
    return t.get(e);
  if ($n(e)) {
    var r = yg(t, e, new Array(e.length));
    return e.forEach(function(i, u) {
      r[u] = up(i, t);
    }), r;
  }
  if (Vr(e)) {
    var n = yg(t, e, /* @__PURE__ */ new Set());
    return e.forEach(function(i) {
      n.add(up(i, t));
    }), n;
  }
  if (Gr(e)) {
    var o = yg(t, e, /* @__PURE__ */ new Map());
    return e.forEach(function(i, u) {
      o.set(u, up(i, t));
    }), o;
  } else {
    var a = yg(t, e, {});
    return aC(e).forEach(function(i) {
      yh.propertyIsEnumerable.call(e, i) && (a[i] = up(e[i], t));
    }), a;
  }
}
function ZD(e, t) {
  return up(e, /* @__PURE__ */ new Map());
}
function eF() {
}
function ho(e, t) {
  t === void 0 && (t = void 0), ei();
  try {
    return e.apply(t);
  } finally {
    ti();
  }
}
function tF(e, t, r) {
  return arguments.length === 1 || t && typeof t == "object" ? rF(e, t) : lC(e, t, r || {});
}
function lC(e, t, r) {
  var n;
  if (typeof r.timeout == "number") {
    var o = new Error("WHEN_TIMEOUT");
    n = setTimeout(function() {
      if (!i[dt].isDisposed)
        if (i(), r.onError)
          r.onError(o);
        else
          throw o;
    }, r.timeout);
  }
  r.name = "When";
  var a = gl("When-effect", t), i = dx(function(u) {
    var c = Jv(!1, e);
    c && (u.dispose(), n && clearTimeout(n), a());
  }, r);
  return i;
}
function rF(e, t) {
  var r;
  if (t != null && (r = t.signal) != null && r.aborted)
    return Object.assign(Promise.reject(new Error("WHEN_ABORTED")), {
      cancel: function() {
        return null;
      }
    });
  var n, o, a = new Promise(function(i, u) {
    var c, d = lC(e, i, ml({}, t, {
      onError: u
    }));
    n = function() {
      d(), u(new Error("WHEN_CANCELLED"));
    }, o = function() {
      d(), u(new Error("WHEN_ABORTED"));
    }, t == null || (c = t.signal) == null || c.addEventListener == null || c.addEventListener("abort", o);
  }).finally(function() {
    var i;
    return t == null || (i = t.signal) == null || i.removeEventListener == null ? void 0 : i.removeEventListener("abort", o);
  });
  return a.cancel = n, a;
}
function np(e) {
  return e[dt];
}
var nF = {
  has: function(t, r) {
    return np(t).has_(r);
  },
  get: function(t, r) {
    return np(t).get_(r);
  },
  set: function(t, r, n) {
    var o;
    return ju(r) ? (o = np(t).set_(r, n, !0)) != null ? o : !0 : !1;
  },
  deleteProperty: function(t, r) {
    var n;
    return ju(r) ? (n = np(t).delete_(r, !0)) != null ? n : !0 : !1;
  },
  defineProperty: function(t, r, n) {
    var o;
    return (o = np(t).defineProperty_(r, n)) != null ? o : !0;
  },
  ownKeys: function(t) {
    return np(t).ownKeys_();
  },
  preventExtensions: function(t) {
    At(13);
  }
};
function iF(e, t) {
  var r, n;
  return vT(), e = Vu(e, t), (n = (r = e[dt]).proxy_) != null ? n : r.proxy_ = new Proxy(e, nF);
}
function Ui(e) {
  return e.interceptors_ !== void 0 && e.interceptors_.length > 0;
}
function _h(e, t) {
  var r = e.interceptors_ || (e.interceptors_ = []);
  return r.push(t), bT(function() {
    var n = r.indexOf(t);
    n !== -1 && r.splice(n, 1);
  });
}
function Vi(e, t) {
  var r = Uu();
  try {
    for (var n = [].concat(e.interceptors_ || []), o = 0, a = n.length; o < a && (t = n[o](t), t && !t.type && At(14), !!t); o++)
      ;
    return t;
  } finally {
    ua(r);
  }
}
function ks(e) {
  return e.changeListeners_ !== void 0 && e.changeListeners_.length > 0;
}
function Eh(e, t) {
  var r = e.changeListeners_ || (e.changeListeners_ = []);
  return r.push(t), bT(function() {
    var n = r.indexOf(t);
    n !== -1 && r.splice(n, 1);
  });
}
function As(e, t) {
  var r = Uu(), n = e.changeListeners_;
  if (n) {
    n = n.slice();
    for (var o = 0, a = n.length; o < a; o++)
      n[o](t);
    ua(r);
  }
}
function uC(e, t, r) {
  return Sl(function() {
    var n, o = Vu(e, r)[dt];
    (n = t) != null || (t = dM(e)), Tp(t).forEach(function(a) {
      return o.make_(a, t[a]);
    });
  }), e;
}
var O0 = /* @__PURE__ */ Symbol("mobx-keys");
function sF(e, t, r) {
  return da(e) ? mx(e, e, t, r) : (Sl(function() {
    var n = Vu(e, r)[dt];
    if (!e[O0]) {
      var o = Object.getPrototypeOf(e), a = new Set([].concat(Tp(e), Tp(o)));
      a.delete("constructor"), a.delete(dt), vh(o, O0, a);
    }
    e[O0].forEach(function(i) {
      return n.make_(
        i,
        // must pass "undefined" for { key: undefined }
        t && i in t ? t[i] : !0
      );
    });
  }), e);
}
var l_ = "splice", wo = "update", oF = 1e4, aF = {
  get: function(t, r) {
    var n = t[dt];
    return r === dt ? n : r === "length" ? n.getArrayLength_() : typeof r == "string" && !isNaN(r) ? n.get_(parseInt(r)) : la(pv, r) ? pv[r] : t[r];
  },
  set: function(t, r, n) {
    var o = t[dt];
    return r === "length" && o.setArrayLength_(n), typeof r == "symbol" || isNaN(r) ? t[r] = n : o.set_(parseInt(r), n), !0;
  },
  preventExtensions: function() {
    At(15);
  }
}, gx = /* @__PURE__ */ function() {
  function e(r, n, o, a) {
    r === void 0 && (r = "ObservableArray"), this.owned_ = void 0, this.legacyMode_ = void 0, this.atom_ = void 0, this.values_ = [], this.interceptors_ = void 0, this.changeListeners_ = void 0, this.enhancer_ = void 0, this.dehancer = void 0, this.proxy_ = void 0, this.lastKnownLength_ = 0, this.owned_ = o, this.legacyMode_ = a, this.atom_ = new wl(r), this.enhancer_ = function(i, u) {
      return n(i, u, "ObservableArray[..]");
    };
  }
  var t = e.prototype;
  return t.dehanceValue_ = function(n) {
    return this.dehancer !== void 0 ? this.dehancer(n) : n;
  }, t.dehanceValues_ = function(n) {
    return this.dehancer !== void 0 && n.length > 0 ? n.map(this.dehancer) : n;
  }, t.intercept_ = function(n) {
    return _h(this, n);
  }, t.observe_ = function(n, o) {
    return o === void 0 && (o = !1), o && n({
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: "splice",
      index: 0,
      added: this.values_.slice(),
      addedCount: this.values_.length,
      removed: [],
      removedCount: 0
    }), Eh(this, n);
  }, t.getArrayLength_ = function() {
    return this.atom_.reportObserved(), this.values_.length;
  }, t.setArrayLength_ = function(n) {
    (typeof n != "number" || isNaN(n) || n < 0) && At("Out of range: " + n);
    var o = this.values_.length;
    if (n !== o)
      if (n > o) {
        for (var a = new Array(n - o), i = 0; i < n - o; i++)
          a[i] = void 0;
        this.spliceWithArray_(o, 0, a);
      } else
        this.spliceWithArray_(n, o - n);
  }, t.updateArrayLength_ = function(n, o) {
    n !== this.lastKnownLength_ && At(16), this.lastKnownLength_ += o, this.legacyMode_ && o > 0 && hC(n + o + 1);
  }, t.spliceWithArray_ = function(n, o, a) {
    var i = this;
    this.atom_;
    var u = this.values_.length;
    if (n === void 0 ? n = 0 : n > u ? n = u : n < 0 && (n = Math.max(0, u + n)), arguments.length === 1 ? o = u - n : o == null ? o = 0 : o = Math.max(0, Math.min(o, u - n)), a === void 0 && (a = pS), Ui(this)) {
      var c = Vi(this, {
        object: this.proxy_,
        type: l_,
        index: n,
        removedCount: o,
        added: a
      });
      if (!c)
        return pS;
      o = c.removedCount, a = c.added;
    }
    if (a = a.length === 0 ? a : a.map(function(g) {
      return i.enhancer_(g, void 0);
    }), this.legacyMode_) {
      var d = a.length - o;
      this.updateArrayLength_(u, d);
    }
    var m = this.spliceItemsIntoValues_(n, o, a);
    return (o !== 0 || a.length !== 0) && this.notifyArraySplice_(n, a, m), this.dehanceValues_(m);
  }, t.spliceItemsIntoValues_ = function(n, o, a) {
    if (a.length < oF) {
      var i;
      return (i = this.values_).splice.apply(i, [n, o].concat(a));
    } else {
      var u = this.values_.slice(n, n + o), c = this.values_.slice(n + o);
      this.values_.length += a.length - o;
      for (var d = 0; d < a.length; d++)
        this.values_[n + d] = a[d];
      for (var m = 0; m < c.length; m++)
        this.values_[n + a.length + m] = c[m];
      return u;
    }
  }, t.notifyArrayChildUpdate_ = function(n, o, a) {
    var i = !this.owned_ && Yd(), u = ks(this), c = u || i ? {
      observableKind: "array",
      object: this.proxy_,
      type: wo,
      debugObjectName: this.atom_.name_,
      index: n,
      newValue: o,
      oldValue: a
    } : null;
    this.atom_.reportChanged(), u && As(this, c);
  }, t.notifyArraySplice_ = function(n, o, a) {
    var i = !this.owned_ && Yd(), u = ks(this), c = u || i ? {
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: l_,
      index: n,
      removed: a,
      added: o,
      removedCount: a.length,
      addedCount: o.length
    } : null;
    this.atom_.reportChanged(), u && As(this, c);
  }, t.get_ = function(n) {
    if (this.legacyMode_ && n >= this.values_.length) {
      console.warn("[mobx] Out of bounds read: " + n);
      return;
    }
    return this.atom_.reportObserved(), this.dehanceValue_(this.values_[n]);
  }, t.set_ = function(n, o) {
    var a = this.values_;
    if (this.legacyMode_ && n > a.length && At(17, n, a.length), n < a.length) {
      this.atom_;
      var i = a[n];
      if (Ui(this)) {
        var u = Vi(this, {
          type: wo,
          object: this.proxy_,
          // since "this" is the real array we need to pass its proxy
          index: n,
          newValue: o
        });
        if (!u)
          return;
        o = u.newValue;
      }
      o = this.enhancer_(o, i);
      var c = o !== i;
      c && (a[n] = o, this.notifyArrayChildUpdate_(n, o, i));
    } else {
      for (var d = new Array(n + 1 - a.length), m = 0; m < d.length - 1; m++)
        d[m] = void 0;
      d[d.length - 1] = o, this.spliceWithArray_(a.length, 0, d);
    }
  }, e;
}();
function lF(e, t, r, n) {
  return r === void 0 && (r = "ObservableArray"), n === void 0 && (n = !1), vT(), Sl(function() {
    var o = new gx(r, t, n, !1);
    ST(o.values_, dt, o);
    var a = new Proxy(o.values_, aF);
    return o.proxy_ = a, e && e.length && o.spliceWithArray_(0, 0, e), a;
  });
}
var pv = {
  clear: function() {
    return this.splice(0);
  },
  replace: function(t) {
    var r = this[dt];
    return r.spliceWithArray_(0, r.values_.length, t);
  },
  // Used by JSON.stringify
  toJSON: function() {
    return this.slice();
  },
  /*
   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
   * since these functions alter the inner structure of the array, the have side effects.
   * Because the have side effects, they should not be used in computed function,
   * and for that reason the do not call dependencyState.notifyObserved
   */
  splice: function(t, r) {
    for (var n = arguments.length, o = new Array(n > 2 ? n - 2 : 0), a = 2; a < n; a++)
      o[a - 2] = arguments[a];
    var i = this[dt];
    switch (arguments.length) {
      case 0:
        return [];
      case 1:
        return i.spliceWithArray_(t);
      case 2:
        return i.spliceWithArray_(t, r);
    }
    return i.spliceWithArray_(t, r, o);
  },
  spliceWithArray: function(t, r, n) {
    return this[dt].spliceWithArray_(t, r, n);
  },
  push: function() {
    for (var t = this[dt], r = arguments.length, n = new Array(r), o = 0; o < r; o++)
      n[o] = arguments[o];
    return t.spliceWithArray_(t.values_.length, 0, n), t.values_.length;
  },
  pop: function() {
    return this.splice(Math.max(this[dt].values_.length - 1, 0), 1)[0];
  },
  shift: function() {
    return this.splice(0, 1)[0];
  },
  unshift: function() {
    for (var t = this[dt], r = arguments.length, n = new Array(r), o = 0; o < r; o++)
      n[o] = arguments[o];
    return t.spliceWithArray_(0, 0, n), t.values_.length;
  },
  reverse: function() {
    return Je.trackingDerivation && At(37, "reverse"), this.replace(this.slice().reverse()), this;
  },
  sort: function() {
    Je.trackingDerivation && At(37, "sort");
    var t = this.slice();
    return t.sort.apply(t, arguments), this.replace(t), this;
  },
  remove: function(t) {
    var r = this[dt], n = r.dehanceValues_(r.values_).indexOf(t);
    return n > -1 ? (this.splice(n, 1), !0) : !1;
  }
};
sr("at", yi);
sr("concat", yi);
sr("flat", yi);
sr("includes", yi);
sr("indexOf", yi);
sr("join", yi);
sr("lastIndexOf", yi);
sr("slice", yi);
sr("toString", yi);
sr("toLocaleString", yi);
sr("toSorted", yi);
sr("toSpliced", yi);
sr("with", yi);
sr("every", $s);
sr("filter", $s);
sr("find", $s);
sr("findIndex", $s);
sr("findLast", $s);
sr("findLastIndex", $s);
sr("flatMap", $s);
sr("forEach", $s);
sr("map", $s);
sr("some", $s);
sr("toReversed", $s);
sr("reduce", cC);
sr("reduceRight", cC);
function sr(e, t) {
  typeof Array.prototype[e] == "function" && (pv[e] = t(e));
}
function yi(e) {
  return function() {
    var t = this[dt];
    t.atom_.reportObserved();
    var r = t.dehanceValues_(t.values_);
    return r[e].apply(r, arguments);
  };
}
function $s(e) {
  return function(t, r) {
    var n = this, o = this[dt];
    o.atom_.reportObserved();
    var a = o.dehanceValues_(o.values_);
    return a[e](function(i, u) {
      return t.call(r, i, u, n);
    });
  };
}
function cC(e) {
  return function() {
    var t = this, r = this[dt];
    r.atom_.reportObserved();
    var n = r.dehanceValues_(r.values_), o = arguments[0];
    return arguments[0] = function(a, i, u) {
      return o(a, i, u, t);
    }, n[e].apply(n, arguments);
  };
}
var uF = /* @__PURE__ */ bl("ObservableArrayAdministration", gx);
function $n(e) {
  return Yv(e) && uF(e[dt]);
}
var cF = {}, al = "add", fv = "delete", yx = /* @__PURE__ */ function() {
  function e(r, n, o) {
    var a = this;
    n === void 0 && (n = Mu), o === void 0 && (o = "ObservableMap"), this.enhancer_ = void 0, this.name_ = void 0, this[dt] = cF, this.data_ = void 0, this.hasMap_ = void 0, this.keysAtom_ = void 0, this.interceptors_ = void 0, this.changeListeners_ = void 0, this.dehancer = void 0, this.enhancer_ = n, this.name_ = o, hi(Map) || At(18), Sl(function() {
      a.keysAtom_ = cx("ObservableMap.keys()"), a.data_ = /* @__PURE__ */ new Map(), a.hasMap_ = /* @__PURE__ */ new Map(), r && a.merge(r);
    });
  }
  var t = e.prototype;
  return t.has_ = function(n) {
    return this.data_.has(n);
  }, t.has = function(n) {
    var o = this;
    if (!Je.trackingDerivation)
      return this.has_(n);
    var a = this.hasMap_.get(n);
    if (!a) {
      var i = a = new pl(this.has_(n), Gv, "ObservableMap.key?", !1);
      this.hasMap_.set(n, i), hx(i, function() {
        return o.hasMap_.delete(n);
      });
    }
    return a.get();
  }, t.set = function(n, o) {
    var a = this.has_(n);
    if (Ui(this)) {
      var i = Vi(this, {
        type: a ? wo : al,
        object: this,
        newValue: o,
        name: n
      });
      if (!i)
        return this;
      o = i.newValue;
    }
    return a ? this.updateValue_(n, o) : this.addValue_(n, o), this;
  }, t.delete = function(n) {
    var o = this;
    if (this.keysAtom_, Ui(this)) {
      var a = Vi(this, {
        type: fv,
        object: this,
        name: n
      });
      if (!a)
        return !1;
    }
    if (this.has_(n)) {
      var i = Yd(), u = ks(this), c = u || i ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: fv,
        object: this,
        oldValue: this.data_.get(n).value_,
        name: n
      } : null;
      return ho(function() {
        var d;
        o.keysAtom_.reportChanged(), (d = o.hasMap_.get(n)) == null || d.setNewValue_(!1);
        var m = o.data_.get(n);
        m.setNewValue_(void 0), o.data_.delete(n);
      }), u && As(this, c), !0;
    }
    return !1;
  }, t.updateValue_ = function(n, o) {
    var a = this.data_.get(n);
    if (o = a.prepareNewValue_(o), o !== Je.UNCHANGED) {
      var i = Yd(), u = ks(this), c = u || i ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: wo,
        object: this,
        oldValue: a.value_,
        name: n,
        newValue: o
      } : null;
      a.setNewValue_(o), u && As(this, c);
    }
  }, t.addValue_ = function(n, o) {
    var a = this;
    this.keysAtom_, ho(function() {
      var d, m = new pl(o, a.enhancer_, "ObservableMap.key", !1);
      a.data_.set(n, m), o = m.value_, (d = a.hasMap_.get(n)) == null || d.setNewValue_(!0), a.keysAtom_.reportChanged();
    });
    var i = Yd(), u = ks(this), c = u || i ? {
      observableKind: "map",
      debugObjectName: this.name_,
      type: al,
      object: this,
      name: n,
      newValue: o
    } : null;
    u && As(this, c);
  }, t.get = function(n) {
    return this.has(n) ? this.dehanceValue_(this.data_.get(n).get()) : this.dehanceValue_(void 0);
  }, t.dehanceValue_ = function(n) {
    return this.dehancer !== void 0 ? this.dehancer(n) : n;
  }, t.keys = function() {
    return this.keysAtom_.reportObserved(), this.data_.keys();
  }, t.values = function() {
    var n = this, o = this.keys();
    return u_({
      next: function() {
        var i = o.next(), u = i.done, c = i.value;
        return {
          done: u,
          value: u ? void 0 : n.get(c)
        };
      }
    });
  }, t.entries = function() {
    var n = this, o = this.keys();
    return u_({
      next: function() {
        var i = o.next(), u = i.done, c = i.value;
        return {
          done: u,
          value: u ? void 0 : [c, n.get(c)]
        };
      }
    });
  }, t[Symbol.iterator] = function() {
    return this.entries();
  }, t.forEach = function(n, o) {
    for (var a = yp(this), i; !(i = a()).done; ) {
      var u = i.value, c = u[0], d = u[1];
      n.call(o, d, c, this);
    }
  }, t.merge = function(n) {
    var o = this;
    return Gr(n) && (n = new Map(n)), ho(function() {
      da(n) ? aM(n).forEach(function(a) {
        return o.set(a, n[a]);
      }) : Array.isArray(n) ? n.forEach(function(a) {
        var i = a[0], u = a[1];
        return o.set(i, u);
      }) : qp(n) ? (oM(n) || At(19, n), n.forEach(function(a, i) {
        return o.set(i, a);
      })) : n != null && At(20, n);
    }), this;
  }, t.clear = function() {
    var n = this;
    ho(function() {
      Bp(function() {
        for (var o = yp(n.keys()), a; !(a = o()).done; ) {
          var i = a.value;
          n.delete(i);
        }
      });
    });
  }, t.replace = function(n) {
    var o = this;
    return ho(function() {
      for (var a = pF(n), i = /* @__PURE__ */ new Map(), u = !1, c = yp(o.data_.keys()), d; !(d = c()).done; ) {
        var m = d.value;
        if (!a.has(m)) {
          var g = o.delete(m);
          if (g)
            u = !0;
          else {
            var v = o.data_.get(m);
            i.set(m, v);
          }
        }
      }
      for (var S = yp(a.entries()), k; !(k = S()).done; ) {
        var b = k.value, x = b[0], A = b[1], _ = o.data_.has(x);
        if (o.set(x, A), o.data_.has(x)) {
          var O = o.data_.get(x);
          i.set(x, O), _ || (u = !0);
        }
      }
      if (!u)
        if (o.data_.size !== i.size)
          o.keysAtom_.reportChanged();
        else
          for (var R = o.data_.keys(), C = i.keys(), T = R.next(), j = C.next(); !T.done; ) {
            if (T.value !== j.value) {
              o.keysAtom_.reportChanged();
              break;
            }
            T = R.next(), j = C.next();
          }
      o.data_ = i;
    }), this;
  }, t.toString = function() {
    return "[object ObservableMap]";
  }, t.toJSON = function() {
    return Array.from(this);
  }, t.observe_ = function(n, o) {
    return Eh(this, n);
  }, t.intercept_ = function(n) {
    return _h(this, n);
  }, zp(e, [{
    key: "size",
    get: function() {
      return this.keysAtom_.reportObserved(), this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function() {
      return "Map";
    }
  }]);
}(), Gr = /* @__PURE__ */ bl("ObservableMap", yx);
function u_(e) {
  return e[Symbol.toStringTag] = "MapIterator", Sx(e);
}
function pF(e) {
  if (qp(e) || Gr(e))
    return e;
  if (Array.isArray(e))
    return new Map(e);
  if (da(e)) {
    var t = /* @__PURE__ */ new Map();
    for (var r in e)
      t.set(r, e[r]);
    return t;
  } else
    return At(21, e);
}
var fF = {}, vx = /* @__PURE__ */ function() {
  function e(r, n, o) {
    var a = this;
    n === void 0 && (n = Mu), o === void 0 && (o = "ObservableSet"), this.name_ = void 0, this[dt] = fF, this.data_ = /* @__PURE__ */ new Set(), this.atom_ = void 0, this.changeListeners_ = void 0, this.interceptors_ = void 0, this.dehancer = void 0, this.enhancer_ = void 0, this.name_ = o, hi(Set) || At(22), this.enhancer_ = function(i, u) {
      return n(i, u, o);
    }, Sl(function() {
      a.atom_ = cx(a.name_), r && a.replace(r);
    });
  }
  var t = e.prototype;
  return t.dehanceValue_ = function(n) {
    return this.dehancer !== void 0 ? this.dehancer(n) : n;
  }, t.clear = function() {
    var n = this;
    ho(function() {
      Bp(function() {
        for (var o = yp(n.data_.values()), a; !(a = o()).done; ) {
          var i = a.value;
          n.delete(i);
        }
      });
    });
  }, t.forEach = function(n, o) {
    for (var a = yp(this), i; !(i = a()).done; ) {
      var u = i.value;
      n.call(o, u, u, this);
    }
  }, t.add = function(n) {
    var o = this;
    if (this.atom_, Ui(this)) {
      var a = Vi(this, {
        type: al,
        object: this,
        newValue: n
      });
      if (!a)
        return this;
      n = a.newValue;
    }
    if (!this.has(n)) {
      ho(function() {
        o.data_.add(o.enhancer_(n, void 0)), o.atom_.reportChanged();
      });
      var i = !1, u = ks(this), c = u || i ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: al,
        object: this,
        newValue: n
      } : null;
      u && As(this, c);
    }
    return this;
  }, t.delete = function(n) {
    var o = this;
    if (Ui(this)) {
      var a = Vi(this, {
        type: fv,
        object: this,
        oldValue: n
      });
      if (!a)
        return !1;
    }
    if (this.has(n)) {
      var i = !1, u = ks(this), c = u || i ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: fv,
        object: this,
        oldValue: n
      } : null;
      return ho(function() {
        o.atom_.reportChanged(), o.data_.delete(n);
      }), u && As(this, c), !0;
    }
    return !1;
  }, t.has = function(n) {
    return this.atom_.reportObserved(), this.data_.has(this.dehanceValue_(n));
  }, t.entries = function() {
    var n = this.values();
    return c_({
      next: function() {
        var a = n.next(), i = a.value, u = a.done;
        return u ? {
          value: void 0,
          done: u
        } : {
          value: [i, i],
          done: u
        };
      }
    });
  }, t.keys = function() {
    return this.values();
  }, t.values = function() {
    this.atom_.reportObserved();
    var n = this, o = this.data_.values();
    return c_({
      next: function() {
        var i = o.next(), u = i.value, c = i.done;
        return c ? {
          value: void 0,
          done: c
        } : {
          value: n.dehanceValue_(u),
          done: c
        };
      }
    });
  }, t.intersection = function(n) {
    if (sa(n) && !Vr(n))
      return n.intersection(this);
    var o = new Set(this);
    return o.intersection(n);
  }, t.union = function(n) {
    if (sa(n) && !Vr(n))
      return n.union(this);
    var o = new Set(this);
    return o.union(n);
  }, t.difference = function(n) {
    return new Set(this).difference(n);
  }, t.symmetricDifference = function(n) {
    if (sa(n) && !Vr(n))
      return n.symmetricDifference(this);
    var o = new Set(this);
    return o.symmetricDifference(n);
  }, t.isSubsetOf = function(n) {
    return new Set(this).isSubsetOf(n);
  }, t.isSupersetOf = function(n) {
    return new Set(this).isSupersetOf(n);
  }, t.isDisjointFrom = function(n) {
    if (sa(n) && !Vr(n))
      return n.isDisjointFrom(this);
    var o = new Set(this);
    return o.isDisjointFrom(n);
  }, t.replace = function(n) {
    var o = this;
    return Vr(n) && (n = new Set(n)), ho(function() {
      Array.isArray(n) ? (o.clear(), n.forEach(function(a) {
        return o.add(a);
      })) : sa(n) ? (o.clear(), n.forEach(function(a) {
        return o.add(a);
      })) : n != null && At("Cannot initialize set from " + n);
    }), this;
  }, t.observe_ = function(n, o) {
    return Eh(this, n);
  }, t.intercept_ = function(n) {
    return _h(this, n);
  }, t.toJSON = function() {
    return Array.from(this);
  }, t.toString = function() {
    return "[object ObservableSet]";
  }, t[Symbol.iterator] = function() {
    return this.values();
  }, zp(e, [{
    key: "size",
    get: function() {
      return this.atom_.reportObserved(), this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function() {
      return "Set";
    }
  }]);
}(), Vr = /* @__PURE__ */ bl("ObservableSet", vx);
function c_(e) {
  return e[Symbol.toStringTag] = "SetIterator", Sx(e);
}
var p_ = /* @__PURE__ */ Object.create(null), f_ = "remove", pC = /* @__PURE__ */ function() {
  function e(r, n, o, a) {
    n === void 0 && (n = /* @__PURE__ */ new Map()), a === void 0 && (a = BM), this.target_ = void 0, this.values_ = void 0, this.name_ = void 0, this.defaultAnnotation_ = void 0, this.keysAtom_ = void 0, this.changeListeners_ = void 0, this.interceptors_ = void 0, this.proxy_ = void 0, this.isPlainObject_ = void 0, this.appliedAnnotations_ = void 0, this.pendingKeys_ = void 0, this.target_ = r, this.values_ = n, this.name_ = o, this.defaultAnnotation_ = a, this.keysAtom_ = new wl("ObservableObject.keys"), this.isPlainObject_ = da(this.target_);
  }
  var t = e.prototype;
  return t.getObservablePropValue_ = function(n) {
    return this.values_.get(n).get();
  }, t.setObservablePropValue_ = function(n, o) {
    var a = this.values_.get(n);
    if (a instanceof Ps)
      return a.set(o), !0;
    if (Ui(this)) {
      var i = Vi(this, {
        type: wo,
        object: this.proxy_ || this.target_,
        name: n,
        newValue: o
      });
      if (!i)
        return null;
      o = i.newValue;
    }
    if (o = a.prepareNewValue_(o), o !== Je.UNCHANGED) {
      var u = ks(this), c = !1, d = u || c ? {
        type: wo,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        oldValue: a.value_,
        name: n,
        newValue: o
      } : null;
      a.setNewValue_(o), u && As(this, d);
    }
    return !0;
  }, t.get_ = function(n) {
    return Je.trackingDerivation && !la(this.target_, n) && this.has_(n), this.target_[n];
  }, t.set_ = function(n, o, a) {
    return a === void 0 && (a = !1), la(this.target_, n) ? this.values_.has(n) ? this.setObservablePropValue_(n, o) : a ? Reflect.set(this.target_, n, o) : (this.target_[n] = o, !0) : this.extend_(n, {
      value: o,
      enumerable: !0,
      writable: !0,
      configurable: !0
    }, this.defaultAnnotation_, a);
  }, t.has_ = function(n) {
    if (!Je.trackingDerivation)
      return n in this.target_;
    this.pendingKeys_ || (this.pendingKeys_ = /* @__PURE__ */ new Map());
    var o = this.pendingKeys_.get(n);
    return o || (o = new pl(n in this.target_, Gv, "ObservableObject.key?", !1), this.pendingKeys_.set(n, o)), o.get();
  }, t.make_ = function(n, o) {
    if (o === !0 && (o = this.defaultAnnotation_), o !== !1) {
      if (!(n in this.target_)) {
        var a;
        if ((a = this.target_[go]) != null && a[n])
          return;
        At(1, o.annotationType_, this.name_ + "." + n.toString());
      }
      for (var i = this.target_; i && i !== yh; ) {
        var u = ov(i, n);
        if (u) {
          var c = o.make_(this, n, u, i);
          if (c === 0)
            return;
          if (c === 1)
            break;
        }
        i = Object.getPrototypeOf(i);
      }
      h_(this, o, n);
    }
  }, t.extend_ = function(n, o, a, i) {
    if (i === void 0 && (i = !1), a === !0 && (a = this.defaultAnnotation_), a === !1)
      return this.defineProperty_(n, o, i);
    var u = a.extend_(this, n, o, i);
    return u && h_(this, a, n), u;
  }, t.defineProperty_ = function(n, o, a) {
    a === void 0 && (a = !1), this.keysAtom_;
    try {
      ei();
      var i = this.delete_(n);
      if (!i)
        return i;
      if (Ui(this)) {
        var u = Vi(this, {
          object: this.proxy_ || this.target_,
          name: n,
          type: al,
          newValue: o.value
        });
        if (!u)
          return null;
        var c = u.newValue;
        o.value !== c && (o = ml({}, o, {
          value: c
        }));
      }
      if (a) {
        if (!Reflect.defineProperty(this.target_, n, o))
          return !1;
      } else
        bo(this.target_, n, o);
      this.notifyPropertyAddition_(n, o.value);
    } finally {
      ti();
    }
    return !0;
  }, t.defineObservableProperty_ = function(n, o, a, i) {
    i === void 0 && (i = !1), this.keysAtom_;
    try {
      ei();
      var u = this.delete_(n);
      if (!u)
        return u;
      if (Ui(this)) {
        var c = Vi(this, {
          object: this.proxy_ || this.target_,
          name: n,
          type: al,
          newValue: o
        });
        if (!c)
          return null;
        o = c.newValue;
      }
      var d = d_(n), m = {
        configurable: Je.safeDescriptors ? this.isPlainObject_ : !0,
        enumerable: !0,
        get: d.get,
        set: d.set
      };
      if (i) {
        if (!Reflect.defineProperty(this.target_, n, m))
          return !1;
      } else
        bo(this.target_, n, m);
      var g = new pl(o, a, "ObservableObject.key", !1);
      this.values_.set(n, g), this.notifyPropertyAddition_(n, g.value_);
    } finally {
      ti();
    }
    return !0;
  }, t.defineComputedProperty_ = function(n, o, a) {
    a === void 0 && (a = !1), this.keysAtom_;
    try {
      ei();
      var i = this.delete_(n);
      if (!i)
        return i;
      if (Ui(this)) {
        var u = Vi(this, {
          object: this.proxy_ || this.target_,
          name: n,
          type: al,
          newValue: void 0
        });
        if (!u)
          return null;
      }
      o.name || (o.name = "ObservableObject.key"), o.context = this.proxy_ || this.target_;
      var c = d_(n), d = {
        configurable: Je.safeDescriptors ? this.isPlainObject_ : !0,
        enumerable: !1,
        get: c.get,
        set: c.set
      };
      if (a) {
        if (!Reflect.defineProperty(this.target_, n, d))
          return !1;
      } else
        bo(this.target_, n, d);
      this.values_.set(n, new Ps(o)), this.notifyPropertyAddition_(n, void 0);
    } finally {
      ti();
    }
    return !0;
  }, t.delete_ = function(n, o) {
    if (o === void 0 && (o = !1), this.keysAtom_, !la(this.target_, n))
      return !0;
    if (Ui(this)) {
      var a = Vi(this, {
        object: this.proxy_ || this.target_,
        name: n,
        type: f_
      });
      if (!a)
        return null;
    }
    try {
      var i;
      ei();
      var u = ks(this), c = !1, d = this.values_.get(n), m = void 0;
      if (!d && (u || c)) {
        var g;
        m = (g = ov(this.target_, n)) == null ? void 0 : g.value;
      }
      if (o) {
        if (!Reflect.deleteProperty(this.target_, n))
          return !1;
      } else
        delete this.target_[n];
      if (d && (this.values_.delete(n), d instanceof pl && (m = d.value_), UT(d)), this.keysAtom_.reportChanged(), (i = this.pendingKeys_) == null || (i = i.get(n)) == null || i.set(n in this.target_), u || c) {
        var v = {
          type: f_,
          observableKind: "object",
          object: this.proxy_ || this.target_,
          debugObjectName: this.name_,
          oldValue: m,
          name: n
        };
        u && As(this, v);
      }
    } finally {
      ti();
    }
    return !0;
  }, t.observe_ = function(n, o) {
    return Eh(this, n);
  }, t.intercept_ = function(n) {
    return _h(this, n);
  }, t.notifyPropertyAddition_ = function(n, o) {
    var a, i = ks(this), u = !1;
    if (i || u) {
      var c = i || u ? {
        type: al,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        name: n,
        newValue: o
      } : null;
      i && As(this, c);
    }
    (a = this.pendingKeys_) == null || (a = a.get(n)) == null || a.set(!0), this.keysAtom_.reportChanged();
  }, t.ownKeys_ = function() {
    return this.keysAtom_.reportObserved(), Tp(this.target_);
  }, t.keys_ = function() {
    return this.keysAtom_.reportObserved(), Object.keys(this.target_);
  }, e;
}();
function Vu(e, t) {
  var r;
  if (la(e, dt))
    return e;
  var n = (r = t == null ? void 0 : t.name) != null ? r : "ObservableObject", o = new pC(e, /* @__PURE__ */ new Map(), String(n), ZM(t));
  return vh(e, dt, o), e;
}
var dF = /* @__PURE__ */ bl("ObservableObjectAdministration", pC);
function d_(e) {
  return p_[e] || (p_[e] = {
    get: function() {
      return this[dt].getObservablePropValue_(e);
    },
    set: function(r) {
      return this[dt].setObservablePropValue_(e, r);
    }
  });
}
function Yr(e) {
  return Yv(e) ? dF(e[dt]) : !1;
}
function h_(e, t, r) {
  var n;
  (n = e.target_[go]) == null || delete n[r];
}
var hF = /* @__PURE__ */ dC(0), mF = /* @__PURE__ */ function() {
  var e = !1, t = {};
  return Object.defineProperty(t, "0", {
    set: function() {
      e = !0;
    }
  }), Object.create(t)[0] = 1, e === !1;
}(), k0 = 0, fC = function() {
};
function gF(e, t) {
  Object.setPrototypeOf ? Object.setPrototypeOf(e.prototype, t) : e.prototype.__proto__ !== void 0 ? e.prototype.__proto__ = t : e.prototype = t;
}
gF(fC, Array.prototype);
var bx = /* @__PURE__ */ function(e) {
  function t(n, o, a, i) {
    var u;
    return a === void 0 && (a = "ObservableArray"), i === void 0 && (i = !1), u = e.call(this) || this, Sl(function() {
      var c = new gx(a, o, i, !0);
      c.proxy_ = u, ST(u, dt, c), n && n.length && u.spliceWithArray(0, 0, n), mF && Object.defineProperty(u, "0", hF);
    }), u;
  }
  ET(t, e);
  var r = t.prototype;
  return r.concat = function() {
    this[dt].atom_.reportObserved();
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return Array.prototype.concat.apply(
      this.slice(),
      //@ts-ignore
      a.map(function(u) {
        return $n(u) ? u.slice() : u;
      })
    );
  }, r[Symbol.iterator] = function() {
    var n = this, o = 0;
    return Sx({
      next: function() {
        return o < n.length ? {
          value: n[o++],
          done: !1
        } : {
          done: !0,
          value: void 0
        };
      }
    });
  }, zp(t, [{
    key: "length",
    get: function() {
      return this[dt].getArrayLength_();
    },
    set: function(o) {
      this[dt].setArrayLength_(o);
    }
  }, {
    key: Symbol.toStringTag,
    get: function() {
      return "Array";
    }
  }]);
}(fC);
Object.entries(pv).forEach(function(e) {
  var t = e[0], r = e[1];
  t !== "concat" && vh(bx.prototype, t, r);
});
function dC(e) {
  return {
    enumerable: !1,
    configurable: !0,
    get: function() {
      return this[dt].get_(e);
    },
    set: function(r) {
      this[dt].set_(e, r);
    }
  };
}
function yF(e) {
  bo(bx.prototype, "" + e, dC(e));
}
function hC(e) {
  if (e > k0) {
    for (var t = k0; t < e + 100; t++)
      yF(t);
    k0 = e;
  }
}
hC(1e3);
function vF(e, t, r) {
  return new bx(e, t, r);
}
function ha(e, t) {
  if (typeof e == "object" && e !== null) {
    if ($n(e))
      return t !== void 0 && At(23), e[dt].atom_;
    if (Vr(e))
      return e.atom_;
    if (Gr(e)) {
      if (t === void 0)
        return e.keysAtom_;
      var r = e.data_.get(t) || e.hasMap_.get(t);
      return r || At(25, t, dv(e)), r;
    }
    if (Yr(e)) {
      if (!t)
        return At(26);
      var n = e[dt].values_.get(t);
      return n || At(27, t, dv(e)), n;
    }
    if (ux(e) || Du(e) || cv(e))
      return e;
  } else if (hi(e) && cv(e[dt]))
    return e[dt];
  At(28);
}
function ma(e, t) {
  if (e || At(29), t !== void 0)
    return ma(ha(e, t));
  if (ux(e) || Du(e) || cv(e) || Gr(e) || Vr(e))
    return e;
  if (e[dt])
    return e[dt];
  At(24, e);
}
function dv(e, t) {
  var r;
  if (t !== void 0)
    r = ha(e, t);
  else {
    if ($p(e))
      return e.name;
    Yr(e) || Gr(e) || Vr(e) ? r = ma(e) : r = ha(e);
  }
  return r.name_;
}
function Sl(e) {
  var t = Uu(), r = Zv(!0);
  ei();
  try {
    return e();
  } finally {
    ti(), eb(r), ua(t);
  }
}
var m_ = yh.toString;
function wx(e, t, r) {
  return r === void 0 && (r = -1), SS(e, t, r);
}
function SS(e, t, r, n, o) {
  if (e === t)
    return e !== 0 || 1 / e === 1 / t;
  if (e == null || t == null)
    return !1;
  if (e !== e)
    return t !== t;
  var a = typeof e;
  if (a !== "function" && a !== "object" && typeof t != "object")
    return !1;
  var i = m_.call(e);
  if (i !== m_.call(t))
    return !1;
  switch (i) {
    // Strings, numbers, regular expressions, dates, and booleans are compared by value.
    case "[object RegExp]":
    // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
    case "[object String]":
      return "" + e == "" + t;
    case "[object Number]":
      return +e != +e ? +t != +t : +e == 0 ? 1 / +e === 1 / t : +e == +t;
    case "[object Date]":
    case "[object Boolean]":
      return +e == +t;
    case "[object Symbol]":
      return typeof Symbol < "u" && Symbol.valueOf.call(e) === Symbol.valueOf.call(t);
    case "[object Map]":
    case "[object Set]":
      r >= 0 && r++;
      break;
  }
  e = g_(e), t = g_(t);
  var u = i === "[object Array]";
  if (!u) {
    if (typeof e != "object" || typeof t != "object")
      return !1;
    var c = e.constructor, d = t.constructor;
    if (c !== d && !(hi(c) && c instanceof c && hi(d) && d instanceof d) && "constructor" in e && "constructor" in t)
      return !1;
  }
  if (r === 0)
    return !1;
  r < 0 && (r = -1), n = n || [], o = o || [];
  for (var m = n.length; m--; )
    if (n[m] === e)
      return o[m] === t;
  if (n.push(e), o.push(t), u) {
    if (m = e.length, m !== t.length)
      return !1;
    for (; m--; )
      if (!SS(e[m], t[m], r - 1, n, o))
        return !1;
  } else {
    var g = Object.keys(e), v = g.length;
    if (Object.keys(t).length !== v)
      return !1;
    for (var S = 0; S < v; S++) {
      var k = g[S];
      if (!(la(t, k) && SS(e[k], t[k], r - 1, n, o)))
        return !1;
    }
  }
  return n.pop(), o.pop(), !0;
}
function g_(e) {
  return $n(e) ? e.slice() : qp(e) || Gr(e) || sa(e) || Vr(e) ? Array.from(e.entries()) : e;
}
var y_, bF = ((y_ = Qv().Iterator) == null ? void 0 : y_.prototype) || {};
function Sx(e) {
  return e[Symbol.iterator] = wF, Object.assign(Object.create(bF), e);
}
function wF() {
  return this;
}
["Symbol", "Map", "Set"].forEach(function(e) {
  var t = Qv();
  typeof t[e] > "u" && At("MobX requires global '" + e + "' to be available or polyfilled");
});
typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ == "object" && __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
  spy: HT,
  extras: {
    getDebugName: dv
  },
  $mobx: dt
});
const SF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  $mobx: dt,
  FlowCancellationError: rb,
  ObservableMap: yx,
  ObservableSet: vx,
  Reaction: Yi,
  _allowStateChanges: Jv,
  _allowStateChangesInsideComputed: wS,
  _allowStateReadsEnd: Sp,
  _allowStateReadsStart: tb,
  _autoAction: Cp,
  _endAction: LT,
  _getAdministration: ma,
  _getGlobalState: cD,
  _interceptReads: DD,
  _isComputingDerivation: oD,
  _resetGlobalState: pD,
  _startAction: jT,
  action: ol,
  autorun: dx,
  comparer: Lu,
  computed: xh,
  configure: ZT,
  createAtom: cx,
  defineProperty: YD,
  entries: WD,
  extendObservable: mx,
  flow: Fu,
  flowResult: MD,
  get: QD,
  getAtom: ha,
  getDebugName: dv,
  getDependencyTree: eC,
  getObserverTree: RD,
  has: oC,
  intercept: FD,
  isAction: $p,
  isBoxedObservable: fx,
  isComputed: BD,
  isComputedProp: UD,
  isFlow: Rp,
  isFlowCancellationError: jD,
  isObservable: nb,
  isObservableArray: $n,
  isObservableMap: Gr,
  isObservableObject: Yr,
  isObservableProp: VD,
  isObservableSet: Vr,
  keys: sh,
  makeAutoObservable: sF,
  makeObservable: uC,
  observable: Er,
  observe: GD,
  onBecomeObserved: XT,
  onBecomeUnobserved: hx,
  onReactionError: yD,
  override: wM,
  ownKeys: aC,
  reaction: kD,
  remove: KD,
  runInAction: wS,
  set: sC,
  spy: HT,
  toJS: ZD,
  trace: eF,
  transaction: ho,
  untracked: Bp,
  values: HD,
  when: tF
}, Symbol.toStringTag, { value: "Module" })), xF = /* @__PURE__ */ _o(SF);
var co = {}, Gn = {};
const _F = {}, EF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _F
}, Symbol.toStringTag, { value: "Module" })), oh = /* @__PURE__ */ _o(EF);
var A0, v_;
function xx() {
  if (v_) return A0;
  v_ = 1;
  function e(o) {
    if (typeof o != "string")
      throw new TypeError("Path must be a string. Received " + JSON.stringify(o));
  }
  function t(o, a) {
    for (var i = "", u = 0, c = -1, d = 0, m, g = 0; g <= o.length; ++g) {
      if (g < o.length)
        m = o.charCodeAt(g);
      else {
        if (m === 47)
          break;
        m = 47;
      }
      if (m === 47) {
        if (!(c === g - 1 || d === 1)) if (c !== g - 1 && d === 2) {
          if (i.length < 2 || u !== 2 || i.charCodeAt(i.length - 1) !== 46 || i.charCodeAt(i.length - 2) !== 46) {
            if (i.length > 2) {
              var v = i.lastIndexOf("/");
              if (v !== i.length - 1) {
                v === -1 ? (i = "", u = 0) : (i = i.slice(0, v), u = i.length - 1 - i.lastIndexOf("/")), c = g, d = 0;
                continue;
              }
            } else if (i.length === 2 || i.length === 1) {
              i = "", u = 0, c = g, d = 0;
              continue;
            }
          }
          a && (i.length > 0 ? i += "/.." : i = "..", u = 2);
        } else
          i.length > 0 ? i += "/" + o.slice(c + 1, g) : i = o.slice(c + 1, g), u = g - c - 1;
        c = g, d = 0;
      } else m === 46 && d !== -1 ? ++d : d = -1;
    }
    return i;
  }
  function r(o, a) {
    var i = a.dir || a.root, u = a.base || (a.name || "") + (a.ext || "");
    return i ? i === a.root ? i + u : i + o + u : u;
  }
  var n = {
    // path.resolve([from ...], to)
    resolve: function() {
      for (var a = "", i = !1, u, c = arguments.length - 1; c >= -1 && !i; c--) {
        var d;
        c >= 0 ? d = arguments[c] : (u === void 0 && (u = process.cwd()), d = u), e(d), d.length !== 0 && (a = d + "/" + a, i = d.charCodeAt(0) === 47);
      }
      return a = t(a, !i), i ? a.length > 0 ? "/" + a : "/" : a.length > 0 ? a : ".";
    },
    normalize: function(a) {
      if (e(a), a.length === 0) return ".";
      var i = a.charCodeAt(0) === 47, u = a.charCodeAt(a.length - 1) === 47;
      return a = t(a, !i), a.length === 0 && !i && (a = "."), a.length > 0 && u && (a += "/"), i ? "/" + a : a;
    },
    isAbsolute: function(a) {
      return e(a), a.length > 0 && a.charCodeAt(0) === 47;
    },
    join: function() {
      if (arguments.length === 0)
        return ".";
      for (var a, i = 0; i < arguments.length; ++i) {
        var u = arguments[i];
        e(u), u.length > 0 && (a === void 0 ? a = u : a += "/" + u);
      }
      return a === void 0 ? "." : n.normalize(a);
    },
    relative: function(a, i) {
      if (e(a), e(i), a === i || (a = n.resolve(a), i = n.resolve(i), a === i)) return "";
      for (var u = 1; u < a.length && a.charCodeAt(u) === 47; ++u)
        ;
      for (var c = a.length, d = c - u, m = 1; m < i.length && i.charCodeAt(m) === 47; ++m)
        ;
      for (var g = i.length, v = g - m, S = d < v ? d : v, k = -1, b = 0; b <= S; ++b) {
        if (b === S) {
          if (v > S) {
            if (i.charCodeAt(m + b) === 47)
              return i.slice(m + b + 1);
            if (b === 0)
              return i.slice(m + b);
          } else d > S && (a.charCodeAt(u + b) === 47 ? k = b : b === 0 && (k = 0));
          break;
        }
        var x = a.charCodeAt(u + b), A = i.charCodeAt(m + b);
        if (x !== A)
          break;
        x === 47 && (k = b);
      }
      var _ = "";
      for (b = u + k + 1; b <= c; ++b)
        (b === c || a.charCodeAt(b) === 47) && (_.length === 0 ? _ += ".." : _ += "/..");
      return _.length > 0 ? _ + i.slice(m + k) : (m += k, i.charCodeAt(m) === 47 && ++m, i.slice(m));
    },
    _makeLong: function(a) {
      return a;
    },
    dirname: function(a) {
      if (e(a), a.length === 0) return ".";
      for (var i = a.charCodeAt(0), u = i === 47, c = -1, d = !0, m = a.length - 1; m >= 1; --m)
        if (i = a.charCodeAt(m), i === 47) {
          if (!d) {
            c = m;
            break;
          }
        } else
          d = !1;
      return c === -1 ? u ? "/" : "." : u && c === 1 ? "//" : a.slice(0, c);
    },
    basename: function(a, i) {
      if (i !== void 0 && typeof i != "string") throw new TypeError('"ext" argument must be a string');
      e(a);
      var u = 0, c = -1, d = !0, m;
      if (i !== void 0 && i.length > 0 && i.length <= a.length) {
        if (i.length === a.length && i === a) return "";
        var g = i.length - 1, v = -1;
        for (m = a.length - 1; m >= 0; --m) {
          var S = a.charCodeAt(m);
          if (S === 47) {
            if (!d) {
              u = m + 1;
              break;
            }
          } else
            v === -1 && (d = !1, v = m + 1), g >= 0 && (S === i.charCodeAt(g) ? --g === -1 && (c = m) : (g = -1, c = v));
        }
        return u === c ? c = v : c === -1 && (c = a.length), a.slice(u, c);
      } else {
        for (m = a.length - 1; m >= 0; --m)
          if (a.charCodeAt(m) === 47) {
            if (!d) {
              u = m + 1;
              break;
            }
          } else c === -1 && (d = !1, c = m + 1);
        return c === -1 ? "" : a.slice(u, c);
      }
    },
    extname: function(a) {
      e(a);
      for (var i = -1, u = 0, c = -1, d = !0, m = 0, g = a.length - 1; g >= 0; --g) {
        var v = a.charCodeAt(g);
        if (v === 47) {
          if (!d) {
            u = g + 1;
            break;
          }
          continue;
        }
        c === -1 && (d = !1, c = g + 1), v === 46 ? i === -1 ? i = g : m !== 1 && (m = 1) : i !== -1 && (m = -1);
      }
      return i === -1 || c === -1 || // We saw a non-dot character immediately before the dot
      m === 0 || // The (right-most) trimmed path component is exactly '..'
      m === 1 && i === c - 1 && i === u + 1 ? "" : a.slice(i, c);
    },
    format: function(a) {
      if (a === null || typeof a != "object")
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof a);
      return r("/", a);
    },
    parse: function(a) {
      e(a);
      var i = { root: "", dir: "", base: "", ext: "", name: "" };
      if (a.length === 0) return i;
      var u = a.charCodeAt(0), c = u === 47, d;
      c ? (i.root = "/", d = 1) : d = 0;
      for (var m = -1, g = 0, v = -1, S = !0, k = a.length - 1, b = 0; k >= d; --k) {
        if (u = a.charCodeAt(k), u === 47) {
          if (!S) {
            g = k + 1;
            break;
          }
          continue;
        }
        v === -1 && (S = !1, v = k + 1), u === 46 ? m === -1 ? m = k : b !== 1 && (b = 1) : m !== -1 && (b = -1);
      }
      return m === -1 || v === -1 || // We saw a non-dot character immediately before the dot
      b === 0 || // The (right-most) trimmed path component is exactly '..'
      b === 1 && m === v - 1 && m === g + 1 ? v !== -1 && (g === 0 && c ? i.base = i.name = a.slice(1, v) : i.base = i.name = a.slice(g, v)) : (g === 0 && c ? (i.name = a.slice(1, m), i.base = a.slice(1, v)) : (i.name = a.slice(g, m), i.base = a.slice(g, v)), i.ext = a.slice(m, v)), g > 0 ? i.dir = a.slice(0, g - 1) : c && (i.dir = "/"), i;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  return n.posix = n, A0 = n, A0;
}
var nn = {}, P0 = {}, T0, b_;
function OF() {
  return b_ || (b_ = 1, T0 = typeof process == "object" && process && process.platform === "win32" ? { sep: "\\" } : { sep: "/" }), T0;
}
var C0, w_;
function kF() {
  if (w_) return C0;
  w_ = 1, C0 = e;
  function e(n, o, a) {
    n instanceof RegExp && (n = t(n, a)), o instanceof RegExp && (o = t(o, a));
    var i = r(n, o, a);
    return i && {
      start: i[0],
      end: i[1],
      pre: a.slice(0, i[0]),
      body: a.slice(i[0] + n.length, i[1]),
      post: a.slice(i[1] + o.length)
    };
  }
  function t(n, o) {
    var a = o.match(n);
    return a ? a[0] : null;
  }
  e.range = r;
  function r(n, o, a) {
    var i, u, c, d, m, g = a.indexOf(n), v = a.indexOf(o, g + 1), S = g;
    if (g >= 0 && v > 0) {
      if (n === o)
        return [g, v];
      for (i = [], c = a.length; S >= 0 && !m; )
        S == g ? (i.push(S), g = a.indexOf(n, S + 1)) : i.length == 1 ? m = [i.pop(), v] : (u = i.pop(), u < c && (c = u, d = v), v = a.indexOf(o, S + 1)), S = g < v && g >= 0 ? g : v;
      i.length && (m = [c, d]);
    }
    return m;
  }
  return C0;
}
var $0, S_;
function AF() {
  if (S_) return $0;
  S_ = 1;
  var e = kF();
  $0 = m;
  var t = "\0SLASH" + Math.random() + "\0", r = "\0OPEN" + Math.random() + "\0", n = "\0CLOSE" + Math.random() + "\0", o = "\0COMMA" + Math.random() + "\0", a = "\0PERIOD" + Math.random() + "\0";
  function i(x) {
    return parseInt(x, 10) == x ? parseInt(x, 10) : x.charCodeAt(0);
  }
  function u(x) {
    return x.split("\\\\").join(t).split("\\{").join(r).split("\\}").join(n).split("\\,").join(o).split("\\.").join(a);
  }
  function c(x) {
    return x.split(t).join("\\").split(r).join("{").split(n).join("}").split(o).join(",").split(a).join(".");
  }
  function d(x) {
    if (!x)
      return [""];
    var A = [], _ = e("{", "}", x);
    if (!_)
      return x.split(",");
    var O = _.pre, R = _.body, C = _.post, T = O.split(",");
    T[T.length - 1] += "{" + R + "}";
    var j = d(C);
    return C.length && (T[T.length - 1] += j.shift(), T.push.apply(T, j)), A.push.apply(A, T), A;
  }
  function m(x) {
    return x ? (x.substr(0, 2) === "{}" && (x = "\\{\\}" + x.substr(2)), b(u(x), !0).map(c)) : [];
  }
  function g(x) {
    return "{" + x + "}";
  }
  function v(x) {
    return /^-?0\d/.test(x);
  }
  function S(x, A) {
    return x <= A;
  }
  function k(x, A) {
    return x >= A;
  }
  function b(x, A) {
    var _ = [], O = e("{", "}", x);
    if (!O) return [x];
    var R = O.pre, C = O.post.length ? b(O.post, !1) : [""];
    if (/\$$/.test(O.pre))
      for (var T = 0; T < C.length; T++) {
        var j = R + "{" + O.body + "}" + C[T];
        _.push(j);
      }
    else {
      var D = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(O.body), V = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(O.body), U = D || V, ne = O.body.indexOf(",") >= 0;
      if (!U && !ne)
        return O.post.match(/,.*\}/) ? (x = O.pre + "{" + O.body + n + O.post, b(x)) : [x];
      var H;
      if (U)
        H = O.body.split(/\.\./);
      else if (H = d(O.body), H.length === 1 && (H = b(H[0], !1).map(g), H.length === 1))
        return C.map(function(Q) {
          return O.pre + H[0] + Q;
        });
      var ae;
      if (U) {
        var ge = i(H[0]), fe = i(H[1]), ve = Math.max(H[0].length, H[1].length), $e = H.length == 3 ? Math.abs(i(H[2])) : 1, ce = S, se = fe < ge;
        se && ($e *= -1, ce = k);
        var te = H.some(v);
        ae = [];
        for (var F = ge; ce(F, fe); F += $e) {
          var J;
          if (V)
            J = String.fromCharCode(F), J === "\\" && (J = "");
          else if (J = String(F), te) {
            var W = ve - J.length;
            if (W > 0) {
              var q = new Array(W + 1).join("0");
              F < 0 ? J = "-" + q + J.slice(1) : J = q + J;
            }
          }
          ae.push(J);
        }
      } else {
        ae = [];
        for (var X = 0; X < H.length; X++)
          ae.push.apply(ae, b(H[X], !1));
      }
      for (var X = 0; X < ae.length; X++)
        for (var T = 0; T < C.length; T++) {
          var j = R + ae[X] + C[T];
          (!A || U || j) && _.push(j);
        }
    }
    return _;
  }
  return $0;
}
var vg, x_;
function PF() {
  if (x_) return vg;
  x_ = 1;
  const e = vg = (j, D, V = {}) => (x(D), !V.nocomment && D.charAt(0) === "#" ? !1 : new T(D, V).match(j));
  vg = e;
  const t = OF();
  e.sep = t.sep;
  const r = Symbol("globstar **");
  e.GLOBSTAR = r;
  const n = AF(), o = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  }, a = "[^/]", i = a + "*?", u = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", c = "(?:(?!(?:\\/|^)\\.).)*?", d = (j) => j.split("").reduce((D, V) => (D[V] = !0, D), {}), m = d("().*{}+?[]^$\\!"), g = d("[.("), v = /\/+/;
  e.filter = (j, D = {}) => (V, U, ne) => e(V, j, D);
  const S = (j, D = {}) => {
    const V = {};
    return Object.keys(j).forEach((U) => V[U] = j[U]), Object.keys(D).forEach((U) => V[U] = D[U]), V;
  };
  e.defaults = (j) => {
    if (!j || typeof j != "object" || !Object.keys(j).length)
      return e;
    const D = e, V = (U, ne, H) => D(U, ne, S(j, H));
    return V.Minimatch = class extends D.Minimatch {
      constructor(ne, H) {
        super(ne, S(j, H));
      }
    }, V.Minimatch.defaults = (U) => D.defaults(S(j, U)).Minimatch, V.filter = (U, ne) => D.filter(U, S(j, ne)), V.defaults = (U) => D.defaults(S(j, U)), V.makeRe = (U, ne) => D.makeRe(U, S(j, ne)), V.braceExpand = (U, ne) => D.braceExpand(U, S(j, ne)), V.match = (U, ne, H) => D.match(U, ne, S(j, H)), V;
  }, e.braceExpand = (j, D) => k(j, D);
  const k = (j, D = {}) => (x(j), D.nobrace || !/\{(?:(?!\{).)*\}/.test(j) ? [j] : n(j)), b = 1024 * 64, x = (j) => {
    if (typeof j != "string")
      throw new TypeError("invalid pattern");
    if (j.length > b)
      throw new TypeError("pattern is too long");
  }, A = Symbol("subparse");
  e.makeRe = (j, D) => new T(j, D || {}).makeRe(), e.match = (j, D, V = {}) => {
    const U = new T(D, V);
    return j = j.filter((ne) => U.match(ne)), U.options.nonull && !j.length && j.push(D), j;
  };
  const _ = (j) => j.replace(/\\(.)/g, "$1"), O = (j) => j.replace(/\\([^-\]])/g, "$1"), R = (j) => j.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), C = (j) => j.replace(/[[\]\\]/g, "\\$&");
  class T {
    constructor(D, V) {
      x(D), V || (V = {}), this.options = V, this.set = [], this.pattern = D, this.windowsPathsNoEscape = !!V.windowsPathsNoEscape || V.allowWindowsEscape === !1, this.windowsPathsNoEscape && (this.pattern = this.pattern.replace(/\\/g, "/")), this.regexp = null, this.negate = !1, this.comment = !1, this.empty = !1, this.partial = !!V.partial, this.make();
    }
    debug() {
    }
    make() {
      const D = this.pattern, V = this.options;
      if (!V.nocomment && D.charAt(0) === "#") {
        this.comment = !0;
        return;
      }
      if (!D) {
        this.empty = !0;
        return;
      }
      this.parseNegate();
      let U = this.globSet = this.braceExpand();
      V.debug && (this.debug = (...ne) => console.error(...ne)), this.debug(this.pattern, U), U = this.globParts = U.map((ne) => ne.split(v)), this.debug(this.pattern, U), U = U.map((ne, H, ae) => ne.map(this.parse, this)), this.debug(this.pattern, U), U = U.filter((ne) => ne.indexOf(!1) === -1), this.debug(this.pattern, U), this.set = U;
    }
    parseNegate() {
      if (this.options.nonegate) return;
      const D = this.pattern;
      let V = !1, U = 0;
      for (let ne = 0; ne < D.length && D.charAt(ne) === "!"; ne++)
        V = !V, U++;
      U && (this.pattern = D.slice(U)), this.negate = V;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(D, V, U) {
      var ne = this.options;
      this.debug(
        "matchOne",
        { this: this, file: D, pattern: V }
      ), this.debug("matchOne", D.length, V.length);
      for (var H = 0, ae = 0, ge = D.length, fe = V.length; H < ge && ae < fe; H++, ae++) {
        this.debug("matchOne loop");
        var ve = V[ae], $e = D[H];
        if (this.debug(V, ve, $e), ve === !1) return !1;
        if (ve === r) {
          this.debug("GLOBSTAR", [V, ve, $e]);
          var ce = H, se = ae + 1;
          if (se === fe) {
            for (this.debug("** at the end"); H < ge; H++)
              if (D[H] === "." || D[H] === ".." || !ne.dot && D[H].charAt(0) === ".") return !1;
            return !0;
          }
          for (; ce < ge; ) {
            var te = D[ce];
            if (this.debug(`
globstar while`, D, ce, V, se, te), this.matchOne(D.slice(ce), V.slice(se), U))
              return this.debug("globstar found match!", ce, ge, te), !0;
            if (te === "." || te === ".." || !ne.dot && te.charAt(0) === ".") {
              this.debug("dot detected!", D, ce, V, se);
              break;
            }
            this.debug("globstar swallow a segment, and continue"), ce++;
          }
          return !!(U && (this.debug(`
>>> no match, partial?`, D, ce, V, se), ce === ge));
        }
        var F;
        if (typeof ve == "string" ? (F = $e === ve, this.debug("string match", ve, $e, F)) : (F = $e.match(ve), this.debug("pattern match", ve, $e, F)), !F) return !1;
      }
      if (H === ge && ae === fe)
        return !0;
      if (H === ge)
        return U;
      if (ae === fe)
        return H === ge - 1 && D[H] === "";
      throw new Error("wtf?");
    }
    braceExpand() {
      return k(this.pattern, this.options);
    }
    parse(D, V) {
      x(D);
      const U = this.options;
      if (D === "**")
        if (U.noglobstar)
          D = "*";
        else
          return r;
      if (D === "") return "";
      let ne = "", H = !1, ae = !1;
      const ge = [], fe = [];
      let ve, $e = !1, ce = -1, se = -1, te, F, J, W = D.charAt(0) === ".", q = U.dot || W;
      const X = () => W ? "" : q ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", Q = (N) => N.charAt(0) === "." ? "" : U.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", ye = () => {
        if (ve) {
          switch (ve) {
            case "*":
              ne += i, H = !0;
              break;
            case "?":
              ne += a, H = !0;
              break;
            default:
              ne += "\\" + ve;
              break;
          }
          this.debug("clearStateChar %j %j", ve, ne), ve = !1;
        }
      };
      for (let N = 0, B; N < D.length && (B = D.charAt(N)); N++) {
        if (this.debug("%s	%s %s %j", D, N, ne, B), ae) {
          if (B === "/")
            return !1;
          m[B] && (ne += "\\"), ne += B, ae = !1;
          continue;
        }
        switch (B) {
          /* istanbul ignore next */
          case "/":
            return !1;
          case "\\":
            if ($e && D.charAt(N + 1) === "-") {
              ne += B;
              continue;
            }
            ye(), ae = !0;
            continue;
          // the various stateChar values
          // for the "extglob" stuff.
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            if (this.debug("%s	%s %s %j <-- stateChar", D, N, ne, B), $e) {
              this.debug("  in class"), B === "!" && N === se + 1 && (B = "^"), ne += B;
              continue;
            }
            this.debug("call clearStateChar %j", ve), ye(), ve = B, U.noext && ye();
            continue;
          case "(": {
            if ($e) {
              ne += "(";
              continue;
            }
            if (!ve) {
              ne += "\\(";
              continue;
            }
            const oe = {
              type: ve,
              start: N - 1,
              reStart: ne.length,
              open: o[ve].open,
              close: o[ve].close
            };
            this.debug(this.pattern, "	", oe), ge.push(oe), ne += oe.open, oe.start === 0 && oe.type !== "!" && (W = !0, ne += Q(D.slice(N + 1))), this.debug("plType %j %j", ve, ne), ve = !1;
            continue;
          }
          case ")": {
            const oe = ge[ge.length - 1];
            if ($e || !oe) {
              ne += "\\)";
              continue;
            }
            ge.pop(), ye(), H = !0, F = oe, ne += F.close, F.type === "!" && fe.push(Object.assign(F, { reEnd: ne.length }));
            continue;
          }
          case "|": {
            const oe = ge[ge.length - 1];
            if ($e || !oe) {
              ne += "\\|";
              continue;
            }
            ye(), ne += "|", oe.start === 0 && oe.type !== "!" && (W = !0, ne += Q(D.slice(N + 1)));
            continue;
          }
          // these are mostly the same in regexp and glob
          case "[":
            if (ye(), $e) {
              ne += "\\" + B;
              continue;
            }
            $e = !0, se = N, ce = ne.length, ne += B;
            continue;
          case "]":
            if (N === se + 1 || !$e) {
              ne += "\\" + B;
              continue;
            }
            te = D.substring(se + 1, N);
            try {
              RegExp("[" + C(O(te)) + "]"), ne += B;
            } catch {
              ne = ne.substring(0, ce) + "(?:$.)";
            }
            H = !0, $e = !1;
            continue;
          default:
            ye(), m[B] && !(B === "^" && $e) && (ne += "\\"), ne += B;
            break;
        }
      }
      for ($e && (te = D.slice(se + 1), J = this.parse(te, A), ne = ne.substring(0, ce) + "\\[" + J[0], H = H || J[1]), F = ge.pop(); F; F = ge.pop()) {
        let N;
        N = ne.slice(F.reStart + F.open.length), this.debug("setting tail", ne, F), N = N.replace(/((?:\\{2}){0,64})(\\?)\|/g, (oe, ie, he) => (he || (he = "\\"), ie + ie + he + "|")), this.debug(`tail=%j
   %s`, N, N, F, ne);
        const B = F.type === "*" ? i : F.type === "?" ? a : "\\" + F.type;
        H = !0, ne = ne.slice(0, F.reStart) + B + "\\(" + N;
      }
      ye(), ae && (ne += "\\\\");
      const Se = g[ne.charAt(0)];
      for (let N = fe.length - 1; N > -1; N--) {
        const B = fe[N], oe = ne.slice(0, B.reStart), ie = ne.slice(B.reStart, B.reEnd - 8);
        let he = ne.slice(B.reEnd);
        const Z = ne.slice(B.reEnd - 8, B.reEnd) + he, re = oe.split(")").length, Pe = oe.split("(").length - re;
        let Oe = he;
        for (let je = 0; je < Pe; je++)
          Oe = Oe.replace(/\)[+*?]?/, "");
        he = Oe;
        const qe = he === "" && V !== A ? "(?:$|\\/)" : "";
        ne = oe + ie + he + qe + Z;
      }
      if (ne !== "" && H && (ne = "(?=.)" + ne), Se && (ne = X() + ne), V === A)
        return [ne, H];
      if (U.nocase && !H && (H = D.toUpperCase() !== D.toLowerCase()), !H)
        return _(D);
      const Ne = U.nocase ? "i" : "";
      try {
        return Object.assign(new RegExp("^" + ne + "$", Ne), {
          _glob: D,
          _src: ne
        });
      } catch {
        return new RegExp("$.");
      }
    }
    makeRe() {
      if (this.regexp || this.regexp === !1) return this.regexp;
      const D = this.set;
      if (!D.length)
        return this.regexp = !1, this.regexp;
      const V = this.options, U = V.noglobstar ? i : V.dot ? u : c, ne = V.nocase ? "i" : "";
      let H = D.map((ae) => (ae = ae.map(
        (ge) => typeof ge == "string" ? R(ge) : ge === r ? r : ge._src
      ).reduce((ge, fe) => (ge[ge.length - 1] === r && fe === r || ge.push(fe), ge), []), ae.forEach((ge, fe) => {
        ge !== r || ae[fe - 1] === r || (fe === 0 ? ae.length > 1 ? ae[fe + 1] = "(?:\\/|" + U + "\\/)?" + ae[fe + 1] : ae[fe] = U : fe === ae.length - 1 ? ae[fe - 1] += "(?:\\/|" + U + ")?" : (ae[fe - 1] += "(?:\\/|\\/" + U + "\\/)" + ae[fe + 1], ae[fe + 1] = r));
      }), ae.filter((ge) => ge !== r).join("/"))).join("|");
      H = "^(?:" + H + ")$", this.negate && (H = "^(?!" + H + ").*$");
      try {
        this.regexp = new RegExp(H, ne);
      } catch {
        this.regexp = !1;
      }
      return this.regexp;
    }
    match(D, V = this.partial) {
      if (this.debug("match", D, this.pattern), this.comment) return !1;
      if (this.empty) return D === "";
      if (D === "/" && V) return !0;
      const U = this.options;
      t.sep !== "/" && (D = D.split(t.sep).join("/")), D = D.split(v), this.debug(this.pattern, "split", D);
      const ne = this.set;
      this.debug(this.pattern, "set", ne);
      let H;
      for (let ae = D.length - 1; ae >= 0 && (H = D[ae], !H); ae--)
        ;
      for (let ae = 0; ae < ne.length; ae++) {
        const ge = ne[ae];
        let fe = D;
        if (U.matchBase && ge.length === 1 && (fe = [H]), this.matchOne(fe, ge, V))
          return U.flipNegate ? !0 : !this.negate;
      }
      return U.flipNegate ? !1 : this.negate;
    }
    static defaults(D) {
      return e.defaults(D).Minimatch;
    }
  }
  return e.Minimatch = T, vg;
}
var yu = {}, vn = {}, bg = {}, tl = {}, __;
function Oh() {
  if (__) return tl;
  __ = 1;
  function e(i) {
    return typeof i > "u" || i === null;
  }
  function t(i) {
    return typeof i == "object" && i !== null;
  }
  function r(i) {
    return Array.isArray(i) ? i : e(i) ? [] : [i];
  }
  function n(i, u) {
    var c, d, m, g;
    if (u)
      for (g = Object.keys(u), c = 0, d = g.length; c < d; c += 1)
        m = g[c], i[m] = u[m];
    return i;
  }
  function o(i, u) {
    var c = "", d;
    for (d = 0; d < u; d += 1)
      c += i;
    return c;
  }
  function a(i) {
    return i === 0 && Number.NEGATIVE_INFINITY === 1 / i;
  }
  return tl.isNothing = e, tl.isObject = t, tl.toArray = r, tl.repeat = o, tl.isNegativeZero = a, tl.extend = n, tl;
}
var R0, E_;
function kh() {
  if (E_) return R0;
  E_ = 1;
  function e(r, n) {
    var o = "", a = r.reason || "(unknown reason)";
    return r.mark ? (r.mark.name && (o += 'in "' + r.mark.name + '" '), o += "(" + (r.mark.line + 1) + ":" + (r.mark.column + 1) + ")", !n && r.mark.snippet && (o += `

` + r.mark.snippet), a + " " + o) : a;
  }
  function t(r, n) {
    Error.call(this), this.name = "YAMLException", this.reason = r, this.mark = n, this.message = e(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
  }
  return t.prototype = Object.create(Error.prototype), t.prototype.constructor = t, t.prototype.toString = function(n) {
    return this.name + ": " + e(this, n);
  }, R0 = t, R0;
}
var I0, O_;
function TF() {
  if (O_) return I0;
  O_ = 1;
  var e = Oh();
  function t(o, a, i, u, c) {
    var d = "", m = "", g = Math.floor(c / 2) - 1;
    return u - a > g && (d = " ... ", a = u - g + d.length), i - u > g && (m = " ...", i = u + g - m.length), {
      str: d + o.slice(a, i).replace(/\t/g, "→") + m,
      pos: u - a + d.length
      // relative position
    };
  }
  function r(o, a) {
    return e.repeat(" ", a - o.length) + o;
  }
  function n(o, a) {
    if (a = Object.create(a || null), !o.buffer) return null;
    a.maxLength || (a.maxLength = 79), typeof a.indent != "number" && (a.indent = 1), typeof a.linesBefore != "number" && (a.linesBefore = 3), typeof a.linesAfter != "number" && (a.linesAfter = 2);
    for (var i = /\r?\n|\r|\0/g, u = [0], c = [], d, m = -1; d = i.exec(o.buffer); )
      c.push(d.index), u.push(d.index + d[0].length), o.position <= d.index && m < 0 && (m = u.length - 2);
    m < 0 && (m = u.length - 1);
    var g = "", v, S, k = Math.min(o.line + a.linesAfter, c.length).toString().length, b = a.maxLength - (a.indent + k + 3);
    for (v = 1; v <= a.linesBefore && !(m - v < 0); v++)
      S = t(
        o.buffer,
        u[m - v],
        c[m - v],
        o.position - (u[m] - u[m - v]),
        b
      ), g = e.repeat(" ", a.indent) + r((o.line - v + 1).toString(), k) + " | " + S.str + `
` + g;
    for (S = t(o.buffer, u[m], c[m], o.position, b), g += e.repeat(" ", a.indent) + r((o.line + 1).toString(), k) + " | " + S.str + `
`, g += e.repeat("-", a.indent + k + 3 + S.pos) + `^
`, v = 1; v <= a.linesAfter && !(m + v >= c.length); v++)
      S = t(
        o.buffer,
        u[m + v],
        c[m + v],
        o.position - (u[m] - u[m + v]),
        b
      ), g += e.repeat(" ", a.indent) + r((o.line + v + 1).toString(), k) + " | " + S.str + `
`;
    return g.replace(/\n$/, "");
  }
  return I0 = n, I0;
}
var N0, k_;
function Rn() {
  if (k_) return N0;
  k_ = 1;
  var e = kh(), t = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases"
  ], r = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function n(a) {
    var i = {};
    return a !== null && Object.keys(a).forEach(function(u) {
      a[u].forEach(function(c) {
        i[String(c)] = u;
      });
    }), i;
  }
  function o(a, i) {
    if (i = i || {}, Object.keys(i).forEach(function(u) {
      if (t.indexOf(u) === -1)
        throw new e('Unknown option "' + u + '" is met in definition of "' + a + '" YAML type.');
    }), this.options = i, this.tag = a, this.kind = i.kind || null, this.resolve = i.resolve || function() {
      return !0;
    }, this.construct = i.construct || function(u) {
      return u;
    }, this.instanceOf = i.instanceOf || null, this.predicate = i.predicate || null, this.represent = i.represent || null, this.representName = i.representName || null, this.defaultStyle = i.defaultStyle || null, this.multi = i.multi || !1, this.styleAliases = n(i.styleAliases || null), r.indexOf(this.kind) === -1)
      throw new e('Unknown kind "' + this.kind + '" is specified for "' + a + '" YAML type.');
  }
  return N0 = o, N0;
}
var j0, A_;
function mC() {
  if (A_) return j0;
  A_ = 1;
  var e = kh(), t = Rn();
  function r(a, i) {
    var u = [];
    return a[i].forEach(function(c) {
      var d = u.length;
      u.forEach(function(m, g) {
        m.tag === c.tag && m.kind === c.kind && m.multi === c.multi && (d = g);
      }), u[d] = c;
    }), u;
  }
  function n() {
    var a = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: {
        scalar: [],
        sequence: [],
        mapping: [],
        fallback: []
      }
    }, i, u;
    function c(d) {
      d.multi ? (a.multi[d.kind].push(d), a.multi.fallback.push(d)) : a[d.kind][d.tag] = a.fallback[d.tag] = d;
    }
    for (i = 0, u = arguments.length; i < u; i += 1)
      arguments[i].forEach(c);
    return a;
  }
  function o(a) {
    return this.extend(a);
  }
  return o.prototype.extend = function(i) {
    var u = [], c = [];
    if (i instanceof t)
      c.push(i);
    else if (Array.isArray(i))
      c = c.concat(i);
    else if (i && (Array.isArray(i.implicit) || Array.isArray(i.explicit)))
      i.implicit && (u = u.concat(i.implicit)), i.explicit && (c = c.concat(i.explicit));
    else
      throw new e("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
    u.forEach(function(m) {
      if (!(m instanceof t))
        throw new e("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      if (m.loadKind && m.loadKind !== "scalar")
        throw new e("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      if (m.multi)
        throw new e("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }), c.forEach(function(m) {
      if (!(m instanceof t))
        throw new e("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    });
    var d = Object.create(o.prototype);
    return d.implicit = (this.implicit || []).concat(u), d.explicit = (this.explicit || []).concat(c), d.compiledImplicit = r(d, "implicit"), d.compiledExplicit = r(d, "explicit"), d.compiledTypeMap = n(d.compiledImplicit, d.compiledExplicit), d;
  }, j0 = o, j0;
}
var L0, P_;
function gC() {
  if (P_) return L0;
  P_ = 1;
  var e = Rn();
  return L0 = new e("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(t) {
      return t !== null ? t : "";
    }
  }), L0;
}
var M0, T_;
function yC() {
  if (T_) return M0;
  T_ = 1;
  var e = Rn();
  return M0 = new e("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(t) {
      return t !== null ? t : [];
    }
  }), M0;
}
var D0, C_;
function vC() {
  if (C_) return D0;
  C_ = 1;
  var e = Rn();
  return D0 = new e("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(t) {
      return t !== null ? t : {};
    }
  }), D0;
}
var F0, $_;
function bC() {
  if ($_) return F0;
  $_ = 1;
  var e = mC();
  return F0 = new e({
    explicit: [
      gC(),
      yC(),
      vC()
    ]
  }), F0;
}
var q0, R_;
function wC() {
  if (R_) return q0;
  R_ = 1;
  var e = Rn();
  function t(o) {
    if (o === null) return !0;
    var a = o.length;
    return a === 1 && o === "~" || a === 4 && (o === "null" || o === "Null" || o === "NULL");
  }
  function r() {
    return null;
  }
  function n(o) {
    return o === null;
  }
  return q0 = new e("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: t,
    construct: r,
    predicate: n,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      },
      empty: function() {
        return "";
      }
    },
    defaultStyle: "lowercase"
  }), q0;
}
var z0, I_;
function SC() {
  if (I_) return z0;
  I_ = 1;
  var e = Rn();
  function t(o) {
    if (o === null) return !1;
    var a = o.length;
    return a === 4 && (o === "true" || o === "True" || o === "TRUE") || a === 5 && (o === "false" || o === "False" || o === "FALSE");
  }
  function r(o) {
    return o === "true" || o === "True" || o === "TRUE";
  }
  function n(o) {
    return Object.prototype.toString.call(o) === "[object Boolean]";
  }
  return z0 = new e("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: t,
    construct: r,
    predicate: n,
    represent: {
      lowercase: function(o) {
        return o ? "true" : "false";
      },
      uppercase: function(o) {
        return o ? "TRUE" : "FALSE";
      },
      camelcase: function(o) {
        return o ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  }), z0;
}
var B0, N_;
function xC() {
  if (N_) return B0;
  N_ = 1;
  var e = Oh(), t = Rn();
  function r(c) {
    return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
  }
  function n(c) {
    return 48 <= c && c <= 55;
  }
  function o(c) {
    return 48 <= c && c <= 57;
  }
  function a(c) {
    if (c === null) return !1;
    var d = c.length, m = 0, g = !1, v;
    if (!d) return !1;
    if (v = c[m], (v === "-" || v === "+") && (v = c[++m]), v === "0") {
      if (m + 1 === d) return !0;
      if (v = c[++m], v === "b") {
        for (m++; m < d; m++)
          if (v = c[m], v !== "_") {
            if (v !== "0" && v !== "1") return !1;
            g = !0;
          }
        return g && v !== "_";
      }
      if (v === "x") {
        for (m++; m < d; m++)
          if (v = c[m], v !== "_") {
            if (!r(c.charCodeAt(m))) return !1;
            g = !0;
          }
        return g && v !== "_";
      }
      if (v === "o") {
        for (m++; m < d; m++)
          if (v = c[m], v !== "_") {
            if (!n(c.charCodeAt(m))) return !1;
            g = !0;
          }
        return g && v !== "_";
      }
    }
    if (v === "_") return !1;
    for (; m < d; m++)
      if (v = c[m], v !== "_") {
        if (!o(c.charCodeAt(m)))
          return !1;
        g = !0;
      }
    return !(!g || v === "_");
  }
  function i(c) {
    var d = c, m = 1, g;
    if (d.indexOf("_") !== -1 && (d = d.replace(/_/g, "")), g = d[0], (g === "-" || g === "+") && (g === "-" && (m = -1), d = d.slice(1), g = d[0]), d === "0") return 0;
    if (g === "0") {
      if (d[1] === "b") return m * parseInt(d.slice(2), 2);
      if (d[1] === "x") return m * parseInt(d.slice(2), 16);
      if (d[1] === "o") return m * parseInt(d.slice(2), 8);
    }
    return m * parseInt(d, 10);
  }
  function u(c) {
    return Object.prototype.toString.call(c) === "[object Number]" && c % 1 === 0 && !e.isNegativeZero(c);
  }
  return B0 = new t("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: a,
    construct: i,
    predicate: u,
    represent: {
      binary: function(c) {
        return c >= 0 ? "0b" + c.toString(2) : "-0b" + c.toString(2).slice(1);
      },
      octal: function(c) {
        return c >= 0 ? "0o" + c.toString(8) : "-0o" + c.toString(8).slice(1);
      },
      decimal: function(c) {
        return c.toString(10);
      },
      /* eslint-disable max-len */
      hexadecimal: function(c) {
        return c >= 0 ? "0x" + c.toString(16).toUpperCase() : "-0x" + c.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  }), B0;
}
var U0, j_;
function _C() {
  if (j_) return U0;
  j_ = 1;
  var e = Oh(), t = Rn(), r = new RegExp(
    // 2.5e4, 2.5 and integers
    "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
  );
  function n(c) {
    return !(c === null || !r.test(c) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    c[c.length - 1] === "_");
  }
  function o(c) {
    var d, m;
    return d = c.replace(/_/g, "").toLowerCase(), m = d[0] === "-" ? -1 : 1, "+-".indexOf(d[0]) >= 0 && (d = d.slice(1)), d === ".inf" ? m === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : d === ".nan" ? NaN : m * parseFloat(d, 10);
  }
  var a = /^[-+]?[0-9]+e/;
  function i(c, d) {
    var m;
    if (isNaN(c))
      switch (d) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    else if (Number.POSITIVE_INFINITY === c)
      switch (d) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    else if (Number.NEGATIVE_INFINITY === c)
      switch (d) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    else if (e.isNegativeZero(c))
      return "-0.0";
    return m = c.toString(10), a.test(m) ? m.replace("e", ".e") : m;
  }
  function u(c) {
    return Object.prototype.toString.call(c) === "[object Number]" && (c % 1 !== 0 || e.isNegativeZero(c));
  }
  return U0 = new t("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: n,
    construct: o,
    predicate: u,
    represent: i,
    defaultStyle: "lowercase"
  }), U0;
}
var V0, L_;
function EC() {
  return L_ || (L_ = 1, V0 = bC().extend({
    implicit: [
      wC(),
      SC(),
      xC(),
      _C()
    ]
  })), V0;
}
var H0, M_;
function OC() {
  return M_ || (M_ = 1, H0 = EC()), H0;
}
var W0, D_;
function kC() {
  if (D_) return W0;
  D_ = 1;
  var e = Rn(), t = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
  ), r = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  );
  function n(i) {
    return i === null ? !1 : t.exec(i) !== null || r.exec(i) !== null;
  }
  function o(i) {
    var u, c, d, m, g, v, S, k = 0, b = null, x, A, _;
    if (u = t.exec(i), u === null && (u = r.exec(i)), u === null) throw new Error("Date resolve error");
    if (c = +u[1], d = +u[2] - 1, m = +u[3], !u[4])
      return new Date(Date.UTC(c, d, m));
    if (g = +u[4], v = +u[5], S = +u[6], u[7]) {
      for (k = u[7].slice(0, 3); k.length < 3; )
        k += "0";
      k = +k;
    }
    return u[9] && (x = +u[10], A = +(u[11] || 0), b = (x * 60 + A) * 6e4, u[9] === "-" && (b = -b)), _ = new Date(Date.UTC(c, d, m, g, v, S, k)), b && _.setTime(_.getTime() - b), _;
  }
  function a(i) {
    return i.toISOString();
  }
  return W0 = new e("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: n,
    construct: o,
    instanceOf: Date,
    represent: a
  }), W0;
}
var K0, F_;
function AC() {
  if (F_) return K0;
  F_ = 1;
  var e = Rn();
  function t(r) {
    return r === "<<" || r === null;
  }
  return K0 = new e("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: t
  }), K0;
}
var Q0, q_;
function PC() {
  if (q_) return Q0;
  q_ = 1;
  var e = Rn(), t = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
  function r(i) {
    if (i === null) return !1;
    var u, c, d = 0, m = i.length, g = t;
    for (c = 0; c < m; c++)
      if (u = g.indexOf(i.charAt(c)), !(u > 64)) {
        if (u < 0) return !1;
        d += 6;
      }
    return d % 8 === 0;
  }
  function n(i) {
    var u, c, d = i.replace(/[\r\n=]/g, ""), m = d.length, g = t, v = 0, S = [];
    for (u = 0; u < m; u++)
      u % 4 === 0 && u && (S.push(v >> 16 & 255), S.push(v >> 8 & 255), S.push(v & 255)), v = v << 6 | g.indexOf(d.charAt(u));
    return c = m % 4 * 6, c === 0 ? (S.push(v >> 16 & 255), S.push(v >> 8 & 255), S.push(v & 255)) : c === 18 ? (S.push(v >> 10 & 255), S.push(v >> 2 & 255)) : c === 12 && S.push(v >> 4 & 255), new Uint8Array(S);
  }
  function o(i) {
    var u = "", c = 0, d, m, g = i.length, v = t;
    for (d = 0; d < g; d++)
      d % 3 === 0 && d && (u += v[c >> 18 & 63], u += v[c >> 12 & 63], u += v[c >> 6 & 63], u += v[c & 63]), c = (c << 8) + i[d];
    return m = g % 3, m === 0 ? (u += v[c >> 18 & 63], u += v[c >> 12 & 63], u += v[c >> 6 & 63], u += v[c & 63]) : m === 2 ? (u += v[c >> 10 & 63], u += v[c >> 4 & 63], u += v[c << 2 & 63], u += v[64]) : m === 1 && (u += v[c >> 2 & 63], u += v[c << 4 & 63], u += v[64], u += v[64]), u;
  }
  function a(i) {
    return Object.prototype.toString.call(i) === "[object Uint8Array]";
  }
  return Q0 = new e("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: r,
    construct: n,
    predicate: a,
    represent: o
  }), Q0;
}
var Y0, z_;
function TC() {
  if (z_) return Y0;
  z_ = 1;
  var e = Rn(), t = Object.prototype.hasOwnProperty, r = Object.prototype.toString;
  function n(a) {
    if (a === null) return !0;
    var i = [], u, c, d, m, g, v = a;
    for (u = 0, c = v.length; u < c; u += 1) {
      if (d = v[u], g = !1, r.call(d) !== "[object Object]") return !1;
      for (m in d)
        if (t.call(d, m))
          if (!g) g = !0;
          else return !1;
      if (!g) return !1;
      if (i.indexOf(m) === -1) i.push(m);
      else return !1;
    }
    return !0;
  }
  function o(a) {
    return a !== null ? a : [];
  }
  return Y0 = new e("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: n,
    construct: o
  }), Y0;
}
var G0, B_;
function CC() {
  if (B_) return G0;
  B_ = 1;
  var e = Rn(), t = Object.prototype.toString;
  function r(o) {
    if (o === null) return !0;
    var a, i, u, c, d, m = o;
    for (d = new Array(m.length), a = 0, i = m.length; a < i; a += 1) {
      if (u = m[a], t.call(u) !== "[object Object]" || (c = Object.keys(u), c.length !== 1)) return !1;
      d[a] = [c[0], u[c[0]]];
    }
    return !0;
  }
  function n(o) {
    if (o === null) return [];
    var a, i, u, c, d, m = o;
    for (d = new Array(m.length), a = 0, i = m.length; a < i; a += 1)
      u = m[a], c = Object.keys(u), d[a] = [c[0], u[c[0]]];
    return d;
  }
  return G0 = new e("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: r,
    construct: n
  }), G0;
}
var X0, U_;
function $C() {
  if (U_) return X0;
  U_ = 1;
  var e = Rn(), t = Object.prototype.hasOwnProperty;
  function r(o) {
    if (o === null) return !0;
    var a, i = o;
    for (a in i)
      if (t.call(i, a) && i[a] !== null)
        return !1;
    return !0;
  }
  function n(o) {
    return o !== null ? o : {};
  }
  return X0 = new e("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: r,
    construct: n
  }), X0;
}
var J0, V_;
function _x() {
  return V_ || (V_ = 1, J0 = OC().extend({
    implicit: [
      kC(),
      AC()
    ],
    explicit: [
      PC(),
      TC(),
      CC(),
      $C()
    ]
  })), J0;
}
var H_;
function CF() {
  if (H_) return bg;
  H_ = 1;
  var e = Oh(), t = kh(), r = TF(), n = _x(), o = Object.prototype.hasOwnProperty, a = 1, i = 2, u = 3, c = 4, d = 1, m = 2, g = 3, v = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, S = /[\x85\u2028\u2029]/, k = /[,\[\]\{\}]/, b = /^(?:!|!!|![a-z\-]+!)$/i, x = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function A($) {
    return Object.prototype.toString.call($);
  }
  function _($) {
    return $ === 10 || $ === 13;
  }
  function O($) {
    return $ === 9 || $ === 32;
  }
  function R($) {
    return $ === 9 || $ === 32 || $ === 10 || $ === 13;
  }
  function C($) {
    return $ === 44 || $ === 91 || $ === 93 || $ === 123 || $ === 125;
  }
  function T($) {
    var K;
    return 48 <= $ && $ <= 57 ? $ - 48 : (K = $ | 32, 97 <= K && K <= 102 ? K - 97 + 10 : -1);
  }
  function j($) {
    return $ === 120 ? 2 : $ === 117 ? 4 : $ === 85 ? 8 : 0;
  }
  function D($) {
    return 48 <= $ && $ <= 57 ? $ - 48 : -1;
  }
  function V($) {
    return $ === 48 ? "\0" : $ === 97 ? "\x07" : $ === 98 ? "\b" : $ === 116 || $ === 9 ? "	" : $ === 110 ? `
` : $ === 118 ? "\v" : $ === 102 ? "\f" : $ === 114 ? "\r" : $ === 101 ? "\x1B" : $ === 32 ? " " : $ === 34 ? '"' : $ === 47 ? "/" : $ === 92 ? "\\" : $ === 78 ? "" : $ === 95 ? " " : $ === 76 ? "\u2028" : $ === 80 ? "\u2029" : "";
  }
  function U($) {
    return $ <= 65535 ? String.fromCharCode($) : String.fromCharCode(
      ($ - 65536 >> 10) + 55296,
      ($ - 65536 & 1023) + 56320
    );
  }
  for (var ne = new Array(256), H = new Array(256), ae = 0; ae < 256; ae++)
    ne[ae] = V(ae) ? 1 : 0, H[ae] = V(ae);
  function ge($, K) {
    this.input = $, this.filename = K.filename || null, this.schema = K.schema || n, this.onWarning = K.onWarning || null, this.legacy = K.legacy || !1, this.json = K.json || !1, this.listener = K.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = $.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
  }
  function fe($, K) {
    var me = {
      name: $.filename,
      buffer: $.input.slice(0, -1),
      // omit trailing \0
      position: $.position,
      line: $.line,
      column: $.position - $.lineStart
    };
    return me.snippet = r(me), new t(K, me);
  }
  function ve($, K) {
    throw fe($, K);
  }
  function $e($, K) {
    $.onWarning && $.onWarning.call(null, fe($, K));
  }
  var ce = {
    YAML: function(K, me, Te) {
      var ke, De, Fe;
      K.version !== null && ve(K, "duplication of %YAML directive"), Te.length !== 1 && ve(K, "YAML directive accepts exactly one argument"), ke = /^([0-9]+)\.([0-9]+)$/.exec(Te[0]), ke === null && ve(K, "ill-formed argument of the YAML directive"), De = parseInt(ke[1], 10), Fe = parseInt(ke[2], 10), De !== 1 && ve(K, "unacceptable YAML version of the document"), K.version = Te[0], K.checkLineBreaks = Fe < 2, Fe !== 1 && Fe !== 2 && $e(K, "unsupported YAML version of the document");
    },
    TAG: function(K, me, Te) {
      var ke, De;
      Te.length !== 2 && ve(K, "TAG directive accepts exactly two arguments"), ke = Te[0], De = Te[1], b.test(ke) || ve(K, "ill-formed tag handle (first argument) of the TAG directive"), o.call(K.tagMap, ke) && ve(K, 'there is a previously declared suffix for "' + ke + '" tag handle'), x.test(De) || ve(K, "ill-formed tag prefix (second argument) of the TAG directive");
      try {
        De = decodeURIComponent(De);
      } catch {
        ve(K, "tag prefix is malformed: " + De);
      }
      K.tagMap[ke] = De;
    }
  };
  function se($, K, me, Te) {
    var ke, De, Fe, Xe;
    if (K < me) {
      if (Xe = $.input.slice(K, me), Te)
        for (ke = 0, De = Xe.length; ke < De; ke += 1)
          Fe = Xe.charCodeAt(ke), Fe === 9 || 32 <= Fe && Fe <= 1114111 || ve($, "expected valid JSON character");
      else v.test(Xe) && ve($, "the stream contains non-printable characters");
      $.result += Xe;
    }
  }
  function te($, K, me, Te) {
    var ke, De, Fe, Xe;
    for (e.isObject(me) || ve($, "cannot merge mappings; the provided source object is unacceptable"), ke = Object.keys(me), Fe = 0, Xe = ke.length; Fe < Xe; Fe += 1)
      De = ke[Fe], o.call(K, De) || (K[De] = me[De], Te[De] = !0);
  }
  function F($, K, me, Te, ke, De, Fe, Xe, ct) {
    var mt, st;
    if (Array.isArray(ke))
      for (ke = Array.prototype.slice.call(ke), mt = 0, st = ke.length; mt < st; mt += 1)
        Array.isArray(ke[mt]) && ve($, "nested arrays are not supported inside keys"), typeof ke == "object" && A(ke[mt]) === "[object Object]" && (ke[mt] = "[object Object]");
    if (typeof ke == "object" && A(ke) === "[object Object]" && (ke = "[object Object]"), ke = String(ke), K === null && (K = {}), Te === "tag:yaml.org,2002:merge")
      if (Array.isArray(De))
        for (mt = 0, st = De.length; mt < st; mt += 1)
          te($, K, De[mt], me);
      else
        te($, K, De, me);
    else
      !$.json && !o.call(me, ke) && o.call(K, ke) && ($.line = Fe || $.line, $.lineStart = Xe || $.lineStart, $.position = ct || $.position, ve($, "duplicated mapping key")), ke === "__proto__" ? Object.defineProperty(K, ke, {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        value: De
      }) : K[ke] = De, delete me[ke];
    return K;
  }
  function J($) {
    var K;
    K = $.input.charCodeAt($.position), K === 10 ? $.position++ : K === 13 ? ($.position++, $.input.charCodeAt($.position) === 10 && $.position++) : ve($, "a line break is expected"), $.line += 1, $.lineStart = $.position, $.firstTabInLine = -1;
  }
  function W($, K, me) {
    for (var Te = 0, ke = $.input.charCodeAt($.position); ke !== 0; ) {
      for (; O(ke); )
        ke === 9 && $.firstTabInLine === -1 && ($.firstTabInLine = $.position), ke = $.input.charCodeAt(++$.position);
      if (K && ke === 35)
        do
          ke = $.input.charCodeAt(++$.position);
        while (ke !== 10 && ke !== 13 && ke !== 0);
      if (_(ke))
        for (J($), ke = $.input.charCodeAt($.position), Te++, $.lineIndent = 0; ke === 32; )
          $.lineIndent++, ke = $.input.charCodeAt(++$.position);
      else
        break;
    }
    return me !== -1 && Te !== 0 && $.lineIndent < me && $e($, "deficient indentation"), Te;
  }
  function q($) {
    var K = $.position, me;
    return me = $.input.charCodeAt(K), !!((me === 45 || me === 46) && me === $.input.charCodeAt(K + 1) && me === $.input.charCodeAt(K + 2) && (K += 3, me = $.input.charCodeAt(K), me === 0 || R(me)));
  }
  function X($, K) {
    K === 1 ? $.result += " " : K > 1 && ($.result += e.repeat(`
`, K - 1));
  }
  function Q($, K, me) {
    var Te, ke, De, Fe, Xe, ct, mt, st, at = $.kind, Vt = $.result, Y;
    if (Y = $.input.charCodeAt($.position), R(Y) || C(Y) || Y === 35 || Y === 38 || Y === 42 || Y === 33 || Y === 124 || Y === 62 || Y === 39 || Y === 34 || Y === 37 || Y === 64 || Y === 96 || (Y === 63 || Y === 45) && (ke = $.input.charCodeAt($.position + 1), R(ke) || me && C(ke)))
      return !1;
    for ($.kind = "scalar", $.result = "", De = Fe = $.position, Xe = !1; Y !== 0; ) {
      if (Y === 58) {
        if (ke = $.input.charCodeAt($.position + 1), R(ke) || me && C(ke))
          break;
      } else if (Y === 35) {
        if (Te = $.input.charCodeAt($.position - 1), R(Te))
          break;
      } else {
        if ($.position === $.lineStart && q($) || me && C(Y))
          break;
        if (_(Y))
          if (ct = $.line, mt = $.lineStart, st = $.lineIndent, W($, !1, -1), $.lineIndent >= K) {
            Xe = !0, Y = $.input.charCodeAt($.position);
            continue;
          } else {
            $.position = Fe, $.line = ct, $.lineStart = mt, $.lineIndent = st;
            break;
          }
      }
      Xe && (se($, De, Fe, !1), X($, $.line - ct), De = Fe = $.position, Xe = !1), O(Y) || (Fe = $.position + 1), Y = $.input.charCodeAt(++$.position);
    }
    return se($, De, Fe, !1), $.result ? !0 : ($.kind = at, $.result = Vt, !1);
  }
  function ye($, K) {
    var me, Te, ke;
    if (me = $.input.charCodeAt($.position), me !== 39)
      return !1;
    for ($.kind = "scalar", $.result = "", $.position++, Te = ke = $.position; (me = $.input.charCodeAt($.position)) !== 0; )
      if (me === 39)
        if (se($, Te, $.position, !0), me = $.input.charCodeAt(++$.position), me === 39)
          Te = $.position, $.position++, ke = $.position;
        else
          return !0;
      else _(me) ? (se($, Te, ke, !0), X($, W($, !1, K)), Te = ke = $.position) : $.position === $.lineStart && q($) ? ve($, "unexpected end of the document within a single quoted scalar") : ($.position++, ke = $.position);
    ve($, "unexpected end of the stream within a single quoted scalar");
  }
  function Se($, K) {
    var me, Te, ke, De, Fe, Xe;
    if (Xe = $.input.charCodeAt($.position), Xe !== 34)
      return !1;
    for ($.kind = "scalar", $.result = "", $.position++, me = Te = $.position; (Xe = $.input.charCodeAt($.position)) !== 0; ) {
      if (Xe === 34)
        return se($, me, $.position, !0), $.position++, !0;
      if (Xe === 92) {
        if (se($, me, $.position, !0), Xe = $.input.charCodeAt(++$.position), _(Xe))
          W($, !1, K);
        else if (Xe < 256 && ne[Xe])
          $.result += H[Xe], $.position++;
        else if ((Fe = j(Xe)) > 0) {
          for (ke = Fe, De = 0; ke > 0; ke--)
            Xe = $.input.charCodeAt(++$.position), (Fe = T(Xe)) >= 0 ? De = (De << 4) + Fe : ve($, "expected hexadecimal character");
          $.result += U(De), $.position++;
        } else
          ve($, "unknown escape sequence");
        me = Te = $.position;
      } else _(Xe) ? (se($, me, Te, !0), X($, W($, !1, K)), me = Te = $.position) : $.position === $.lineStart && q($) ? ve($, "unexpected end of the document within a double quoted scalar") : ($.position++, Te = $.position);
    }
    ve($, "unexpected end of the stream within a double quoted scalar");
  }
  function Ne($, K) {
    var me = !0, Te, ke, De, Fe = $.tag, Xe, ct = $.anchor, mt, st, at, Vt, Y, Ie = /* @__PURE__ */ Object.create(null), Le, Me, ze, He;
    if (He = $.input.charCodeAt($.position), He === 91)
      st = 93, Y = !1, Xe = [];
    else if (He === 123)
      st = 125, Y = !0, Xe = {};
    else
      return !1;
    for ($.anchor !== null && ($.anchorMap[$.anchor] = Xe), He = $.input.charCodeAt(++$.position); He !== 0; ) {
      if (W($, !0, K), He = $.input.charCodeAt($.position), He === st)
        return $.position++, $.tag = Fe, $.anchor = ct, $.kind = Y ? "mapping" : "sequence", $.result = Xe, !0;
      me ? He === 44 && ve($, "expected the node content, but found ','") : ve($, "missed comma between flow collection entries"), Me = Le = ze = null, at = Vt = !1, He === 63 && (mt = $.input.charCodeAt($.position + 1), R(mt) && (at = Vt = !0, $.position++, W($, !0, K))), Te = $.line, ke = $.lineStart, De = $.position, re($, K, a, !1, !0), Me = $.tag, Le = $.result, W($, !0, K), He = $.input.charCodeAt($.position), (Vt || $.line === Te) && He === 58 && (at = !0, He = $.input.charCodeAt(++$.position), W($, !0, K), re($, K, a, !1, !0), ze = $.result), Y ? F($, Xe, Ie, Me, Le, ze, Te, ke, De) : at ? Xe.push(F($, null, Ie, Me, Le, ze, Te, ke, De)) : Xe.push(Le), W($, !0, K), He = $.input.charCodeAt($.position), He === 44 ? (me = !0, He = $.input.charCodeAt(++$.position)) : me = !1;
    }
    ve($, "unexpected end of the stream within a flow collection");
  }
  function N($, K) {
    var me, Te, ke = d, De = !1, Fe = !1, Xe = K, ct = 0, mt = !1, st, at;
    if (at = $.input.charCodeAt($.position), at === 124)
      Te = !1;
    else if (at === 62)
      Te = !0;
    else
      return !1;
    for ($.kind = "scalar", $.result = ""; at !== 0; )
      if (at = $.input.charCodeAt(++$.position), at === 43 || at === 45)
        d === ke ? ke = at === 43 ? g : m : ve($, "repeat of a chomping mode identifier");
      else if ((st = D(at)) >= 0)
        st === 0 ? ve($, "bad explicit indentation width of a block scalar; it cannot be less than one") : Fe ? ve($, "repeat of an indentation width identifier") : (Xe = K + st - 1, Fe = !0);
      else
        break;
    if (O(at)) {
      do
        at = $.input.charCodeAt(++$.position);
      while (O(at));
      if (at === 35)
        do
          at = $.input.charCodeAt(++$.position);
        while (!_(at) && at !== 0);
    }
    for (; at !== 0; ) {
      for (J($), $.lineIndent = 0, at = $.input.charCodeAt($.position); (!Fe || $.lineIndent < Xe) && at === 32; )
        $.lineIndent++, at = $.input.charCodeAt(++$.position);
      if (!Fe && $.lineIndent > Xe && (Xe = $.lineIndent), _(at)) {
        ct++;
        continue;
      }
      if ($.lineIndent < Xe) {
        ke === g ? $.result += e.repeat(`
`, De ? 1 + ct : ct) : ke === d && De && ($.result += `
`);
        break;
      }
      for (Te ? O(at) ? (mt = !0, $.result += e.repeat(`
`, De ? 1 + ct : ct)) : mt ? (mt = !1, $.result += e.repeat(`
`, ct + 1)) : ct === 0 ? De && ($.result += " ") : $.result += e.repeat(`
`, ct) : $.result += e.repeat(`
`, De ? 1 + ct : ct), De = !0, Fe = !0, ct = 0, me = $.position; !_(at) && at !== 0; )
        at = $.input.charCodeAt(++$.position);
      se($, me, $.position, !1);
    }
    return !0;
  }
  function B($, K) {
    var me, Te = $.tag, ke = $.anchor, De = [], Fe, Xe = !1, ct;
    if ($.firstTabInLine !== -1) return !1;
    for ($.anchor !== null && ($.anchorMap[$.anchor] = De), ct = $.input.charCodeAt($.position); ct !== 0 && ($.firstTabInLine !== -1 && ($.position = $.firstTabInLine, ve($, "tab characters must not be used in indentation")), !(ct !== 45 || (Fe = $.input.charCodeAt($.position + 1), !R(Fe)))); ) {
      if (Xe = !0, $.position++, W($, !0, -1) && $.lineIndent <= K) {
        De.push(null), ct = $.input.charCodeAt($.position);
        continue;
      }
      if (me = $.line, re($, K, u, !1, !0), De.push($.result), W($, !0, -1), ct = $.input.charCodeAt($.position), ($.line === me || $.lineIndent > K) && ct !== 0)
        ve($, "bad indentation of a sequence entry");
      else if ($.lineIndent < K)
        break;
    }
    return Xe ? ($.tag = Te, $.anchor = ke, $.kind = "sequence", $.result = De, !0) : !1;
  }
  function oe($, K, me) {
    var Te, ke, De, Fe, Xe, ct, mt = $.tag, st = $.anchor, at = {}, Vt = /* @__PURE__ */ Object.create(null), Y = null, Ie = null, Le = null, Me = !1, ze = !1, He;
    if ($.firstTabInLine !== -1) return !1;
    for ($.anchor !== null && ($.anchorMap[$.anchor] = at), He = $.input.charCodeAt($.position); He !== 0; ) {
      if (!Me && $.firstTabInLine !== -1 && ($.position = $.firstTabInLine, ve($, "tab characters must not be used in indentation")), Te = $.input.charCodeAt($.position + 1), De = $.line, (He === 63 || He === 58) && R(Te))
        He === 63 ? (Me && (F($, at, Vt, Y, Ie, null, Fe, Xe, ct), Y = Ie = Le = null), ze = !0, Me = !0, ke = !0) : Me ? (Me = !1, ke = !0) : ve($, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), $.position += 1, He = Te;
      else {
        if (Fe = $.line, Xe = $.lineStart, ct = $.position, !re($, me, i, !1, !0))
          break;
        if ($.line === De) {
          for (He = $.input.charCodeAt($.position); O(He); )
            He = $.input.charCodeAt(++$.position);
          if (He === 58)
            He = $.input.charCodeAt(++$.position), R(He) || ve($, "a whitespace character is expected after the key-value separator within a block mapping"), Me && (F($, at, Vt, Y, Ie, null, Fe, Xe, ct), Y = Ie = Le = null), ze = !0, Me = !1, ke = !1, Y = $.tag, Ie = $.result;
          else if (ze)
            ve($, "can not read an implicit mapping pair; a colon is missed");
          else
            return $.tag = mt, $.anchor = st, !0;
        } else if (ze)
          ve($, "can not read a block mapping entry; a multiline key may not be an implicit key");
        else
          return $.tag = mt, $.anchor = st, !0;
      }
      if (($.line === De || $.lineIndent > K) && (Me && (Fe = $.line, Xe = $.lineStart, ct = $.position), re($, K, c, !0, ke) && (Me ? Ie = $.result : Le = $.result), Me || (F($, at, Vt, Y, Ie, Le, Fe, Xe, ct), Y = Ie = Le = null), W($, !0, -1), He = $.input.charCodeAt($.position)), ($.line === De || $.lineIndent > K) && He !== 0)
        ve($, "bad indentation of a mapping entry");
      else if ($.lineIndent < K)
        break;
    }
    return Me && F($, at, Vt, Y, Ie, null, Fe, Xe, ct), ze && ($.tag = mt, $.anchor = st, $.kind = "mapping", $.result = at), ze;
  }
  function ie($) {
    var K, me = !1, Te = !1, ke, De, Fe;
    if (Fe = $.input.charCodeAt($.position), Fe !== 33) return !1;
    if ($.tag !== null && ve($, "duplication of a tag property"), Fe = $.input.charCodeAt(++$.position), Fe === 60 ? (me = !0, Fe = $.input.charCodeAt(++$.position)) : Fe === 33 ? (Te = !0, ke = "!!", Fe = $.input.charCodeAt(++$.position)) : ke = "!", K = $.position, me) {
      do
        Fe = $.input.charCodeAt(++$.position);
      while (Fe !== 0 && Fe !== 62);
      $.position < $.length ? (De = $.input.slice(K, $.position), Fe = $.input.charCodeAt(++$.position)) : ve($, "unexpected end of the stream within a verbatim tag");
    } else {
      for (; Fe !== 0 && !R(Fe); )
        Fe === 33 && (Te ? ve($, "tag suffix cannot contain exclamation marks") : (ke = $.input.slice(K - 1, $.position + 1), b.test(ke) || ve($, "named tag handle cannot contain such characters"), Te = !0, K = $.position + 1)), Fe = $.input.charCodeAt(++$.position);
      De = $.input.slice(K, $.position), k.test(De) && ve($, "tag suffix cannot contain flow indicator characters");
    }
    De && !x.test(De) && ve($, "tag name cannot contain such characters: " + De);
    try {
      De = decodeURIComponent(De);
    } catch {
      ve($, "tag name is malformed: " + De);
    }
    return me ? $.tag = De : o.call($.tagMap, ke) ? $.tag = $.tagMap[ke] + De : ke === "!" ? $.tag = "!" + De : ke === "!!" ? $.tag = "tag:yaml.org,2002:" + De : ve($, 'undeclared tag handle "' + ke + '"'), !0;
  }
  function he($) {
    var K, me;
    if (me = $.input.charCodeAt($.position), me !== 38) return !1;
    for ($.anchor !== null && ve($, "duplication of an anchor property"), me = $.input.charCodeAt(++$.position), K = $.position; me !== 0 && !R(me) && !C(me); )
      me = $.input.charCodeAt(++$.position);
    return $.position === K && ve($, "name of an anchor node must contain at least one character"), $.anchor = $.input.slice(K, $.position), !0;
  }
  function Z($) {
    var K, me, Te;
    if (Te = $.input.charCodeAt($.position), Te !== 42) return !1;
    for (Te = $.input.charCodeAt(++$.position), K = $.position; Te !== 0 && !R(Te) && !C(Te); )
      Te = $.input.charCodeAt(++$.position);
    return $.position === K && ve($, "name of an alias node must contain at least one character"), me = $.input.slice(K, $.position), o.call($.anchorMap, me) || ve($, 'unidentified alias "' + me + '"'), $.result = $.anchorMap[me], W($, !0, -1), !0;
  }
  function re($, K, me, Te, ke) {
    var De, Fe, Xe, ct = 1, mt = !1, st = !1, at, Vt, Y, Ie, Le, Me;
    if ($.listener !== null && $.listener("open", $), $.tag = null, $.anchor = null, $.kind = null, $.result = null, De = Fe = Xe = c === me || u === me, Te && W($, !0, -1) && (mt = !0, $.lineIndent > K ? ct = 1 : $.lineIndent === K ? ct = 0 : $.lineIndent < K && (ct = -1)), ct === 1)
      for (; ie($) || he($); )
        W($, !0, -1) ? (mt = !0, Xe = De, $.lineIndent > K ? ct = 1 : $.lineIndent === K ? ct = 0 : $.lineIndent < K && (ct = -1)) : Xe = !1;
    if (Xe && (Xe = mt || ke), (ct === 1 || c === me) && (a === me || i === me ? Le = K : Le = K + 1, Me = $.position - $.lineStart, ct === 1 ? Xe && (B($, Me) || oe($, Me, Le)) || Ne($, Le) ? st = !0 : (Fe && N($, Le) || ye($, Le) || Se($, Le) ? st = !0 : Z($) ? (st = !0, ($.tag !== null || $.anchor !== null) && ve($, "alias node should not have any properties")) : Q($, Le, a === me) && (st = !0, $.tag === null && ($.tag = "?")), $.anchor !== null && ($.anchorMap[$.anchor] = $.result)) : ct === 0 && (st = Xe && B($, Me))), $.tag === null)
      $.anchor !== null && ($.anchorMap[$.anchor] = $.result);
    else if ($.tag === "?") {
      for ($.result !== null && $.kind !== "scalar" && ve($, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + $.kind + '"'), at = 0, Vt = $.implicitTypes.length; at < Vt; at += 1)
        if (Ie = $.implicitTypes[at], Ie.resolve($.result)) {
          $.result = Ie.construct($.result), $.tag = Ie.tag, $.anchor !== null && ($.anchorMap[$.anchor] = $.result);
          break;
        }
    } else if ($.tag !== "!") {
      if (o.call($.typeMap[$.kind || "fallback"], $.tag))
        Ie = $.typeMap[$.kind || "fallback"][$.tag];
      else
        for (Ie = null, Y = $.typeMap.multi[$.kind || "fallback"], at = 0, Vt = Y.length; at < Vt; at += 1)
          if ($.tag.slice(0, Y[at].tag.length) === Y[at].tag) {
            Ie = Y[at];
            break;
          }
      Ie || ve($, "unknown tag !<" + $.tag + ">"), $.result !== null && Ie.kind !== $.kind && ve($, "unacceptable node kind for !<" + $.tag + '> tag; it should be "' + Ie.kind + '", not "' + $.kind + '"'), Ie.resolve($.result, $.tag) ? ($.result = Ie.construct($.result, $.tag), $.anchor !== null && ($.anchorMap[$.anchor] = $.result)) : ve($, "cannot resolve a node with !<" + $.tag + "> explicit tag");
    }
    return $.listener !== null && $.listener("close", $), $.tag !== null || $.anchor !== null || st;
  }
  function Pe($) {
    var K = $.position, me, Te, ke, De = !1, Fe;
    for ($.version = null, $.checkLineBreaks = $.legacy, $.tagMap = /* @__PURE__ */ Object.create(null), $.anchorMap = /* @__PURE__ */ Object.create(null); (Fe = $.input.charCodeAt($.position)) !== 0 && (W($, !0, -1), Fe = $.input.charCodeAt($.position), !($.lineIndent > 0 || Fe !== 37)); ) {
      for (De = !0, Fe = $.input.charCodeAt(++$.position), me = $.position; Fe !== 0 && !R(Fe); )
        Fe = $.input.charCodeAt(++$.position);
      for (Te = $.input.slice(me, $.position), ke = [], Te.length < 1 && ve($, "directive name must not be less than one character in length"); Fe !== 0; ) {
        for (; O(Fe); )
          Fe = $.input.charCodeAt(++$.position);
        if (Fe === 35) {
          do
            Fe = $.input.charCodeAt(++$.position);
          while (Fe !== 0 && !_(Fe));
          break;
        }
        if (_(Fe)) break;
        for (me = $.position; Fe !== 0 && !R(Fe); )
          Fe = $.input.charCodeAt(++$.position);
        ke.push($.input.slice(me, $.position));
      }
      Fe !== 0 && J($), o.call(ce, Te) ? ce[Te]($, Te, ke) : $e($, 'unknown document directive "' + Te + '"');
    }
    if (W($, !0, -1), $.lineIndent === 0 && $.input.charCodeAt($.position) === 45 && $.input.charCodeAt($.position + 1) === 45 && $.input.charCodeAt($.position + 2) === 45 ? ($.position += 3, W($, !0, -1)) : De && ve($, "directives end mark is expected"), re($, $.lineIndent - 1, c, !1, !0), W($, !0, -1), $.checkLineBreaks && S.test($.input.slice(K, $.position)) && $e($, "non-ASCII line breaks are interpreted as content"), $.documents.push($.result), $.position === $.lineStart && q($)) {
      $.input.charCodeAt($.position) === 46 && ($.position += 3, W($, !0, -1));
      return;
    }
    if ($.position < $.length - 1)
      ve($, "end of the stream or a document separator is expected");
    else
      return;
  }
  function Oe($, K) {
    $ = String($), K = K || {}, $.length !== 0 && ($.charCodeAt($.length - 1) !== 10 && $.charCodeAt($.length - 1) !== 13 && ($ += `
`), $.charCodeAt(0) === 65279 && ($ = $.slice(1)));
    var me = new ge($, K), Te = $.indexOf("\0");
    for (Te !== -1 && (me.position = Te, ve(me, "null byte is not allowed in input")), me.input += "\0"; me.input.charCodeAt(me.position) === 32; )
      me.lineIndent += 1, me.position += 1;
    for (; me.position < me.length - 1; )
      Pe(me);
    return me.documents;
  }
  function qe($, K, me) {
    K !== null && typeof K == "object" && typeof me > "u" && (me = K, K = null);
    var Te = Oe($, me);
    if (typeof K != "function")
      return Te;
    for (var ke = 0, De = Te.length; ke < De; ke += 1)
      K(Te[ke]);
  }
  function je($, K) {
    var me = Oe($, K);
    if (me.length !== 0) {
      if (me.length === 1)
        return me[0];
      throw new t("expected a single document in the stream, but found more");
    }
  }
  return bg.loadAll = qe, bg.load = je, bg;
}
var Z0 = {}, W_;
function $F() {
  if (W_) return Z0;
  W_ = 1;
  var e = Oh(), t = kh(), r = _x(), n = Object.prototype.toString, o = Object.prototype.hasOwnProperty, a = 65279, i = 9, u = 10, c = 13, d = 32, m = 33, g = 34, v = 35, S = 37, k = 38, b = 39, x = 42, A = 44, _ = 45, O = 58, R = 61, C = 62, T = 63, j = 64, D = 91, V = 93, U = 96, ne = 123, H = 124, ae = 125, ge = {};
  ge[0] = "\\0", ge[7] = "\\a", ge[8] = "\\b", ge[9] = "\\t", ge[10] = "\\n", ge[11] = "\\v", ge[12] = "\\f", ge[13] = "\\r", ge[27] = "\\e", ge[34] = '\\"', ge[92] = "\\\\", ge[133] = "\\N", ge[160] = "\\_", ge[8232] = "\\L", ge[8233] = "\\P";
  var fe = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ], ve = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
  function $e(Y, Ie) {
    var Le, Me, ze, He, rt, Ye, Ze;
    if (Ie === null) return {};
    for (Le = {}, Me = Object.keys(Ie), ze = 0, He = Me.length; ze < He; ze += 1)
      rt = Me[ze], Ye = String(Ie[rt]), rt.slice(0, 2) === "!!" && (rt = "tag:yaml.org,2002:" + rt.slice(2)), Ze = Y.compiledTypeMap.fallback[rt], Ze && o.call(Ze.styleAliases, Ye) && (Ye = Ze.styleAliases[Ye]), Le[rt] = Ye;
    return Le;
  }
  function ce(Y) {
    var Ie, Le, Me;
    if (Ie = Y.toString(16).toUpperCase(), Y <= 255)
      Le = "x", Me = 2;
    else if (Y <= 65535)
      Le = "u", Me = 4;
    else if (Y <= 4294967295)
      Le = "U", Me = 8;
    else
      throw new t("code point within a string may not be greater than 0xFFFFFFFF");
    return "\\" + Le + e.repeat("0", Me - Ie.length) + Ie;
  }
  var se = 1, te = 2;
  function F(Y) {
    this.schema = Y.schema || r, this.indent = Math.max(1, Y.indent || 2), this.noArrayIndent = Y.noArrayIndent || !1, this.skipInvalid = Y.skipInvalid || !1, this.flowLevel = e.isNothing(Y.flowLevel) ? -1 : Y.flowLevel, this.styleMap = $e(this.schema, Y.styles || null), this.sortKeys = Y.sortKeys || !1, this.lineWidth = Y.lineWidth || 80, this.noRefs = Y.noRefs || !1, this.noCompatMode = Y.noCompatMode || !1, this.condenseFlow = Y.condenseFlow || !1, this.quotingType = Y.quotingType === '"' ? te : se, this.forceQuotes = Y.forceQuotes || !1, this.replacer = typeof Y.replacer == "function" ? Y.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
  }
  function J(Y, Ie) {
    for (var Le = e.repeat(" ", Ie), Me = 0, ze = -1, He = "", rt, Ye = Y.length; Me < Ye; )
      ze = Y.indexOf(`
`, Me), ze === -1 ? (rt = Y.slice(Me), Me = Ye) : (rt = Y.slice(Me, ze + 1), Me = ze + 1), rt.length && rt !== `
` && (He += Le), He += rt;
    return He;
  }
  function W(Y, Ie) {
    return `
` + e.repeat(" ", Y.indent * Ie);
  }
  function q(Y, Ie) {
    var Le, Me, ze;
    for (Le = 0, Me = Y.implicitTypes.length; Le < Me; Le += 1)
      if (ze = Y.implicitTypes[Le], ze.resolve(Ie))
        return !0;
    return !1;
  }
  function X(Y) {
    return Y === d || Y === i;
  }
  function Q(Y) {
    return 32 <= Y && Y <= 126 || 161 <= Y && Y <= 55295 && Y !== 8232 && Y !== 8233 || 57344 <= Y && Y <= 65533 && Y !== a || 65536 <= Y && Y <= 1114111;
  }
  function ye(Y) {
    return Q(Y) && Y !== a && Y !== c && Y !== u;
  }
  function Se(Y, Ie, Le) {
    var Me = ye(Y), ze = Me && !X(Y);
    return (
      // ns-plain-safe
      (Le ? (
        // c = flow-in
        Me
      ) : Me && Y !== A && Y !== D && Y !== V && Y !== ne && Y !== ae) && Y !== v && !(Ie === O && !ze) || ye(Ie) && !X(Ie) && Y === v || Ie === O && ze
    );
  }
  function Ne(Y) {
    return Q(Y) && Y !== a && !X(Y) && Y !== _ && Y !== T && Y !== O && Y !== A && Y !== D && Y !== V && Y !== ne && Y !== ae && Y !== v && Y !== k && Y !== x && Y !== m && Y !== H && Y !== R && Y !== C && Y !== b && Y !== g && Y !== S && Y !== j && Y !== U;
  }
  function N(Y) {
    return !X(Y) && Y !== O;
  }
  function B(Y, Ie) {
    var Le = Y.charCodeAt(Ie), Me;
    return Le >= 55296 && Le <= 56319 && Ie + 1 < Y.length && (Me = Y.charCodeAt(Ie + 1), Me >= 56320 && Me <= 57343) ? (Le - 55296) * 1024 + Me - 56320 + 65536 : Le;
  }
  function oe(Y) {
    var Ie = /^\n* /;
    return Ie.test(Y);
  }
  var ie = 1, he = 2, Z = 3, re = 4, Pe = 5;
  function Oe(Y, Ie, Le, Me, ze, He, rt, Ye) {
    var Ze, Ge = 0, bt = null, kt = !1, Tt = !1, It = Me !== -1, Xr = -1, er = Ne(B(Y, 0)) && N(B(Y, Y.length - 1));
    if (Ie || rt)
      for (Ze = 0; Ze < Y.length; Ge >= 65536 ? Ze += 2 : Ze++) {
        if (Ge = B(Y, Ze), !Q(Ge))
          return Pe;
        er = er && Se(Ge, bt, Ye), bt = Ge;
      }
    else {
      for (Ze = 0; Ze < Y.length; Ge >= 65536 ? Ze += 2 : Ze++) {
        if (Ge = B(Y, Ze), Ge === u)
          kt = !0, It && (Tt = Tt || // Foldable line = too long, and not more-indented.
          Ze - Xr - 1 > Me && Y[Xr + 1] !== " ", Xr = Ze);
        else if (!Q(Ge))
          return Pe;
        er = er && Se(Ge, bt, Ye), bt = Ge;
      }
      Tt = Tt || It && Ze - Xr - 1 > Me && Y[Xr + 1] !== " ";
    }
    return !kt && !Tt ? er && !rt && !ze(Y) ? ie : He === te ? Pe : he : Le > 9 && oe(Y) ? Pe : rt ? He === te ? Pe : he : Tt ? re : Z;
  }
  function qe(Y, Ie, Le, Me, ze) {
    Y.dump = function() {
      if (Ie.length === 0)
        return Y.quotingType === te ? '""' : "''";
      if (!Y.noCompatMode && (fe.indexOf(Ie) !== -1 || ve.test(Ie)))
        return Y.quotingType === te ? '"' + Ie + '"' : "'" + Ie + "'";
      var He = Y.indent * Math.max(1, Le), rt = Y.lineWidth === -1 ? -1 : Math.max(Math.min(Y.lineWidth, 40), Y.lineWidth - He), Ye = Me || Y.flowLevel > -1 && Le >= Y.flowLevel;
      function Ze(Ge) {
        return q(Y, Ge);
      }
      switch (Oe(
        Ie,
        Ye,
        Y.indent,
        rt,
        Ze,
        Y.quotingType,
        Y.forceQuotes && !Me,
        ze
      )) {
        case ie:
          return Ie;
        case he:
          return "'" + Ie.replace(/'/g, "''") + "'";
        case Z:
          return "|" + je(Ie, Y.indent) + $(J(Ie, He));
        case re:
          return ">" + je(Ie, Y.indent) + $(J(K(Ie, rt), He));
        case Pe:
          return '"' + Te(Ie) + '"';
        default:
          throw new t("impossible error: invalid scalar style");
      }
    }();
  }
  function je(Y, Ie) {
    var Le = oe(Y) ? String(Ie) : "", Me = Y[Y.length - 1] === `
`, ze = Me && (Y[Y.length - 2] === `
` || Y === `
`), He = ze ? "+" : Me ? "" : "-";
    return Le + He + `
`;
  }
  function $(Y) {
    return Y[Y.length - 1] === `
` ? Y.slice(0, -1) : Y;
  }
  function K(Y, Ie) {
    for (var Le = /(\n+)([^\n]*)/g, Me = function() {
      var Ge = Y.indexOf(`
`);
      return Ge = Ge !== -1 ? Ge : Y.length, Le.lastIndex = Ge, me(Y.slice(0, Ge), Ie);
    }(), ze = Y[0] === `
` || Y[0] === " ", He, rt; rt = Le.exec(Y); ) {
      var Ye = rt[1], Ze = rt[2];
      He = Ze[0] === " ", Me += Ye + (!ze && !He && Ze !== "" ? `
` : "") + me(Ze, Ie), ze = He;
    }
    return Me;
  }
  function me(Y, Ie) {
    if (Y === "" || Y[0] === " ") return Y;
    for (var Le = / [^ ]/g, Me, ze = 0, He, rt = 0, Ye = 0, Ze = ""; Me = Le.exec(Y); )
      Ye = Me.index, Ye - ze > Ie && (He = rt > ze ? rt : Ye, Ze += `
` + Y.slice(ze, He), ze = He + 1), rt = Ye;
    return Ze += `
`, Y.length - ze > Ie && rt > ze ? Ze += Y.slice(ze, rt) + `
` + Y.slice(rt + 1) : Ze += Y.slice(ze), Ze.slice(1);
  }
  function Te(Y) {
    for (var Ie = "", Le = 0, Me, ze = 0; ze < Y.length; Le >= 65536 ? ze += 2 : ze++)
      Le = B(Y, ze), Me = ge[Le], !Me && Q(Le) ? (Ie += Y[ze], Le >= 65536 && (Ie += Y[ze + 1])) : Ie += Me || ce(Le);
    return Ie;
  }
  function ke(Y, Ie, Le) {
    var Me = "", ze = Y.tag, He, rt, Ye;
    for (He = 0, rt = Le.length; He < rt; He += 1)
      Ye = Le[He], Y.replacer && (Ye = Y.replacer.call(Le, String(He), Ye)), (mt(Y, Ie, Ye, !1, !1) || typeof Ye > "u" && mt(Y, Ie, null, !1, !1)) && (Me !== "" && (Me += "," + (Y.condenseFlow ? "" : " ")), Me += Y.dump);
    Y.tag = ze, Y.dump = "[" + Me + "]";
  }
  function De(Y, Ie, Le, Me) {
    var ze = "", He = Y.tag, rt, Ye, Ze;
    for (rt = 0, Ye = Le.length; rt < Ye; rt += 1)
      Ze = Le[rt], Y.replacer && (Ze = Y.replacer.call(Le, String(rt), Ze)), (mt(Y, Ie + 1, Ze, !0, !0, !1, !0) || typeof Ze > "u" && mt(Y, Ie + 1, null, !0, !0, !1, !0)) && ((!Me || ze !== "") && (ze += W(Y, Ie)), Y.dump && u === Y.dump.charCodeAt(0) ? ze += "-" : ze += "- ", ze += Y.dump);
    Y.tag = He, Y.dump = ze || "[]";
  }
  function Fe(Y, Ie, Le) {
    var Me = "", ze = Y.tag, He = Object.keys(Le), rt, Ye, Ze, Ge, bt;
    for (rt = 0, Ye = He.length; rt < Ye; rt += 1)
      bt = "", Me !== "" && (bt += ", "), Y.condenseFlow && (bt += '"'), Ze = He[rt], Ge = Le[Ze], Y.replacer && (Ge = Y.replacer.call(Le, Ze, Ge)), mt(Y, Ie, Ze, !1, !1) && (Y.dump.length > 1024 && (bt += "? "), bt += Y.dump + (Y.condenseFlow ? '"' : "") + ":" + (Y.condenseFlow ? "" : " "), mt(Y, Ie, Ge, !1, !1) && (bt += Y.dump, Me += bt));
    Y.tag = ze, Y.dump = "{" + Me + "}";
  }
  function Xe(Y, Ie, Le, Me) {
    var ze = "", He = Y.tag, rt = Object.keys(Le), Ye, Ze, Ge, bt, kt, Tt;
    if (Y.sortKeys === !0)
      rt.sort();
    else if (typeof Y.sortKeys == "function")
      rt.sort(Y.sortKeys);
    else if (Y.sortKeys)
      throw new t("sortKeys must be a boolean or a function");
    for (Ye = 0, Ze = rt.length; Ye < Ze; Ye += 1)
      Tt = "", (!Me || ze !== "") && (Tt += W(Y, Ie)), Ge = rt[Ye], bt = Le[Ge], Y.replacer && (bt = Y.replacer.call(Le, Ge, bt)), mt(Y, Ie + 1, Ge, !0, !0, !0) && (kt = Y.tag !== null && Y.tag !== "?" || Y.dump && Y.dump.length > 1024, kt && (Y.dump && u === Y.dump.charCodeAt(0) ? Tt += "?" : Tt += "? "), Tt += Y.dump, kt && (Tt += W(Y, Ie)), mt(Y, Ie + 1, bt, !0, kt) && (Y.dump && u === Y.dump.charCodeAt(0) ? Tt += ":" : Tt += ": ", Tt += Y.dump, ze += Tt));
    Y.tag = He, Y.dump = ze || "{}";
  }
  function ct(Y, Ie, Le) {
    var Me, ze, He, rt, Ye, Ze;
    for (ze = Le ? Y.explicitTypes : Y.implicitTypes, He = 0, rt = ze.length; He < rt; He += 1)
      if (Ye = ze[He], (Ye.instanceOf || Ye.predicate) && (!Ye.instanceOf || typeof Ie == "object" && Ie instanceof Ye.instanceOf) && (!Ye.predicate || Ye.predicate(Ie))) {
        if (Le ? Ye.multi && Ye.representName ? Y.tag = Ye.representName(Ie) : Y.tag = Ye.tag : Y.tag = "?", Ye.represent) {
          if (Ze = Y.styleMap[Ye.tag] || Ye.defaultStyle, n.call(Ye.represent) === "[object Function]")
            Me = Ye.represent(Ie, Ze);
          else if (o.call(Ye.represent, Ze))
            Me = Ye.represent[Ze](Ie, Ze);
          else
            throw new t("!<" + Ye.tag + '> tag resolver accepts not "' + Ze + '" style');
          Y.dump = Me;
        }
        return !0;
      }
    return !1;
  }
  function mt(Y, Ie, Le, Me, ze, He, rt) {
    Y.tag = null, Y.dump = Le, ct(Y, Le, !1) || ct(Y, Le, !0);
    var Ye = n.call(Y.dump), Ze = Me, Ge;
    Me && (Me = Y.flowLevel < 0 || Y.flowLevel > Ie);
    var bt = Ye === "[object Object]" || Ye === "[object Array]", kt, Tt;
    if (bt && (kt = Y.duplicates.indexOf(Le), Tt = kt !== -1), (Y.tag !== null && Y.tag !== "?" || Tt || Y.indent !== 2 && Ie > 0) && (ze = !1), Tt && Y.usedDuplicates[kt])
      Y.dump = "*ref_" + kt;
    else {
      if (bt && Tt && !Y.usedDuplicates[kt] && (Y.usedDuplicates[kt] = !0), Ye === "[object Object]")
        Me && Object.keys(Y.dump).length !== 0 ? (Xe(Y, Ie, Y.dump, ze), Tt && (Y.dump = "&ref_" + kt + Y.dump)) : (Fe(Y, Ie, Y.dump), Tt && (Y.dump = "&ref_" + kt + " " + Y.dump));
      else if (Ye === "[object Array]")
        Me && Y.dump.length !== 0 ? (Y.noArrayIndent && !rt && Ie > 0 ? De(Y, Ie - 1, Y.dump, ze) : De(Y, Ie, Y.dump, ze), Tt && (Y.dump = "&ref_" + kt + Y.dump)) : (ke(Y, Ie, Y.dump), Tt && (Y.dump = "&ref_" + kt + " " + Y.dump));
      else if (Ye === "[object String]")
        Y.tag !== "?" && qe(Y, Y.dump, Ie, He, Ze);
      else {
        if (Ye === "[object Undefined]")
          return !1;
        if (Y.skipInvalid) return !1;
        throw new t("unacceptable kind of an object to dump " + Ye);
      }
      Y.tag !== null && Y.tag !== "?" && (Ge = encodeURI(
        Y.tag[0] === "!" ? Y.tag.slice(1) : Y.tag
      ).replace(/!/g, "%21"), Y.tag[0] === "!" ? Ge = "!" + Ge : Ge.slice(0, 18) === "tag:yaml.org,2002:" ? Ge = "!!" + Ge.slice(18) : Ge = "!<" + Ge + ">", Y.dump = Ge + " " + Y.dump);
    }
    return !0;
  }
  function st(Y, Ie) {
    var Le = [], Me = [], ze, He;
    for (at(Y, Le, Me), ze = 0, He = Me.length; ze < He; ze += 1)
      Ie.duplicates.push(Le[Me[ze]]);
    Ie.usedDuplicates = new Array(He);
  }
  function at(Y, Ie, Le) {
    var Me, ze, He;
    if (Y !== null && typeof Y == "object")
      if (ze = Ie.indexOf(Y), ze !== -1)
        Le.indexOf(ze) === -1 && Le.push(ze);
      else if (Ie.push(Y), Array.isArray(Y))
        for (ze = 0, He = Y.length; ze < He; ze += 1)
          at(Y[ze], Ie, Le);
      else
        for (Me = Object.keys(Y), ze = 0, He = Me.length; ze < He; ze += 1)
          at(Y[Me[ze]], Ie, Le);
  }
  function Vt(Y, Ie) {
    Ie = Ie || {};
    var Le = new F(Ie);
    Le.noRefs || st(Y, Le);
    var Me = Y;
    return Le.replacer && (Me = Le.replacer.call({ "": Me }, "", Me)), mt(Le, 0, Me, !0, !0) ? Le.dump + `
` : "";
  }
  return Z0.dump = Vt, Z0;
}
var K_;
function RF() {
  if (K_) return vn;
  K_ = 1;
  var e = CF(), t = $F();
  function r(n, o) {
    return function() {
      throw new Error("Function yaml." + n + " is removed in js-yaml 4. Use yaml." + o + " instead, which is now safe by default.");
    };
  }
  return vn.Type = Rn(), vn.Schema = mC(), vn.FAILSAFE_SCHEMA = bC(), vn.JSON_SCHEMA = EC(), vn.CORE_SCHEMA = OC(), vn.DEFAULT_SCHEMA = _x(), vn.load = e.load, vn.loadAll = e.loadAll, vn.dump = t.dump, vn.YAMLException = kh(), vn.types = {
    binary: PC(),
    float: _C(),
    map: vC(),
    null: wC(),
    pairs: CC(),
    set: $C(),
    timestamp: kC(),
    bool: SC(),
    int: xC(),
    merge: AC(),
    omap: TC(),
    seq: yC(),
    str: gC()
  }, vn.safeLoad = r("safeLoad", "load"), vn.safeLoadAll = r("safeLoadAll", "loadAll"), vn.safeDump = r("safeDump", "dump"), vn;
}
var Q_;
function xS() {
  if (Q_) return yu;
  Q_ = 1, Object.defineProperty(yu, "__esModule", { value: !0 }), yu.stringifyYaml = yu.parseYaml = void 0;
  const e = RF(), t = e.JSON_SCHEMA.extend({
    implicit: [e.types.merge],
    explicit: [e.types.binary, e.types.omap, e.types.pairs, e.types.set]
  }), r = (o, a) => (0, e.load)(o, { schema: t, ...a });
  yu.parseYaml = r;
  const n = (o, a) => (0, e.dump)(o, a);
  return yu.stringifyYaml = n, yu;
}
var ew = {}, Y_;
function Ex() {
  return Y_ || (Y_ = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.env = e.isBrowser = void 0, e.isBrowser = typeof window < "u" || typeof process > "u" || (process == null ? void 0 : process.platform) === "browser", e.env = e.isBrowser ? {} : process.env || {};
  }(ew)), ew;
}
var tw = {}, G_;
function RC() {
  return G_ || (G_ = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.logger = e.colorize = e.colorOptions = void 0;
    const t = oh, r = Ex(), n = vi();
    e.colorOptions = t.options, e.colorize = new Proxy(t, {
      get(a, i) {
        return r.isBrowser ? n.identity : a[i];
      }
    });
    class o {
      stderr(i) {
        return process.stderr.write(i);
      }
      info(i) {
        return r.isBrowser ? console.log(i) : this.stderr(i);
      }
      warn(i) {
        return r.isBrowser ? console.warn(i) : this.stderr(e.colorize.yellow(i));
      }
      error(i) {
        return r.isBrowser ? console.error(i) : this.stderr(e.colorize.red(i));
      }
    }
    e.logger = new o();
  }(tw)), tw;
}
function IF(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var By = { exports: {} }, NF = By.exports, X_;
function jF() {
  return X_ || (X_ = 1, function(e, t) {
    (function(r, n) {
      typeof IF == "function" ? e.exports = n() : r.pluralize = n();
    })(NF, function() {
      var r = [], n = [], o = {}, a = {}, i = {};
      function u(b) {
        return typeof b == "string" ? new RegExp("^" + b + "$", "i") : b;
      }
      function c(b, x) {
        return b === x ? x : b === b.toLowerCase() ? x.toLowerCase() : b === b.toUpperCase() ? x.toUpperCase() : b[0] === b[0].toUpperCase() ? x.charAt(0).toUpperCase() + x.substr(1).toLowerCase() : x.toLowerCase();
      }
      function d(b, x) {
        return b.replace(/\$(\d{1,2})/g, function(A, _) {
          return x[_] || "";
        });
      }
      function m(b, x) {
        return b.replace(x[0], function(A, _) {
          var O = d(x[1], arguments);
          return c(A === "" ? b[_ - 1] : A, O);
        });
      }
      function g(b, x, A) {
        if (!b.length || o.hasOwnProperty(b))
          return x;
        for (var _ = A.length; _--; ) {
          var O = A[_];
          if (O[0].test(x)) return m(x, O);
        }
        return x;
      }
      function v(b, x, A) {
        return function(_) {
          var O = _.toLowerCase();
          return x.hasOwnProperty(O) ? c(_, O) : b.hasOwnProperty(O) ? c(_, b[O]) : g(O, _, A);
        };
      }
      function S(b, x, A, _) {
        return function(O) {
          var R = O.toLowerCase();
          return x.hasOwnProperty(R) ? !0 : b.hasOwnProperty(R) ? !1 : g(R, R, A) === R;
        };
      }
      function k(b, x, A) {
        var _ = x === 1 ? k.singular(b) : k.plural(b);
        return (A ? x + " " : "") + _;
      }
      return k.plural = v(
        i,
        a,
        r
      ), k.isPlural = S(
        i,
        a,
        r
      ), k.singular = v(
        a,
        i,
        n
      ), k.isSingular = S(
        a,
        i,
        n
      ), k.addPluralRule = function(b, x) {
        r.push([u(b), x]);
      }, k.addSingularRule = function(b, x) {
        n.push([u(b), x]);
      }, k.addUncountableRule = function(b) {
        if (typeof b == "string") {
          o[b.toLowerCase()] = !0;
          return;
        }
        k.addPluralRule(b, "$0"), k.addSingularRule(b, "$0");
      }, k.addIrregularRule = function(b, x) {
        x = x.toLowerCase(), b = b.toLowerCase(), i[b] = x, a[x] = b;
      }, [
        // Pronouns.
        ["I", "we"],
        ["me", "us"],
        ["he", "they"],
        ["she", "they"],
        ["them", "them"],
        ["myself", "ourselves"],
        ["yourself", "yourselves"],
        ["itself", "themselves"],
        ["herself", "themselves"],
        ["himself", "themselves"],
        ["themself", "themselves"],
        ["is", "are"],
        ["was", "were"],
        ["has", "have"],
        ["this", "these"],
        ["that", "those"],
        // Words ending in with a consonant and `o`.
        ["echo", "echoes"],
        ["dingo", "dingoes"],
        ["volcano", "volcanoes"],
        ["tornado", "tornadoes"],
        ["torpedo", "torpedoes"],
        // Ends with `us`.
        ["genus", "genera"],
        ["viscus", "viscera"],
        // Ends with `ma`.
        ["stigma", "stigmata"],
        ["stoma", "stomata"],
        ["dogma", "dogmata"],
        ["lemma", "lemmata"],
        ["schema", "schemata"],
        ["anathema", "anathemata"],
        // Other irregular rules.
        ["ox", "oxen"],
        ["axe", "axes"],
        ["die", "dice"],
        ["yes", "yeses"],
        ["foot", "feet"],
        ["eave", "eaves"],
        ["goose", "geese"],
        ["tooth", "teeth"],
        ["quiz", "quizzes"],
        ["human", "humans"],
        ["proof", "proofs"],
        ["carve", "carves"],
        ["valve", "valves"],
        ["looey", "looies"],
        ["thief", "thieves"],
        ["groove", "grooves"],
        ["pickaxe", "pickaxes"],
        ["passerby", "passersby"]
      ].forEach(function(b) {
        return k.addIrregularRule(b[0], b[1]);
      }), [
        [/s?$/i, "s"],
        [/[^\u0000-\u007F]$/i, "$0"],
        [/([^aeiou]ese)$/i, "$1"],
        [/(ax|test)is$/i, "$1es"],
        [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"],
        [/(e[mn]u)s?$/i, "$1s"],
        [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
        [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
        [/(seraph|cherub)(?:im)?$/i, "$1im"],
        [/(her|at|gr)o$/i, "$1oes"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
        [/sis$/i, "ses"],
        [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
        [/([^aeiouy]|qu)y$/i, "$1ies"],
        [/([^ch][ieo][ln])ey$/i, "$1ies"],
        [/(x|ch|ss|sh|zz)$/i, "$1es"],
        [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
        [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"],
        [/(pe)(?:rson|ople)$/i, "$1ople"],
        [/(child)(?:ren)?$/i, "$1ren"],
        [/eaux$/i, "$0"],
        [/m[ae]n$/i, "men"],
        ["thou", "you"]
      ].forEach(function(b) {
        return k.addPluralRule(b[0], b[1]);
      }), [
        [/s$/i, ""],
        [/(ss)$/i, "$1"],
        [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
        [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
        [/ies$/i, "y"],
        [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
        [/\b(mon|smil)ies$/i, "$1ey"],
        [/\b((?:tit)?m|l)ice$/i, "$1ouse"],
        [/(seraph|cherub)im$/i, "$1"],
        [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, "$1"],
        [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, "$1sis"],
        [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"],
        [/(test)(?:is|es)$/i, "$1is"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
        [/(alumn|alg|vertebr)ae$/i, "$1a"],
        [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
        [/(matr|append)ices$/i, "$1ix"],
        [/(pe)(rson|ople)$/i, "$1rson"],
        [/(child)ren$/i, "$1"],
        [/(eau)x?$/i, "$1"],
        [/men$/i, "man"]
      ].forEach(function(b) {
        return k.addSingularRule(b[0], b[1]);
      }), [
        // Singular words with no plurals.
        "adulthood",
        "advice",
        "agenda",
        "aid",
        "aircraft",
        "alcohol",
        "ammo",
        "analytics",
        "anime",
        "athletics",
        "audio",
        "bison",
        "blood",
        "bream",
        "buffalo",
        "butter",
        "carp",
        "cash",
        "chassis",
        "chess",
        "clothing",
        "cod",
        "commerce",
        "cooperation",
        "corps",
        "debris",
        "diabetes",
        "digestion",
        "elk",
        "energy",
        "equipment",
        "excretion",
        "expertise",
        "firmware",
        "flounder",
        "fun",
        "gallows",
        "garbage",
        "graffiti",
        "hardware",
        "headquarters",
        "health",
        "herpes",
        "highjinks",
        "homework",
        "housework",
        "information",
        "jeans",
        "justice",
        "kudos",
        "labour",
        "literature",
        "machinery",
        "mackerel",
        "mail",
        "media",
        "mews",
        "moose",
        "music",
        "mud",
        "manga",
        "news",
        "only",
        "personnel",
        "pike",
        "plankton",
        "pliers",
        "police",
        "pollution",
        "premises",
        "rain",
        "research",
        "rice",
        "salmon",
        "scissors",
        "series",
        "sewage",
        "shambles",
        "shrimp",
        "software",
        "species",
        "staff",
        "swine",
        "tennis",
        "traffic",
        "transportation",
        "trout",
        "tuna",
        "wealth",
        "welfare",
        "whiting",
        "wildebeest",
        "wildlife",
        "you",
        /pok[eé]mon$/i,
        // Regexes.
        /[^aeiou]ese$/i,
        // "chinese", "japanese"
        /deer$/i,
        // "deer", "reindeer"
        /fish$/i,
        // "fish", "blowfish", "angelfish"
        /measles$/i,
        /o[iu]s$/i,
        // "carnivorous"
        /pox$/i,
        // "chickpox", "smallpox"
        /sheep$/i
      ].forEach(k.addUncountableRule), k;
    });
  }(By)), By.exports;
}
var J_;
function vi() {
  return J_ || (J_ = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.assignConfig = e.stringifyYaml = e.parseYaml = void 0, e.pushStack = m, e.pluralize = g, e.popStack = v, e.loadYaml = S, e.isDefined = k, e.isPlainObject = b, e.isEmptyObject = x, e.isNotEmptyObject = A, e.isEmptyArray = _, e.isNotEmptyArray = O, e.readFileFromUrl = R, e.pickObjectProps = T, e.omitObjectProps = j, e.splitCamelCaseIntoWords = D, e.validateMimeType = V, e.validateMimeTypeOAS3 = U, e.readFileAsStringSync = ne, e.yamlAndJsonSyncReader = H, e.isPathParameter = ae, e.slash = ge, e.isString = fe, e.isNotString = ve, e.assignOnlyExistingConfig = ce, e.getMatchingStatusCodeRange = se, e.isCustomRuleId = te, e.doesYamlFileExist = F, e.showWarningForDeprecatedField = J, e.showErrorForDeprecatedField = W, e.isTruthy = q, e.identity = X, e.keysOf = Q, e.pickDefined = ye, e.nextTick = Se, e.pause = Ne, e.getProxyAgent = B, e.dequal = oe;
    const t = oh, r = xx(), n = PF(), o = xS(), a = Ex(), i = RC(), u = oh, c = jF();
    var d = xS();
    Object.defineProperty(e, "parseYaml", { enumerable: !0, get: function() {
      return d.parseYaml;
    } }), Object.defineProperty(e, "stringifyYaml", { enumerable: !0, get: function() {
      return d.stringifyYaml;
    } });
    function m(ie, he) {
      return { prev: ie, value: he };
    }
    function g(ie, he, Z) {
      return ie.split(" ").map((re) => c(re, he, Z)).join(" ");
    }
    function v(ie) {
      return (ie == null ? void 0 : ie.prev) ?? null;
    }
    async function S(ie) {
      const he = await t.promises.readFile(ie, "utf-8");
      return (0, o.parseYaml)(he);
    }
    function k(ie) {
      return ie !== void 0;
    }
    function b(ie) {
      return ie !== null && typeof ie == "object" && !Array.isArray(ie);
    }
    function x(ie) {
      return b(ie) && Object.keys(ie).length === 0;
    }
    function A(ie) {
      return b(ie) && !x(ie);
    }
    function _(ie) {
      return Array.isArray(ie) && ie.length === 0;
    }
    function O(ie) {
      return !!ie && Array.isArray(ie) && !!ie.length;
    }
    async function R(ie, he) {
      const Z = {};
      for (const Pe of he.headers)
        C(ie, Pe.matches) && (Z[Pe.name] = Pe.envVariable !== void 0 ? a.env[Pe.envVariable] || "" : Pe.value);
      const re = await (he.customFetch || fetch)(ie, {
        headers: Z
      });
      if (!re.ok)
        throw new Error(`Failed to load ${ie}: ${re.status} ${re.statusText}`);
      return { body: await re.text(), mimeType: re.headers.get("content-type") };
    }
    function C(ie, he) {
      return he.match(/^https?:\/\//) || (ie = ie.replace(/^https?:\/\//, "")), n(ie, he);
    }
    function T(ie, he) {
      return Object.fromEntries(he.filter((Z) => Z in ie).map((Z) => [Z, ie[Z]]));
    }
    function j(ie, he) {
      return Object.fromEntries(Object.entries(ie).filter(([Z]) => !he.includes(Z)));
    }
    function D(ie) {
      const he = ie.split(/(?:[-._])|([A-Z][a-z]+)/).filter(q).map((re) => re.toLocaleLowerCase()), Z = ie.split(/([A-Z]{2,})/).filter((re) => re && re === re.toUpperCase()).map((re) => re.toLocaleLowerCase());
      return /* @__PURE__ */ new Set([...he, ...Z]);
    }
    function V({ type: ie, value: he }, { report: Z, location: re }, Pe) {
      const Oe = ie === "consumes" ? "request" : "response";
      if (!Pe)
        throw new Error(`Parameter "allowedValues" is not provided for "${Oe}-mime-type" rule`);
      if (he[ie])
        for (const qe of he[ie])
          Pe.includes(qe) || Z({
            message: `Mime type "${qe}" is not allowed`,
            location: re.child(he[ie].indexOf(qe)).key()
          });
    }
    function U({ type: ie, value: he }, { report: Z, location: re }, Pe) {
      const Oe = ie === "consumes" ? "request" : "response";
      if (!Pe)
        throw new Error(`Parameter "allowedValues" is not provided for "${Oe}-mime-type" rule`);
      if (he.content)
        for (const qe of Object.keys(he.content))
          Pe.includes(qe) || Z({
            message: `Mime type "${qe}" is not allowed`,
            location: re.child("content").child(qe).key()
          });
    }
    function ne(ie) {
      return t.readFileSync(ie, "utf-8");
    }
    function H(ie) {
      const he = t.readFileSync(ie, "utf-8");
      return (0, o.parseYaml)(he);
    }
    function ae(ie) {
      return ie.startsWith("{") && ie.endsWith("}");
    }
    function ge(ie) {
      return /^\\\\\?\\/.test(ie) ? ie : ie.replace(/\\/g, "/");
    }
    function fe(ie) {
      return typeof ie == "string";
    }
    function ve(ie) {
      return !fe(ie);
    }
    const $e = (ie, he) => {
      if (he)
        for (const Z of Object.keys(he))
          b(ie[Z]) && typeof he[Z] == "string" ? ie[Z].severity = he[Z] : ie[Z] = he[Z];
    };
    e.assignConfig = $e;
    function ce(ie, he) {
      if (he)
        for (const Z of Object.keys(he))
          ie.hasOwnProperty(Z) && (b(ie[Z]) && typeof he[Z] == "string" ? ie[Z].severity = he[Z] : ie[Z] = he[Z]);
    }
    function se(ie) {
      return `${ie}`.replace(/^(\d)\d\d$/, (he, Z) => `${Z}XX`);
    }
    function te(ie) {
      return ie.includes("/");
    }
    function F(ie) {
      var he;
      return ((0, r.extname)(ie) === ".yaml" || (0, r.extname)(ie) === ".yml") && ((he = t == null ? void 0 : t.hasOwnProperty) == null ? void 0 : he.call(t, "existsSync")) && t.existsSync(ie);
    }
    function J(ie, he, Z, re) {
      const Pe = re ? `Read more about this change: ${re}` : "";
      i.logger.warn(`The '${i.colorize.red(ie)}' field is deprecated. ${he ? `Use ${i.colorize.green(N(he, Z))} instead. ` : ""}${Pe}
`);
    }
    function W(ie, he, Z) {
      throw new Error(`Do not use '${ie}' field. ${he ? `Use '${N(he, Z)}' instead. ` : ""}
`);
    }
    function q(ie) {
      return !!ie;
    }
    function X(ie) {
      return ie;
    }
    function Q(ie) {
      return ie ? Object.keys(ie) : [];
    }
    function ye(ie) {
      if (!ie)
        return;
      const he = {};
      for (const Z in ie)
        ie[Z] !== void 0 && (he[Z] = ie[Z]);
      return he;
    }
    function Se() {
      return new Promise((ie) => {
        setTimeout(ie);
      });
    }
    async function Ne(ie) {
      return new Promise((he) => setTimeout(he, ie));
    }
    function N(ie, he) {
      return `${typeof he < "u" ? `${he}.` : ""}${ie}`;
    }
    function B() {
      const ie = process.env.HTTPS_PROXY || process.env.HTTP_PROXY;
      return ie ? new u.HttpsProxyAgent(ie) : void 0;
    }
    function oe(ie, he) {
      let Z, re;
      if (ie === he)
        return !0;
      if (ie && he && (Z = ie.constructor) === he.constructor) {
        if (Z === Date)
          return ie.getTime() === he.getTime();
        if (Z === RegExp)
          return ie.toString() === he.toString();
        if (Z === Array) {
          if ((re = ie.length) === he.length)
            for (; re-- && oe(ie[re], he[re]); )
              ;
          return re === -1;
        }
        if (!Z || typeof ie == "object") {
          re = 0;
          for (Z in ie)
            if (Object.prototype.hasOwnProperty.call(ie, Z) && ++re && !Object.prototype.hasOwnProperty.call(he, Z) || !(Z in he) || !oe(ie[Z], he[Z]))
              return !1;
          return Object.keys(he).length === re;
        }
      }
      return ie !== ie && he !== he;
    }
  }(P0)), P0;
}
var Z_;
function Up() {
  if (Z_) return nn;
  Z_ = 1, Object.defineProperty(nn, "__esModule", { value: !0 }), nn.Location = void 0, nn.joinPointer = t, nn.isRef = r, nn.isExternalValue = n, nn.unescapePointer = a, nn.escapePointer = i, nn.parseRef = u, nn.parsePointer = c, nn.pointerBaseName = d, nn.refBaseName = m, nn.isAbsoluteUrl = g, nn.isMappingRef = v, nn.isAnchor = S;
  const e = vi();
  function t(k, b) {
    return k === "" && (k = "#/"), k[k.length - 1] === "/" ? k + b : k + "/" + b;
  }
  function r(k) {
    return (0, e.isPlainObject)(k) && typeof k.$ref == "string";
  }
  function n(k) {
    return (0, e.isPlainObject)(k) && typeof k.externalValue == "string";
  }
  class o {
    constructor(b, x) {
      this.source = b, this.pointer = x;
    }
    child(b) {
      return new o(this.source, t(this.pointer, (Array.isArray(b) ? b : [b]).map(i).join("/")));
    }
    key() {
      return { ...this, reportOnKey: !0 };
    }
    get absolutePointer() {
      return this.source.absoluteRef + (this.pointer === "#/" ? "" : this.pointer);
    }
  }
  nn.Location = o;
  function a(k) {
    return decodeURIComponent(k.replace(/~1/g, "/").replace(/~0/g, "~"));
  }
  function i(k) {
    return typeof k == "number" ? k : k.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function u(k) {
    const [b, x = ""] = k.split("#/");
    return {
      uri: (b.endsWith("#") ? b.slice(0, -1) : b) || null,
      pointer: c(x)
    };
  }
  function c(k) {
    return k.split("/").map(a).filter(e.isTruthy);
  }
  function d(k) {
    const b = k.split("/");
    return b[b.length - 1];
  }
  function m(k) {
    const b = k.split(/[\/\\]/);
    return b[b.length - 1].replace(/\.[^.]+$/, "");
  }
  function g(k) {
    return k.startsWith("http://") || k.startsWith("https://");
  }
  function v(k) {
    return k.startsWith("#") || k.startsWith("https://") || k.startsWith("http://") || k.startsWith("./") || k.startsWith("../") || k.indexOf("/") > -1;
  }
  function S(k) {
    return /^#[A-Za-z][A-Za-z0-9\-_:.]*$/.test(k);
  }
  return nn;
}
var rw = {}, eE;
function mi() {
  return eE || (eE = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SpecExtension = void 0, e.listOf = t, e.mapOf = r, e.normalizeTypes = n, e.isNamedType = o;
    function t(a) {
      return {
        name: `${a}List`,
        properties: {},
        items: a
      };
    }
    function r(a) {
      return {
        name: `${a}Map`,
        properties: {},
        additionalProperties: () => a
      };
    }
    e.SpecExtension = {
      name: "SpecExtension",
      properties: {},
      // skip validation of additional properties for unknown extensions
      additionalProperties: { resolvable: !0 }
    };
    function n(a, i = {}) {
      const u = {};
      for (const m of Object.keys(a))
        u[m] = {
          ...a[m],
          name: m
        };
      for (const m of Object.values(u))
        c(m);
      return u.SpecExtension = e.SpecExtension, u;
      function c(m) {
        if (m.additionalProperties && (m.additionalProperties = d(m.additionalProperties)), m.items && (m.items = d(m.items)), m.properties) {
          const g = {};
          for (const [v, S] of Object.entries(m.properties))
            g[v] = d(S), i.doNotResolveExamples && S && S.isExample && (g[v] = {
              ...S,
              resolvable: !1
            });
          m.properties = g;
        }
      }
      function d(m) {
        if (typeof m == "string") {
          if (!u[m])
            throw new Error(`Unknown type name found: ${m}`);
          return u[m];
        } else return typeof m == "function" ? (g, v) => d(m(g, v)) : m && m.name ? (m = { ...m }, c(m), m) : m && m.directResolveAs ? {
          ...m,
          directResolveAs: d(m.directResolveAs)
        } : m;
      }
    }
    function o(a) {
      return typeof (a == null ? void 0 : a.name) == "string";
    }
  }(rw)), rw;
}
var tE;
function Ox() {
  if (tE) return Gn;
  tE = 1, Object.defineProperty(Gn, "__esModule", { value: !0 }), Gn.BaseResolver = Gn.YamlParseError = Gn.ResolveError = Gn.Source = void 0, Gn.makeRefId = d, Gn.makeDocumentFromString = m, Gn.resolveDocument = x;
  const e = oh, t = xx(), r = Up(), n = mi(), o = vi();
  class a {
    constructor(_, O, R) {
      this.absoluteRef = _, this.body = O, this.mimeType = R;
    }
    // pass safeLoad as argument to separate it from browser bundle
    getAst(_) {
      return this._ast === void 0 && (this._ast = _(this.body, { filename: this.absoluteRef }) ?? void 0, this._ast && this._ast.kind === 0 && // KIND.scalar = 0
      this._ast.value === "" && this._ast.startPosition !== 1 && (this._ast.startPosition = 1, this._ast.endPosition = 1)), this._ast;
    }
    getLines() {
      return this._lines === void 0 && (this._lines = this.body.split(/\r\n|[\n\r]/g)), this._lines;
    }
  }
  Gn.Source = a;
  class i extends Error {
    constructor(_) {
      super(_.message), this.originalError = _, Object.setPrototypeOf(this, i.prototype);
    }
  }
  Gn.ResolveError = i;
  const u = /\((\d+):(\d+)\)$/;
  class c extends Error {
    constructor(_, O) {
      super(_.message.split(`
`)[0]), this.originalError = _, this.source = O, Object.setPrototypeOf(this, c.prototype);
      const [, R, C] = this.message.match(u) || [];
      this.line = parseInt(R, 10), this.col = parseInt(C, 10);
    }
  }
  Gn.YamlParseError = c;
  function d(A, _) {
    return A + "::" + _;
  }
  function m(A, _) {
    const O = new a(_, A);
    try {
      return {
        source: O,
        parsed: (0, o.parseYaml)(A, { filename: _ })
      };
    } catch (R) {
      throw new c(R, O);
    }
  }
  class g {
    constructor(_ = { http: { headers: [] } }) {
      this.config = _, this.cache = /* @__PURE__ */ new Map();
    }
    getFiles() {
      return new Set(Array.from(this.cache.keys()));
    }
    resolveExternalRef(_, O) {
      return (0, r.isAbsoluteUrl)(O) ? O : _ && (0, r.isAbsoluteUrl)(_) ? new URL(O, _).href : t.resolve(_ ? t.dirname(_) : process.cwd(), O);
    }
    async loadExternalRef(_) {
      try {
        if ((0, r.isAbsoluteUrl)(_)) {
          const { body: O, mimeType: R } = await (0, o.readFileFromUrl)(_, this.config.http);
          return new a(_, O, R);
        } else {
          if (e.lstatSync(_).isDirectory())
            throw new Error(`Expected a file but received a folder at ${_}.`);
          const O = await e.promises.readFile(_, "utf-8");
          return new a(_, O.replace(/\r\n/g, `
`));
        }
      } catch (O) {
        throw O.message = O.message.replace(", lstat", ""), new i(O);
      }
    }
    parseDocument(_, O = !1) {
      var C;
      const R = _.absoluteRef.substr(_.absoluteRef.lastIndexOf("."));
      if (![".json", ".json", ".yml", ".yaml"].includes(R) && !((C = _.mimeType) != null && C.match(/(json|yaml|openapi)/)) && !O)
        return { source: _, parsed: _.body };
      try {
        return {
          source: _,
          parsed: (0, o.parseYaml)(_.body, { filename: _.absoluteRef })
        };
      } catch (T) {
        throw new c(T, _);
      }
    }
    async resolveDocument(_, O, R = !1) {
      const C = this.resolveExternalRef(_, O), T = this.cache.get(C);
      if (T)
        return T;
      const j = this.loadExternalRef(C).then((D) => this.parseDocument(D, R));
      return this.cache.set(C, j), j;
    }
  }
  Gn.BaseResolver = g;
  function v(A, _) {
    return {
      prev: A,
      node: _
    };
  }
  function S(A, _) {
    for (; A; ) {
      if (A.node === _)
        return !0;
      A = A.prev;
    }
    return !1;
  }
  const k = { name: "unknown", properties: {} }, b = { name: "scalar", properties: {} };
  async function x(A) {
    const { rootDocument: _, externalRefResolver: O, rootType: R } = A, C = /* @__PURE__ */ new Map(), T = /* @__PURE__ */ new Set(), j = [];
    V(_.parsed, _, "#/", R);
    let D;
    do
      D = await Promise.all(j);
    while (j.length !== D.length);
    return C;
    function V(U, ne, H, ae) {
      const ge = ne.source.absoluteRef, fe = /* @__PURE__ */ new Map();
      ve(U, ae, ge + H);
      function ve(ce, se, te) {
        if (typeof ce != "object" || ce === null)
          return;
        const F = `${se.name}::${te}`;
        if (T.has(F))
          return;
        T.add(F);
        const [J, W] = Object.entries(ce).find(([q]) => q === "$anchor") || [];
        if (W && fe.set(`#${W}`, ce), Array.isArray(ce)) {
          const q = se.items;
          if (q === void 0 && se !== k && se !== n.SpecExtension)
            return;
          const X = typeof q == "function";
          for (let Q = 0; Q < ce.length; Q++) {
            const ye = X ? q(ce[Q], (0, r.joinPointer)(te, Q)) : q;
            ye === void 0 && se !== k && se !== n.SpecExtension || ve(ce[Q], (0, n.isNamedType)(ye) ? ye : k, (0, r.joinPointer)(te, Q));
          }
          return;
        }
        for (const q of Object.keys(ce)) {
          let X = ce[q], Q = se.properties[q];
          Q === void 0 && (Q = se.additionalProperties), typeof Q == "function" && (Q = Q(X, q)), Q === void 0 && (Q = k), se.extensionsPrefix && q.startsWith(se.extensionsPrefix) && Q === k && (Q = n.SpecExtension), !(0, n.isNamedType)(Q) && (Q != null && Q.directResolveAs) && (Q = Q.directResolveAs, X = { $ref: X }), Q && Q.name === void 0 && Q.resolvable !== !1 && (Q = b), !(!(0, n.isNamedType)(Q) || typeof X != "object") && ve(X, Q, (0, r.joinPointer)(te, (0, r.escapePointer)(q)));
        }
        if ((0, r.isRef)(ce)) {
          const q = $e(ne, ce, {
            prev: null,
            node: ce
          }).then((X) => {
            X.resolved && V(X.node, X.document, X.nodePointer, se);
          });
          j.push(q);
        }
        if ((0, r.isExternalValue)(ce)) {
          const q = $e(ne, { $ref: ce.externalValue }, {
            prev: null,
            node: ce
          }).then((X) => {
            X.resolved && V(X.node, X.document, X.nodePointer, se);
          });
          j.push(q);
        }
      }
      async function $e(ce, se, te) {
        if (S(te.prev, se))
          throw new Error("Self-referencing circular pointer");
        if ((0, r.isAnchor)(se.$ref)) {
          await (0, o.nextTick)();
          const Ne = {
            resolved: !0,
            isRemote: !1,
            node: fe.get(se.$ref),
            document: ce,
            nodePointer: se.$ref
          }, N = d(ce.source.absoluteRef, se.$ref);
          return C.set(N, Ne), Ne;
        }
        const { uri: F, pointer: J } = (0, r.parseRef)(se.$ref), W = F !== null;
        let q;
        try {
          q = W ? await O.resolveDocument(ce.source.absoluteRef, F) : ce;
        } catch (Ne) {
          const N = {
            resolved: !1,
            isRemote: W,
            document: void 0,
            error: Ne
          }, B = d(ce.source.absoluteRef, se.$ref);
          return C.set(B, N), N;
        }
        let X = {
          resolved: !0,
          document: q,
          isRemote: W,
          node: ce.parsed,
          nodePointer: "#/"
        }, Q = q.parsed;
        const ye = J;
        for (const Ne of ye)
          if (typeof Q != "object") {
            Q = void 0;
            break;
          } else if (Q[Ne] !== void 0)
            Q = Q[Ne], X.nodePointer = (0, r.joinPointer)(X.nodePointer, (0, r.escapePointer)(Ne));
          else if ((0, r.isRef)(Q)) {
            if (X = await $e(q, Q, v(te, Q)), q = X.document || q, typeof X.node != "object") {
              Q = void 0;
              break;
            }
            Q = X.node[Ne], X.nodePointer = (0, r.joinPointer)(X.nodePointer, (0, r.escapePointer)(Ne));
          } else {
            Q = void 0;
            break;
          }
        X.node = Q, X.document = q;
        const Se = d(ce.source.absoluteRef, se.$ref);
        return X.document && (0, r.isRef)(Q) && (X = await $e(X.document, Q, v(te, Q))), C.set(Se, X), { ...X };
      }
    }
  }
  return Gn;
}
var wg = {}, rE;
function LF() {
  if (rE) return wg;
  rE = 1, Object.defineProperty(wg, "__esModule", { value: !0 }), wg.normalizeVisitors = r;
  const e = mi(), t = {
    Root: "DefinitionRoot",
    ServerVariablesMap: "ServerVariableMap",
    Paths: ["PathMap", "PathsMap"],
    CallbacksMap: "CallbackMap",
    MediaTypesMap: "MediaTypeMap",
    ExamplesMap: "ExampleMap",
    EncodingMap: "EncodingsMap",
    HeadersMap: "HeaderMap",
    LinksMap: "LinkMap",
    OAuth2Flows: "SecuritySchemeFlows",
    Responses: "ResponsesMap"
  };
  function r(n, o) {
    const a = {};
    a.any = {
      enter: [],
      leave: []
    };
    for (const d of Object.keys(o))
      a[d] = {
        enter: [],
        leave: []
      };
    a.ref = {
      enter: [],
      leave: []
    };
    for (const { ruleId: d, severity: m, message: g, visitor: v } of n)
      c({ ruleId: d, severity: m, message: g }, v, null);
    for (const d of Object.keys(a))
      a[d].enter.sort((m, g) => g.depth - m.depth), a[d].leave.sort((m, g) => m.depth - g.depth);
    return a;
    function i(d, m, g, v, S = []) {
      if (S.includes(m))
        return;
      S = [...S, m];
      const k = /* @__PURE__ */ new Set();
      for (const x of Object.values(m.properties)) {
        if (x === g) {
          b(d, S);
          continue;
        }
        typeof x == "object" && x !== null && x.name && k.add(x);
      }
      m.additionalProperties && typeof m.additionalProperties != "function" && (m.additionalProperties === g ? b(d, S) : m.additionalProperties.name !== void 0 && k.add(m.additionalProperties)), m.items && typeof m.items != "function" && (m.items === g ? b(d, S) : m.items.name !== void 0 && k.add(m.items)), m.extensionsPrefix && k.add(e.SpecExtension);
      for (const x of Array.from(k.values()))
        i(d, x, g, v, S);
      function b(x, A) {
        for (const _ of A.slice(1))
          a[_.name] = a[_.name] || {
            enter: [],
            leave: []
          }, a[_.name].enter.push({
            ...x,
            visit: () => {
            },
            depth: 0,
            context: {
              isSkippedLevel: !0,
              seen: /* @__PURE__ */ new Set(),
              parent: v
            }
          });
      }
    }
    function u(d, m) {
      if (Array.isArray(m)) {
        const g = m.find((v) => d[v]) || void 0;
        return g && d[g];
      }
      return d[m];
    }
    function c(d, m, g, v = 0) {
      const S = Object.keys(o);
      if (v === 0)
        S.push("any"), S.push("ref");
      else {
        if (m.any)
          throw new Error("any() is allowed only on top level");
        if (m.ref)
          throw new Error("ref() is allowed only on top level");
      }
      for (const k of S) {
        const b = m[k] || u(m, t[k]), x = a[k];
        if (!b)
          continue;
        let A, _, O;
        const R = typeof b == "object";
        if (k === "ref" && R && b.skip)
          throw new Error("ref() visitor does not support skip");
        typeof b == "function" ? A = b : R && (A = b.enter, _ = b.leave, O = b.skip);
        const C = {
          activatedOn: null,
          type: o[k],
          parent: g,
          isSkippedLevel: !1
        };
        if (typeof b == "object" && c(d, b, C, v + 1), g && i(d, g.type, o[k], g), A || R) {
          if (A && typeof A != "function")
            throw new Error("DEV: should be function");
          x.enter.push({
            ...d,
            visit: A || (() => {
            }),
            skip: O,
            depth: v,
            context: C
          });
        }
        if (_) {
          if (typeof _ != "function")
            throw new Error("DEV: should be function");
          x.leave.push({
            ...d,
            visit: _,
            depth: v,
            context: C
          });
        }
      }
    }
  }
  return wg;
}
var Sg = {}, nE;
function MF() {
  if (nE) return Sg;
  nE = 1, Object.defineProperty(Sg, "__esModule", { value: !0 }), Sg.walkDocument = i;
  const e = Up(), t = vi(), r = Ox(), n = mi();
  function o(u) {
    var d;
    const c = {};
    for (; u.parent; )
      c[u.parent.type.name] = (d = u.parent.activatedOn) == null ? void 0 : d.value.node, u = u.parent;
    return c;
  }
  function a(u) {
    var d, m;
    const c = {};
    for (; u.parent; )
      (d = u.parent.activatedOn) != null && d.value.location && (c[u.parent.type.name] = (m = u.parent.activatedOn) == null ? void 0 : m.value.location), u = u.parent;
    return c;
  }
  function i(u) {
    const { document: c, rootType: d, normalizedVisitors: m, resolvedRefMap: g, ctx: v } = u, S = {}, k = /* @__PURE__ */ new Set();
    b(c.parsed, d, new e.Location(c.source, "#/"), void 0, "");
    function b(x, A, _, O, R) {
      var fe, ve, $e, ce, se, te, F, J, W, q;
      const C = (X, Q = j.source.absoluteRef) => {
        if (!(0, e.isRef)(X))
          return { location: _, node: X };
        const ye = (0, r.makeRefId)(Q, X.$ref), Se = g.get(ye);
        if (!Se)
          return {
            location: void 0,
            node: void 0
          };
        const { resolved: Ne, node: N, document: B, nodePointer: oe, error: ie } = Se;
        return { location: Ne ? new e.Location(B.source, oe) : ie instanceof r.YamlParseError ? new e.Location(ie.source, "") : void 0, node: N, error: ie };
      }, T = _;
      let j = _;
      const { node: D, location: V, error: U } = C(x), ne = /* @__PURE__ */ new Set();
      if ((0, e.isRef)(x)) {
        const X = m.ref.enter;
        for (const { visit: Q, ruleId: ye, severity: Se, message: Ne, context: N } of X) {
          ne.add(N);
          const B = ae.bind(void 0, ye, Se, Ne);
          Q(x, {
            report: B,
            resolve: C,
            rawNode: x,
            rawLocation: T,
            location: _,
            type: A,
            parent: O,
            key: R,
            parentLocations: {},
            oasVersion: v.oasVersion,
            getVisitorData: ge.bind(void 0, ye)
          }, { node: D, location: V, error: U }), V != null && V.source.absoluteRef && v.refTypes && v.refTypes.set(V == null ? void 0 : V.source.absoluteRef, A);
        }
      }
      if (D !== void 0 && V && A.name !== "scalar") {
        j = V;
        const X = (ve = (fe = S[A.name]) == null ? void 0 : fe.has) == null ? void 0 : ve.call(fe, D);
        let Q = !1;
        const Se = m.any.enter.concat((($e = m[A.name]) == null ? void 0 : $e.enter) || []), Ne = [];
        for (const { context: oe, visit: ie, skip: he, ruleId: Z, severity: re, message: Pe } of Se) {
          if (k.has(`${j.absolutePointer}${j.pointer}`))
            break;
          if (oe.isSkippedLevel)
            oe.parent.activatedOn && !oe.parent.activatedOn.value.nextLevelTypeActivated && !oe.seen.has(x) && (oe.seen.add(x), Q = !0, Ne.push(oe));
          else if (oe.parent && // if nested
          oe.parent.activatedOn && ((ce = oe.activatedOn) == null ? void 0 : ce.value.withParentNode) !== oe.parent.activatedOn.value.node && // do not enter if visited by parent children (it works thanks because deeper visitors are sorted before)
          ((se = oe.parent.activatedOn.value.nextLevelTypeActivated) == null ? void 0 : se.value) !== A || !oe.parent && !X) {
            Ne.push(oe);
            const Oe = {
              node: D,
              location: V,
              nextLevelTypeActivated: null,
              withParentNode: (F = (te = oe.parent) == null ? void 0 : te.activatedOn) == null ? void 0 : F.value.node,
              skipped: (((W = (J = oe.parent) == null ? void 0 : J.activatedOn) == null ? void 0 : W.value.skipped) || (he == null ? void 0 : he(D, R, {
                location: _,
                rawLocation: T,
                resolve: C,
                rawNode: x
              }))) ?? !1
            };
            oe.activatedOn = (0, t.pushStack)(oe.activatedOn, Oe);
            let qe = oe.parent;
            for (; qe; )
              qe.activatedOn.value.nextLevelTypeActivated = (0, t.pushStack)(qe.activatedOn.value.nextLevelTypeActivated, A), qe = qe.parent;
            Oe.skipped || (Q = !0, ne.add(oe), H(ie, D, x, oe, Z, re, Pe));
          }
        }
        if (Q || !X) {
          if (S[A.name] = S[A.name] || /* @__PURE__ */ new Set(), S[A.name].add(D), Array.isArray(D)) {
            const oe = A.items;
            if (oe !== void 0) {
              const ie = typeof oe == "function";
              for (let he = 0; he < D.length; he++) {
                const Z = ie ? oe(D[he], V.child([he]).absolutePointer) : oe;
                (0, n.isNamedType)(Z) && b(D[he], Z, V.child([he]), D, he);
              }
            }
          } else if (typeof D == "object" && D !== null) {
            const oe = Object.keys(A.properties);
            A.additionalProperties ? oe.push(...Object.keys(D).filter((ie) => !oe.includes(ie))) : A.extensionsPrefix && oe.push(...Object.keys(D).filter((ie) => ie.startsWith(A.extensionsPrefix))), (0, e.isRef)(x) && oe.push(...Object.keys(x).filter((ie) => ie !== "$ref" && !oe.includes(ie)));
            for (const ie of oe) {
              let he = D[ie], Z = V;
              he === void 0 && (he = x[ie], Z = _);
              let re = A.properties[ie];
              re === void 0 && (re = A.additionalProperties), typeof re == "function" && (re = re(he, ie)), re === void 0 && A.extensionsPrefix && ie.startsWith(A.extensionsPrefix) && (re = n.SpecExtension), !(0, n.isNamedType)(re) && (re != null && re.directResolveAs) && (re = re.directResolveAs, he = { $ref: he }), re && re.name === void 0 && re.resolvable !== !1 && (re = { name: "scalar", properties: {} }), !(!(0, n.isNamedType)(re) || re.name === "scalar" && !(0, e.isRef)(he)) && b(he, re, Z.child([ie]), D, ie);
            }
          }
        }
        const N = m.any.leave, B = (((q = m[A.name]) == null ? void 0 : q.leave) || []).concat(N);
        for (const oe of Ne.reverse())
          if (oe.isSkippedLevel)
            oe.seen.delete(D);
          else if (oe.activatedOn = (0, t.popStack)(oe.activatedOn), oe.parent) {
            let ie = oe.parent;
            for (; ie; )
              ie.activatedOn.value.nextLevelTypeActivated = (0, t.popStack)(ie.activatedOn.value.nextLevelTypeActivated), ie = ie.parent;
          }
        for (const { context: oe, visit: ie, ruleId: he, severity: Z, message: re } of B)
          !oe.isSkippedLevel && ne.has(oe) && H(ie, D, x, oe, he, Z, re);
      }
      if (j = _, (0, e.isRef)(x)) {
        const X = m.ref.leave;
        for (const { visit: Q, ruleId: ye, severity: Se, context: Ne, message: N } of X)
          if (ne.has(Ne)) {
            const B = ae.bind(void 0, ye, Se, N);
            Q(x, {
              report: B,
              resolve: C,
              rawNode: x,
              rawLocation: T,
              location: _,
              type: A,
              parent: O,
              key: R,
              parentLocations: {},
              oasVersion: v.oasVersion,
              getVisitorData: ge.bind(void 0, ye)
            }, { node: D, location: V, error: U });
          }
      }
      function H(X, Q, ye, Se, Ne, N, B) {
        const oe = ae.bind(void 0, Ne, N, B);
        X(Q, {
          report: oe,
          resolve: C,
          rawNode: ye,
          location: j,
          rawLocation: T,
          type: A,
          parent: O,
          key: R,
          parentLocations: a(Se),
          oasVersion: v.oasVersion,
          ignoreNextVisitorsOnNode: () => {
            k.add(`${j.absolutePointer}${j.pointer}`);
          },
          getVisitorData: ge.bind(void 0, Ne)
        }, o(Se), Se);
      }
      function ae(X, Q, ye, Se) {
        const N = (Se.location ? Array.isArray(Se.location) ? Se.location : [Se.location] : [{ ...j, reportOnKey: !1 }]).map((oe) => ({
          ...j,
          reportOnKey: !1,
          ...oe
        })), B = Se.forceSeverity || Q;
        B !== "off" && v.problems.push({
          ruleId: Se.ruleId || X,
          severity: B,
          ...Se,
          message: ye ? ye.replace("{{message}}", Se.message) : Se.message,
          suggest: Se.suggest || [],
          location: N
        });
      }
      function ge(X) {
        return v.visitorsData[X] = v.visitorsData[X] || {}, v.visitorsData[X];
      }
    }
  }
  return Sg;
}
var po = {}, Ed = {}, iE;
function DF() {
  if (iE) return Ed;
  iE = 1, Object.defineProperty(Ed, "__esModule", { value: !0 }), Ed.Oas2Types = void 0;
  const e = mi(), t = /^[0-9][0-9Xx]{2}$/, r = {
    properties: {
      swagger: { type: "string" },
      info: "Info",
      host: { type: "string" },
      basePath: { type: "string" },
      schemes: { type: "array", items: { type: "string" } },
      consumes: { type: "array", items: { type: "string" } },
      produces: { type: "array", items: { type: "string" } },
      paths: "Paths",
      definitions: "NamedSchemas",
      parameters: "NamedParameters",
      responses: "NamedResponses",
      securityDefinitions: "NamedSecuritySchemes",
      security: "SecurityRequirementList",
      tags: "TagList",
      externalDocs: "ExternalDocs",
      "x-servers": "XServerList",
      "x-tagGroups": "TagGroups",
      "x-ignoredHeaderParameters": { type: "array", items: { type: "string" } }
    },
    required: ["swagger", "paths", "info"],
    extensionsPrefix: "x-"
  }, n = {
    properties: {
      title: { type: "string" },
      description: { type: "string" },
      termsOfService: { type: "string" },
      contact: "Contact",
      license: "License",
      version: { type: "string" },
      "x-logo": "Logo"
    },
    required: ["title", "version"],
    extensionsPrefix: "x-"
  }, o = {
    properties: {
      url: { type: "string" },
      altText: { type: "string" },
      backgroundColor: { type: "string" },
      href: { type: "string" }
    },
    extensionsPrefix: "x-"
  }, a = {
    properties: {
      name: { type: "string" },
      url: { type: "string" },
      email: { type: "string" }
    },
    extensionsPrefix: "x-"
  }, i = {
    properties: {
      name: { type: "string" },
      url: { type: "string" }
    },
    required: ["name"],
    extensionsPrefix: "x-"
  }, u = {
    properties: {},
    additionalProperties: (H, ae) => ae.startsWith("/") ? "PathItem" : void 0
  }, c = {
    properties: {
      $ref: { type: "string" },
      // TODO: verify special $ref handling for Path Item
      parameters: "ParameterList",
      get: "Operation",
      put: "Operation",
      post: "Operation",
      delete: "Operation",
      options: "Operation",
      head: "Operation",
      patch: "Operation"
    },
    extensionsPrefix: "x-"
  }, d = {
    properties: {
      tags: { type: "array", items: { type: "string" } },
      summary: { type: "string" },
      description: { type: "string" },
      externalDocs: "ExternalDocs",
      operationId: { type: "string" },
      consumes: { type: "array", items: { type: "string" } },
      produces: { type: "array", items: { type: "string" } },
      parameters: "ParameterList",
      responses: "Responses",
      schemes: { type: "array", items: { type: "string" } },
      deprecated: { type: "boolean" },
      security: "SecurityRequirementList",
      "x-codeSamples": "XCodeSampleList",
      "x-code-samples": "XCodeSampleList",
      // deprecated
      "x-hideTryItPanel": { type: "boolean" }
    },
    required: ["responses"],
    extensionsPrefix: "x-"
  }, m = {
    properties: {
      lang: { type: "string" },
      label: { type: "string" },
      source: { type: "string" }
    }
  }, g = {
    properties: {
      url: { type: "string" },
      description: { type: "string" }
    },
    required: ["url"]
  }, v = {
    properties: {
      description: { type: "string" },
      url: { type: "string" }
    },
    required: ["url"],
    extensionsPrefix: "x-"
  }, S = {
    properties: {
      name: { type: "string" },
      in: { type: "string", enum: ["query", "header", "path", "formData", "body"] },
      description: { type: "string" },
      required: { type: "boolean" },
      schema: "Schema",
      type: { type: "string", enum: ["string", "number", "integer", "boolean", "array", "file"] },
      format: { type: "string" },
      allowEmptyValue: { type: "boolean" },
      items: "ParameterItems",
      collectionFormat: { type: "string", enum: ["csv", "ssv", "tsv", "pipes", "multi"] },
      default: null,
      maximum: { type: "integer" },
      exclusiveMaximum: { type: "boolean" },
      minimum: { type: "integer" },
      exclusiveMinimum: { type: "boolean" },
      maxLength: { type: "integer" },
      minLength: { type: "integer" },
      pattern: { type: "string" },
      maxItems: { type: "integer" },
      minItems: { type: "integer" },
      uniqueItems: { type: "boolean" },
      enum: { type: "array" },
      multipleOf: { type: "number" },
      "x-example": {},
      // any
      "x-examples": "ExamplesMap"
    },
    required(H) {
      return !H || !H.in ? ["name", "in"] : H.in === "body" ? ["name", "in", "schema"] : H.type === "array" ? ["name", "in", "type", "items"] : ["name", "in", "type"];
    },
    extensionsPrefix: "x-"
  }, k = {
    properties: {
      type: { type: "string", enum: ["string", "number", "integer", "boolean", "array"] },
      format: { type: "string" },
      items: "ParameterItems",
      collectionFormat: { type: "string", enum: ["csv", "ssv", "tsv", "pipes", "multi"] },
      default: null,
      maximum: { type: "integer" },
      exclusiveMaximum: { type: "boolean" },
      minimum: { type: "integer" },
      exclusiveMinimum: { type: "boolean" },
      maxLength: { type: "integer" },
      minLength: { type: "integer" },
      pattern: { type: "string" },
      maxItems: { type: "integer" },
      minItems: { type: "integer" },
      uniqueItems: { type: "boolean" },
      enum: { type: "array" },
      multipleOf: { type: "number" }
    },
    required(H) {
      return H && H.type === "array" ? ["type", "items"] : ["type"];
    },
    extensionsPrefix: "x-"
  }, b = {
    properties: {
      default: "Response"
    },
    additionalProperties: (H, ae) => t.test(ae) ? "Response" : void 0
  }, x = {
    properties: {
      description: { type: "string" },
      schema: "Schema",
      headers: (0, e.mapOf)("Header"),
      examples: "Examples",
      "x-summary": { type: "string" }
    },
    required: ["description"],
    extensionsPrefix: "x-"
  }, A = {
    properties: {},
    additionalProperties: { isExample: !0 }
  }, _ = {
    properties: {
      description: { type: "string" },
      type: { type: "string", enum: ["string", "number", "integer", "boolean", "array"] },
      format: { type: "string" },
      items: "ParameterItems",
      collectionFormat: { type: "string", enum: ["csv", "ssv", "tsv", "pipes", "multi"] },
      default: null,
      maximum: { type: "integer" },
      exclusiveMaximum: { type: "boolean" },
      minimum: { type: "integer" },
      exclusiveMinimum: { type: "boolean" },
      maxLength: { type: "integer" },
      minLength: { type: "integer" },
      pattern: { type: "string" },
      maxItems: { type: "integer" },
      minItems: { type: "integer" },
      uniqueItems: { type: "boolean" },
      enum: { type: "array" },
      multipleOf: { type: "number" }
    },
    required(H) {
      return H && H.type === "array" ? ["type", "items"] : ["type"];
    },
    extensionsPrefix: "x-"
  }, O = {
    properties: {
      name: { type: "string" },
      description: { type: "string" },
      externalDocs: "ExternalDocs",
      "x-traitTag": { type: "boolean" },
      "x-displayName": { type: "string" }
    },
    required: ["name"],
    extensionsPrefix: "x-"
  }, R = {
    properties: {
      name: { type: "string" },
      tags: { type: "array", items: { type: "string" } }
    }
  }, C = {
    properties: {
      format: { type: "string" },
      title: { type: "string" },
      description: { type: "string" },
      default: null,
      multipleOf: { type: "number" },
      maximum: { type: "number" },
      minimum: { type: "number" },
      exclusiveMaximum: { type: "boolean" },
      exclusiveMinimum: { type: "boolean" },
      maxLength: { type: "number" },
      minLength: { type: "number" },
      pattern: { type: "string" },
      maxItems: { type: "number" },
      minItems: { type: "number" },
      uniqueItems: { type: "boolean" },
      maxProperties: { type: "number" },
      minProperties: { type: "number" },
      required: { type: "array", items: { type: "string" } },
      enum: { type: "array" },
      type: {
        type: "string",
        enum: ["object", "array", "string", "number", "integer", "boolean", "null"]
      },
      items: (H) => Array.isArray(H) ? (0, e.listOf)("Schema") : "Schema",
      allOf: (0, e.listOf)("Schema"),
      properties: "SchemaProperties",
      additionalProperties: (H) => typeof H == "boolean" ? { type: "boolean" } : "Schema",
      discriminator: { type: "string" },
      readOnly: { type: "boolean" },
      xml: "Xml",
      externalDocs: "ExternalDocs",
      example: { isExample: !0 },
      "x-tags": { type: "array", items: { type: "string" } },
      "x-nullable": { type: "boolean" },
      "x-extendedDiscriminator": { type: "string" },
      "x-additionalPropertiesName": { type: "string" },
      "x-explicitMappingOnly": { type: "boolean" },
      "x-enumDescriptions": "EnumDescriptions"
    },
    extensionsPrefix: "x-"
  }, T = {
    properties: {},
    additionalProperties: { type: "string" }
  }, j = {
    properties: {},
    additionalProperties: "Schema"
  }, D = {
    properties: {
      name: { type: "string" },
      namespace: { type: "string" },
      prefix: { type: "string" },
      attribute: { type: "boolean" },
      wrapped: { type: "boolean" }
    },
    extensionsPrefix: "x-"
  }, V = {
    properties: {
      type: { enum: ["basic", "apiKey", "oauth2"] },
      description: { type: "string" },
      name: { type: "string" },
      in: { type: "string", enum: ["query", "header"] },
      flow: { enum: ["implicit", "password", "application", "accessCode"] },
      authorizationUrl: { type: "string" },
      tokenUrl: { type: "string" },
      scopes: { type: "object", additionalProperties: { type: "string" } },
      "x-defaultClientId": { type: "string" }
    },
    required(H) {
      switch (H == null ? void 0 : H.type) {
        case "apiKey":
          return ["type", "name", "in"];
        case "oauth2":
          switch (H == null ? void 0 : H.flow) {
            case "implicit":
              return ["type", "flow", "authorizationUrl", "scopes"];
            case "accessCode":
              return ["type", "flow", "authorizationUrl", "tokenUrl", "scopes"];
            case "application":
            case "password":
              return ["type", "flow", "tokenUrl", "scopes"];
            default:
              return ["type", "flow", "scopes"];
          }
        default:
          return ["type"];
      }
    },
    allowed(H) {
      switch (H == null ? void 0 : H.type) {
        case "basic":
          return ["type", "description"];
        case "apiKey":
          return ["type", "name", "in", "description"];
        case "oauth2":
          switch (H == null ? void 0 : H.flow) {
            case "implicit":
              return ["type", "flow", "authorizationUrl", "description", "scopes"];
            case "accessCode":
              return ["type", "flow", "authorizationUrl", "tokenUrl", "description", "scopes"];
            case "application":
            case "password":
              return ["type", "flow", "tokenUrl", "description", "scopes"];
            default:
              return ["type", "flow", "tokenUrl", "authorizationUrl", "description", "scopes"];
          }
        default:
          return ["type", "description"];
      }
    },
    extensionsPrefix: "x-"
  }, U = {
    properties: {},
    additionalProperties: { type: "array", items: { type: "string" } }
  }, ne = {
    properties: {
      value: { isExample: !0 },
      summary: { type: "string" },
      description: { type: "string" },
      externalValue: { type: "string" }
    },
    extensionsPrefix: "x-"
  };
  return Ed.Oas2Types = {
    Root: r,
    Tag: O,
    TagList: (0, e.listOf)("Tag"),
    TagGroups: (0, e.listOf)("TagGroup"),
    TagGroup: R,
    ExternalDocs: v,
    Example: ne,
    ExamplesMap: (0, e.mapOf)("Example"),
    EnumDescriptions: T,
    SecurityRequirement: U,
    SecurityRequirementList: (0, e.listOf)("SecurityRequirement"),
    Info: n,
    Contact: a,
    License: i,
    Logo: o,
    Paths: u,
    PathItem: c,
    Parameter: S,
    ParameterItems: k,
    ParameterList: (0, e.listOf)("Parameter"),
    Operation: d,
    Examples: A,
    Header: _,
    Responses: b,
    Response: x,
    Schema: C,
    Xml: D,
    SchemaProperties: j,
    NamedSchemas: (0, e.mapOf)("Schema"),
    NamedResponses: (0, e.mapOf)("Response"),
    NamedParameters: (0, e.mapOf)("Parameter"),
    NamedSecuritySchemes: (0, e.mapOf)("SecurityScheme"),
    SecurityScheme: V,
    XCodeSample: m,
    XCodeSampleList: (0, e.listOf)("XCodeSample"),
    XServerList: (0, e.listOf)("XServer"),
    XServer: g
  }, Ed;
}
var nw = {}, sE;
function kx() {
  return sE || (sE = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Oas3Types = e.Discriminator = e.DiscriminatorMapping = e.Xml = e.ExternalDocs = void 0;
    const t = mi(), r = Up(), n = /^[0-9][0-9Xx]{2}$/, o = {
      properties: {
        openapi: null,
        info: "Info",
        servers: "ServerList",
        security: "SecurityRequirementList",
        tags: "TagList",
        externalDocs: "ExternalDocs",
        paths: "Paths",
        components: "Components",
        "x-webhooks": "WebhooksMap",
        "x-tagGroups": "TagGroups",
        "x-ignoredHeaderParameters": { type: "array", items: { type: "string" } }
      },
      required: ["openapi", "paths", "info"],
      extensionsPrefix: "x-"
    }, a = {
      properties: {
        name: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs",
        "x-traitTag": { type: "boolean" },
        "x-displayName": { type: "string" }
      },
      required: ["name"],
      extensionsPrefix: "x-"
    }, i = {
      properties: {
        name: { type: "string" },
        tags: { type: "array", items: { type: "string" } }
      },
      extensionsPrefix: "x-"
    };
    e.ExternalDocs = {
      properties: {
        description: { type: "string" },
        url: { type: "string" }
      },
      required: ["url"],
      extensionsPrefix: "x-"
    };
    const u = {
      properties: {
        url: { type: "string" },
        description: { type: "string" },
        variables: "ServerVariablesMap"
      },
      required: ["url"],
      extensionsPrefix: "x-"
    }, c = {
      properties: {
        enum: {
          type: "array",
          items: { type: "string" }
        },
        default: { type: "string" },
        description: { type: "string" }
      },
      required: ["default"],
      extensionsPrefix: "x-"
    }, d = {
      properties: {},
      additionalProperties: { type: "array", items: { type: "string" } }
    }, m = {
      properties: {
        title: { type: "string" },
        version: { type: "string" },
        description: { type: "string" },
        termsOfService: { type: "string" },
        contact: "Contact",
        license: "License",
        "x-logo": "Logo"
      },
      required: ["title", "version"],
      extensionsPrefix: "x-"
    }, g = {
      properties: {
        url: { type: "string" },
        altText: { type: "string" },
        backgroundColor: { type: "string" },
        href: { type: "string" }
      }
    }, v = {
      properties: {
        name: { type: "string" },
        url: { type: "string" },
        email: { type: "string" }
      },
      extensionsPrefix: "x-"
    }, S = {
      properties: {
        name: { type: "string" },
        url: { type: "string" }
      },
      required: ["name"],
      extensionsPrefix: "x-"
    }, k = {
      properties: {},
      additionalProperties: (q, X) => X.startsWith("/") ? "PathItem" : void 0
    }, b = {
      properties: {},
      additionalProperties: () => "PathItem"
    }, x = {
      properties: {
        $ref: { type: "string" },
        // TODO: verify special $ref handling for Path Item
        servers: "ServerList",
        parameters: "ParameterList",
        summary: { type: "string" },
        description: { type: "string" },
        get: "Operation",
        put: "Operation",
        post: "Operation",
        delete: "Operation",
        options: "Operation",
        head: "Operation",
        patch: "Operation",
        trace: "Operation"
      },
      extensionsPrefix: "x-"
    }, A = {
      properties: {
        name: { type: "string" },
        in: { enum: ["query", "header", "path", "cookie"] },
        description: { type: "string" },
        required: { type: "boolean" },
        deprecated: { type: "boolean" },
        allowEmptyValue: { type: "boolean" },
        style: {
          enum: ["form", "simple", "label", "matrix", "spaceDelimited", "pipeDelimited", "deepObject"]
        },
        explode: { type: "boolean" },
        allowReserved: { type: "boolean" },
        schema: "Schema",
        example: { isExample: !0 },
        examples: "ExamplesMap",
        content: "MediaTypesMap"
      },
      required: ["name", "in"],
      requiredOneOf: ["schema", "content"],
      extensionsPrefix: "x-"
    }, _ = {
      properties: {
        tags: {
          type: "array",
          items: { type: "string" }
        },
        summary: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs",
        operationId: { type: "string" },
        parameters: "ParameterList",
        security: "SecurityRequirementList",
        servers: "ServerList",
        requestBody: "RequestBody",
        responses: "Responses",
        deprecated: { type: "boolean" },
        callbacks: "CallbacksMap",
        "x-codeSamples": "XCodeSampleList",
        "x-code-samples": "XCodeSampleList",
        // deprecated
        "x-hideTryItPanel": { type: "boolean" }
      },
      required: ["responses"],
      extensionsPrefix: "x-"
    }, O = {
      properties: {
        lang: { type: "string" },
        label: { type: "string" },
        source: { type: "string" }
      }
    }, R = {
      properties: {
        description: { type: "string" },
        required: { type: "boolean" },
        content: "MediaTypesMap"
      },
      required: ["content"],
      extensionsPrefix: "x-"
    }, C = {
      properties: {},
      additionalProperties: "MediaType"
    }, T = {
      properties: {
        schema: "Schema",
        example: { isExample: !0 },
        examples: "ExamplesMap",
        encoding: "EncodingMap"
      },
      extensionsPrefix: "x-"
    }, j = {
      properties: {
        value: { isExample: !0 },
        summary: { type: "string" },
        description: { type: "string" },
        externalValue: { type: "string" }
      },
      extensionsPrefix: "x-"
    }, D = {
      properties: {
        contentType: { type: "string" },
        headers: "HeadersMap",
        style: {
          enum: ["form", "simple", "label", "matrix", "spaceDelimited", "pipeDelimited", "deepObject"]
        },
        explode: { type: "boolean" },
        allowReserved: { type: "boolean" }
      },
      extensionsPrefix: "x-"
    }, V = {
      properties: {},
      additionalProperties: { type: "string" }
    }, U = {
      properties: {
        description: { type: "string" },
        required: { type: "boolean" },
        deprecated: { type: "boolean" },
        allowEmptyValue: { type: "boolean" },
        style: {
          enum: ["form", "simple", "label", "matrix", "spaceDelimited", "pipeDelimited", "deepObject"]
        },
        explode: { type: "boolean" },
        allowReserved: { type: "boolean" },
        schema: "Schema",
        example: { isExample: !0 },
        examples: "ExamplesMap",
        content: "MediaTypesMap"
      },
      requiredOneOf: ["schema", "content"],
      extensionsPrefix: "x-"
    }, ne = {
      properties: { default: "Response" },
      additionalProperties: (q, X) => n.test(X) ? "Response" : void 0
    }, H = {
      properties: {
        description: { type: "string" },
        headers: "HeadersMap",
        content: "MediaTypesMap",
        links: "LinksMap",
        "x-summary": { type: "string" }
      },
      required: ["description"],
      extensionsPrefix: "x-"
    }, ae = {
      properties: {
        operationRef: { type: "string" },
        operationId: { type: "string" },
        parameters: null,
        // TODO: figure out how to describe/validate this
        requestBody: null,
        // TODO: figure out how to describe/validate this
        description: { type: "string" },
        server: "Server"
      },
      extensionsPrefix: "x-"
    }, ge = {
      properties: {
        externalDocs: "ExternalDocs",
        discriminator: "Discriminator",
        title: { type: "string" },
        multipleOf: { type: "number", minimum: 0 },
        maximum: { type: "number" },
        minimum: { type: "number" },
        exclusiveMaximum: { type: "boolean" },
        exclusiveMinimum: { type: "boolean" },
        maxLength: { type: "integer", minimum: 0 },
        minLength: { type: "integer", minimum: 0 },
        pattern: { type: "string" },
        maxItems: { type: "integer", minimum: 0 },
        minItems: { type: "integer", minimum: 0 },
        uniqueItems: { type: "boolean" },
        maxProperties: { type: "integer", minimum: 0 },
        minProperties: { type: "integer", minimum: 0 },
        required: { type: "array", items: { type: "string" } },
        enum: { type: "array" },
        type: {
          enum: ["object", "array", "string", "number", "integer", "boolean"]
        },
        allOf: (0, t.listOf)("Schema"),
        anyOf: (0, t.listOf)("Schema"),
        oneOf: (0, t.listOf)("Schema"),
        not: "Schema",
        properties: "SchemaProperties",
        items: (q) => Array.isArray(q) ? (0, t.listOf)("Schema") : "Schema",
        additionalProperties: (q) => typeof q == "boolean" ? { type: "boolean" } : "Schema",
        description: { type: "string" },
        format: { type: "string" },
        default: null,
        nullable: { type: "boolean" },
        readOnly: { type: "boolean" },
        writeOnly: { type: "boolean" },
        xml: "Xml",
        example: { isExample: !0 },
        deprecated: { type: "boolean" },
        "x-tags": { type: "array", items: { type: "string" } },
        "x-additionalPropertiesName": { type: "string" },
        "x-explicitMappingOnly": { type: "boolean" }
      },
      extensionsPrefix: "x-"
    };
    e.Xml = {
      properties: {
        name: { type: "string" },
        namespace: { type: "string" },
        prefix: { type: "string" },
        attribute: { type: "boolean" },
        wrapped: { type: "boolean" }
      },
      extensionsPrefix: "x-"
    };
    const fe = {
      properties: {},
      additionalProperties: "Schema"
    };
    e.DiscriminatorMapping = {
      properties: {},
      additionalProperties: (q) => (0, r.isMappingRef)(q) ? { type: "string", directResolveAs: "Schema" } : { type: "string" }
    }, e.Discriminator = {
      properties: {
        propertyName: { type: "string" },
        mapping: "DiscriminatorMapping"
      },
      required: ["propertyName"],
      extensionsPrefix: "x-"
    };
    const ve = {
      properties: {
        parameters: "NamedParameters",
        schemas: "NamedSchemas",
        responses: "NamedResponses",
        examples: "NamedExamples",
        requestBodies: "NamedRequestBodies",
        headers: "NamedHeaders",
        securitySchemes: "NamedSecuritySchemes",
        links: "NamedLinks",
        callbacks: "NamedCallbacks"
      },
      extensionsPrefix: "x-"
    }, $e = {
      properties: {
        refreshUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        authorizationUrl: { type: "string" }
      },
      required: ["authorizationUrl", "scopes"],
      extensionsPrefix: "x-"
    }, ce = {
      properties: {
        refreshUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        tokenUrl: { type: "string" }
      },
      required: ["tokenUrl", "scopes"],
      extensionsPrefix: "x-"
    }, se = {
      properties: {
        refreshUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        tokenUrl: { type: "string" }
      },
      required: ["tokenUrl", "scopes"],
      extensionsPrefix: "x-"
    }, te = {
      properties: {
        refreshUrl: { type: "string" },
        authorizationUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        tokenUrl: { type: "string" },
        "x-usePkce": (q) => typeof q == "boolean" ? { type: "boolean" } : "XUsePkce"
      },
      required: ["authorizationUrl", "tokenUrl", "scopes"],
      extensionsPrefix: "x-"
    }, F = {
      properties: {
        implicit: "ImplicitFlow",
        password: "PasswordFlow",
        clientCredentials: "ClientCredentials",
        authorizationCode: "AuthorizationCode"
      },
      extensionsPrefix: "x-"
    }, J = {
      properties: {
        type: { enum: ["apiKey", "http", "oauth2", "openIdConnect"] },
        description: { type: "string" },
        name: { type: "string" },
        in: { type: "string", enum: ["query", "header", "cookie"] },
        scheme: { type: "string" },
        bearerFormat: { type: "string" },
        flows: "OAuth2Flows",
        openIdConnectUrl: { type: "string" },
        "x-defaultClientId": { type: "string" }
      },
      required(q) {
        switch (q == null ? void 0 : q.type) {
          case "apiKey":
            return ["type", "name", "in"];
          case "http":
            return ["type", "scheme"];
          case "oauth2":
            return ["type", "flows"];
          case "openIdConnect":
            return ["type", "openIdConnectUrl"];
          default:
            return ["type"];
        }
      },
      allowed(q) {
        switch (q == null ? void 0 : q.type) {
          case "apiKey":
            return ["type", "name", "in", "description"];
          case "http":
            return ["type", "scheme", "bearerFormat", "description"];
          case "oauth2":
            return ["type", "flows", "description"];
          case "openIdConnect":
            return ["type", "openIdConnectUrl", "description"];
          default:
            return ["type", "description"];
        }
      },
      extensionsPrefix: "x-"
    }, W = {
      properties: {
        disableManualConfiguration: { type: "boolean" },
        hideClientSecretInput: { type: "boolean" }
      }
    };
    e.Oas3Types = {
      Root: o,
      Tag: a,
      TagList: (0, t.listOf)("Tag"),
      TagGroups: (0, t.listOf)("TagGroup"),
      TagGroup: i,
      ExternalDocs: e.ExternalDocs,
      Server: u,
      ServerList: (0, t.listOf)("Server"),
      ServerVariable: c,
      ServerVariablesMap: (0, t.mapOf)("ServerVariable"),
      SecurityRequirement: d,
      SecurityRequirementList: (0, t.listOf)("SecurityRequirement"),
      Info: m,
      Contact: v,
      License: S,
      Paths: k,
      PathItem: x,
      Parameter: A,
      ParameterList: (0, t.listOf)("Parameter"),
      Operation: _,
      Callback: (0, t.mapOf)("PathItem"),
      CallbacksMap: (0, t.mapOf)("Callback"),
      RequestBody: R,
      MediaTypesMap: C,
      MediaType: T,
      Example: j,
      ExamplesMap: (0, t.mapOf)("Example"),
      Encoding: D,
      EncodingMap: (0, t.mapOf)("Encoding"),
      EnumDescriptions: V,
      Header: U,
      HeadersMap: (0, t.mapOf)("Header"),
      Responses: ne,
      Response: H,
      Link: ae,
      Logo: g,
      Schema: ge,
      Xml: e.Xml,
      SchemaProperties: fe,
      DiscriminatorMapping: e.DiscriminatorMapping,
      Discriminator: e.Discriminator,
      Components: ve,
      LinksMap: (0, t.mapOf)("Link"),
      NamedSchemas: (0, t.mapOf)("Schema"),
      NamedResponses: (0, t.mapOf)("Response"),
      NamedParameters: (0, t.mapOf)("Parameter"),
      NamedExamples: (0, t.mapOf)("Example"),
      NamedRequestBodies: (0, t.mapOf)("RequestBody"),
      NamedHeaders: (0, t.mapOf)("Header"),
      NamedSecuritySchemes: (0, t.mapOf)("SecurityScheme"),
      NamedLinks: (0, t.mapOf)("Link"),
      NamedCallbacks: (0, t.mapOf)("Callback"),
      ImplicitFlow: $e,
      PasswordFlow: ce,
      ClientCredentials: se,
      AuthorizationCode: te,
      OAuth2Flows: F,
      SecurityScheme: J,
      XCodeSample: O,
      XCodeSampleList: (0, t.listOf)("XCodeSample"),
      XUsePkce: W,
      WebhooksMap: b
    };
  }(nw)), nw;
}
var iw = {}, oE;
function IC() {
  return oE || (oE = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Oas3_1Types = e.DependentRequired = e.SchemaProperties = e.Schema = void 0;
    const t = mi(), r = kx(), n = {
      properties: {
        openapi: null,
        info: "Info",
        servers: "ServerList",
        security: "SecurityRequirementList",
        tags: "TagList",
        externalDocs: "ExternalDocs",
        paths: "Paths",
        webhooks: "WebhooksMap",
        components: "Components",
        jsonSchemaDialect: { type: "string" }
      },
      required: ["openapi", "info"],
      requiredOneOf: ["paths", "components", "webhooks"],
      extensionsPrefix: "x-"
    }, o = {
      properties: {
        name: { type: "string" },
        url: { type: "string" },
        identifier: { type: "string" }
      },
      required: ["name"],
      extensionsPrefix: "x-"
    }, a = {
      properties: {
        title: { type: "string" },
        version: { type: "string" },
        description: { type: "string" },
        termsOfService: { type: "string" },
        summary: { type: "string" },
        contact: "Contact",
        license: "License",
        "x-logo": "Logo"
      },
      required: ["title", "version"],
      extensionsPrefix: "x-"
    }, i = {
      properties: {
        parameters: "NamedParameters",
        schemas: "NamedSchemas",
        responses: "NamedResponses",
        examples: "NamedExamples",
        requestBodies: "NamedRequestBodies",
        headers: "NamedHeaders",
        securitySchemes: "NamedSecuritySchemes",
        links: "NamedLinks",
        callbacks: "NamedCallbacks",
        pathItems: "NamedPathItems"
      },
      extensionsPrefix: "x-"
    }, u = {
      properties: {
        tags: {
          type: "array",
          items: { type: "string" }
        },
        summary: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs",
        operationId: { type: "string" },
        parameters: "ParameterList",
        security: "SecurityRequirementList",
        servers: "ServerList",
        requestBody: "RequestBody",
        responses: "Responses",
        deprecated: { type: "boolean" },
        callbacks: "CallbacksMap",
        "x-codeSamples": "XCodeSampleList",
        "x-code-samples": "XCodeSampleList",
        // deprecated
        "x-hideTryItPanel": { type: "boolean" }
      },
      extensionsPrefix: "x-"
    };
    e.Schema = {
      properties: {
        $id: { type: "string" },
        $anchor: { type: "string" },
        id: { type: "string" },
        $schema: { type: "string" },
        definitions: "NamedSchemas",
        $defs: "NamedSchemas",
        $vocabulary: { type: "string" },
        externalDocs: "ExternalDocs",
        discriminator: "Discriminator",
        title: { type: "string" },
        multipleOf: { type: "number", minimum: 0 },
        maximum: { type: "number" },
        minimum: { type: "number" },
        exclusiveMaximum: { type: "number" },
        exclusiveMinimum: { type: "number" },
        maxLength: { type: "integer", minimum: 0 },
        minLength: { type: "integer", minimum: 0 },
        pattern: { type: "string" },
        maxItems: { type: "integer", minimum: 0 },
        minItems: { type: "integer", minimum: 0 },
        uniqueItems: { type: "boolean" },
        maxProperties: { type: "integer", minimum: 0 },
        minProperties: { type: "integer", minimum: 0 },
        required: { type: "array", items: { type: "string" } },
        enum: { type: "array" },
        type: (d) => Array.isArray(d) ? {
          type: "array",
          items: { enum: ["object", "array", "string", "number", "integer", "boolean", "null"] }
        } : {
          enum: ["object", "array", "string", "number", "integer", "boolean", "null"]
        },
        allOf: (0, t.listOf)("Schema"),
        anyOf: (0, t.listOf)("Schema"),
        oneOf: (0, t.listOf)("Schema"),
        not: "Schema",
        if: "Schema",
        then: "Schema",
        else: "Schema",
        dependentSchemas: (0, t.mapOf)("Schema"),
        dependentRequired: "DependentRequired",
        prefixItems: (0, t.listOf)("Schema"),
        contains: "Schema",
        minContains: { type: "integer", minimum: 0 },
        maxContains: { type: "integer", minimum: 0 },
        patternProperties: "PatternProperties",
        propertyNames: "Schema",
        unevaluatedItems: (d) => typeof d == "boolean" ? { type: "boolean" } : "Schema",
        unevaluatedProperties: (d) => typeof d == "boolean" ? { type: "boolean" } : "Schema",
        summary: { type: "string" },
        properties: "SchemaProperties",
        items: (d) => typeof d == "boolean" ? { type: "boolean" } : "Schema",
        additionalProperties: (d) => typeof d == "boolean" ? { type: "boolean" } : "Schema",
        description: { type: "string" },
        format: { type: "string" },
        contentEncoding: { type: "string" },
        contentMediaType: { type: "string" },
        contentSchema: "Schema",
        default: null,
        readOnly: { type: "boolean" },
        writeOnly: { type: "boolean" },
        xml: "Xml",
        examples: { type: "array" },
        example: { isExample: !0 },
        deprecated: { type: "boolean" },
        const: null,
        $comment: { type: "string" },
        "x-tags": { type: "array", items: { type: "string" } },
        $dynamicAnchor: { type: "string" },
        $dynamicRef: { type: "string" }
      },
      extensionsPrefix: "x-"
    }, e.SchemaProperties = {
      properties: {},
      additionalProperties: (d) => typeof d == "boolean" ? { type: "boolean" } : "Schema"
    };
    const c = {
      properties: {
        type: { enum: ["apiKey", "http", "oauth2", "openIdConnect", "mutualTLS"] },
        description: { type: "string" },
        name: { type: "string" },
        in: { type: "string", enum: ["query", "header", "cookie"] },
        scheme: { type: "string" },
        bearerFormat: { type: "string" },
        flows: "OAuth2Flows",
        openIdConnectUrl: { type: "string" }
      },
      required(d) {
        switch (d == null ? void 0 : d.type) {
          case "apiKey":
            return ["type", "name", "in"];
          case "http":
            return ["type", "scheme"];
          case "oauth2":
            return ["type", "flows"];
          case "openIdConnect":
            return ["type", "openIdConnectUrl"];
          default:
            return ["type"];
        }
      },
      allowed(d) {
        switch (d == null ? void 0 : d.type) {
          case "apiKey":
            return ["type", "name", "in", "description"];
          case "http":
            return ["type", "scheme", "bearerFormat", "description"];
          case "oauth2":
            switch (d == null ? void 0 : d.flows) {
              case "implicit":
                return ["type", "flows", "authorizationUrl", "refreshUrl", "description", "scopes"];
              case "password":
              case "clientCredentials":
                return ["type", "flows", "tokenUrl", "refreshUrl", "description", "scopes"];
              case "authorizationCode":
                return [
                  "type",
                  "flows",
                  "authorizationUrl",
                  "refreshUrl",
                  "tokenUrl",
                  "description",
                  "scopes"
                ];
              default:
                return [
                  "type",
                  "flows",
                  "authorizationUrl",
                  "refreshUrl",
                  "tokenUrl",
                  "description",
                  "scopes"
                ];
            }
          case "openIdConnect":
            return ["type", "openIdConnectUrl", "description"];
          case "mutualTLS":
            return ["type", "description"];
          default:
            return ["type", "description"];
        }
      },
      extensionsPrefix: "x-"
    };
    e.DependentRequired = {
      properties: {},
      additionalProperties: { type: "array", items: { type: "string" } }
    }, e.Oas3_1Types = {
      ...r.Oas3Types,
      Info: a,
      Root: n,
      Schema: e.Schema,
      SchemaProperties: e.SchemaProperties,
      PatternProperties: e.SchemaProperties,
      License: o,
      Components: i,
      NamedPathItems: (0, t.mapOf)("PathItem"),
      SecurityScheme: c,
      Operation: u,
      DependentRequired: e.DependentRequired
    };
  }(iw)), iw;
}
var sw = {}, aE;
function NC() {
  return aE || (aE = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.AsyncApi2Types = e.AsyncApi2Bindings = e.Dependencies = e.SecuritySchemeFlows = e.Discriminator = e.DiscriminatorMapping = e.SchemaProperties = e.Schema = e.MessageExample = e.CorrelationId = e.License = e.Contact = e.ServerVariable = e.ServerMap = e.ExternalDocs = e.Tag = void 0;
    const t = mi(), r = Up(), n = {
      properties: {
        asyncapi: null,
        // TODO: validate semver format and supported version
        info: "Info",
        id: { type: "string" },
        servers: "ServerMap",
        channels: "ChannelMap",
        components: "Components",
        tags: "TagList",
        externalDocs: "ExternalDocs",
        defaultContentType: { type: "string" }
      },
      required: ["asyncapi", "channels", "info"]
    }, o = {
      properties: {
        description: { type: "string" },
        subscribe: "Operation",
        publish: "Operation",
        parameters: "ParametersMap",
        bindings: "ChannelBindings",
        servers: { type: "array", items: { type: "string" } }
      }
    }, a = {
      properties: {},
      additionalProperties: "Channel"
    }, i = {
      properties: {},
      allowed() {
        return [
          "http",
          "ws",
          "kafka",
          "anypointmq",
          "amqp",
          "amqp1",
          "mqtt",
          "mqtt5",
          "nats",
          "jms",
          "sns",
          "solace",
          "sqs",
          "stomp",
          "redis",
          "mercure",
          "ibmmq",
          "googlepubsub",
          "pulsar"
        ];
      },
      additionalProperties: { type: "object" }
    };
    e.Tag = {
      properties: {
        name: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs"
      },
      required: ["name"]
    }, e.ExternalDocs = {
      properties: {
        description: { type: "string" },
        url: { type: "string" }
      },
      required: ["url"]
    };
    const u = {
      properties: {},
      additionalProperties: { type: "array", items: { type: "string" } }
    }, c = {
      properties: {},
      allowed() {
        return [
          "http",
          "ws",
          "kafka",
          "anypointmq",
          "amqp",
          "amqp1",
          "mqtt",
          "mqtt5",
          "nats",
          "jms",
          "sns",
          "solace",
          "sqs",
          "stomp",
          "redis",
          "mercure",
          "ibmmq",
          "googlepubsub",
          "pulsar"
        ];
      },
      additionalProperties: { type: "object" }
    }, d = {
      properties: {
        url: { type: "string" },
        protocol: { type: "string" },
        protocolVersion: { type: "string" },
        description: { type: "string" },
        variables: "ServerVariablesMap",
        security: "SecurityRequirementList",
        bindings: "ServerBindings",
        tags: "TagList"
      },
      required: ["url", "protocol"]
    };
    e.ServerMap = {
      properties: {},
      additionalProperties: (It, Xr) => (
        // eslint-disable-next-line no-useless-escape
        Xr.match(/^[A-Za-z0-9_\-]+$/) ? "Server" : void 0
      )
    }, e.ServerVariable = {
      properties: {
        enum: {
          type: "array",
          items: { type: "string" }
        },
        default: { type: "string" },
        description: { type: "string" },
        examples: {
          type: "array",
          items: { type: "string" }
        }
      },
      required: []
    };
    const m = {
      properties: {
        title: { type: "string" },
        version: { type: "string" },
        description: { type: "string" },
        termsOfService: { type: "string" },
        contact: "Contact",
        license: "License"
      },
      required: ["title", "version"]
    };
    e.Contact = {
      properties: {
        name: { type: "string" },
        url: { type: "string" },
        email: { type: "string" }
      }
    }, e.License = {
      properties: {
        name: { type: "string" },
        url: { type: "string" }
      },
      required: ["name"]
    };
    const g = {
      properties: {
        description: { type: "string" },
        schema: "Schema",
        location: { type: "string" }
      }
    };
    e.CorrelationId = {
      properties: {
        description: { type: "string" },
        location: { type: "string" }
      },
      required: ["location"]
    };
    const v = {
      properties: {
        messageId: { type: "string" },
        headers: "Schema",
        payload: "Schema",
        // TODO: strictly this does not cover all cases
        correlationId: "CorrelationId",
        schemaFormat: { type: "string" },
        // TODO: support official list of schema formats and custom values
        contentType: { type: "string" },
        name: { type: "string" },
        title: { type: "string" },
        summary: { type: "string" },
        description: { type: "string" },
        tags: "TagList",
        externalDocs: "ExternalDocs",
        bindings: "MessageBindings",
        examples: "MessageExampleList",
        traits: "MessageTraitList"
      },
      additionalProperties: {}
    }, S = {
      properties: {},
      allowed() {
        return [
          "http",
          "ws",
          "kafka",
          "anypointmq",
          "amqp",
          "amqp1",
          "mqtt",
          "mqtt5",
          "nats",
          "jms",
          "sns",
          "solace",
          "sqs",
          "stomp",
          "redis",
          "mercure",
          "ibmmq",
          "googlepubsub",
          "pulsar"
        ];
      },
      additionalProperties: { type: "object" }
    }, k = {
      properties: {},
      allowed() {
        return [
          "http",
          "ws",
          "kafka",
          "anypointmq",
          "amqp",
          "amqp1",
          "mqtt",
          "mqtt5",
          "nats",
          "jms",
          "sns",
          "solace",
          "sqs",
          "stomp",
          "redis",
          "mercure",
          "ibmmq",
          "googlepubsub",
          "pulsar"
        ];
      },
      additionalProperties: { type: "object" }
    }, b = {
      properties: {
        tags: "TagList",
        summary: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs",
        operationId: { type: "string" },
        security: "SecurityRequirementList",
        bindings: "OperationBindings"
      },
      required: []
    }, x = {
      properties: {
        messageId: { type: "string" },
        headers: "Schema",
        correlationId: "CorrelationId",
        schemaFormat: { type: "string" },
        contentType: { type: "string" },
        name: { type: "string" },
        title: { type: "string" },
        summary: { type: "string" },
        description: { type: "string" },
        tags: "TagList",
        externalDocs: "ExternalDocs",
        bindings: "MessageBindings",
        examples: "MessageExampleList"
      },
      additionalProperties: {}
    }, A = {
      properties: {
        tags: "TagList",
        summary: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs",
        operationId: { type: "string" },
        security: "SecurityRequirementList",
        bindings: "OperationBindings",
        traits: "OperationTraitList",
        message: "Message"
      },
      required: []
    };
    e.MessageExample = {
      properties: {
        payload: { isExample: !0 },
        summary: { type: "string" },
        name: { type: "string" },
        headers: { type: "object" }
      }
    }, e.Schema = {
      properties: {
        $id: { type: "string" },
        $schema: { type: "string" },
        definitions: "NamedSchemas",
        externalDocs: "ExternalDocs",
        discriminator: "Discriminator",
        myArbitraryKeyword: { type: "boolean" },
        title: { type: "string" },
        multipleOf: { type: "number", minimum: 0 },
        maximum: { type: "number" },
        minimum: { type: "number" },
        exclusiveMaximum: { type: "number" },
        exclusiveMinimum: { type: "number" },
        maxLength: { type: "integer", minimum: 0 },
        minLength: { type: "integer", minimum: 0 },
        pattern: { type: "string" },
        maxItems: { type: "integer", minimum: 0 },
        minItems: { type: "integer", minimum: 0 },
        uniqueItems: { type: "boolean" },
        maxProperties: { type: "integer", minimum: 0 },
        minProperties: { type: "integer", minimum: 0 },
        required: { type: "array", items: { type: "string" } },
        enum: { type: "array" },
        type: (It) => Array.isArray(It) ? {
          type: "array",
          items: { enum: ["object", "array", "string", "number", "integer", "boolean", "null"] }
        } : {
          enum: ["object", "array", "string", "number", "integer", "boolean", "null"]
        },
        allOf: (0, t.listOf)("Schema"),
        anyOf: (0, t.listOf)("Schema"),
        oneOf: (0, t.listOf)("Schema"),
        not: "Schema",
        if: "Schema",
        then: "Schema",
        else: "Schema",
        contains: "Schema",
        patternProperties: { type: "object" },
        propertyNames: "Schema",
        properties: "SchemaProperties",
        items: (It) => Array.isArray(It) ? (0, t.listOf)("Schema") : "Schema",
        additionalProperties: (It) => typeof It == "boolean" ? { type: "boolean" } : "Schema",
        description: { type: "string" },
        format: { type: "string" },
        contentEncoding: { type: "string" },
        contentMediaType: { type: "string" },
        default: null,
        readOnly: { type: "boolean" },
        writeOnly: { type: "boolean" },
        examples: { type: "array" },
        example: { isExample: !0 },
        deprecated: { type: "boolean" },
        const: null,
        $comment: { type: "string" },
        additionalItems: (It) => typeof It == "boolean" ? { type: "boolean" } : "Schema",
        dependencies: "Dependencies"
      }
    }, e.SchemaProperties = {
      properties: {},
      additionalProperties: (It) => typeof It == "boolean" ? { type: "boolean" } : "Schema"
    }, e.DiscriminatorMapping = {
      properties: {},
      additionalProperties: (It) => (0, r.isMappingRef)(It) ? { type: "string", directResolveAs: "Schema" } : { type: "string" }
    }, e.Discriminator = {
      properties: {
        propertyName: { type: "string" },
        mapping: "DiscriminatorMapping"
      },
      required: ["propertyName"]
    };
    const _ = {
      properties: {
        messages: "NamedMessages",
        parameters: "NamedParameters",
        schemas: "NamedSchemas",
        correlationIds: "NamedCorrelationIds",
        messageTraits: "NamedMessageTraits",
        operationTraits: "NamedOperationTraits",
        securitySchemes: "NamedSecuritySchemes",
        servers: "ServerMap",
        serverVariables: "ServerVariablesMap",
        channels: "ChannelMap",
        serverBindings: "ServerBindings",
        channelBindings: "ChannelBindings",
        operationBindings: "OperationBindings",
        messageBindings: "MessageBindings"
      }
    }, O = {
      properties: {
        refreshUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        authorizationUrl: { type: "string" }
      },
      required: ["authorizationUrl", "scopes"]
    }, R = {
      properties: {
        refreshUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        tokenUrl: { type: "string" }
      },
      required: ["tokenUrl", "scopes"]
    }, C = {
      properties: {
        refreshUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        tokenUrl: { type: "string" }
      },
      required: ["tokenUrl", "scopes"]
    }, T = {
      properties: {
        refreshUrl: { type: "string" },
        authorizationUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        tokenUrl: { type: "string" }
      },
      required: ["authorizationUrl", "tokenUrl", "scopes"]
    };
    e.SecuritySchemeFlows = {
      properties: {
        implicit: "ImplicitFlow",
        password: "PasswordFlow",
        clientCredentials: "ClientCredentials",
        authorizationCode: "AuthorizationCode"
      }
    };
    const j = {
      properties: {
        type: {
          enum: [
            "userPassword",
            "apiKey",
            "X509",
            "symmetricEncryption",
            "asymmetricEncryption",
            "httpApiKey",
            "http",
            "oauth2",
            "openIdConnect",
            "plain",
            "scramSha256",
            "scramSha512",
            "gssapi"
          ]
        },
        description: { type: "string" },
        name: { type: "string" },
        in: { type: "string", enum: ["query", "header", "cookie", "user", "password"] },
        scheme: { type: "string" },
        bearerFormat: { type: "string" },
        flows: "SecuritySchemeFlows",
        openIdConnectUrl: { type: "string" }
      },
      required(It) {
        switch (It == null ? void 0 : It.type) {
          case "apiKey":
            return ["type", "in"];
          case "httpApiKey":
            return ["type", "name", "in"];
          case "http":
            return ["type", "scheme"];
          case "oauth2":
            return ["type", "flows"];
          case "openIdConnect":
            return ["type", "openIdConnectUrl"];
          default:
            return ["type"];
        }
      },
      allowed(It) {
        switch (It == null ? void 0 : It.type) {
          case "apiKey":
            return ["type", "in", "description"];
          case "httpApiKey":
            return ["type", "name", "in", "description"];
          case "http":
            return ["type", "scheme", "bearerFormat", "description"];
          case "oauth2":
            return ["type", "flows", "description"];
          case "openIdConnect":
            return ["type", "openIdConnectUrl", "description"];
          default:
            return ["type", "description"];
        }
      },
      extensionsPrefix: "x-"
    };
    e.Dependencies = {
      properties: {},
      additionalProperties: (It) => Array.isArray(It) ? { type: "array", items: { type: "string" } } : "Schema"
    };
    const D = {
      properties: {}
      // empty object
    };
    i.properties.http = D;
    const V = {
      properties: {}
      // empty object
    };
    c.properties.http = V;
    const U = {
      properties: {
        headers: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    S.properties.http = U;
    const ne = {
      properties: {
        type: { type: "string" },
        method: {
          type: "string",
          enum: ["GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS", "CONNECT", "TRACE"]
        },
        headers: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    k.properties.http = ne;
    const H = {
      properties: {
        method: { type: "string" },
        query: "Schema",
        headers: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    i.properties.ws = H;
    const ae = {
      properties: {}
      // empty object
    };
    c.properties.ws = ae;
    const ge = {
      properties: {}
      // empty object
    };
    S.properties.ws = ge;
    const fe = {
      properties: {}
      // empty object
    };
    k.properties.ws = fe;
    const ve = {
      properties: {
        "cleanup.policy": { type: "array", items: { enum: ["delete", "compact"] } },
        "retention.ms": { type: "integer" },
        "retention.bytes": { type: "integer" },
        "delete.retention.ms": { type: "integer" },
        "max.message.bytes": { type: "integer" }
      }
    }, $e = {
      properties: {
        topic: { type: "string" },
        partitions: { type: "integer" },
        replicas: { type: "integer" },
        topicConfiguration: "KafkaTopicConfiguration",
        bindingVersion: { type: "string" }
      }
    };
    i.properties.kafka = $e;
    const ce = {
      properties: {}
      // empty object
    };
    c.properties.kafka = ce;
    const se = {
      properties: {
        key: "Schema",
        // TODO: add avro support
        schemaIdLocation: { type: "string" },
        schemaIdPayloadEncoding: { type: "string" },
        schemaLookupStrategy: { type: "string" },
        bindingVersion: { type: "string" }
      }
    };
    S.properties.kafka = se;
    const te = {
      properties: {
        groupId: "Schema",
        clientId: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    k.properties.kafka = te;
    const F = {
      properties: {
        destination: { type: "string" },
        destinationType: { type: "string" },
        bindingVersion: { type: "string" }
      }
    };
    i.properties.anypointmq = F;
    const J = {
      properties: {}
      // empty object
    };
    c.properties.anypointmq = J;
    const W = {
      properties: {
        headers: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    S.properties.anypointmq = W;
    const q = {
      properties: {}
      // empty object
    };
    k.properties.anypointmq = q;
    const X = {
      properties: {}
      // empty object
    };
    i.properties.amqp = X;
    const Q = {
      properties: {}
      // empty object
    };
    c.properties.amqp = Q;
    const ye = {
      properties: {
        contentEncoding: { type: "string" },
        messageType: { type: "string" },
        bindingVersion: { type: "string" }
      }
    };
    S.properties.amqp = ye;
    const Se = {
      // TODO: some fields are subscribe only
      properties: {
        expiration: { type: "integer" },
        userId: { type: "string" },
        cc: { type: "array", items: { type: "string" } },
        priority: { type: "integer" },
        deliveryMode: { type: "integer" },
        // TODO: enum: [1, 2]
        mandatory: { type: "boolean" },
        bcc: { type: "array", items: { type: "string" } },
        replyTo: { type: "string" },
        timestamp: { type: "boolean" },
        ack: { type: "boolean" },
        bindingVersion: { type: "string" }
      }
    };
    k.properties.amqp = Se;
    const Ne = {
      properties: {}
      // empty object
    };
    i.properties.amqp1 = Ne;
    const N = {
      properties: {}
      // empty object
    };
    c.properties.amqp1 = N;
    const B = {
      properties: {}
      // empty object
    };
    S.properties.amqp1 = B;
    const oe = {
      properties: {}
      // empty object
    };
    k.properties.amqp1 = oe;
    const ie = {
      properties: {
        qos: { type: "integer" },
        retain: { type: "boolean" },
        bindingVersion: { type: "string" }
      }
    };
    i.properties.mqtt = ie;
    const he = {
      properties: {
        topic: { type: "string" },
        qos: { type: "integer" },
        message: { type: "string" },
        retain: { type: "boolean" }
      }
    }, Z = {
      properties: {
        clientId: { type: "string" },
        cleanSession: { type: "boolean" },
        lastWill: "MqttServerBindingLastWill",
        keepAlive: { type: "integer" },
        bindingVersion: { type: "string" }
      }
    };
    c.properties.mqtt = Z;
    const re = {
      properties: {
        bindingVersion: { type: "string" }
      }
    };
    S.properties.mqtt = re;
    const Pe = {
      properties: {
        qos: { type: "integer" },
        retain: { type: "boolean" },
        bindingVersion: { type: "string" }
      }
    };
    k.properties.mqtt = Pe;
    const Oe = {
      properties: {}
      // empty object
    };
    i.properties.mqtt5 = Oe;
    const qe = {
      properties: {}
      // empty object
    };
    c.properties.mqtt5 = qe;
    const je = {
      properties: {}
      // empty object
    };
    S.properties.mqtt5 = je;
    const $ = {
      properties: {}
      // empty object
    };
    k.properties.mqtt5 = $;
    const K = {
      properties: {}
      // empty object
    };
    i.properties.nats = K;
    const me = {
      properties: {}
      // empty object
    };
    c.properties.nats = me;
    const Te = {
      properties: {}
      // empty object
    };
    S.properties.nats = Te;
    const ke = {
      properties: {
        queue: { type: "string" },
        bindingVersion: { type: "string" }
      }
    };
    k.properties.nats = ke;
    const De = {
      properties: {
        destination: { type: "string" },
        destinationType: { type: "string" },
        bindingVersion: { type: "string" }
      }
    };
    i.properties.jms = De;
    const Fe = {
      properties: {}
      // empty object
    };
    c.properties.jms = Fe;
    const Xe = {
      properties: {
        headers: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    S.properties.jms = Xe;
    const ct = {
      properties: {
        headers: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    k.properties.jms = ct;
    const mt = {
      properties: {}
      // empty object
    };
    i.properties.solace = mt;
    const st = {
      properties: {
        bindingVersion: { type: "string" },
        msgVpn: { type: "string" }
      }
    };
    c.properties.solace = st;
    const at = {
      properties: {}
      // empty object
    };
    S.properties.solace = at;
    const Vt = {
      properties: {
        destinationType: { type: "string", enum: ["queue", "topic"] },
        deliveryMode: { type: "string", enum: ["direct", "persistent"] },
        "queue.name": { type: "string" },
        "queue.topicSubscriptions": { type: "array", items: { type: "string" } },
        "queue.accessType": { type: "string", enum: ["exclusive", "nonexclusive"] },
        "queue.maxMsgSpoolSize": { type: "string" },
        "queue.maxTtl": { type: "string" },
        "topic.topicSubscriptions": { type: "array", items: { type: "string" } }
      }
    }, Y = {
      properties: {
        bindingVersion: { type: "string" },
        destinations: (0, t.listOf)("SolaceDestination")
      }
    };
    k.properties.solace = Y;
    const Ie = {
      properties: {}
      // empty object
    };
    i.properties.stomp = Ie;
    const Le = {
      properties: {}
      // empty object
    };
    c.properties.stomp = Le;
    const Me = {
      properties: {}
      // empty object
    };
    S.properties.stomp = Me;
    const ze = {
      properties: {}
      // empty object
    };
    k.properties.stomp = ze;
    const He = {
      properties: {}
      // empty object
    };
    i.properties.redis = He;
    const rt = {
      properties: {}
      // empty object
    };
    c.properties.redis = rt;
    const Ye = {
      properties: {}
      // empty object
    };
    S.properties.redis = Ye;
    const Ze = {
      properties: {}
      // empty object
    };
    k.properties.redis = Ze;
    const Ge = {
      properties: {}
      // empty object
    };
    i.properties.mercure = Ge;
    const bt = {
      properties: {}
      // empty object
    };
    c.properties.mercure = bt;
    const kt = {
      properties: {}
      // empty object
    };
    S.properties.mercure = kt;
    const Tt = {
      properties: {}
      // empty object
    };
    k.properties.mercure = Tt, e.AsyncApi2Bindings = {
      HttpServerBinding: V,
      HttpChannelBinding: D,
      HttpMessageBinding: U,
      HttpOperationBinding: ne,
      WsServerBinding: ae,
      WsChannelBinding: H,
      WsMessageBinding: ge,
      WsOperationBinding: fe,
      KafkaServerBinding: ce,
      KafkaTopicConfiguration: ve,
      KafkaChannelBinding: $e,
      KafkaMessageBinding: se,
      KafkaOperationBinding: te,
      AnypointmqServerBinding: J,
      AnypointmqChannelBinding: F,
      AnypointmqMessageBinding: W,
      AnypointmqOperationBinding: q,
      AmqpServerBinding: Q,
      AmqpChannelBinding: X,
      AmqpMessageBinding: ye,
      AmqpOperationBinding: Se,
      Amqp1ServerBinding: N,
      Amqp1ChannelBinding: Ne,
      Amqp1MessageBinding: B,
      Amqp1OperationBinding: oe,
      MqttServerBindingLastWill: he,
      MqttServerBinding: Z,
      MqttChannelBinding: ie,
      MqttMessageBinding: re,
      MqttOperationBinding: Pe,
      Mqtt5ServerBinding: qe,
      Mqtt5ChannelBinding: Oe,
      Mqtt5MessageBinding: je,
      Mqtt5OperationBinding: $,
      NatsServerBinding: me,
      NatsChannelBinding: K,
      NatsMessageBinding: Te,
      NatsOperationBinding: ke,
      JmsServerBinding: Fe,
      JmsChannelBinding: De,
      JmsMessageBinding: Xe,
      JmsOperationBinding: ct,
      SolaceServerBinding: st,
      SolaceChannelBinding: mt,
      SolaceMessageBinding: at,
      SolaceDestination: Vt,
      SolaceOperationBinding: Y,
      StompServerBinding: Le,
      StompChannelBinding: Ie,
      StompMessageBinding: Me,
      StompOperationBinding: ze,
      RedisServerBinding: rt,
      RedisChannelBinding: He,
      RedisMessageBinding: Ye,
      RedisOperationBinding: Ze,
      MercureServerBinding: bt,
      MercureChannelBinding: Ge,
      MercureMessageBinding: kt,
      MercureOperationBinding: Tt,
      ServerBindings: c,
      ChannelBindings: i,
      MessageBindings: S,
      OperationBindings: k
    }, e.AsyncApi2Types = {
      ...e.AsyncApi2Bindings,
      Root: n,
      Tag: e.Tag,
      TagList: (0, t.listOf)("Tag"),
      ServerMap: e.ServerMap,
      ExternalDocs: e.ExternalDocs,
      Server: d,
      ServerVariable: e.ServerVariable,
      ServerVariablesMap: (0, t.mapOf)("ServerVariable"),
      SecurityRequirement: u,
      SecurityRequirementList: (0, t.listOf)("SecurityRequirement"),
      Info: m,
      Contact: e.Contact,
      License: e.License,
      ChannelMap: a,
      Channel: o,
      Parameter: g,
      ParametersMap: (0, t.mapOf)("Parameter"),
      Operation: A,
      Schema: e.Schema,
      MessageExample: e.MessageExample,
      SchemaProperties: e.SchemaProperties,
      DiscriminatorMapping: e.DiscriminatorMapping,
      Discriminator: e.Discriminator,
      Components: _,
      NamedSchemas: (0, t.mapOf)("Schema"),
      NamedMessages: (0, t.mapOf)("Message"),
      NamedMessageTraits: (0, t.mapOf)("MessageTrait"),
      NamedOperationTraits: (0, t.mapOf)("OperationTrait"),
      NamedParameters: (0, t.mapOf)("Parameter"),
      NamedSecuritySchemes: (0, t.mapOf)("SecurityScheme"),
      NamedCorrelationIds: (0, t.mapOf)("CorrelationId"),
      ImplicitFlow: O,
      PasswordFlow: R,
      ClientCredentials: C,
      AuthorizationCode: T,
      SecuritySchemeFlows: e.SecuritySchemeFlows,
      SecurityScheme: j,
      Message: v,
      MessageBindings: S,
      OperationBindings: k,
      OperationTrait: b,
      OperationTraitList: (0, t.listOf)("OperationTrait"),
      MessageTrait: x,
      MessageTraitList: (0, t.listOf)("MessageTrait"),
      MessageExampleList: (0, t.listOf)("MessageExample"),
      CorrelationId: e.CorrelationId,
      Dependencies: e.Dependencies
    };
  }(sw)), sw;
}
var Od = {}, lE;
function FF() {
  if (lE) return Od;
  lE = 1, Object.defineProperty(Od, "__esModule", { value: !0 }), Od.AsyncApi3Types = void 0;
  const e = mi(), t = NC(), r = {
    properties: {
      asyncapi: { type: "string", enum: ["3.0.0"] },
      info: "Info",
      id: { type: "string" },
      servers: "ServerMap",
      channels: "NamedChannels",
      components: "Components",
      operations: "NamedOperations",
      defaultContentType: { type: "string" }
    },
    required: ["asyncapi", "info"]
  }, n = {
    properties: {
      address: { type: "string" },
      messages: "NamedMessages",
      title: { type: "string" },
      summary: { type: "string" },
      description: { type: "string" },
      servers: "ServerList",
      parameters: "ParametersMap",
      bindings: "ChannelBindings",
      tags: "TagList",
      externalDocs: "ExternalDocs"
    }
  }, o = {
    properties: {
      host: { type: "string" },
      pathname: { type: "string" },
      protocol: { type: "string" },
      protocolVersion: { type: "string" },
      description: { type: "string" },
      variables: "ServerVariablesMap",
      security: "SecuritySchemeList",
      bindings: "ServerBindings",
      externalDocs: "ExternalDocs",
      tags: "TagList"
    },
    required: ["host", "protocol"]
  }, a = {
    properties: {
      title: { type: "string" },
      version: { type: "string" },
      description: { type: "string" },
      termsOfService: { type: "string" },
      contact: "Contact",
      license: "License",
      tags: "TagList",
      externalDocs: "ExternalDocs"
    },
    required: ["title", "version"]
  }, i = {
    properties: {
      description: { type: "string" },
      enum: { type: "array", items: { type: "string" } },
      default: { type: "string" },
      examples: { type: "array", items: { type: "string" } },
      location: { type: "string" }
    }
  }, u = {
    properties: {
      headers: "Schema",
      payload: (O) => O && (O != null && O.schemaFormat) ? {
        properties: {
          schema: "Schema",
          schemaFormat: { type: "string" }
        },
        required: ["schema", "schemaFormat"]
      } : "Schema",
      correlationId: "CorrelationId",
      contentType: { type: "string" },
      name: { type: "string" },
      title: { type: "string" },
      summary: { type: "string" },
      description: { type: "string" },
      tags: "TagList",
      externalDocs: "ExternalDocs",
      bindings: "MessageBindings",
      examples: "MessageExampleList",
      traits: "MessageTraitList"
    },
    additionalProperties: {}
  }, c = {
    properties: {
      tags: "TagList",
      title: { type: "string" },
      summary: { type: "string" },
      description: { type: "string" },
      externalDocs: "ExternalDocs",
      security: "SecuritySchemeList",
      bindings: "OperationBindings"
    },
    required: []
  }, d = {
    properties: {
      headers: (O) => typeof O == "function" || typeof O == "object" && O ? {
        properties: {
          schema: "Schema",
          schemaFormat: { type: "string" }
        }
      } : "Schema",
      correlationId: "CorrelationId",
      contentType: { type: "string" },
      name: { type: "string" },
      title: { type: "string" },
      summary: { type: "string" },
      description: { type: "string" },
      tags: "TagList",
      externalDocs: "ExternalDocs",
      bindings: "MessageBindings",
      examples: "MessageExampleList"
    },
    additionalProperties: {}
  }, m = {
    properties: {
      action: { type: "string", enum: ["send", "receive"] },
      channel: "Channel",
      title: { type: "string" },
      tags: "TagList",
      summary: { type: "string" },
      description: { type: "string" },
      externalDocs: "ExternalDocs",
      operationId: { type: "string" },
      security: "SecuritySchemeList",
      bindings: "OperationBindings",
      traits: "OperationTraitList",
      messages: "MessageList",
      reply: "OperationReply"
    },
    required: ["action", "channel"]
  }, g = {
    properties: {
      channel: "Channel",
      messages: "MessageList",
      address: "OperationReplyAddress"
    }
  }, v = {
    properties: {
      location: { type: "string" },
      description: { type: "string" }
    },
    required: ["location"]
  }, S = {
    properties: {
      messages: "NamedMessages",
      parameters: "NamedParameters",
      schemas: "NamedSchemas",
      replies: "NamedOperationReplies",
      replyAddresses: "NamedOperationRelyAddresses",
      correlationIds: "NamedCorrelationIds",
      messageTraits: "NamedMessageTraits",
      operationTraits: "NamedOperationTraits",
      tags: "NamedTags",
      externalDocs: "NamedExternalDocs",
      securitySchemes: "NamedSecuritySchemes",
      servers: "ServerMap",
      serverVariables: "ServerVariablesMap",
      channels: "NamedChannels",
      operations: "NamedOperations",
      serverBindings: "ServerBindings",
      channelBindings: "ChannelBindings",
      operationBindings: "OperationBindings",
      messageBindings: "MessageBindings"
    }
  }, k = {
    properties: {
      refreshUrl: { type: "string" },
      availableScopes: { type: "object", additionalProperties: { type: "string" } },
      authorizationUrl: { type: "string" }
    },
    required: ["authorizationUrl", "availableScopes"]
  }, b = {
    properties: {
      refreshUrl: { type: "string" },
      availableScopes: { type: "object", additionalProperties: { type: "string" } },
      tokenUrl: { type: "string" }
    },
    required: ["tokenUrl", "availableScopes"]
  }, x = {
    properties: {
      refreshUrl: { type: "string" },
      availableScopes: { type: "object", additionalProperties: { type: "string" } },
      tokenUrl: { type: "string" }
    },
    required: ["tokenUrl", "availableScopes"]
  }, A = {
    properties: {
      refreshUrl: { type: "string" },
      authorizationUrl: { type: "string" },
      availableScopes: { type: "object", additionalProperties: { type: "string" } },
      tokenUrl: { type: "string" }
    },
    required: ["authorizationUrl", "tokenUrl", "availableScopes"]
  }, _ = {
    properties: {
      type: {
        enum: [
          "userPassword",
          "apiKey",
          "X509",
          "symmetricEncryption",
          "asymmetricEncryption",
          "httpApiKey",
          "http",
          "oauth2",
          "openIdConnect",
          "plain",
          "scramSha256",
          "scramSha512",
          "gssapi"
        ]
      },
      description: { type: "string" },
      name: { type: "string" },
      in: { type: "string", enum: ["query", "header", "cookie", "user", "password"] },
      scheme: { type: "string" },
      bearerFormat: { type: "string" },
      flows: "SecuritySchemeFlows",
      openIdConnectUrl: { type: "string" },
      scopes: { type: "array", items: { type: "string" } }
    },
    required(O) {
      switch (O == null ? void 0 : O.type) {
        case "apiKey":
          return ["type", "in"];
        case "httpApiKey":
          return ["type", "name", "in"];
        case "http":
          return ["type", "scheme"];
        case "oauth2":
          return ["type", "flows"];
        case "openIdConnect":
          return ["type", "openIdConnectUrl"];
        default:
          return ["type"];
      }
    },
    allowed(O) {
      switch (O == null ? void 0 : O.type) {
        case "apiKey":
          return ["type", "in", "description"];
        case "httpApiKey":
          return ["type", "name", "in", "description"];
        case "http":
          return ["type", "scheme", "bearerFormat", "description"];
        case "oauth2":
          return ["type", "flows", "description", "scopes"];
        case "openIdConnect":
          return ["type", "openIdConnectUrl", "description", "scopes"];
        default:
          return ["type", "description"];
      }
    },
    extensionsPrefix: "x-"
  };
  return Od.AsyncApi3Types = {
    // from asyncapi2
    ...t.AsyncApi2Bindings,
    CorrelationId: t.CorrelationId,
    SecuritySchemeFlows: t.SecuritySchemeFlows,
    ServerVariable: t.ServerVariable,
    Contact: t.Contact,
    License: t.License,
    MessageExample: t.MessageExample,
    Tag: t.Tag,
    Dependencies: t.Dependencies,
    Schema: t.Schema,
    Discriminator: t.Discriminator,
    DiscriminatorMapping: t.DiscriminatorMapping,
    SchemaProperties: t.SchemaProperties,
    ServerMap: t.ServerMap,
    ExternalDocs: t.ExternalDocs,
    Root: r,
    Channel: n,
    Parameter: i,
    Info: a,
    Server: o,
    MessageTrait: d,
    Operation: m,
    OperationReply: g,
    OperationReplyAddress: v,
    Components: S,
    ImplicitFlow: k,
    PasswordFlow: b,
    ClientCredentials: x,
    AuthorizationCode: A,
    SecurityScheme: _,
    Message: u,
    OperationTrait: c,
    ServerVariablesMap: (0, e.mapOf)("ServerVariable"),
    NamedTags: (0, e.mapOf)("Tag"),
    NamedExternalDocs: (0, e.mapOf)("ExternalDocs"),
    NamedChannels: (0, e.mapOf)("Channel"),
    ParametersMap: (0, e.mapOf)("Parameter"),
    NamedOperations: (0, e.mapOf)("Operation"),
    NamedOperationReplies: (0, e.mapOf)("OperationReply"),
    NamedOperationRelyAddresses: (0, e.mapOf)("OperationReplyAddress"),
    NamedSchemas: (0, e.mapOf)("Schema"),
    NamedMessages: (0, e.mapOf)("Message"),
    NamedMessageTraits: (0, e.mapOf)("MessageTrait"),
    NamedOperationTraits: (0, e.mapOf)("OperationTrait"),
    NamedParameters: (0, e.mapOf)("Parameter"),
    NamedSecuritySchemes: (0, e.mapOf)("SecurityScheme"),
    NamedCorrelationIds: (0, e.mapOf)("CorrelationId"),
    ServerList: (0, e.listOf)("Server"),
    SecuritySchemeList: (0, e.listOf)("SecurityScheme"),
    MessageList: (0, e.listOf)("Message"),
    OperationTraitList: (0, e.listOf)("OperationTrait"),
    MessageTraitList: (0, e.listOf)("MessageTrait"),
    MessageExampleList: (0, e.listOf)("MessageExample"),
    TagList: (0, e.listOf)("Tag")
  }, Od;
}
var kd = {}, uE;
function qF() {
  if (uE) return kd;
  uE = 1, Object.defineProperty(kd, "__esModule", { value: !0 }), kd.Arazzo1Types = void 0;
  const e = mi(), t = IC(), r = kx(), n = {
    properties: {
      arazzo: { type: "string" },
      info: "Info",
      sourceDescriptions: "SourceDescriptions",
      workflows: "Workflows",
      components: "Components"
    },
    required: ["arazzo", "info", "sourceDescriptions", "workflows"],
    extensionsPrefix: "x-"
  }, o = {
    properties: {},
    additionalProperties: "Parameter"
  }, a = {
    properties: {},
    additionalProperties: "SuccessActionObject"
  }, i = {
    properties: {},
    additionalProperties: "FailureActionObject"
  }, u = {
    properties: {
      inputs: "NamedInputs",
      parameters: "NamedParameters",
      successActions: "NamedSuccessActions",
      failureActions: "NamedFailureActions"
    },
    extensionsPrefix: "x-"
  }, c = (0, e.mapOf)("Schema"), d = {
    properties: {
      title: { type: "string" },
      description: { type: "string" },
      summary: { type: "string" },
      version: { type: "string" }
    },
    required: ["title", "version"],
    extensionsPrefix: "x-"
  }, m = {
    properties: {},
    items: (fe) => (fe == null ? void 0 : fe.type) === "openapi" ? "OpenAPISourceDescription" : "ArazzoSourceDescription"
  }, g = {
    properties: {
      name: { type: "string" },
      type: { type: "string", enum: ["openapi"] },
      url: { type: "string" },
      "x-serverUrl": { type: "string" }
    },
    required: ["name", "type", "url"],
    extensionsPrefix: "x-"
  }, v = {
    properties: {
      name: { type: "string" },
      type: { type: "string", enum: ["arazzo"] },
      url: { type: "string" }
    },
    required: ["name", "type", "url"],
    extensionsPrefix: "x-"
  }, S = {
    properties: {
      reference: { type: "string" },
      value: {}
      // any
    },
    required: ["reference"],
    extensionsPrefix: "x-"
  }, k = {
    properties: {
      in: { type: "string", enum: ["header", "query", "path", "cookie"] },
      name: { type: "string" },
      value: {}
      // any
    },
    required: ["name", "value"],
    extensionsPrefix: "x-"
  }, b = {
    properties: {},
    items: (fe) => fe != null && fe.reference ? "ReusableObject" : "Parameter"
  }, x = {
    properties: {
      workflowId: { type: "string" },
      summary: { type: "string" },
      description: { type: "string" },
      parameters: "Parameters",
      dependsOn: { type: "array", items: { type: "string" } },
      inputs: "Schema",
      outputs: "Outputs",
      steps: "Steps",
      successActions: "OnSuccessActionList",
      failureActions: "OnFailureActionList"
    },
    required: ["workflowId", "steps"],
    extensionsPrefix: "x-"
  }, A = (0, e.listOf)("Workflow"), _ = (0, e.listOf)("Step"), O = {
    properties: {
      stepId: { type: "string" },
      description: { type: "string" },
      operationId: { type: "string" },
      operationPath: { type: "string" },
      workflowId: { type: "string" },
      parameters: "Parameters",
      successCriteria: (0, e.listOf)("CriterionObject"),
      onSuccess: "OnSuccessActionList",
      onFailure: "OnFailureActionList",
      outputs: "Outputs",
      "x-operation": "ExtendedOperation",
      requestBody: "RequestBody"
    },
    required: ["stepId"],
    requiredOneOf: ["x-operation", "operationId", "operationPath", "workflowId"],
    extensionsPrefix: "x-"
  }, R = {
    properties: {},
    additionalProperties: {
      type: "string"
    }
  }, C = {
    properties: {
      contentType: { type: "string" },
      payload: {},
      replacements: (0, e.listOf)("Replacement")
    },
    required: ["payload"],
    extensionsPrefix: "x-"
  }, T = {
    properties: {
      target: { type: "string" },
      value: {}
    },
    required: ["target", "value"],
    extensionsPrefix: "x-"
  }, j = {
    properties: {
      url: { type: "string" },
      method: {
        enum: [
          "get",
          "post",
          "put",
          "delete",
          "patch",
          "head",
          "options",
          "trace",
          "connect",
          "query",
          "GET",
          "POST",
          "PUT",
          "DELETE",
          "PATCH",
          "OPTIONS",
          "HEAD",
          "TRACE",
          "CONNECT",
          "QUERY"
        ]
      }
    },
    required: ["url", "method"]
  }, D = {
    properties: {
      condition: { type: "string" },
      context: { type: "string" },
      type: (fe) => {
        if (fe)
          return typeof fe == "string" ? { enum: ["regex", "jsonpath", "simple", "xpath"] } : (fe == null ? void 0 : fe.type) === "jsonpath" ? "JSONPathCriterion" : "XPathCriterion";
      }
    },
    required: ["condition"]
  }, V = {
    properties: {
      type: { type: "string", enum: ["jsonpath"] },
      version: { type: "string", enum: ["draft-goessner-dispatch-jsonpath-00"] }
    }
  }, U = {
    properties: {
      type: { type: "string", enum: ["xpath"] },
      version: { type: "string", enum: ["xpath-30", "xpath-20", "xpath-10"] }
    }
  }, ne = {
    properties: {
      name: { type: "string" },
      type: { type: "string", enum: ["goto", "end"] },
      stepId: { type: "string" },
      workflowId: { type: "string" },
      criteria: (0, e.listOf)("CriterionObject")
    },
    required: ["type", "name"]
  }, H = {
    properties: {},
    items: (fe) => fe != null && fe.type && (fe != null && fe.name) ? "SuccessActionObject" : "ReusableObject"
  }, ae = {
    properties: {
      name: { type: "string" },
      type: { type: "string", enum: ["goto", "retry", "end"] },
      workflowId: { type: "string" },
      stepId: { type: "string" },
      retryAfter: { type: "number" },
      retryLimit: { type: "number" },
      criteria: (0, e.listOf)("CriterionObject")
    },
    required: ["type", "name"]
  }, ge = {
    properties: {},
    items: (fe) => fe != null && fe.type && (fe != null && fe.name) ? "FailureActionObject" : "ReusableObject"
  };
  return kd.Arazzo1Types = {
    Root: n,
    Info: d,
    SourceDescriptions: m,
    OpenAPISourceDescription: g,
    ArazzoSourceDescription: v,
    Parameters: b,
    Parameter: k,
    ReusableObject: S,
    Workflows: A,
    Workflow: x,
    Steps: _,
    Step: O,
    RequestBody: C,
    Replacement: T,
    ExtendedOperation: j,
    Outputs: R,
    CriterionObject: D,
    XPathCriterion: U,
    JSONPathCriterion: V,
    SuccessActionObject: ne,
    OnSuccessActionList: H,
    FailureActionObject: ae,
    OnFailureActionList: ge,
    Schema: t.Schema,
    NamedSchemas: (0, e.mapOf)("Schema"),
    ExternalDocs: r.ExternalDocs,
    DiscriminatorMapping: r.DiscriminatorMapping,
    Discriminator: r.Discriminator,
    DependentRequired: t.DependentRequired,
    SchemaProperties: t.SchemaProperties,
    PatternProperties: t.SchemaProperties,
    Components: u,
    NamedInputs: c,
    NamedParameters: o,
    NamedSuccessActions: a,
    NamedFailureActions: i,
    Xml: r.Xml
  }, kd;
}
var Ad = {}, cE;
function zF() {
  if (cE) return Ad;
  cE = 1, Object.defineProperty(Ad, "__esModule", { value: !0 }), Ad.Overlay1Types = void 0;
  const e = mi(), t = {
    properties: {
      overlay: { type: "string" },
      info: "Info",
      extends: { type: "string" },
      actions: "Actions"
    },
    required: ["overlay", "info", "actions"],
    extensionsPrefix: "x-"
  }, r = {
    properties: {
      title: { type: "string" },
      version: { type: "string" }
    },
    required: ["title", "version"],
    extensionsPrefix: "x-"
  }, n = (0, e.listOf)("Action"), o = {
    properties: {
      target: { type: "string" },
      description: { type: "string" },
      update: {},
      // any
      remove: { type: "boolean" }
    },
    required: ["target"],
    extensionsPrefix: "x-"
  };
  return Ad.Overlay1Types = {
    Root: t,
    Info: r,
    Actions: n,
    Action: o
  }, Ad;
}
var vu = {}, pE;
function BF() {
  return pE || (pE = 1, Object.defineProperty(vu, "__esModule", { value: !0 }), vu.ARAZZO_VERSIONS_SUPPORTED_BY_RESPECT = vu.VERSION_PATTERN = void 0, vu.VERSION_PATTERN = /^1\.0\.\d+(-.+)?$/, vu.ARAZZO_VERSIONS_SUPPORTED_BY_RESPECT = ["1.0.1"]), vu;
}
var fE;
function Ax() {
  if (fE) return po;
  fE = 1, Object.defineProperty(po, "__esModule", { value: !0 }), po.SpecMajorVersion = po.SpecVersion = void 0, po.detectSpec = v, po.getMajorSpecVersion = S, po.getTypes = k;
  const e = DF(), t = kx(), r = IC(), n = NC(), o = FF(), a = qF(), i = zF(), u = vi(), c = BF();
  var d;
  (function(b) {
    b.OAS2 = "oas2", b.OAS3_0 = "oas3_0", b.OAS3_1 = "oas3_1", b.Async2 = "async2", b.Async3 = "async3", b.Arazzo1 = "arazzo1", b.Overlay1 = "overlay1";
  })(d || (po.SpecVersion = d = {}));
  var m;
  (function(b) {
    b.OAS2 = "oas2", b.OAS3 = "oas3", b.Async2 = "async2", b.Async3 = "async3", b.Arazzo1 = "arazzo1", b.Overlay1 = "overlay1";
  })(m || (po.SpecMajorVersion = m = {}));
  const g = {
    [d.OAS2]: e.Oas2Types,
    [d.OAS3_0]: t.Oas3Types,
    [d.OAS3_1]: r.Oas3_1Types,
    [d.Async2]: n.AsyncApi2Types,
    [d.Async3]: o.AsyncApi3Types,
    [d.Arazzo1]: a.Arazzo1Types,
    [d.Overlay1]: i.Overlay1Types
  };
  function v(b) {
    if (!(0, u.isPlainObject)(b))
      throw new Error(`Document must be JSON object, got ${typeof b}`);
    if (b.openapi && typeof b.openapi != "string")
      throw new Error(`Invalid OpenAPI version: should be a string but got "${typeof b.openapi}"`);
    if (typeof b.openapi == "string" && b.openapi.startsWith("3.0"))
      return d.OAS3_0;
    if (typeof b.openapi == "string" && b.openapi.startsWith("3.1"))
      return d.OAS3_1;
    if (b.swagger && b.swagger === "2.0")
      return d.OAS2;
    if (b.openapi || b.swagger)
      throw new Error(`Unsupported OpenAPI version: ${b.openapi || b.swagger}`);
    if (typeof b.asyncapi == "string" && b.asyncapi.startsWith("2."))
      return d.Async2;
    if (typeof b.asyncapi == "string" && b.asyncapi.startsWith("3."))
      return d.Async3;
    if (b.asyncapi)
      throw new Error(`Unsupported AsyncAPI version: ${b.asyncapi}`);
    if (typeof b.arazzo == "string" && c.VERSION_PATTERN.test(b.arazzo))
      return d.Arazzo1;
    if (typeof b.overlay == "string" && c.VERSION_PATTERN.test(b.overlay))
      return d.Overlay1;
    throw new Error("Unsupported specification");
  }
  function S(b) {
    return b === d.OAS2 ? m.OAS2 : b === d.Async2 ? m.Async2 : b === d.Async3 ? m.Async3 : b === d.Arazzo1 ? m.Arazzo1 : b === d.Overlay1 ? m.Overlay1 : m.OAS3;
  }
  function k(b) {
    return g[b];
  }
  return po;
}
var xg = {}, dE;
function UF() {
  if (dE) return xg;
  dE = 1, Object.defineProperty(xg, "__esModule", { value: !0 }), xg.initRules = t;
  const e = vi();
  function t(r, n, o, a) {
    return r.flatMap((i) => Object.keys(i).map((u) => {
      const c = i[u], d = o === "rules" ? n.getRuleSettings(u, a) : o === "preprocessors" ? n.getPreprocessorSettings(u, a) : n.getDecoratorSettings(u, a);
      if (d.severity === "off")
        return;
      const m = d.severity, g = d.message, v = c(d);
      return Array.isArray(v) ? v.map((S) => ({
        severity: m,
        ruleId: u,
        message: g,
        visitor: S
      })) : {
        severity: m,
        message: g,
        ruleId: u,
        visitor: v
        // note: actually it is only one visitor object
      };
    })).flatMap((i) => i).filter(e.isDefined);
  }
  return xg;
}
var ip = {}, hE;
function VF() {
  if (hE) return ip;
  hE = 1, Object.defineProperty(ip, "__esModule", { value: !0 }), ip.NoUnresolvedRefs = void 0, ip.reportUnresolvedRef = r;
  const e = Ox(), t = () => ({
    ref: {
      leave(n, { report: o, location: a }, i) {
        i.node === void 0 && r(i, o, a);
      }
    },
    DiscriminatorMapping(n, { report: o, resolve: a, location: i }) {
      for (const u of Object.keys(n)) {
        const c = a({ $ref: n[u] });
        if (c.node !== void 0)
          return;
        r(c, o, i.child(u));
      }
    }
  });
  ip.NoUnresolvedRefs = t;
  function r(n, o, a) {
    var c;
    const i = n.error;
    i instanceof e.YamlParseError && o({
      message: "Failed to parse: " + i.message,
      location: {
        source: i.source,
        pointer: void 0,
        start: {
          col: i.col,
          line: i.line
        }
      }
    });
    const u = (c = n.error) == null ? void 0 : c.message;
    o({
      location: a,
      message: `Can't resolve $ref${u ? ": " + u : ""}`
    });
  }
  return ip;
}
var ow = {}, mE;
function HF() {
  return mE || (mE = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.AVAILABLE_REGIONS = e.DOMAINS = e.DEFAULT_REGION = void 0, e.getDomains = r, e.setRedoclyDomain = n, e.getRedoclyDomain = o, e.isRedoclyRegistryURL = a;
    let t = "redocly.com";
    e.DEFAULT_REGION = "us", e.DOMAINS = r(), e.AVAILABLE_REGIONS = Object.keys(e.DOMAINS);
    function r() {
      const i = {
        us: "redocly.com",
        eu: "eu.redocly.com"
      }, u = t;
      return u != null && u.endsWith(".redocly.host") && (i[u.split(".")[0]] = u), u === "redoc.online" && (i[u] = u), i;
    }
    function n(i) {
      t = i;
    }
    function o() {
      return t;
    }
    function a(i) {
      const u = o() || e.DOMAINS[e.DEFAULT_REGION], c = u === "redocly.com" ? "redoc.ly" : u;
      return !(!i.startsWith(`https://api.${u}/registry/`) && !i.startsWith(`https://api.${c}/registry/`));
    }
  }(ow)), ow;
}
var Pd = {}, gE;
function WF() {
  if (gE) return Pd;
  gE = 1, Object.defineProperty(Pd, "__esModule", { value: !0 }), Pd.RemoveUnusedComponents = void 0;
  const e = vi(), t = () => {
    const r = /* @__PURE__ */ new Map();
    function n(a, i, u) {
      var c;
      r.set(a.absolutePointer, {
        usedIn: ((c = r.get(a.absolutePointer)) == null ? void 0 : c.usedIn) ?? [],
        componentType: i,
        name: u
      });
    }
    function o(a, i) {
      const u = i.length;
      for (const [c, { usedIn: d, name: m, componentType: g }] of r)
        !d.some((S) => !i.some((k) => (
          // Check if the current location's absolute pointer starts with the 'removed' path
          // and either its length matches exactly with 'removed' or the character after the 'removed' path is a '/'
          S.absolutePointer.startsWith(k) && (S.absolutePointer.length === k.length || S.absolutePointer[k.length] === "/")
        ))) && g && (i.push(c), delete a[g][m], r.delete(c), (0, e.isEmptyObject)(a[g]) && delete a[g]);
      return i.length > u ? o(a, i) : i.length;
    }
    return {
      ref: {
        leave(a, { location: i, type: u, resolve: c, key: d }) {
          if (["Schema", "Parameter", "Response", "SecurityScheme"].includes(u.name)) {
            const m = c(a);
            if (!m.location)
              return;
            const [g, v] = m.location.absolutePointer.split("#", 2), S = v.split("/").slice(0, 3).join("/"), k = `${g}#${S}`, b = r.get(k);
            b ? b.usedIn.push(i) : r.set(k, {
              usedIn: [i],
              name: d.toString()
            });
          }
        }
      },
      Root: {
        leave(a, i) {
          const u = i.getVisitorData();
          u.removedCount = o(a, []);
        }
      },
      NamedSchemas: {
        Schema(a, { location: i, key: u }) {
          a.allOf || n(i, "definitions", u.toString());
        }
      },
      NamedParameters: {
        Parameter(a, { location: i, key: u }) {
          n(i, "parameters", u.toString());
        }
      },
      NamedResponses: {
        Response(a, { location: i, key: u }) {
          n(i, "responses", u.toString());
        }
      },
      NamedSecuritySchemes: {
        SecurityScheme(a, { location: i, key: u }) {
          n(i, "securityDefinitions", u.toString());
        }
      }
    };
  };
  return Pd.RemoveUnusedComponents = t, Pd;
}
var Td = {}, yE;
function KF() {
  if (yE) return Td;
  yE = 1, Object.defineProperty(Td, "__esModule", { value: !0 }), Td.RemoveUnusedComponents = void 0;
  const e = vi(), t = () => {
    const r = /* @__PURE__ */ new Map();
    function n(a, i, u) {
      var c;
      r.set(a.absolutePointer, {
        usedIn: ((c = r.get(a.absolutePointer)) == null ? void 0 : c.usedIn) ?? [],
        componentType: i,
        name: u
      });
    }
    function o(a, i) {
      const u = i.length;
      for (const [c, { usedIn: d, name: m, componentType: g }] of r)
        if (!d.some((S) => !i.some((k) => S.absolutePointer.startsWith(k) && (S.absolutePointer.length === k.length || S.absolutePointer[k.length] === "/"))) && g && a.components) {
          i.push(c);
          const S = a.components[g];
          delete S[m], r.delete(c), (0, e.isEmptyObject)(S) && delete a.components[g];
        }
      return i.length > u ? o(a, i) : i.length;
    }
    return {
      ref: {
        leave(a, { location: i, type: u, resolve: c, key: d }) {
          if (["Schema", "Header", "Parameter", "Response", "Example", "RequestBody"].includes(u.name)) {
            const m = c(a);
            if (!m.location)
              return;
            const [g, v] = m.location.absolutePointer.split("#", 2), S = v.split("/").slice(0, 4).join("/"), k = `${g}#${S}`, b = r.get(k);
            b ? b.usedIn.push(i) : r.set(k, {
              usedIn: [i],
              name: d.toString()
            });
          }
        }
      },
      Root: {
        leave(a, i) {
          const u = i.getVisitorData();
          u.removedCount = o(a, []), (0, e.isEmptyObject)(a.components) && delete a.components;
        }
      },
      NamedSchemas: {
        Schema(a, { location: i, key: u }) {
          a.allOf || n(i, "schemas", u.toString());
        }
      },
      NamedParameters: {
        Parameter(a, { location: i, key: u }) {
          n(i, "parameters", u.toString());
        }
      },
      NamedResponses: {
        Response(a, { location: i, key: u }) {
          n(i, "responses", u.toString());
        }
      },
      NamedExamples: {
        Example(a, { location: i, key: u }) {
          n(i, "examples", u.toString());
        }
      },
      NamedRequestBodies: {
        RequestBody(a, { location: i, key: u }) {
          n(i, "requestBodies", u.toString());
        }
      },
      NamedHeaders: {
        Header(a, { location: i, key: u }) {
          n(i, "headers", u.toString());
        }
      }
    };
  };
  return Td.RemoveUnusedComponents = t, Td;
}
var aw = {};
const jC = {
  hide: {
    type: "boolean",
    default: !1
  },
  component: {
    type: "string",
    enum: ["radio", "checkbox"],
    default: "checkbox"
  },
  label: { type: "string" },
  items: { type: "array", items: { type: "string" } }
}, Cd = {
  type: "object",
  properties: jC,
  additionalProperties: !1
}, QF = {
  type: "object",
  properties: {
    hide: {
      type: "boolean",
      default: !1
    },
    label: { type: "string" },
    placeholder: { type: "string" }
  },
  additionalProperties: !1
}, ib = {
  type: "object",
  properties: {
    hide: {
      type: "boolean",
      default: !1
    },
    type: {
      type: "string",
      enum: ["rating", "sentiment", "comment", "reasons", "mood", "scale"],
      default: "sentiment"
    },
    settings: {
      type: "object",
      properties: {
        label: { type: "string" },
        submitText: { type: "string" },
        buttonText: { type: "string" },
        component: {
          type: "string",
          enum: ["radio", "checkbox"],
          default: "checkbox"
        },
        items: { type: "array", items: { type: "string" }, minItems: 1 },
        leftScaleLabel: { type: "string" },
        rightScaleLabel: { type: "string" },
        reasons: {
          type: "object",
          properties: Object.assign(Object.assign({}, jC), { like: Cd, dislike: Cd, satisfied: Cd, neutral: Cd, dissatisfied: Cd }),
          additionalProperties: !1
        },
        comment: {
          type: "object",
          properties: {
            hide: {
              type: "boolean",
              default: !1
            },
            label: { type: "string" },
            likeLabel: { type: "string" },
            dislikeLabel: { type: "string" },
            satisfiedLabel: { type: "string" },
            neutralLabel: { type: "string" },
            dissatisfiedLabel: { type: "string" }
          },
          additionalProperties: !1
        },
        optionalEmail: QF
      },
      additionalProperties: !1
    }
  },
  additionalProperties: !1
}, sp = {
  type: "object",
  properties: {
    includeByName: {
      type: "array",
      items: {
        type: "string"
      }
    },
    excludeByName: {
      type: "array",
      items: {
        type: "string"
      }
    }
  },
  additionalProperties: !1
}, YF = {
  type: "object",
  properties: {
    name: {
      type: "string"
    },
    items: sp,
    queries: sp,
    mutations: sp,
    subscriptions: sp,
    types: sp,
    directives: sp
  },
  required: ["name"],
  additionalProperties: !1
}, GF = {
  properties: {
    requireExactGroups: {
      type: "boolean"
    },
    groups: {
      type: "array",
      items: YF
    },
    otherItemsGroupName: {
      type: "string"
    }
  }
}, hv = {
  type: "object",
  properties: {
    hidePaginationButtons: {
      type: "boolean"
    },
    menu: {
      type: "object",
      properties: Object.assign({}, GF.properties),
      additionalProperties: !1
    },
    sidebar: {
      type: "object",
      properties: {
        hide: {
          type: "boolean"
        }
      }
    },
    apiLogo: {
      type: "object",
      properties: {
        imageUrl: {
          type: "string"
        },
        href: {
          type: "string"
        },
        altText: {
          type: "string"
        },
        backgroundColor: {
          type: "string"
        }
      }
    },
    jsonSamplesDepth: {
      type: "number"
    },
    samplesMaxInlineArgs: {
      type: "number"
    },
    licenseKey: {
      type: "string"
    },
    fieldExpandLevel: {
      type: "number"
    },
    baseUrlPath: {
      type: "string"
    },
    feedback: ib
  },
  additionalProperties: !1
}, XF = {
  type: "object",
  properties: {
    languages: {
      type: "array",
      items: {
        type: "object",
        properties: {
          lang: {
            type: "string",
            enum: [
              "curl",
              "JavaScript",
              "Node.js",
              "Python",
              "Java8+Apache",
              "Java",
              "C#",
              "C#+Newtonsoft",
              "PHP",
              "Go",
              "Ruby",
              "R",
              "Payload"
            ]
          },
          label: { type: "string" },
          options: {
            type: "object",
            properties: {
              indent: { type: "string" },
              withImports: { type: "boolean" },
              withComments: { type: "boolean" },
              binary: { type: "boolean" },
              credentials: {
                type: "string",
                enum: ["omit", "same-origin", "include"]
              }
            },
            additionalProperties: !1
          }
        },
        required: ["lang"],
        additionalProperties: !1
      }
    },
    skipOptionalParameters: { type: "boolean" },
    withOAuth2Call: { type: "boolean" }
  },
  required: ["languages"],
  additionalProperties: !1
}, JF = {
  type: "array",
  items: {
    type: "object",
    properties: {
      title: { type: "string" },
      url: { type: "string" }
    },
    required: ["url"],
    additionalProperties: !1
  }
}, _S = {
  type: "object",
  properties: {
    licenseKey: { type: "string" },
    hideLoading: { type: "boolean" },
    disableRouter: { type: "boolean" },
    hideSidebar: { type: "boolean" },
    feedback: ib,
    hideReplay: { type: "boolean" },
    oAuth2RedirectURI: { type: "string", nullable: !0 },
    corsProxyUrl: { type: "string" },
    sortRequiredPropsFirst: { type: "boolean" },
    sanitize: { type: "boolean" },
    hideDownloadButtons: { type: "boolean" },
    downloadUrls: JF,
    onlyRequiredInSamples: { type: "boolean" },
    generatedSamplesMaxDepth: { oneOf: [{ type: "number" }, { type: "string" }] },
    showExtensions: {
      oneOf: [
        { type: "boolean" },
        { type: "string" },
        { type: "array", items: { type: "string" } }
      ]
    },
    hideSchemaTitles: { type: "boolean" },
    jsonSamplesExpandLevel: { oneOf: [{ type: "number" }, { type: "string" }] },
    schemasExpansionLevel: { oneOf: [{ type: "number" }, { type: "string" }] },
    mockServer: {
      type: "object",
      properties: {
        url: { type: "string" },
        position: { type: "string", enum: ["first", "last", "replace", "off"] },
        description: { type: "string" }
      }
    },
    maxDisplayedEnumValues: { type: "number" },
    schemaDefinitionsTagName: { type: "string" },
    layout: { type: "string", enum: ["stacked", "three-panel"] },
    hideInfoMetadata: { type: "boolean" },
    events: { type: "object" },
    skipBundle: { type: "boolean" },
    routingBasePath: { type: "string" },
    codeSamples: XF,
    ignoreNamedSchemas: {
      oneOf: [{ type: "array", items: { type: "string" } }, { type: "string" }]
    },
    hidePropertiesPrefix: { type: "boolean" },
    excludeFromSearch: { type: "boolean" }
  },
  additionalProperties: !1
}, ZF = {
  type: "object",
  properties: {
    label: { type: "string" },
    lang: {
      enum: [
        "curl",
        "C#",
        "Go",
        "Java",
        "Java8+Apache",
        "JavaScript",
        "Node.js",
        "PHP",
        "Python",
        "R",
        "Ruby"
      ]
    }
  },
  required: ["lang"]
}, eq = {
  type: "object",
  properties: {
    enum: { type: "string" },
    enumSingleValue: { type: "string" },
    enumArray: { type: "string" },
    default: { type: "string" },
    deprecated: { type: "string" },
    example: { type: "string" },
    examples: { type: "string" },
    nullable: { type: "string" },
    recursive: { type: "string" },
    arrayOf: { type: "string" },
    webhook: { type: "string" },
    authorizations: { type: "string" },
    tryItAuthBasicUsername: { type: "string" },
    tryItAuthBasicPassword: { type: "string" }
  }
}, vE = {
  type: "object",
  properties: {
    label: { type: "string" },
    link: { type: "string" },
    target: { type: "string" }
  },
  required: ["label", "link"]
}, tq = {
  type: "object",
  properties: {
    beforeInfo: { type: "array", items: vE },
    end: { type: "array", items: vE }
  }
}, Au = {
  type: "object",
  properties: {
    main: { type: "string" },
    light: { type: "string" },
    dark: { type: "string" },
    contrastText: { type: "string" }
  }
}, _g = {
  type: "object",
  properties: {
    backgroundColor: { type: "string" },
    borderColor: { type: "string" },
    color: { type: "string" },
    tabTextColor: { type: "string" }
  }
}, rq = {
  type: "object",
  properties: sb(Au.properties, ["light", "dark"])
}, nq = {
  type: "object",
  properties: {
    basic: { type: "string" },
    delete: { type: "string" },
    get: { type: "string" },
    head: { type: "string" },
    link: { type: "string" },
    options: { type: "string" },
    patch: { type: "string" },
    post: { type: "string" },
    put: { type: "string" }
  }
}, iq = {
  type: "object",
  properties: {
    error: _g,
    info: _g,
    redirect: _g,
    success: _g
  }
}, sq = {
  type: "object",
  properties: Vp(Au.properties, ["dark"])
}, oq = {
  type: "object",
  properties: {
    primary: { type: "string" },
    secondary: { type: "string" },
    light: { type: "string" }
  }
}, aq = {
  type: "object",
  properties: {
    accent: Au,
    border: rq,
    error: Au,
    http: nq,
    primary: Au,
    responses: iq,
    secondary: sq,
    success: Au,
    text: oq,
    tonalOffset: { type: "number" },
    warning: Au
  }
}, Eg = {
  type: "object",
  properties: {
    fontSize: { type: "string" },
    padding: { type: "string" },
    minWidth: { type: "string" }
  }
}, lq = {
  type: "object",
  properties: {
    small: Eg,
    medium: Eg,
    large: Eg,
    xlarge: Eg
  }
}, xo = {
  type: "object",
  properties: {
    fontFamily: { type: "string" },
    fontSize: { type: "string" },
    fontWeight: { type: "string" },
    lineHeight: { type: "string" }
  }
}, uq = {
  type: "object",
  properties: Object.assign(Object.assign({}, Vp(xo.properties, ["fontSize", "lineHeight"])), { borderRadius: { type: "string" }, hoverStyle: { type: "string" }, boxShadow: { type: "string" }, hoverBoxShadow: { type: "string" }, sizes: lq })
}, bE = {
  type: "object",
  properties: sb(xo.properties, ["fontSize", "lineHeight"])
}, cq = {
  type: "object",
  properties: {
    medium: bE,
    small: bE
  }
}, pq = {
  type: "object",
  properties: Object.assign(Object.assign({}, Vp(xo.properties, ["fontSize", "lineHeight"])), { borderRadius: { type: "string" }, color: { type: "string" }, sizes: cq })
}, fq = {
  type: "object",
  properties: {
    top: { type: "string" },
    width: { type: "string" },
    height: { type: "string" }
  }
}, dq = {
  type: "object",
  properties: {
    borderRadius: { type: "string" },
    backgroundColor: { type: "string" }
  }
}, wE = {
  type: "object",
  properties: {
    fullWidth: { type: "boolean" }
  }
}, hq = {
  type: "object",
  properties: {
    buttons: uq,
    httpBadges: pq,
    layoutControls: fq,
    panels: dq,
    tryItButton: wE,
    tryItSendButton: wE
  }
}, mv = {
  type: "object",
  properties: {
    small: { type: "string" },
    medium: { type: "string" },
    large: { type: "string" }
  }
}, mq = {
  type: "object",
  properties: {
    maxWidth: mv
  }
}, gq = {
  type: "object",
  properties: {
    maxWidth: mv,
    middlePanelMaxWidth: mv
  }
}, yq = {
  type: "object",
  properties: {
    showDarkRightPanel: { type: "boolean" },
    stacked: mq,
    "three-panel": gq
  }
}, SE = {
  type: "object",
  properties: {
    backgroundColor: { type: "string" },
    border: { type: "string" }
  }
}, vq = {
  type: "object",
  properties: {
    breakFieldNames: { type: "boolean" },
    caretColor: { type: "string" },
    caretSize: { type: "string" },
    constraints: SE,
    defaultDetailsWidth: { type: "string" },
    examples: SE,
    labelsTextSize: { type: "string" },
    linesColor: { type: "string" },
    nestedBackground: { type: "string" },
    nestingSpacing: { type: "string" },
    requireLabelColor: { type: "string" },
    typeNameColor: { type: "string" },
    typeTitleColor: { type: "string" }
  }
}, LC = {
  type: "object",
  properties: {
    subItemsColor: { type: "string" },
    textTransform: { type: "string" },
    fontWeight: { type: "string" }
  }
}, bq = {
  type: "object",
  properties: sb(LC.properties, ["textTransform"])
}, wq = {
  type: "object",
  properties: {
    unit: { type: "number" },
    paddingHorizontal: { type: "string" },
    paddingVertical: { type: "string" },
    offsetTop: { type: "string" },
    offsetLeft: { type: "string" },
    offsetNesting: { type: "string" }
  }
}, Sq = {
  type: "object",
  properties: Object.assign(Object.assign({}, Vp(xo.properties, ["fontWeight", "lineHeight"])), { activeBgColor: { type: "string" }, activeTextColor: { type: "string" }, backgroundColor: { type: "string" }, borderRadius: { type: "string" }, breakPath: { type: "boolean" }, caretColor: { type: "string" }, caretSize: { type: "string" }, groupItems: LC, level1items: bq, rightLineColor: { type: "string" }, separatorLabelColor: { type: "string" }, showAtBreakpoint: { type: "string" }, spacing: wq, textColor: { type: "string" }, width: { type: "string" } })
}, Og = {
  type: "object",
  properties: Object.assign(Object.assign({}, xo.properties), { color: { type: "string" }, transform: { type: "string" } })
}, xq = {
  type: "object",
  properties: Object.assign(Object.assign({}, xo.properties), { backgroundColor: { type: "string" }, color: { type: "string" }, wordBreak: {
    type: "string",
    enum: [
      "break-all",
      "break-word",
      "keep-all",
      "normal",
      "revert",
      "unset",
      "inherit",
      "initial"
    ]
  }, wrap: { type: "boolean" } })
}, _q = {
  type: "object",
  properties: Vp(xo.properties, ["fontSize"])
}, Eq = {
  type: "object",
  properties: {
    color: { type: "string" },
    hover: { type: "string" },
    textDecoration: { type: "string" },
    hoverTextDecoration: { type: "string" },
    visited: { type: "string" }
  }
}, Oq = {
  type: "object",
  properties: Object.assign(Object.assign({ code: xq, fieldName: xo }, sb(xo.properties, ["fontSize", "fontFamily"])), { fontWeightBold: { type: "string" }, fontWeightLight: { type: "string" }, fontWeightRegular: { type: "string" }, heading1: Og, heading2: Og, heading3: Og, headings: _q, lineHeight: { type: "string" }, links: Eq, optimizeSpeed: { type: "boolean" }, rightPanelHeading: Og, smoothing: {
    type: "string",
    enum: ["auto", "none", "antialiased", "subpixel-antialiased", "grayscale"]
  } })
}, kq = {
  type: "object",
  properties: Object.assign({ color: { type: "string" } }, Vp(xo.properties, ["fontWeight"]))
}, Aq = {
  type: "object",
  properties: {
    backgroundColor: { type: "string" },
    borderRadius: { type: "string" },
    tokens: kq
  }
}, Pq = {
  type: "object",
  properties: {
    gutter: { type: "string" },
    maxHeight: { type: "string" },
    maxWidth: { type: "string" }
  }
}, Tq = {
  type: "object",
  properties: {
    backgroundColor: { type: "string" },
    color: { type: "string" }
  }
}, xE = {
  type: "object",
  properties: {
    custom: { type: "string" }
  }
}, Cq = {
  type: "object",
  properties: {
    DownloadButton: xE,
    NextSectionButton: xE
  }
}, $q = {
  type: "object",
  properties: {
    backgroundColor: { type: "string" },
    panelBackgroundColor: { type: "string" },
    panelControlsBackgroundColor: { type: "string" },
    showAtBreakpoint: { type: "string" },
    textColor: { type: "string" },
    width: { type: "string" }
  }
}, Rq = {
  type: "object",
  properties: { borderRadius: { type: "string" } }
}, Iq = {
  type: "object",
  properties: {
    sectionHorizontal: { type: "number" },
    sectionVertical: { type: "number" },
    unit: { type: "number" }
  }
}, Nq = {
  type: "object",
  properties: {
    breakpoints: mv,
    codeBlock: Aq,
    colors: aq,
    components: hq,
    layout: yq,
    logo: Pq,
    fab: Tq,
    overrides: Cq,
    rightPanel: $q,
    schema: vq,
    shape: Rq,
    sidebar: Sq,
    spacing: Iq,
    typography: Oq,
    links: { properties: { color: { type: "string" } } },
    codeSample: { properties: { backgroundColor: { type: "string" } } }
  }
}, jq = {
  type: "object",
  properties: {
    skipOptionalParameters: { type: "boolean" },
    languages: { type: "array", items: ZF }
  },
  required: ["languages"]
}, Lq = {
  properties: {
    theme: Nq,
    ctrlFHijack: { type: "boolean" },
    defaultSampleLanguage: { type: "string" },
    disableDeepLinks: { type: "boolean" },
    disableSearch: { type: "boolean" },
    disableSidebar: { type: "boolean" },
    downloadDefinitionUrl: { type: "string" },
    expandDefaultServerVariables: { type: "boolean" },
    enumSkipQuotes: { type: "boolean" },
    expandDefaultRequest: { type: "boolean" },
    expandDefaultResponse: { type: "boolean" },
    expandResponses: { type: "string" },
    expandSingleSchemaField: { type: "boolean" },
    generateCodeSamples: jq,
    generatedPayloadSamplesMaxDepth: { type: "number" },
    hideDownloadButton: { type: "boolean" },
    hideHostname: { type: "boolean" },
    hideInfoSection: { type: "boolean" },
    hideLogo: { type: "boolean" },
    hideRequestPayloadSample: { type: "boolean" },
    hideRightPanel: { type: "boolean" },
    hideSchemaPattern: { type: "boolean" },
    hideSingleRequestSampleTab: { type: "boolean" },
    hideSecuritySection: { type: "boolean" },
    hideTryItPanel: { type: "boolean" },
    hideFab: { type: "boolean" },
    hideOneOfDescription: { type: "boolean" },
    htmlTemplate: { type: "string" },
    jsonSampleExpandLevel: {
      oneOf: [{ type: "number", minimum: 1 }, { type: "string" }]
    },
    labels: eq,
    menuToggle: { type: "boolean" },
    nativeScrollbars: { type: "boolean" },
    noAutoAuth: { type: "boolean" },
    onDeepLinkClick: { type: "object" },
    pagination: { enum: ["none", "section", "item"] },
    pathInMiddlePanel: { type: "boolean" },
    payloadSampleIdx: { type: "number", minimum: 0 },
    requestInterceptor: { type: "object" },
    requiredPropsFirst: { type: "boolean" },
    routingStrategy: { type: "string" },
    samplesTabsMaxCount: { type: "number" },
    schemaExpansionLevel: {
      oneOf: [{ type: "number", minimum: 0 }, { type: "string" }]
    },
    minCharacterLengthToInitSearch: { type: "number", minimum: 1 },
    maxResponseHeadersToShowInTryIt: { type: "number", minimum: 0 },
    scrollYOffset: {
      oneOf: [{ type: "number" }, { type: "string" }]
    },
    searchAutoExpand: { type: "boolean" },
    searchFieldLevelBoost: { type: "number", minimum: 0 },
    searchMaxDepth: { type: "number", minimum: 1 },
    searchMode: { type: "string", enum: ["default", "path-only"] },
    searchOperationTitleBoost: { type: "number" },
    searchTagTitleBoost: { type: "number" },
    sendXUserAgentInTryIt: { type: "boolean" },
    showChangeLayoutButton: { type: "boolean" },
    showConsole: { type: "boolean" },
    showNextButton: { type: "boolean" },
    showRightPanelToggle: { type: "boolean" },
    showSecuritySchemeType: { type: "boolean" },
    showWebhookVerb: { type: "boolean" },
    showObjectSchemaExamples: { type: "boolean" },
    disableTryItRequestUrlEncoding: { type: "boolean" },
    sidebarLinks: tq,
    sideNavStyle: { type: "string", enum: ["summary-only", "path-first", "id-only", "path-only"] },
    simpleOneOfTypeLabel: { type: "boolean" },
    sortEnumValuesAlphabetically: { type: "boolean" },
    sortOperationsAlphabetically: { type: "boolean" },
    sortPropsAlphabetically: { type: "boolean" },
    sortTagsAlphabetically: { type: "boolean" },
    suppressWarnings: { type: "boolean" },
    unstable_externalDescription: { type: "boolean" },
    unstable_ignoreMimeParameters: { type: "boolean" },
    untrustedDefinition: { type: "boolean" },
    showAccessMode: { type: "boolean" },
    preserveOriginalExtensionsName: { type: "boolean" },
    markdownHeadingsAnchorLevel: { type: "number" }
  }
};
function sb(e, t) {
  return Object.fromEntries(t.filter((r) => r in e).map((r) => [r, e[r]]));
}
function Vp(e, t) {
  return Object.fromEntries(Object.entries(e).filter(([r]) => !t.includes(r)));
}
const on = {
  type: "object",
  properties: {
    hide: { type: "boolean" }
  },
  additionalProperties: !1
}, _E = {
  type: "object",
  properties: {
    src: { type: "string" },
    async: { type: "boolean" },
    crossorigin: { type: "string" },
    defer: { type: "boolean" },
    fetchpriority: { type: "string" },
    integrity: { type: "string" },
    module: { type: "boolean" },
    nomodule: { type: "boolean" },
    nonce: { type: "string" },
    referrerpolicy: { type: "string" },
    type: { type: "string" }
  },
  required: ["src"],
  additionalProperties: !0
}, lw = {
  type: "object",
  properties: {
    page: { type: "string" },
    directory: { type: "string" },
    disconnect: { type: "boolean", default: !1 },
    group: { type: "string" },
    label: { type: "string" },
    href: { type: "string" },
    external: { type: "boolean" },
    labelTranslationKey: { type: "string" },
    groupTranslationKey: { type: "string" },
    icon: {
      oneOf: [
        { type: "string" },
        { type: "object", properties: { srcSet: { type: "string" } }, required: ["srcSet"] }
      ]
    },
    separator: { type: "string" },
    separatorLine: { type: "boolean" },
    linePosition: {
      type: "string",
      enum: ["top", "bottom"],
      default: "top"
    },
    version: { type: "string" },
    menuStyle: { type: "string", enum: ["drilldown"] },
    expanded: { type: "string", const: "always" },
    selectFirstItemOnExpand: { type: "boolean" },
    flatten: { type: "boolean" },
    linkedSidebars: {
      type: "array",
      items: { type: "string" }
    },
    // Allow users to eject the navbar and implement additional levels of nesting
    items: { type: "array", items: { type: "object", additionalProperties: !0 } },
    rbac: {
      type: "object",
      additionalProperties: { type: "string" }
    }
  }
}, Px = {
  type: "array",
  items: Object.assign(Object.assign({}, lw), { properties: Object.assign(Object.assign({}, lw.properties), { items: { type: "array", items: lw } }) })
}, Mq = {
  type: "object",
  properties: {
    name: { type: "string" },
    icon: { type: "string" },
    folder: { type: "string" }
  },
  additionalProperties: !1,
  required: ["name", "folder"]
}, Dq = {
  type: "object",
  properties: {
    hide: {
      type: "boolean",
      default: !1
    },
    suggestions: {
      default: [],
      type: "array",
      items: {
        type: "string"
      }
    },
    prompt: {
      type: "string"
    }
  },
  additionalProperties: !1
}, Fq = {
  type: "array",
  items: {
    type: "object",
    required: ["name", "field", "type"],
    properties: {
      name: { type: "string" },
      field: { type: "string" },
      type: {
        type: "string",
        enum: ["multi-select", "select", "tags"]
      }
    },
    additionalProperties: !1
  }
}, qq = {
  type: "object",
  properties: Object.assign({ facets: Fq }, on.properties),
  additionalProperties: !1
}, zq = {
  type: "object",
  properties: {
    page: { type: "string" },
    label: { type: "string" },
    labelTranslationKey: { type: "string" }
  },
  required: ["page"]
}, MC = {
  type: "object",
  properties: {
    image: { type: "string" },
    srcSet: { type: "string" },
    altText: { type: "string" },
    link: { type: "string" },
    favicon: { type: "string" }
  },
  additionalProperties: !1
}, DC = {
  type: "object",
  properties: Object.assign({ items: Px }, on.properties),
  additionalProperties: !1
}, FC = {
  type: "object",
  additionalProperties: Mq
}, qC = {
  type: "object",
  properties: Object.assign({ items: Px, copyrightText: { type: "string" }, logo: on }, on.properties),
  additionalProperties: !1
}, zC = {
  type: "object",
  properties: Object.assign({ separatorLine: { type: "boolean" }, linePosition: {
    type: "string",
    enum: ["top", "bottom"],
    default: "bottom"
  } }, on.properties),
  additionalProperties: !1
}, BC = {
  type: "object",
  properties: {
    head: { type: "array", items: _E },
    body: { type: "array", items: _E }
  },
  additionalProperties: !1
}, UC = {
  type: "array",
  items: {
    type: "object",
    properties: {
      href: { type: "string" },
      as: { type: "string" },
      crossorigin: { type: "string" },
      fetchpriority: { type: "string" },
      hreflang: { type: "string" },
      imagesizes: { type: "string" },
      imagesrcset: { type: "string" },
      integrity: { type: "string" },
      media: { type: "string" },
      prefetch: { type: "string" },
      referrerpolicy: { type: "string" },
      rel: { type: "string" },
      sizes: { type: "string" },
      title: { type: "string" },
      type: { type: "string" }
    },
    required: ["href"],
    additionalProperties: !0
  }
}, VC = {
  type: "object",
  properties: Object.assign({ engine: {
    type: "string",
    enum: ["flexsearch", "typesense"],
    default: "flexsearch"
  }, ai: Dq, filters: qq, placement: {
    type: "string",
    default: "navbar"
  }, shortcuts: {
    type: "array",
    items: { type: "string" },
    default: ["/"]
  }, suggestedPages: {
    type: "array",
    items: zq
  } }, on.properties),
  additionalProperties: !1
}, HC = {
  type: "object",
  properties: Object.assign({ ignoreDetection: { type: "boolean" }, modes: {
    type: "array",
    items: { type: "string" },
    default: ["light", "dark"]
  } }, on.properties),
  additionalProperties: !1
}, WC = {
  type: "object",
  properties: {
    nextButton: {
      type: "object",
      properties: Object.assign({ text: { type: "string", default: "Next page" } }, on.properties),
      additionalProperties: !1,
      default: {}
    },
    previousButton: {
      type: "object",
      properties: Object.assign({ text: { type: "string", default: "Previous page" } }, on.properties),
      additionalProperties: !1,
      default: {}
    }
  },
  additionalProperties: !1
}, KC = {
  type: "object",
  properties: {
    elementFormat: { type: "string", default: "icon" },
    copy: {
      type: "object",
      properties: Object.assign({}, on.properties),
      additionalProperties: !1,
      default: { hide: !1 }
    },
    report: {
      type: "object",
      properties: Object.assign({ tooltipText: { type: "string" }, buttonText: { type: "string" }, label: { type: "string" } }, on.properties),
      additionalProperties: !1,
      default: { hide: !1 }
    },
    expand: {
      type: "object",
      properties: Object.assign({}, on.properties),
      additionalProperties: !1,
      default: { hide: !1 }
    },
    collapse: {
      type: "object",
      properties: Object.assign({}, on.properties),
      additionalProperties: !1,
      default: { hide: !1 }
    }
  },
  additionalProperties: !1
}, QC = {
  type: "object",
  properties: {
    frontMatterKeysToResolve: {
      type: "array",
      items: { type: "string" },
      default: ["image", "links"]
    },
    partialsFolders: {
      type: "array",
      items: { type: "string" },
      default: ["_partials"]
    },
    lastUpdatedBlock: {
      type: "object",
      properties: Object.assign({ format: {
        type: "string",
        enum: ["timeago", "iso", "long", "short"],
        default: "timeago"
      }, locale: { type: "string" } }, on.properties),
      additionalProperties: !1,
      default: {}
    },
    toc: {
      type: "object",
      properties: Object.assign({ header: { type: "string", default: "On this page" }, depth: { type: "integer", default: 3, minimum: 1 } }, on.properties),
      additionalProperties: !1,
      default: {}
    },
    editPage: {
      type: "object",
      properties: Object.assign({ baseUrl: { type: "string" } }, on.properties),
      additionalProperties: !1,
      default: {}
    }
  },
  additionalProperties: !1,
  default: {}
}, gv = Object.assign(Object.assign({}, _S), { properties: Object.assign(Object.assign({}, _S.properties), Lq.properties) }), Bq = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    scriptUrl: { type: "string" },
    pageViewEventName: { type: "string" }
  },
  additionalProperties: !1,
  required: ["scriptUrl"]
}, Uq = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    apiKey: { type: "string" },
    head: { type: "boolean" },
    respectDNT: { type: "boolean" },
    exclude: { type: "array", items: { type: "string" } },
    outboundClickEventName: { type: "string" },
    pageViewEventName: { type: "string" },
    amplitudeConfig: { type: "object", additionalProperties: !0 }
  },
  additionalProperties: !1,
  required: ["apiKey"]
}, Vq = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    orgId: { type: "string" }
  },
  additionalProperties: !1,
  required: ["orgId"]
}, Hq = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    appId: { type: "string" }
  },
  additionalProperties: !1,
  required: ["appId"]
}, Wq = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    writeKey: { type: "string", minLength: 10 },
    trackPage: { type: "boolean" },
    dataPlaneUrl: { type: "string" },
    controlPlaneUrl: { type: "string" },
    sdkUrl: { type: "string" },
    loadOptions: { type: "object", additionalProperties: !0 }
  },
  additionalProperties: !1,
  required: ["writeKey"]
}, Kq = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    writeKey: { type: "string", minLength: 10 },
    trackPage: { type: "boolean" },
    includeTitleInPageCall: { type: "boolean" },
    host: { type: "string" }
  },
  additionalProperties: !1,
  required: ["writeKey"]
}, Qq = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    trackingId: { type: "string" },
    gtmAuth: { type: "string" },
    gtmPreview: { type: "string" },
    defaultDataLayer: {},
    dataLayerName: { type: "string" },
    enableWebVitalsTracking: { type: "boolean" },
    selfHostedOrigin: { type: "string" },
    pageViewEventName: { type: "string" }
  },
  additionalProperties: !1,
  required: ["trackingId"]
}, YC = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    trackingId: { type: "string" },
    conversionId: { type: "string" },
    floodlightId: { type: "string" },
    optimizeId: { type: "string" },
    exclude: { type: "array", items: { type: "string" } }
  },
  additionalProperties: !1,
  required: ["trackingId"]
}, Yq = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    trackingId: { type: "string" },
    conversionId: { type: "string" },
    floodlightId: { type: "string" },
    head: { type: "boolean" },
    respectDNT: { type: "boolean" },
    exclude: { type: "array", items: { type: "string" } },
    optimizeId: { type: "string" },
    anonymizeIp: { type: "boolean" },
    cookieExpires: { type: "number" },
    // All enabled tracking configs
    trackers: {
      type: "object",
      additionalProperties: YC
    }
  },
  additionalProperties: !1,
  required: ["trackingId"]
}, GC = {
  type: "object",
  properties: {
    adobe: Bq,
    amplitude: Uq,
    fullstory: Vq,
    heap: Hq,
    rudderstack: Wq,
    segment: Kq,
    gtm: Qq,
    ga: Yq
  }
}, XC = {
  type: "object",
  properties: Object.assign({ items: {
    type: "array",
    items: {
      type: "object",
      properties: {
        label: { type: "string" },
        external: { type: "boolean" },
        link: { type: "string" },
        separatorLine: { type: "boolean" }
      },
      additionalProperties: !0
    },
    default: []
  }, hideLoginButton: { type: "boolean" } }, on.properties),
  additionalProperties: !1
}, JC = {
  type: "object",
  properties: {
    hide: { type: "boolean" },
    showForUnversioned: {
      type: "boolean"
    }
  }
}, ZC = {
  type: "object",
  properties: {
    hide: { type: "boolean" },
    prefixItems: {
      type: "array",
      items: {
        type: "object",
        properties: {
          label: { type: "string" },
          labelTranslationKey: { type: "string" },
          page: { type: "string" }
        },
        additionalProperties: !1,
        default: {}
      }
    }
  },
  additionalProperties: !1
}, Gq = {
  type: "object",
  additionalProperties: !1,
  required: ["title", "property"],
  properties: {
    type: {
      type: "string",
      enum: ["select", "checkboxes", "date-range"],
      default: "checkboxes"
    },
    title: { type: "string" },
    titleTranslationKey: { type: "string" },
    property: { type: "string" },
    parentFilter: { type: "string" },
    valuesMapping: { type: "object", additionalProperties: { type: "string" } },
    missingCategoryName: { type: "string" },
    missingCategoryNameTranslationKey: { type: "string" },
    options: { type: "array", items: { type: "string" } }
  }
}, Xq = {
  type: "object",
  additionalProperties: !0,
  required: ["slug", "items"],
  properties: {
    slug: { type: "string" },
    filters: { type: "array", items: Gq },
    groupByFirstFilter: { type: "boolean" },
    filterValuesCasing: {
      type: "string",
      enum: ["sentence", "original", "lowercase", "uppercase"]
    },
    items: Px,
    requiredPermission: { type: "string" },
    separateVersions: { type: "boolean" },
    title: { type: "string" },
    titleTranslationKey: { type: "string" },
    description: { type: "string" },
    descriptionTranslationKey: { type: "string" }
  }
}, e$ = {
  type: "object",
  patternProperties: {
    ".*": Xq
  }
}, t$ = {
  type: "object",
  additionalProperties: !0,
  required: [],
  properties: {
    /**
     * @deprecated Should use `reunite.ignoreLint` instead
     */
    ignoreNonCompliant: { type: "boolean", default: !1 },
    teamMetadataProperty: {
      type: "object",
      properties: {
        property: { type: "string" },
        label: { type: "string" },
        default: { type: "string" }
      }
    },
    levels: {
      type: "array",
      items: {
        type: "object",
        required: ["name"],
        properties: {
          name: { type: "string" },
          color: { type: "string" },
          extends: { type: "array", items: { type: "string" } },
          rules: {
            type: "object",
            additionalProperties: {
              oneOf: [{ type: "string" }, { type: "object" }]
            }
          }
        },
        additionalProperties: !1
      }
    },
    targets: {
      type: "array",
      items: {
        type: "object",
        required: ["where"],
        properties: {
          minimumLevel: { type: "string" },
          rules: { type: "object", additionalProperties: !0 },
          where: {
            type: "object",
            required: ["metadata"],
            properties: {
              metadata: { type: "object", additionalProperties: { type: "string" } }
            },
            additionalProperties: !1
          }
        },
        additionalProperties: !1
      }
    },
    ignore: {
      type: "array",
      items: { type: "string" }
    }
  }
}, xs = {
  type: "object",
  properties: {
    /**
     * @deprecated Should use `plugins` instead
     */
    imports: {
      type: "array",
      items: { type: "string" }
    },
    logo: MC,
    navbar: DC,
    products: FC,
    footer: qC,
    sidebar: zC,
    scripts: BC,
    links: UC,
    feedback: ib,
    search: VC,
    colorMode: HC,
    navigation: WC,
    codeSnippet: KC,
    markdown: QC,
    openapi: gv,
    graphql: hv,
    analytics: GC,
    userMenu: XC,
    versionPicker: JC,
    breadcrumbs: ZC,
    catalog: e$,
    scorecard: t$
  },
  additionalProperties: !0
};
Object.assign(Object.assign({}, xs), { additionalProperties: !1 });
const r$ = "https://redocly.com/sso/teams";
var ah;
(function(e) {
  e.OIDC = "OIDC", e.SAML2 = "SAML2";
})(ah || (ah = {}));
var lh;
(function(e) {
  e.SERVICE_ACCOUNT = "SERVICE_ACCOUNT", e.OAUTH2 = "OAUTH2";
})(lh || (lh = {}));
const Jq = "redocly::teams-rbac", Zq = "redocly::route-rbac";
var ES;
(function(e) {
  e.STACKED = "stacked", e.THREE_PANEL = "three-panel";
})(ES || (ES = {}));
function OS(e, t) {
  return Object.fromEntries(Object.entries(e).map(([r, n]) => {
    if (r !== t)
      return typeof n != "object" || !n ? [r, n] : Array.isArray(n) ? [
        r,
        n.map((o) => typeof o == "object" ? OS(o, t) : o)
      ] : [r, OS(n, t)];
  }).filter(Boolean));
}
const ez = {
  type: "object",
  additionalProperties: { type: "string" }
}, tz = {
  type: "object",
  additionalProperties: !1,
  patternProperties: {
    "^[a-zA-Z0-9_-]+$": {
      type: "string",
      pattern: "^https?://[^\\s/$.?#].[^\\s]*$"
    }
  }
}, kg = {
  type: "string",
  enum: ["error", "warn", "off"]
}, rz = {
  type: "object",
  additionalProperties: !1,
  properties: {
    schemaCheck: kg,
    statusCodeCheck: kg,
    contentTypeCheck: kg,
    successCriteriaCheck: kg
  }
}, nz = {
  type: "object",
  additionalProperties: !1,
  properties: {
    event: {
      type: "string",
      enum: ["schedule"]
    },
    interval: { type: "string", pattern: "^[1-9]\\d*[mhdw]$" }
  },
  required: ["event"]
}, iz = {
  type: "object",
  properties: {
    ignoreLint: {
      oneOf: [
        { type: "boolean", default: !1 },
        {
          type: "object",
          additionalProperties: { type: "boolean" }
        }
      ]
    },
    ignoreLinkChecker: { type: "boolean" },
    ignoreMarkdocErrors: { type: "boolean" },
    jobs: {
      type: "array",
      items: {
        type: "object",
        properties: {
          path: {
            type: "string",
            pattern: "^(?!\\.\\./)(/[a-zA-Z0-9_\\-\\./]+|./[a-zA-Z0-9_\\-\\./]+|[a-zA-Z0-9_\\-\\./]+)$"
          },
          agent: {
            type: "string",
            enum: ["respect"]
          },
          trigger: nz,
          inputs: ez,
          servers: tz,
          severity: rz
        },
        required: ["path", "trigger", "agent"],
        additionalProperties: !1
      }
    }
  },
  additionalProperties: !1
}, sz = {
  type: "object",
  properties: {
    end_session_endpoint: { type: "string" },
    token_endpoint: { type: "string" },
    authorization_endpoint: { type: "string" },
    jwks_uri: { type: "string" }
  },
  required: ["token_endpoint", "authorization_endpoint"],
  additionalProperties: !0
}, oz = {
  type: "object",
  properties: {
    type: { type: "string", const: ah.OIDC },
    title: { type: "string" },
    pkce: { type: "boolean", default: !1 },
    configurationUrl: { type: "string", minLength: 1 },
    configuration: sz,
    clientId: { type: "string", minLength: 1 },
    clientSecret: { type: "string", minLength: 0 },
    teamsClaimName: { type: "string" },
    teamsClaimMap: { type: "object", additionalProperties: { type: "string" } },
    defaultTeams: { type: "array", items: { type: "string" } },
    scopes: { type: "array", items: { type: "string" } },
    tokenExpirationTime: { type: "number" },
    authorizationRequestCustomParams: { type: "object", additionalProperties: { type: "string" } },
    tokenRequestCustomParams: { type: "object", additionalProperties: { type: "string" } },
    audience: { type: "array", items: { type: "string" } }
  },
  required: ["type", "clientId"],
  oneOf: [{ required: ["configurationUrl"] }, { required: ["configuration"] }],
  additionalProperties: !1
}, az = {
  type: "object",
  properties: {
    type: { type: "string", const: ah.SAML2 },
    title: { type: "string" },
    issuerId: { type: "string" },
    entityId: { type: "string" },
    ssoUrl: { type: "string" },
    x509PublicCert: { type: "string" },
    teamsAttributeName: { type: "string", default: r$ },
    teamsAttributeMap: { type: "object", additionalProperties: { type: "string" } },
    defaultTeams: { type: "array", items: { type: "string" } }
  },
  additionalProperties: !1,
  required: ["type", "issuerId", "ssoUrl", "x509PublicCert"]
}, lz = {
  oneOf: [oz, az],
  discriminator: { propertyName: "type" }
}, uz = {
  type: "object",
  additionalProperties: lz
}, cz = {
  oneOf: [
    {
      type: "array",
      items: {
        type: "string",
        enum: ["REDOCLY", "CORPORATE", "GUEST"]
      },
      uniqueItems: !0
    },
    {
      type: "string",
      enum: ["REDOCLY", "CORPORATE", "GUEST"]
    }
  ]
}, pz = {
  type: "object",
  properties: {
    to: { type: "string" },
    type: { type: "number", default: 301 }
  },
  additionalProperties: !1
}, fz = {
  type: "object",
  additionalProperties: pz,
  default: {}
}, n$ = {
  type: "object",
  additionalProperties: {
    oneOf: [{ type: "string" }, { type: "object" }]
  }
}, i$ = {
  type: "object",
  properties: {
    root: { type: "string" },
    output: { type: "string", pattern: "(.ya?ml|.json)$" },
    rbac: { type: "object", additionalProperties: !0 },
    openapi: gv,
    graphql: hv,
    /**
     * @deprecated left for backwards compatibility
     */
    theme: {
      type: "object",
      properties: {
        openapi: gv,
        graphql: hv
      },
      additionalProperties: !1
    },
    title: { type: "string" },
    metadata: { type: "object", additionalProperties: !0 },
    rules: n$,
    decorators: { type: "object", additionalProperties: !0 },
    preprocessors: { type: "object", additionalProperties: !0 }
  },
  required: ["root"]
}, dz = {
  type: "object",
  additionalProperties: !0
}, hz = {
  type: "object",
  additionalProperties: {
    type: "object",
    additionalProperties: !0
  }
}, mz = {
  type: "object",
  properties: {
    title: { type: "string" },
    description: { type: "string" },
    siteUrl: { type: "string" },
    image: { type: "string" },
    keywords: {
      oneOf: [{ type: "array", items: { type: "string" } }, { type: "string" }]
    },
    lang: { type: "string" },
    jsonLd: { type: "object" },
    meta: {
      type: "array",
      items: {
        type: "object",
        properties: {
          name: { type: "string" },
          content: { type: "string" }
        },
        required: ["name", "content"],
        additionalProperties: !1
      }
    }
  },
  additionalProperties: !1
}, gz = {
  type: "object",
  properties: {
    folders: { type: "array", items: { type: "string" } }
  },
  additionalProperties: !1
}, bu = {
  type: "object",
  additionalProperties: { type: "string" }
}, s$ = {
  type: "object",
  properties: {
    teamNamePatterns: { type: "array", items: { type: "string" } },
    teamFolders: { type: "array", items: { type: "string" } },
    teamFoldersBaseRoles: bu,
    cms: bu,
    // deprecated in favor of reunite
    reunite: bu,
    features: {
      type: "object",
      properties: {
        aiSearch: bu
      },
      additionalProperties: !1
    },
    content: {
      type: "object",
      properties: {
        "**": bu
      },
      additionalProperties: bu
    }
  },
  additionalProperties: bu
}, yz = {
  type: "object",
  properties: { static: { type: "string" } },
  additionalProperties: !1,
  required: ["static"]
}, vz = {
  type: "object",
  properties: { idp: { type: "string" } },
  additionalProperties: !1,
  required: ["idp"]
}, bz = {
  type: "object",
  properties: {
    type: { type: "string", const: "GRAVITEE" },
    apiBaseUrl: { type: "string" },
    env: { type: "string" },
    allowApiProductsOutsideCatalog: { type: "boolean", default: !1 },
    stage: { type: "string", default: "non-production" },
    auth: {
      oneOf: [yz, vz]
    }
  },
  additionalProperties: !1,
  required: ["type", "apiBaseUrl"]
}, wz = {
  type: "object",
  properties: {
    type: { type: "string", const: lh.OAUTH2 },
    tokenEndpoint: { type: "string" },
    clientId: { type: "string" },
    clientSecret: { type: "string" }
  },
  additionalProperties: !1,
  required: ["type", "tokenEndpoint", "clientId", "clientSecret"]
}, Sz = {
  type: "object",
  properties: {
    type: { type: "string", const: lh.SERVICE_ACCOUNT },
    serviceAccountEmail: { type: "string" },
    serviceAccountPrivateKey: { type: "string" }
  },
  additionalProperties: !1,
  required: ["type", "serviceAccountEmail", "serviceAccountPrivateKey"]
}, kS = {
  type: "object",
  properties: {
    type: { type: "string", const: "APIGEE_X" },
    apiUrl: { type: "string" },
    stage: { type: "string", default: "non-production" },
    organizationName: { type: "string" },
    ignoreApiProducts: { type: "array", items: { type: "string" } },
    allowApiProductsOutsideCatalog: { type: "boolean", default: !1 },
    auth: {
      type: "object",
      oneOf: [wz, Sz],
      discriminator: { propertyName: "type" }
    }
  },
  additionalProperties: !1,
  required: ["type", "organizationName", "auth"]
}, xz = Object.assign(Object.assign({}, kS), { properties: Object.assign(Object.assign({}, kS.properties), { type: { type: "string", const: "APIGEE_EDGE" } }) }), _z = {
  type: "object",
  oneOf: [kS, xz, bz],
  discriminator: { propertyName: "type" }
}, Ez = {
  type: "object",
  required: ["adapters"],
  additionalProperties: !1,
  properties: {
    adapters: {
      type: "array",
      items: _z
    }
  }
}, EE = {
  type: "object",
  properties: {
    defaultLocale: {
      type: "string"
    },
    locales: {
      type: "array",
      items: {
        type: "object",
        properties: {
          code: {
            type: "string"
          },
          name: {
            type: "string"
          }
        },
        required: ["code"]
      }
    }
  },
  additionalProperties: !1,
  required: ["defaultLocale"]
}, Oz = {
  type: "object",
  properties: {
    name: { type: "string" },
    value: { type: "string" }
  },
  additionalProperties: !1,
  required: ["name", "value"]
}, AS = {
  type: "object",
  properties: {
    /**
     * @deprecated Should use `plugins` instead
     */
    imports: {
      type: "array",
      items: { type: "string" }
    },
    licenseKey: { type: "string" },
    redirects: fz,
    seo: mz,
    rbac: s$,
    apiFunctions: gz,
    requiresLogin: { type: "boolean" },
    responseHeaders: {
      type: "object",
      additionalProperties: {
        type: "array",
        items: Oz
      }
    },
    mockServer: {
      type: "object",
      properties: {
        off: { type: "boolean", default: !1 },
        position: { type: "string", enum: ["first", "last", "replace", "off"], default: "first" },
        strictExamples: { type: "boolean", default: !1 },
        errorIfForcedExampleNotFound: { type: "boolean", default: !1 },
        description: { type: "string" }
      }
    },
    apis: {
      type: "object",
      additionalProperties: i$
    },
    rules: n$,
    decorators: { type: "object", additionalProperties: !0 },
    preprocessors: { type: "object", additionalProperties: !0 },
    ssoDirect: uz,
    sso: cz,
    residency: { type: "string" },
    developerOnboarding: Ez,
    removeAttribution: { type: "boolean" },
    i18n: EE,
    // deprecated
    l10n: EE,
    metadata: dz,
    metadataGlobs: hz,
    ignore: {
      type: "array",
      items: {
        type: "string"
      }
    },
    /**
     * @deprecated properties moved to the root of the config
     */
    theme: xs,
    reunite: iz,
    // Ex theme properties
    logo: MC,
    navbar: DC,
    products: FC,
    footer: qC,
    sidebar: zC,
    scripts: BC,
    links: UC,
    feedback: ib,
    search: VC,
    colorMode: HC,
    navigation: WC,
    codeSnippet: KC,
    markdown: QC,
    openapi: gv,
    graphql: hv,
    analytics: GC,
    userMenu: XC,
    versionPicker: JC,
    breadcrumbs: ZC,
    catalog: e$,
    scorecard: t$
  },
  default: { redirects: {} },
  additionalProperties: !0
}, kz = Object.assign(Object.assign({}, OS(AS, "default")), { additionalProperties: !1 }), Az = Object.assign(Object.assign({ $id: "root-redocly-config" }, AS), { properties: Object.assign(Object.assign({ plugins: {
  type: "array",
  items: { type: "string" }
} }, AS.properties), { env: {
  type: "object",
  additionalProperties: kz
  // TODO: if we want full validation we need to override apis, theme and the root
} }), default: {}, additionalProperties: !1 }), PS = {
  type: "object",
  properties: {
    logo: xs.properties.logo,
    navbar: xs.properties.navbar,
    footer: xs.properties.footer,
    sidebar: xs.properties.sidebar,
    search: xs.properties.search,
    codeSnippet: xs.properties.codeSnippet,
    breadcrumbs: xs.properties.breadcrumbs,
    openapi: xs.properties.openapi,
    feedback: xs.properties.feedback,
    analytics: {
      type: "object",
      properties: {
        ga: YC
      }
    }
  },
  additionalProperties: !0,
  default: {}
}, Pz = {
  $id: "product-config-override",
  type: "object",
  properties: Object.assign(Object.assign({}, PS.properties), {
    apis: {
      type: "object",
      additionalProperties: i$
    },
    /**
     * @deprecated left for backwards compatibility
     */
    theme: PS
  }),
  additionalProperties: !1
}, Tz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ApigeeDevOnboardingIntegrationAuthType() {
    return lh;
  },
  get AuthProviderType() {
    return ah;
  },
  DEFAULT_TEAM_CLAIM_NAME: r$,
  get LayoutVariant() {
    return ES;
  },
  REDOCLY_ROUTE_RBAC: Zq,
  REDOCLY_TEAMS_RBAC: Jq,
  productConfigOverrideSchema: Pz,
  productThemeOverrideSchema: PS,
  rbacConfigSchema: s$,
  redocConfigSchema: _S,
  rootRedoclyConfigSchema: Az
}, Symbol.toStringTag, { value: "Module" })), Cz = /* @__PURE__ */ _o(Tz);
var Ag = {}, Pg = { exports: {} }, uw = {}, wu = {}, $d = {}, cw = {}, pw = {}, fw = {}, OE;
function yv() {
  return OE || (OE = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.nil = e._Code = e.Name = e.IDENTIFIER = e._CodeOrName = void 0, e._ = o, e.str = i, e.addCodeArg = u, e.strConcat = m, e.stringify = v, e.safeStringify = S, e.getProperty = k, e.getEsmExportName = b, e.regexpCode = x;
    class t {
    }
    e._CodeOrName = t, e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    class r extends t {
      constructor(_) {
        if (super(), !e.IDENTIFIER.test(_))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = _;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return !1;
      }
      get names() {
        return { [this.str]: 1 };
      }
    }
    e.Name = r;
    class n extends t {
      constructor(_) {
        super(), this._items = typeof _ == "string" ? [_] : _;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return !1;
        const _ = this._items[0];
        return _ === "" || _ === '""';
      }
      get str() {
        var _;
        return (_ = this._str) !== null && _ !== void 0 ? _ : this._str = this._items.reduce((O, R) => `${O}${R}`, "");
      }
      get names() {
        var _;
        return (_ = this._names) !== null && _ !== void 0 ? _ : this._names = this._items.reduce((O, R) => (R instanceof r && (O[R.str] = (O[R.str] || 0) + 1), O), {});
      }
    }
    e._Code = n, e.nil = new n("");
    function o(A, ..._) {
      const O = [A[0]];
      let R = 0;
      for (; R < _.length; )
        u(O, _[R]), O.push(A[++R]);
      return new n(O);
    }
    const a = new n("+");
    function i(A, ..._) {
      const O = [S(A[0])];
      let R = 0;
      for (; R < _.length; )
        O.push(a), u(O, _[R]), O.push(a, S(A[++R]));
      return c(O), new n(O);
    }
    function u(A, _) {
      _ instanceof n ? A.push(..._._items) : _ instanceof r ? A.push(_) : A.push(g(_));
    }
    function c(A) {
      let _ = 1;
      for (; _ < A.length - 1; ) {
        if (A[_] === a) {
          const O = d(A[_ - 1], A[_ + 1]);
          if (O !== void 0) {
            A.splice(_ - 1, 3, O);
            continue;
          }
          A[_++] = "+";
        }
        _++;
      }
    }
    function d(A, _) {
      if (_ === '""')
        return A;
      if (A === '""')
        return _;
      if (typeof A == "string")
        return _ instanceof r || A[A.length - 1] !== '"' ? void 0 : typeof _ != "string" ? `${A.slice(0, -1)}${_}"` : _[0] === '"' ? A.slice(0, -1) + _.slice(1) : void 0;
      if (typeof _ == "string" && _[0] === '"' && !(A instanceof r))
        return `"${A}${_.slice(1)}`;
    }
    function m(A, _) {
      return _.emptyStr() ? A : A.emptyStr() ? _ : i`${A}${_}`;
    }
    function g(A) {
      return typeof A == "number" || typeof A == "boolean" || A === null ? A : S(Array.isArray(A) ? A.join(",") : A);
    }
    function v(A) {
      return new n(S(A));
    }
    function S(A) {
      return JSON.stringify(A).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    function k(A) {
      return typeof A == "string" && e.IDENTIFIER.test(A) ? new n(`.${A}`) : o`[${A}]`;
    }
    function b(A) {
      if (typeof A == "string" && e.IDENTIFIER.test(A))
        return new n(`${A}`);
      throw new Error(`CodeGen: invalid export name: ${A}, use explicit $id name mapping`);
    }
    function x(A) {
      return new n(A.toString());
    }
  }(fw)), fw;
}
var dw = {}, kE;
function AE() {
  return kE || (kE = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueScope = e.ValueScopeName = e.Scope = e.varKinds = e.UsedValueState = void 0;
    const t = yv();
    class r extends Error {
      constructor(d) {
        super(`CodeGen: "code" for ${d} not defined`), this.value = d.value;
      }
    }
    var n;
    (function(c) {
      c[c.Started = 0] = "Started", c[c.Completed = 1] = "Completed";
    })(n || (e.UsedValueState = n = {})), e.varKinds = {
      const: new t.Name("const"),
      let: new t.Name("let"),
      var: new t.Name("var")
    };
    class o {
      constructor({ prefixes: d, parent: m } = {}) {
        this._names = {}, this._prefixes = d, this._parent = m;
      }
      toName(d) {
        return d instanceof t.Name ? d : this.name(d);
      }
      name(d) {
        return new t.Name(this._newName(d));
      }
      _newName(d) {
        const m = this._names[d] || this._nameGroup(d);
        return `${d}${m.index++}`;
      }
      _nameGroup(d) {
        var m, g;
        if (!((g = (m = this._parent) === null || m === void 0 ? void 0 : m._prefixes) === null || g === void 0) && g.has(d) || this._prefixes && !this._prefixes.has(d))
          throw new Error(`CodeGen: prefix "${d}" is not allowed in this scope`);
        return this._names[d] = { prefix: d, index: 0 };
      }
    }
    e.Scope = o;
    class a extends t.Name {
      constructor(d, m) {
        super(m), this.prefix = d;
      }
      setValue(d, { property: m, itemIndex: g }) {
        this.value = d, this.scopePath = (0, t._)`.${new t.Name(m)}[${g}]`;
      }
    }
    e.ValueScopeName = a;
    const i = (0, t._)`\n`;
    class u extends o {
      constructor(d) {
        super(d), this._values = {}, this._scope = d.scope, this.opts = { ...d, _n: d.lines ? i : t.nil };
      }
      get() {
        return this._scope;
      }
      name(d) {
        return new a(d, this._newName(d));
      }
      value(d, m) {
        var g;
        if (m.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const v = this.toName(d), { prefix: S } = v, k = (g = m.key) !== null && g !== void 0 ? g : m.ref;
        let b = this._values[S];
        if (b) {
          const _ = b.get(k);
          if (_)
            return _;
        } else
          b = this._values[S] = /* @__PURE__ */ new Map();
        b.set(k, v);
        const x = this._scope[S] || (this._scope[S] = []), A = x.length;
        return x[A] = m.ref, v.setValue(m, { property: S, itemIndex: A }), v;
      }
      getValue(d, m) {
        const g = this._values[d];
        if (g)
          return g.get(m);
      }
      scopeRefs(d, m = this._values) {
        return this._reduceValues(m, (g) => {
          if (g.scopePath === void 0)
            throw new Error(`CodeGen: name "${g}" has no value`);
          return (0, t._)`${d}${g.scopePath}`;
        });
      }
      scopeCode(d = this._values, m, g) {
        return this._reduceValues(d, (v) => {
          if (v.value === void 0)
            throw new Error(`CodeGen: name "${v}" has no value`);
          return v.value.code;
        }, m, g);
      }
      _reduceValues(d, m, g = {}, v) {
        let S = t.nil;
        for (const k in d) {
          const b = d[k];
          if (!b)
            continue;
          const x = g[k] = g[k] || /* @__PURE__ */ new Map();
          b.forEach((A) => {
            if (x.has(A))
              return;
            x.set(A, n.Started);
            let _ = m(A);
            if (_) {
              const O = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
              S = (0, t._)`${S}${O} ${A} = ${_};${this.opts._n}`;
            } else if (_ = v == null ? void 0 : v(A))
              S = (0, t._)`${S}${_}${this.opts._n}`;
            else
              throw new r(A);
            x.set(A, n.Completed);
          });
        }
        return S;
      }
    }
    e.ValueScope = u;
  }(dw)), dw;
}
var PE;
function Ct() {
  return PE || (PE = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.operators = e.varKinds = e.ValueScopeName = e.ValueScope = e.Scope = e.Name = e.regexpCode = e.stringify = e.getProperty = e.nil = e.strConcat = e.str = e._ = void 0, e.not = ve, e.and = ce, e.or = te;
    const t = yv(), r = AE();
    var n = yv();
    Object.defineProperty(e, "_", { enumerable: !0, get: function() {
      return n._;
    } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
      return n.str;
    } }), Object.defineProperty(e, "strConcat", { enumerable: !0, get: function() {
      return n.strConcat;
    } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
      return n.nil;
    } }), Object.defineProperty(e, "getProperty", { enumerable: !0, get: function() {
      return n.getProperty;
    } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
      return n.stringify;
    } }), Object.defineProperty(e, "regexpCode", { enumerable: !0, get: function() {
      return n.regexpCode;
    } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
      return n.Name;
    } });
    var o = AE();
    Object.defineProperty(e, "Scope", { enumerable: !0, get: function() {
      return o.Scope;
    } }), Object.defineProperty(e, "ValueScope", { enumerable: !0, get: function() {
      return o.ValueScope;
    } }), Object.defineProperty(e, "ValueScopeName", { enumerable: !0, get: function() {
      return o.ValueScopeName;
    } }), Object.defineProperty(e, "varKinds", { enumerable: !0, get: function() {
      return o.varKinds;
    } }), e.operators = {
      GT: new t._Code(">"),
      GTE: new t._Code(">="),
      LT: new t._Code("<"),
      LTE: new t._Code("<="),
      EQ: new t._Code("==="),
      NEQ: new t._Code("!=="),
      NOT: new t._Code("!"),
      OR: new t._Code("||"),
      AND: new t._Code("&&"),
      ADD: new t._Code("+")
    };
    class a {
      optimizeNodes() {
        return this;
      }
      optimizeNames(q, X) {
        return this;
      }
    }
    class i extends a {
      constructor(q, X, Q) {
        super(), this.varKind = q, this.name = X, this.rhs = Q;
      }
      render({ es5: q, _n: X }) {
        const Q = q ? r.varKinds.var : this.varKind, ye = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${Q} ${this.name}${ye};` + X;
      }
      optimizeNames(q, X) {
        if (q[this.name.str])
          return this.rhs && (this.rhs = ge(this.rhs, q, X)), this;
      }
      get names() {
        return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
      }
    }
    class u extends a {
      constructor(q, X, Q) {
        super(), this.lhs = q, this.rhs = X, this.sideEffects = Q;
      }
      render({ _n: q }) {
        return `${this.lhs} = ${this.rhs};` + q;
      }
      optimizeNames(q, X) {
        if (!(this.lhs instanceof t.Name && !q[this.lhs.str] && !this.sideEffects))
          return this.rhs = ge(this.rhs, q, X), this;
      }
      get names() {
        const q = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
        return ae(q, this.rhs);
      }
    }
    class c extends u {
      constructor(q, X, Q, ye) {
        super(q, Q, ye), this.op = X;
      }
      render({ _n: q }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + q;
      }
    }
    class d extends a {
      constructor(q) {
        super(), this.label = q, this.names = {};
      }
      render({ _n: q }) {
        return `${this.label}:` + q;
      }
    }
    class m extends a {
      constructor(q) {
        super(), this.label = q, this.names = {};
      }
      render({ _n: q }) {
        return `break${this.label ? ` ${this.label}` : ""};` + q;
      }
    }
    class g extends a {
      constructor(q) {
        super(), this.error = q;
      }
      render({ _n: q }) {
        return `throw ${this.error};` + q;
      }
      get names() {
        return this.error.names;
      }
    }
    class v extends a {
      constructor(q) {
        super(), this.code = q;
      }
      render({ _n: q }) {
        return `${this.code};` + q;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(q, X) {
        return this.code = ge(this.code, q, X), this;
      }
      get names() {
        return this.code instanceof t._CodeOrName ? this.code.names : {};
      }
    }
    class S extends a {
      constructor(q = []) {
        super(), this.nodes = q;
      }
      render(q) {
        return this.nodes.reduce((X, Q) => X + Q.render(q), "");
      }
      optimizeNodes() {
        const { nodes: q } = this;
        let X = q.length;
        for (; X--; ) {
          const Q = q[X].optimizeNodes();
          Array.isArray(Q) ? q.splice(X, 1, ...Q) : Q ? q[X] = Q : q.splice(X, 1);
        }
        return q.length > 0 ? this : void 0;
      }
      optimizeNames(q, X) {
        const { nodes: Q } = this;
        let ye = Q.length;
        for (; ye--; ) {
          const Se = Q[ye];
          Se.optimizeNames(q, X) || (fe(q, Se.names), Q.splice(ye, 1));
        }
        return Q.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((q, X) => H(q, X.names), {});
      }
    }
    class k extends S {
      render(q) {
        return "{" + q._n + super.render(q) + "}" + q._n;
      }
    }
    class b extends S {
    }
    class x extends k {
    }
    x.kind = "else";
    class A extends k {
      constructor(q, X) {
        super(X), this.condition = q;
      }
      render(q) {
        let X = `if(${this.condition})` + super.render(q);
        return this.else && (X += "else " + this.else.render(q)), X;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const q = this.condition;
        if (q === !0)
          return this.nodes;
        let X = this.else;
        if (X) {
          const Q = X.optimizeNodes();
          X = this.else = Array.isArray(Q) ? new x(Q) : Q;
        }
        if (X)
          return q === !1 ? X instanceof A ? X : X.nodes : this.nodes.length ? this : new A(ve(q), X instanceof A ? [X] : X.nodes);
        if (!(q === !1 || !this.nodes.length))
          return this;
      }
      optimizeNames(q, X) {
        var Q;
        if (this.else = (Q = this.else) === null || Q === void 0 ? void 0 : Q.optimizeNames(q, X), !!(super.optimizeNames(q, X) || this.else))
          return this.condition = ge(this.condition, q, X), this;
      }
      get names() {
        const q = super.names;
        return ae(q, this.condition), this.else && H(q, this.else.names), q;
      }
    }
    A.kind = "if";
    class _ extends k {
    }
    _.kind = "for";
    class O extends _ {
      constructor(q) {
        super(), this.iteration = q;
      }
      render(q) {
        return `for(${this.iteration})` + super.render(q);
      }
      optimizeNames(q, X) {
        if (super.optimizeNames(q, X))
          return this.iteration = ge(this.iteration, q, X), this;
      }
      get names() {
        return H(super.names, this.iteration.names);
      }
    }
    class R extends _ {
      constructor(q, X, Q, ye) {
        super(), this.varKind = q, this.name = X, this.from = Q, this.to = ye;
      }
      render(q) {
        const X = q.es5 ? r.varKinds.var : this.varKind, { name: Q, from: ye, to: Se } = this;
        return `for(${X} ${Q}=${ye}; ${Q}<${Se}; ${Q}++)` + super.render(q);
      }
      get names() {
        const q = ae(super.names, this.from);
        return ae(q, this.to);
      }
    }
    class C extends _ {
      constructor(q, X, Q, ye) {
        super(), this.loop = q, this.varKind = X, this.name = Q, this.iterable = ye;
      }
      render(q) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(q);
      }
      optimizeNames(q, X) {
        if (super.optimizeNames(q, X))
          return this.iterable = ge(this.iterable, q, X), this;
      }
      get names() {
        return H(super.names, this.iterable.names);
      }
    }
    class T extends k {
      constructor(q, X, Q) {
        super(), this.name = q, this.args = X, this.async = Q;
      }
      render(q) {
        return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(q);
      }
    }
    T.kind = "func";
    class j extends S {
      render(q) {
        return "return " + super.render(q);
      }
    }
    j.kind = "return";
    class D extends k {
      render(q) {
        let X = "try" + super.render(q);
        return this.catch && (X += this.catch.render(q)), this.finally && (X += this.finally.render(q)), X;
      }
      optimizeNodes() {
        var q, X;
        return super.optimizeNodes(), (q = this.catch) === null || q === void 0 || q.optimizeNodes(), (X = this.finally) === null || X === void 0 || X.optimizeNodes(), this;
      }
      optimizeNames(q, X) {
        var Q, ye;
        return super.optimizeNames(q, X), (Q = this.catch) === null || Q === void 0 || Q.optimizeNames(q, X), (ye = this.finally) === null || ye === void 0 || ye.optimizeNames(q, X), this;
      }
      get names() {
        const q = super.names;
        return this.catch && H(q, this.catch.names), this.finally && H(q, this.finally.names), q;
      }
    }
    class V extends k {
      constructor(q) {
        super(), this.error = q;
      }
      render(q) {
        return `catch(${this.error})` + super.render(q);
      }
    }
    V.kind = "catch";
    class U extends k {
      render(q) {
        return "finally" + super.render(q);
      }
    }
    U.kind = "finally";
    class ne {
      constructor(q, X = {}) {
        this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...X, _n: X.lines ? `
` : "" }, this._extScope = q, this._scope = new r.Scope({ parent: q }), this._nodes = [new b()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(q) {
        return this._scope.name(q);
      }
      // reserves unique name in the external scope
      scopeName(q) {
        return this._extScope.name(q);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(q, X) {
        const Q = this._extScope.value(q, X);
        return (this._values[Q.prefix] || (this._values[Q.prefix] = /* @__PURE__ */ new Set())).add(Q), Q;
      }
      getScopeValue(q, X) {
        return this._extScope.getValue(q, X);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(q) {
        return this._extScope.scopeRefs(q, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(q, X, Q, ye) {
        const Se = this._scope.toName(X);
        return Q !== void 0 && ye && (this._constants[Se.str] = Q), this._leafNode(new i(q, Se, Q)), Se;
      }
      // `const` declaration (`var` in es5 mode)
      const(q, X, Q) {
        return this._def(r.varKinds.const, q, X, Q);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(q, X, Q) {
        return this._def(r.varKinds.let, q, X, Q);
      }
      // `var` declaration with optional assignment
      var(q, X, Q) {
        return this._def(r.varKinds.var, q, X, Q);
      }
      // assignment code
      assign(q, X, Q) {
        return this._leafNode(new u(q, X, Q));
      }
      // `+=` code
      add(q, X) {
        return this._leafNode(new c(q, e.operators.ADD, X));
      }
      // appends passed SafeExpr to code or executes Block
      code(q) {
        return typeof q == "function" ? q() : q !== t.nil && this._leafNode(new v(q)), this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...q) {
        const X = ["{"];
        for (const [Q, ye] of q)
          X.length > 1 && X.push(","), X.push(Q), (Q !== ye || this.opts.es5) && (X.push(":"), (0, t.addCodeArg)(X, ye));
        return X.push("}"), new t._Code(X);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(q, X, Q) {
        if (this._blockNode(new A(q)), X && Q)
          this.code(X).else().code(Q).endIf();
        else if (X)
          this.code(X).endIf();
        else if (Q)
          throw new Error('CodeGen: "else" body without "then" body');
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(q) {
        return this._elseNode(new A(q));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new x());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(A, x);
      }
      _for(q, X) {
        return this._blockNode(q), X && this.code(X).endFor(), this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(q, X) {
        return this._for(new O(q), X);
      }
      // `for` statement for a range of values
      forRange(q, X, Q, ye, Se = this.opts.es5 ? r.varKinds.var : r.varKinds.let) {
        const Ne = this._scope.toName(q);
        return this._for(new R(Se, Ne, X, Q), () => ye(Ne));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(q, X, Q, ye = r.varKinds.const) {
        const Se = this._scope.toName(q);
        if (this.opts.es5) {
          const Ne = X instanceof t.Name ? X : this.var("_arr", X);
          return this.forRange("_i", 0, (0, t._)`${Ne}.length`, (N) => {
            this.var(Se, (0, t._)`${Ne}[${N}]`), Q(Se);
          });
        }
        return this._for(new C("of", ye, Se, X), () => Q(Se));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(q, X, Q, ye = this.opts.es5 ? r.varKinds.var : r.varKinds.const) {
        if (this.opts.ownProperties)
          return this.forOf(q, (0, t._)`Object.keys(${X})`, Q);
        const Se = this._scope.toName(q);
        return this._for(new C("in", ye, Se, X), () => Q(Se));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(_);
      }
      // `label` statement
      label(q) {
        return this._leafNode(new d(q));
      }
      // `break` statement
      break(q) {
        return this._leafNode(new m(q));
      }
      // `return` statement
      return(q) {
        const X = new j();
        if (this._blockNode(X), this.code(q), X.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(j);
      }
      // `try` statement
      try(q, X, Q) {
        if (!X && !Q)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const ye = new D();
        if (this._blockNode(ye), this.code(q), X) {
          const Se = this.name("e");
          this._currNode = ye.catch = new V(Se), X(Se);
        }
        return Q && (this._currNode = ye.finally = new U(), this.code(Q)), this._endBlockNode(V, U);
      }
      // `throw` statement
      throw(q) {
        return this._leafNode(new g(q));
      }
      // start self-balancing block
      block(q, X) {
        return this._blockStarts.push(this._nodes.length), q && this.code(q).endBlock(X), this;
      }
      // end the current self-balancing block
      endBlock(q) {
        const X = this._blockStarts.pop();
        if (X === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const Q = this._nodes.length - X;
        if (Q < 0 || q !== void 0 && Q !== q)
          throw new Error(`CodeGen: wrong number of nodes: ${Q} vs ${q} expected`);
        return this._nodes.length = X, this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(q, X = t.nil, Q, ye) {
        return this._blockNode(new T(q, X, Q)), ye && this.code(ye).endFunc(), this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(T);
      }
      optimize(q = 1) {
        for (; q-- > 0; )
          this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
      }
      _leafNode(q) {
        return this._currNode.nodes.push(q), this;
      }
      _blockNode(q) {
        this._currNode.nodes.push(q), this._nodes.push(q);
      }
      _endBlockNode(q, X) {
        const Q = this._currNode;
        if (Q instanceof q || X && Q instanceof X)
          return this._nodes.pop(), this;
        throw new Error(`CodeGen: not in block "${X ? `${q.kind}/${X.kind}` : q.kind}"`);
      }
      _elseNode(q) {
        const X = this._currNode;
        if (!(X instanceof A))
          throw new Error('CodeGen: "else" without "if"');
        return this._currNode = X.else = q, this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const q = this._nodes;
        return q[q.length - 1];
      }
      set _currNode(q) {
        const X = this._nodes;
        X[X.length - 1] = q;
      }
    }
    e.CodeGen = ne;
    function H(W, q) {
      for (const X in q)
        W[X] = (W[X] || 0) + (q[X] || 0);
      return W;
    }
    function ae(W, q) {
      return q instanceof t._CodeOrName ? H(W, q.names) : W;
    }
    function ge(W, q, X) {
      if (W instanceof t.Name)
        return Q(W);
      if (!ye(W))
        return W;
      return new t._Code(W._items.reduce((Se, Ne) => (Ne instanceof t.Name && (Ne = Q(Ne)), Ne instanceof t._Code ? Se.push(...Ne._items) : Se.push(Ne), Se), []));
      function Q(Se) {
        const Ne = X[Se.str];
        return Ne === void 0 || q[Se.str] !== 1 ? Se : (delete q[Se.str], Ne);
      }
      function ye(Se) {
        return Se instanceof t._Code && Se._items.some((Ne) => Ne instanceof t.Name && q[Ne.str] === 1 && X[Ne.str] !== void 0);
      }
    }
    function fe(W, q) {
      for (const X in q)
        W[X] = (W[X] || 0) - (q[X] || 0);
    }
    function ve(W) {
      return typeof W == "boolean" || typeof W == "number" || W === null ? !W : (0, t._)`!${J(W)}`;
    }
    const $e = F(e.operators.AND);
    function ce(...W) {
      return W.reduce($e);
    }
    const se = F(e.operators.OR);
    function te(...W) {
      return W.reduce(se);
    }
    function F(W) {
      return (q, X) => q === t.nil ? X : X === t.nil ? q : (0, t._)`${J(q)} ${W} ${J(X)}`;
    }
    function J(W) {
      return W instanceof t.Name ? W : (0, t._)`(${W})`;
    }
  }(pw)), pw;
}
var yr = {}, TE;
function Mt() {
  if (TE) return yr;
  TE = 1, Object.defineProperty(yr, "__esModule", { value: !0 }), yr.Type = yr.mergeEvaluated = void 0, yr.toHash = r, yr.alwaysValidSchema = n, yr.checkUnknownRules = o, yr.schemaHasRules = a, yr.schemaHasRulesButRef = i, yr.schemaRefOrVal = u, yr.unescapeFragment = c, yr.escapeFragment = d, yr.escapeJsonPointer = m, yr.unescapeJsonPointer = g, yr.eachItem = v, yr.evaluatedPropsToName = k, yr.setEvaluated = b, yr.useFunc = A, yr.getErrorPath = O, yr.checkStrictMode = R;
  const e = Ct(), t = yv();
  function r(C) {
    const T = {};
    for (const j of C)
      T[j] = !0;
    return T;
  }
  function n(C, T) {
    return typeof T == "boolean" ? T : Object.keys(T).length === 0 ? !0 : (o(C, T), !a(T, C.self.RULES.all));
  }
  function o(C, T = C.schema) {
    const { opts: j, self: D } = C;
    if (!j.strictSchema || typeof T == "boolean")
      return;
    const V = D.RULES.keywords;
    for (const U in T)
      V[U] || R(C, `unknown keyword: "${U}"`);
  }
  function a(C, T) {
    if (typeof C == "boolean")
      return !C;
    for (const j in C)
      if (T[j])
        return !0;
    return !1;
  }
  function i(C, T) {
    if (typeof C == "boolean")
      return !C;
    for (const j in C)
      if (j !== "$ref" && T.all[j])
        return !0;
    return !1;
  }
  function u({ topSchemaRef: C, schemaPath: T }, j, D, V) {
    if (!V) {
      if (typeof j == "number" || typeof j == "boolean")
        return j;
      if (typeof j == "string")
        return (0, e._)`${j}`;
    }
    return (0, e._)`${C}${T}${(0, e.getProperty)(D)}`;
  }
  function c(C) {
    return g(decodeURIComponent(C));
  }
  function d(C) {
    return encodeURIComponent(m(C));
  }
  function m(C) {
    return typeof C == "number" ? `${C}` : C.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function g(C) {
    return C.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  function v(C, T) {
    if (Array.isArray(C))
      for (const j of C)
        T(j);
    else
      T(C);
  }
  function S({ mergeNames: C, mergeToName: T, mergeValues: j, resultToName: D }) {
    return (V, U, ne, H) => {
      const ae = ne === void 0 ? U : ne instanceof e.Name ? (U instanceof e.Name ? C(V, U, ne) : T(V, U, ne), ne) : U instanceof e.Name ? (T(V, ne, U), U) : j(U, ne);
      return H === e.Name && !(ae instanceof e.Name) ? D(V, ae) : ae;
    };
  }
  yr.mergeEvaluated = {
    props: S({
      mergeNames: (C, T, j) => C.if((0, e._)`${j} !== true && ${T} !== undefined`, () => {
        C.if((0, e._)`${T} === true`, () => C.assign(j, !0), () => C.assign(j, (0, e._)`${j} || {}`).code((0, e._)`Object.assign(${j}, ${T})`));
      }),
      mergeToName: (C, T, j) => C.if((0, e._)`${j} !== true`, () => {
        T === !0 ? C.assign(j, !0) : (C.assign(j, (0, e._)`${j} || {}`), b(C, j, T));
      }),
      mergeValues: (C, T) => C === !0 ? !0 : { ...C, ...T },
      resultToName: k
    }),
    items: S({
      mergeNames: (C, T, j) => C.if((0, e._)`${j} !== true && ${T} !== undefined`, () => C.assign(j, (0, e._)`${T} === true ? true : ${j} > ${T} ? ${j} : ${T}`)),
      mergeToName: (C, T, j) => C.if((0, e._)`${j} !== true`, () => C.assign(j, T === !0 ? !0 : (0, e._)`${j} > ${T} ? ${j} : ${T}`)),
      mergeValues: (C, T) => C === !0 ? !0 : Math.max(C, T),
      resultToName: (C, T) => C.var("items", T)
    })
  };
  function k(C, T) {
    if (T === !0)
      return C.var("props", !0);
    const j = C.var("props", (0, e._)`{}`);
    return T !== void 0 && b(C, j, T), j;
  }
  function b(C, T, j) {
    Object.keys(j).forEach((D) => C.assign((0, e._)`${T}${(0, e.getProperty)(D)}`, !0));
  }
  const x = {};
  function A(C, T) {
    return C.scopeValue("func", {
      ref: T,
      code: x[T.code] || (x[T.code] = new t._Code(T.code))
    });
  }
  var _;
  (function(C) {
    C[C.Num = 0] = "Num", C[C.Str = 1] = "Str";
  })(_ || (yr.Type = _ = {}));
  function O(C, T, j) {
    if (C instanceof e.Name) {
      const D = T === _.Num;
      return j ? D ? (0, e._)`"[" + ${C} + "]"` : (0, e._)`"['" + ${C} + "']"` : D ? (0, e._)`"/" + ${C}` : (0, e._)`"/" + ${C}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return j ? (0, e.getProperty)(C).toString() : "/" + m(C);
  }
  function R(C, T, j = C.opts.strictSchema) {
    if (j) {
      if (T = `strict mode: ${T}`, j === !0)
        throw new Error(T);
      C.self.logger.warn(T);
    }
  }
  return yr;
}
var Tg = {}, CE;
function Rs() {
  if (CE) return Tg;
  CE = 1, Object.defineProperty(Tg, "__esModule", { value: !0 });
  const e = Ct(), t = {
    // validation function arguments
    data: new e.Name("data"),
    // data passed to validation function
    // args passed from referencing schema
    valCxt: new e.Name("valCxt"),
    // validation/data context - should not be used directly, it is destructured to the names below
    instancePath: new e.Name("instancePath"),
    parentData: new e.Name("parentData"),
    parentDataProperty: new e.Name("parentDataProperty"),
    rootData: new e.Name("rootData"),
    // root data - same as the data passed to the first/top validation function
    dynamicAnchors: new e.Name("dynamicAnchors"),
    // used to support recursiveRef and dynamicRef
    isAllOfVariant: new e.Name("isAllOfVariant"),
    // used to check in runtime if the current function (ref) is called from allOf
    // function scoped variables
    vErrors: new e.Name("vErrors"),
    // null or array of validation errors
    errors: new e.Name("errors"),
    // counter of validation errors
    this: new e.Name("this"),
    // "globals"
    self: new e.Name("self"),
    scope: new e.Name("scope"),
    // JTD serialize/parse name for JSON string and position
    json: new e.Name("json"),
    jsonPos: new e.Name("jsonPos"),
    jsonLen: new e.Name("jsonLen"),
    jsonPart: new e.Name("jsonPart")
  };
  return Tg.default = t, Tg;
}
var $E;
function ob() {
  return $E || ($E = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.keyword$DataError = e.keywordError = void 0, e.reportError = o, e.reportExtraError = a, e.resetErrorsCount = i, e.extendErrors = u;
    const t = Ct(), r = Mt(), n = Rs();
    e.keywordError = {
      message: ({ keyword: x }) => (0, t.str)`must pass "${x}" keyword validation`
    }, e.keyword$DataError = {
      message: ({ keyword: x, schemaType: A }) => A ? (0, t.str)`"${x}" keyword must be ${A} ($data)` : (0, t.str)`"${x}" keyword is invalid ($data)`
    };
    function o(x, A = e.keywordError, _, O) {
      const { it: R } = x, { gen: C, compositeRule: T, allErrors: j } = R, D = g(x, A, _);
      O ?? (T || j) ? c(C, D) : d(R, (0, t._)`[${D}]`);
    }
    function a(x, A = e.keywordError, _) {
      const { it: O } = x, { gen: R, compositeRule: C, allErrors: T } = O, j = g(x, A, _);
      c(R, j), C || T || d(O, n.default.vErrors);
    }
    function i(x, A) {
      x.assign(n.default.errors, A), x.if((0, t._)`${n.default.vErrors} !== null`, () => x.if(A, () => x.assign((0, t._)`${n.default.vErrors}.length`, A), () => x.assign(n.default.vErrors, null)));
    }
    function u({ gen: x, keyword: A, schemaValue: _, data: O, errsCount: R, it: C }) {
      if (R === void 0)
        throw new Error("ajv implementation error");
      const T = x.name("err");
      x.forRange("i", R, n.default.errors, (j) => {
        x.const(T, (0, t._)`${n.default.vErrors}[${j}]`), x.if((0, t._)`${T}.instancePath === undefined`, () => x.assign((0, t._)`${T}.instancePath`, (0, t.strConcat)(n.default.instancePath, C.errorPath))), x.assign((0, t._)`${T}.schemaPath`, (0, t.str)`${C.errSchemaPath}/${A}`), C.opts.verbose && (x.assign((0, t._)`${T}.schema`, _), x.assign((0, t._)`${T}.data`, O));
      });
    }
    function c(x, A) {
      const _ = x.const("err", A);
      x.if((0, t._)`${n.default.vErrors} === null`, () => x.assign(n.default.vErrors, (0, t._)`[${_}]`), (0, t._)`${n.default.vErrors}.push(${_})`), x.code((0, t._)`${n.default.errors}++`);
    }
    function d(x, A) {
      const { gen: _, validateName: O, schemaEnv: R } = x;
      R.$async ? _.throw((0, t._)`new ${x.ValidationError}(${A})`) : (_.assign((0, t._)`${O}.errors`, A), _.return(!1));
    }
    const m = {
      keyword: new t.Name("keyword"),
      schemaPath: new t.Name("schemaPath"),
      // also used in JTD errors
      params: new t.Name("params"),
      propertyName: new t.Name("propertyName"),
      message: new t.Name("message"),
      schema: new t.Name("schema"),
      parentSchema: new t.Name("parentSchema")
    };
    function g(x, A, _) {
      const { createErrors: O } = x.it;
      return O === !1 ? (0, t._)`{}` : v(x, A, _);
    }
    function v(x, A, _ = {}) {
      const { gen: O, it: R } = x, C = [
        S(R, _),
        k(x, _)
      ];
      return b(x, A, C), O.object(...C);
    }
    function S({ errorPath: x }, { instancePath: A }) {
      const _ = A ? (0, t.str)`${x}${(0, r.getErrorPath)(A, r.Type.Str)}` : x;
      return [n.default.instancePath, (0, t.strConcat)(n.default.instancePath, _)];
    }
    function k({ keyword: x, it: { errSchemaPath: A } }, { schemaPath: _, parentSchema: O }) {
      let R = O ? A : (0, t.str)`${A}/${x}`;
      return _ && (R = (0, t.str)`${R}${(0, r.getErrorPath)(_, r.Type.Str)}`), [m.schemaPath, R];
    }
    function b(x, { params: A, message: _ }, O) {
      const { keyword: R, data: C, schemaValue: T, it: j } = x, { opts: D, propertyName: V, topSchemaRef: U, schemaPath: ne } = j;
      O.push([m.keyword, R], [m.params, typeof A == "function" ? A(x) : A || (0, t._)`{}`]), D.messages && O.push([m.message, typeof _ == "function" ? _(x) : _]), D.verbose && O.push([m.schema, T], [m.parentSchema, (0, t._)`${U}${ne}`], [n.default.data, C]), V && O.push([m.propertyName, V]);
    }
  }(cw)), cw;
}
var RE;
function $z() {
  if (RE) return $d;
  RE = 1, Object.defineProperty($d, "__esModule", { value: !0 }), $d.topBoolOrEmptySchema = o, $d.boolOrEmptySchema = a;
  const e = ob(), t = Ct(), r = Rs(), n = {
    message: "boolean schema is false"
  };
  function o(u) {
    const { gen: c, schema: d, validateName: m } = u;
    d === !1 ? i(u, !1) : typeof d == "object" && d.$async === !0 ? c.return(r.default.data) : (c.assign((0, t._)`${m}.errors`, null), c.return(!0));
  }
  function a(u, c) {
    const { gen: d, schema: m } = u;
    m === !1 ? (d.var(c, !1), i(u)) : d.var(c, !0);
  }
  function i(u, c) {
    const { gen: d, data: m } = u, g = {
      gen: d,
      keyword: "false schema",
      data: m,
      schema: !1,
      schemaCode: !1,
      schemaValue: !1,
      params: {},
      it: u
    };
    (0, e.reportError)(g, n, void 0, c);
  }
  return $d;
}
var ws = {}, Rd = {}, IE;
function o$() {
  if (IE) return Rd;
  IE = 1, Object.defineProperty(Rd, "__esModule", { value: !0 }), Rd.isJSONType = r, Rd.getRules = n;
  const e = ["string", "number", "integer", "boolean", "null", "object", "array"], t = new Set(e);
  function r(o) {
    return typeof o == "string" && t.has(o);
  }
  function n() {
    const o = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...o, integer: !0, boolean: !0, null: !0 },
      rules: [{ rules: [] }, o.number, o.string, o.array, o.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  return Rd;
}
var op = {}, NE;
function a$() {
  if (NE) return op;
  NE = 1, Object.defineProperty(op, "__esModule", { value: !0 }), op.schemaHasRulesForType = e, op.shouldUseGroup = t, op.shouldUseRule = r;
  function e({ schema: n, self: o }, a) {
    const i = o.RULES.types[a];
    return i && i !== !0 && t(n, i);
  }
  function t(n, o) {
    return o.rules.some((a) => r(n, a));
  }
  function r(n, o) {
    var a;
    return n[o.keyword] !== void 0 || ((a = o.definition.implements) === null || a === void 0 ? void 0 : a.some((i) => n[i] !== void 0));
  }
  return op;
}
var jE;
function vv() {
  if (jE) return ws;
  jE = 1, Object.defineProperty(ws, "__esModule", { value: !0 }), ws.DataType = void 0, ws.getSchemaTypes = i, ws.getJSONTypes = u, ws.coerceAndCheckDataType = c, ws.checkDataType = S, ws.checkDataTypes = k, ws.reportTypeError = x;
  const e = o$(), t = a$(), r = ob(), n = Ct(), o = Mt();
  var a;
  (function(_) {
    _[_.Correct = 0] = "Correct", _[_.Wrong = 1] = "Wrong";
  })(a || (ws.DataType = a = {}));
  function i(_) {
    const O = u(_.type);
    if (O.includes("null")) {
      if (_.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!O.length && _.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      _.nullable === !0 && O.push("null");
    }
    return O;
  }
  function u(_) {
    const O = Array.isArray(_) ? _ : _ ? [_] : [];
    if (O.every(e.isJSONType))
      return O;
    throw new Error("type must be JSONType or JSONType[]: " + O.join(","));
  }
  function c(_, O) {
    const { gen: R, data: C, opts: T } = _, j = m(O, T.coerceTypes), D = O.length > 0 && !(j.length === 0 && O.length === 1 && (0, t.schemaHasRulesForType)(_, O[0]));
    if (D) {
      const V = k(O, C, T.strictNumbers, a.Wrong);
      R.if(V, () => {
        j.length ? g(_, O, j) : x(_);
      });
    }
    return D;
  }
  const d = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function m(_, O) {
    return O ? _.filter((R) => d.has(R) || O === "array" && R === "array") : [];
  }
  function g(_, O, R) {
    const { gen: C, data: T, opts: j } = _, D = C.let("dataType", (0, n._)`typeof ${T}`), V = C.let("coerced", (0, n._)`undefined`);
    j.coerceTypes === "array" && C.if((0, n._)`${D} == 'object' && Array.isArray(${T}) && ${T}.length == 1`, () => C.assign(T, (0, n._)`${T}[0]`).assign(D, (0, n._)`typeof ${T}`).if(k(O, T, j.strictNumbers), () => C.assign(V, T))), C.if((0, n._)`${V} !== undefined`);
    for (const ne of R)
      (d.has(ne) || ne === "array" && j.coerceTypes === "array") && U(ne);
    C.else(), x(_), C.endIf(), C.if((0, n._)`${V} !== undefined`, () => {
      C.assign(T, V), v(_, V);
    });
    function U(ne) {
      switch (ne) {
        case "string":
          C.elseIf((0, n._)`${D} == "number" || ${D} == "boolean"`).assign(V, (0, n._)`"" + ${T}`).elseIf((0, n._)`${T} === null`).assign(V, (0, n._)`""`);
          return;
        case "number":
          C.elseIf((0, n._)`${D} == "boolean" || ${T} === null
              || (${D} == "string" && ${T} && ${T} == +${T})`).assign(V, (0, n._)`+${T}`);
          return;
        case "integer":
          C.elseIf((0, n._)`${D} === "boolean" || ${T} === null
              || (${D} === "string" && ${T} && ${T} == +${T} && !(${T} % 1))`).assign(V, (0, n._)`+${T}`);
          return;
        case "boolean":
          C.elseIf((0, n._)`${T} === "false" || ${T} === 0 || ${T} === null`).assign(V, !1).elseIf((0, n._)`${T} === "true" || ${T} === 1`).assign(V, !0);
          return;
        case "null":
          C.elseIf((0, n._)`${T} === "" || ${T} === 0 || ${T} === false`), C.assign(V, null);
          return;
        case "array":
          C.elseIf((0, n._)`${D} === "string" || ${D} === "number"
              || ${D} === "boolean" || ${T} === null`).assign(V, (0, n._)`[${T}]`);
      }
    }
  }
  function v({ gen: _, parentData: O, parentDataProperty: R }, C) {
    _.if((0, n._)`${O} !== undefined`, () => _.assign((0, n._)`${O}[${R}]`, C));
  }
  function S(_, O, R, C = a.Correct) {
    const T = C === a.Correct ? n.operators.EQ : n.operators.NEQ;
    let j;
    switch (_) {
      case "null":
        return (0, n._)`${O} ${T} null`;
      case "array":
        j = (0, n._)`Array.isArray(${O})`;
        break;
      case "object":
        j = (0, n._)`${O} && typeof ${O} == "object" && !Array.isArray(${O})`;
        break;
      case "integer":
        j = D((0, n._)`!(${O} % 1) && !isNaN(${O})`);
        break;
      case "number":
        j = D();
        break;
      default:
        return (0, n._)`typeof ${O} ${T} ${_}`;
    }
    return C === a.Correct ? j : (0, n.not)(j);
    function D(V = n.nil) {
      return (0, n.and)((0, n._)`typeof ${O} == "number"`, V, R ? (0, n._)`isFinite(${O})` : n.nil);
    }
  }
  function k(_, O, R, C) {
    if (_.length === 1)
      return S(_[0], O, R, C);
    let T;
    const j = (0, o.toHash)(_);
    if (j.array && j.object) {
      const D = (0, n._)`typeof ${O} != "object"`;
      T = j.null ? D : (0, n._)`!${O} || ${D}`, delete j.null, delete j.array, delete j.object;
    } else
      T = n.nil;
    j.number && delete j.integer;
    for (const D in j)
      T = (0, n.and)(T, S(D, O, R, C));
    return T;
  }
  const b = {
    message: ({ schema: _ }) => `must be ${_}`,
    params: ({ schema: _, schemaValue: O }) => typeof _ == "string" ? (0, n._)`{type: ${_}}` : (0, n._)`{type: ${O}}`
  };
  function x(_) {
    const O = A(_);
    (0, r.reportError)(O, b);
  }
  function A(_) {
    const { gen: O, data: R, schema: C } = _, T = (0, o.schemaRefOrVal)(_, C, "type");
    return {
      gen: O,
      keyword: "type",
      data: R,
      schema: C.type,
      schemaCode: T,
      schemaValue: T,
      parentSchema: C,
      params: {},
      it: _
    };
  }
  return ws;
}
var Cg = {}, LE;
function Rz() {
  if (LE) return Cg;
  LE = 1, Object.defineProperty(Cg, "__esModule", { value: !0 }), Cg.assignDefaults = r;
  const e = Ct(), t = Mt();
  function r(o, a) {
    const { properties: i, items: u } = o.schema;
    if (a === "object" && i)
      for (const c in i)
        n(o, c, i[c].default);
    else a === "array" && Array.isArray(u) && u.forEach((c, d) => n(o, d, c.default));
  }
  function n(o, a, i) {
    const { gen: u, compositeRule: c, data: d, opts: m } = o;
    if (i === void 0)
      return;
    const g = (0, e._)`${d}${(0, e.getProperty)(a)}`;
    if (c) {
      (0, t.checkStrictMode)(o, `default is ignored for: ${g}`);
      return;
    }
    let v = (0, e._)`${g} === undefined`;
    m.useDefaults === "empty" && (v = (0, e._)`${v} || ${g} === null || ${g} === ""`), u.if(v, (0, e._)`${g} = ${(0, e.stringify)(i)}`);
  }
  return Cg;
}
var Su = {}, bn = {}, ME;
function Is() {
  if (ME) return bn;
  ME = 1, Object.defineProperty(bn, "__esModule", { value: !0 }), bn.checkReportMissingProp = o, bn.checkMissingProp = a, bn.reportMissingProp = i, bn.hasPropFunc = u, bn.isOwnProperty = c, bn.propertyInData = d, bn.noPropertyInData = m, bn.allSchemaProperties = g, bn.schemaProperties = v, bn.callValidateCode = S, bn.usePattern = b, bn.validateArray = x, bn.validateUnion = A;
  const e = Ct(), t = Mt(), r = Rs(), n = Mt();
  function o(_, O) {
    const { gen: R, data: C, it: T } = _;
    R.if(m(R, C, O, T.opts.ownProperties), () => {
      _.setParams({ missingProperty: (0, e._)`${O}` }, !0), _.error();
    });
  }
  function a({ gen: _, data: O, it: { opts: R } }, C, T) {
    return (0, e.or)(...C.map((j) => (0, e.and)(m(_, O, j, R.ownProperties), (0, e._)`${T} = ${j}`)));
  }
  function i(_, O) {
    _.setParams({ missingProperty: O }, !0), _.error();
  }
  function u(_) {
    return _.scopeValue("func", {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ref: Object.prototype.hasOwnProperty,
      code: (0, e._)`Object.prototype.hasOwnProperty`
    });
  }
  function c(_, O, R) {
    return (0, e._)`${u(_)}.call(${O}, ${R})`;
  }
  function d(_, O, R, C) {
    const T = (0, e._)`${O}${(0, e.getProperty)(R)} !== undefined`;
    return C ? (0, e._)`${T} && ${c(_, O, R)}` : T;
  }
  function m(_, O, R, C) {
    const T = (0, e._)`${O}${(0, e.getProperty)(R)} === undefined`;
    return C ? (0, e.or)(T, (0, e.not)(c(_, O, R))) : T;
  }
  function g(_) {
    return _ ? Object.keys(_).filter((O) => O !== "__proto__") : [];
  }
  function v(_, O) {
    return g(O).filter((R) => !(0, t.alwaysValidSchema)(_, O[R]));
  }
  function S({ schemaCode: _, data: O, it: { gen: R, topSchemaRef: C, schemaPath: T, errorPath: j }, it: D }, V, U, ne) {
    const H = ne ? (0, e._)`${_}, ${O}, ${C}${T}` : O, ae = [
      [r.default.instancePath, (0, e.strConcat)(r.default.instancePath, j)],
      [r.default.parentData, D.parentData],
      [r.default.parentDataProperty, D.parentDataProperty],
      [r.default.rootData, r.default.rootData],
      [r.default.isAllOfVariant, D.isAllOfVariant ? 1 : 0]
    ];
    D.opts.dynamicRef && ae.push([r.default.dynamicAnchors, r.default.dynamicAnchors]);
    const ge = (0, e._)`${H}, ${R.object(...ae)}`;
    return U !== e.nil ? (0, e._)`${V}.call(${U}, ${ge})` : (0, e._)`${V}(${ge})`;
  }
  const k = (0, e._)`new RegExp`;
  function b({ gen: _, it: { opts: O } }, R) {
    const C = O.unicodeRegExp ? "u" : "", { regExp: T } = O.code, j = T(R, C);
    return _.scopeValue("pattern", {
      key: j.toString(),
      ref: j,
      code: (0, e._)`${T.code === "new RegExp" ? k : (0, n.useFunc)(_, T)}(${R}, ${C})`
    });
  }
  function x(_) {
    const { gen: O, data: R, keyword: C, it: T } = _, j = O.name("valid");
    if (T.allErrors) {
      const V = O.let("valid", !0);
      return D(() => O.assign(V, !1)), V;
    }
    return O.var(j, !0), D(() => O.break()), j;
    function D(V) {
      const U = O.const("len", (0, e._)`${R}.length`);
      O.forRange("i", 0, U, (ne) => {
        _.subschema({
          keyword: C,
          dataProp: ne,
          dataPropType: t.Type.Num
        }, j), O.if((0, e.not)(j), V);
      });
    }
  }
  function A(_) {
    const { gen: O, schema: R, keyword: C, parentSchema: T, it: j } = _;
    if (!Array.isArray(R))
      throw new Error("ajv implementation error");
    if (j.opts.discriminator && T.discriminator || R.some((ne) => (0, t.alwaysValidSchema)(j, ne)) && !j.opts.unevaluated)
      return;
    const V = O.let("valid", !1), U = O.name("_valid");
    O.block(() => R.forEach((ne, H) => {
      const ae = _.subschema({
        keyword: C,
        schemaProp: H,
        compositeRule: !0
      }, U);
      O.assign(V, (0, e._)`${V} || ${U}`), _.mergeValidEvaluated(ae, U) || O.if((0, e.not)(V));
    })), _.result(V, () => _.reset(), () => _.error(!0));
  }
  return bn;
}
var DE;
function Iz() {
  if (DE) return Su;
  DE = 1, Object.defineProperty(Su, "__esModule", { value: !0 }), Su.macroKeywordCode = o, Su.funcKeywordCode = a, Su.validSchemaType = m, Su.validateKeywordUsage = g;
  const e = Ct(), t = Rs(), r = Is(), n = ob();
  function o(v, S) {
    const { gen: k, keyword: b, schema: x, parentSchema: A, it: _ } = v, O = S.macro.call(_.self, x, A, _), R = d(k, b, O);
    _.opts.validateSchema !== !1 && _.self.validateSchema(O, !0);
    const C = k.name("valid");
    v.subschema({
      schema: O,
      schemaPath: e.nil,
      errSchemaPath: `${_.errSchemaPath}/${b}`,
      topSchemaRef: R,
      compositeRule: !0
    }, C), v.pass(C, () => v.error(!0));
  }
  function a(v, S) {
    var k;
    const { gen: b, keyword: x, schema: A, parentSchema: _, $data: O, it: R } = v;
    c(R, S);
    const C = !O && S.compile ? S.compile.call(R.self, A, _, R) : S.validate, T = d(b, x, C), j = b.let("valid");
    v.block$data(j, D), v.ok((k = S.valid) !== null && k !== void 0 ? k : j);
    function D() {
      if (S.errors === !1)
        ne(), S.modifying && i(v), H(() => v.error());
      else {
        const ae = S.async ? V() : U();
        S.modifying && i(v), H(() => u(v, ae));
      }
    }
    function V() {
      const ae = b.let("ruleErrs", null);
      return b.try(() => ne((0, e._)`await `), (ge) => b.assign(j, !1).if((0, e._)`${ge} instanceof ${R.ValidationError}`, () => b.assign(ae, (0, e._)`${ge}.errors`), () => b.throw(ge))), ae;
    }
    function U() {
      const ae = (0, e._)`${T}.errors`;
      return b.assign(ae, null), ne(e.nil), ae;
    }
    function ne(ae = S.async ? (0, e._)`await ` : e.nil) {
      const ge = R.opts.passContext ? t.default.this : t.default.self, fe = !("compile" in S && !O || S.schema === !1);
      b.assign(j, (0, e._)`${ae}${(0, r.callValidateCode)(v, T, ge, fe)}`, S.modifying);
    }
    function H(ae) {
      var ge;
      b.if((0, e.not)((ge = S.valid) !== null && ge !== void 0 ? ge : j), ae);
    }
  }
  function i(v) {
    const { gen: S, data: k, it: b } = v;
    S.if(b.parentData, () => S.assign(k, (0, e._)`${b.parentData}[${b.parentDataProperty}]`));
  }
  function u(v, S) {
    const { gen: k } = v;
    k.if((0, e._)`Array.isArray(${S})`, () => {
      k.assign(t.default.vErrors, (0, e._)`${t.default.vErrors} === null ? ${S} : ${t.default.vErrors}.concat(${S})`).assign(t.default.errors, (0, e._)`${t.default.vErrors}.length`), (0, n.extendErrors)(v);
    }, () => v.error());
  }
  function c({ schemaEnv: v }, S) {
    if (S.async && !v.$async)
      throw new Error("async keyword in sync schema");
  }
  function d(v, S, k) {
    if (k === void 0)
      throw new Error(`keyword "${S}" failed to compile`);
    return v.scopeValue("keyword", typeof k == "function" ? { ref: k } : { ref: k, code: (0, e.stringify)(k) });
  }
  function m(v, S, k = !1) {
    return !S.length || S.some((b) => b === "array" ? Array.isArray(v) : b === "object" ? v && typeof v == "object" && !Array.isArray(v) : typeof v == b || k && typeof v > "u");
  }
  function g({ schema: v, opts: S, self: k, errSchemaPath: b }, x, A) {
    if (Array.isArray(x.keyword) ? !x.keyword.includes(A) : x.keyword !== A)
      throw new Error("ajv implementation error");
    const _ = x.dependencies;
    if (_ != null && _.some((O) => !Object.prototype.hasOwnProperty.call(v, O)))
      throw new Error(`parent schema must have dependencies of ${A}: ${_.join(",")}`);
    if (x.validateSchema && !x.validateSchema(v[A])) {
      const R = `keyword "${A}" value is invalid at path "${b}": ` + k.errorsText(x.validateSchema.errors);
      if (S.validateSchema === "log")
        k.logger.error(R);
      else
        throw new Error(R);
    }
  }
  return Su;
}
var ap = {}, FE;
function Nz() {
  if (FE) return ap;
  FE = 1, Object.defineProperty(ap, "__esModule", { value: !0 }), ap.getSubschema = r, ap.extendSubschemaData = n, ap.extendSubschemaMode = o;
  const e = Ct(), t = Mt();
  function r(a, { keyword: i, schemaProp: u, schema: c, schemaPath: d, errSchemaPath: m, topSchemaRef: g }) {
    if (i !== void 0 && c !== void 0)
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    if (i !== void 0) {
      const v = a.schema[i];
      return u === void 0 ? {
        schema: v,
        schemaPath: (0, e._)`${a.schemaPath}${(0, e.getProperty)(i)}`,
        errSchemaPath: `${a.errSchemaPath}/${i}`
      } : {
        schema: v[u],
        schemaPath: (0, e._)`${a.schemaPath}${(0, e.getProperty)(i)}${(0, e.getProperty)(u)}`,
        errSchemaPath: `${a.errSchemaPath}/${i}/${(0, t.escapeFragment)(u)}`
      };
    }
    if (c !== void 0) {
      if (d === void 0 || m === void 0 || g === void 0)
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      return {
        schema: c,
        schemaPath: d,
        topSchemaRef: g,
        errSchemaPath: m
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  function n(a, i, { dataProp: u, dataPropType: c, data: d, dataTypes: m, propertyName: g }) {
    if (d !== void 0 && u !== void 0)
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    const { gen: v } = i;
    if (u !== void 0) {
      const { errorPath: k, dataPathArr: b, opts: x } = i, A = v.let("data", (0, e._)`${i.data}${(0, e.getProperty)(u)}`, !0);
      S(A), a.errorPath = (0, e.str)`${k}${(0, t.getErrorPath)(u, c, x.jsPropertySyntax)}`, a.parentDataProperty = (0, e._)`${u}`, a.dataPathArr = [...b, a.parentDataProperty];
    }
    if (d !== void 0) {
      const k = d instanceof e.Name ? d : v.let("data", d, !0);
      S(k), g !== void 0 && (a.propertyName = g);
    }
    m && (a.dataTypes = m);
    function S(k) {
      a.data = k, a.dataLevel = i.dataLevel + 1, a.dataTypes = [], i.definedProperties = /* @__PURE__ */ new Set(), a.parentData = i.data, a.dataNames = [...i.dataNames, k];
    }
  }
  function o(a, { jtdDiscriminator: i, jtdMetadata: u, compositeRule: c, createErrors: d, allErrors: m }) {
    c !== void 0 && (a.compositeRule = c), d !== void 0 && (a.createErrors = d), m !== void 0 && (a.allErrors = m), a.jtdDiscriminator = i, a.jtdMetadata = u;
  }
  return ap;
}
var ra = {}, hw, qE;
function l$() {
  return qE || (qE = 1, hw = function e(t, r) {
    if (t === r) return !0;
    if (t && r && typeof t == "object" && typeof r == "object") {
      if (t.constructor !== r.constructor) return !1;
      var n, o, a;
      if (Array.isArray(t)) {
        if (n = t.length, n != r.length) return !1;
        for (o = n; o-- !== 0; )
          if (!e(t[o], r[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === r.source && t.flags === r.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === r.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === r.toString();
      if (a = Object.keys(t), n = a.length, n !== Object.keys(r).length) return !1;
      for (o = n; o-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(r, a[o])) return !1;
      for (o = n; o-- !== 0; ) {
        var i = a[o];
        if (!e(t[i], r[i])) return !1;
      }
      return !0;
    }
    return t !== t && r !== r;
  }), hw;
}
var mw = { exports: {} }, zE;
function jz() {
  if (zE) return mw.exports;
  zE = 1;
  var e = mw.exports = function(n, o, a) {
    typeof o == "function" && (a = o, o = {}), a = o.cb || a;
    var i = typeof a == "function" ? a : a.pre || function() {
    }, u = a.post || function() {
    };
    t(o, i, u, n, "", n);
  };
  e.keywords = {
    additionalItems: !0,
    items: !0,
    contains: !0,
    additionalProperties: !0,
    propertyNames: !0,
    not: !0,
    if: !0,
    then: !0,
    else: !0
  }, e.arrayKeywords = {
    items: !0,
    allOf: !0,
    anyOf: !0,
    oneOf: !0
  }, e.propsKeywords = {
    $defs: !0,
    definitions: !0,
    properties: !0,
    patternProperties: !0,
    dependencies: !0
  }, e.skipKeywords = {
    default: !0,
    enum: !0,
    const: !0,
    required: !0,
    maximum: !0,
    minimum: !0,
    exclusiveMaximum: !0,
    exclusiveMinimum: !0,
    multipleOf: !0,
    maxLength: !0,
    minLength: !0,
    pattern: !0,
    format: !0,
    maxItems: !0,
    minItems: !0,
    uniqueItems: !0,
    maxProperties: !0,
    minProperties: !0
  };
  function t(n, o, a, i, u, c, d, m, g, v) {
    if (i && typeof i == "object" && !Array.isArray(i)) {
      o(i, u, c, d, m, g, v);
      for (var S in i) {
        var k = i[S];
        if (Array.isArray(k)) {
          if (S in e.arrayKeywords)
            for (var b = 0; b < k.length; b++)
              t(n, o, a, k[b], u + "/" + S + "/" + b, c, u, S, i, b);
        } else if (S in e.propsKeywords) {
          if (k && typeof k == "object")
            for (var x in k)
              t(n, o, a, k[x], u + "/" + S + "/" + r(x), c, u, S, i, x);
        } else (S in e.keywords || n.allKeys && !(S in e.skipKeywords)) && t(n, o, a, k, u + "/" + S, c, u, S, i);
      }
      a(i, u, c, d, m, g, v);
    }
  }
  function r(n) {
    return n.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  return mw.exports;
}
var BE;
function ab() {
  if (BE) return ra;
  BE = 1, Object.defineProperty(ra, "__esModule", { value: !0 }), ra.inlineRef = o, ra.getFullPath = c, ra._getFullPath = d, ra.normalizeId = g, ra.resolveUrl = v, ra.getSchemaRefs = k;
  const e = Mt(), t = l$(), r = jz(), n = /* @__PURE__ */ new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function o(b, x = !0) {
    return typeof b == "boolean" ? !0 : x === !0 ? !i(b) : x ? u(b) <= x : !1;
  }
  const a = /* @__PURE__ */ new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function i(b) {
    for (const x in b) {
      if (a.has(x))
        return !0;
      const A = b[x];
      if (Array.isArray(A) && A.some(i) || typeof A == "object" && i(A))
        return !0;
    }
    return !1;
  }
  function u(b) {
    let x = 0;
    for (const A in b) {
      if (A === "$ref")
        return 1 / 0;
      if (x++, !n.has(A) && (typeof b[A] == "object" && (0, e.eachItem)(b[A], (_) => x += u(_)), x === 1 / 0))
        return 1 / 0;
    }
    return x;
  }
  function c(b, x = "", A) {
    A !== !1 && (x = g(x));
    const _ = b.parse(x);
    return d(b, _);
  }
  function d(b, x) {
    return b.serialize(x).split("#")[0] + "#";
  }
  const m = /#\/?$/;
  function g(b) {
    return b ? b.replace(m, "") : "";
  }
  function v(b, x, A) {
    return A = g(A), b.resolve(x, A);
  }
  const S = /^[a-z_][-a-z0-9._]*$/i;
  function k(b, x) {
    if (typeof b == "boolean")
      return {};
    const { schemaId: A, uriResolver: _ } = this.opts, O = g(b[A] || x), R = { "": O }, C = c(_, O, !1), T = {}, j = /* @__PURE__ */ new Set();
    return r(b, { allKeys: !0 }, (U, ne, H, ae) => {
      if (ae === void 0)
        return;
      const ge = C + ne;
      let fe = R[ae];
      typeof U[A] == "string" && (fe = ve.call(this, U[A])), $e.call(this, U.$anchor), $e.call(this, U.$dynamicAnchor), R[ne] = fe;
      function ve(ce) {
        const se = this.opts.uriResolver.resolve;
        if (ce = g(fe ? se(fe, ce) : ce), j.has(ce))
          throw V(ce);
        j.add(ce);
        let te = this.refs[ce];
        return typeof te == "string" && (te = this.refs[te]), typeof te == "object" ? D(U, te.schema, ce) : ce !== g(ge) && (ce[0] === "#" ? (D(U, T[ce], ce), T[ce] = U) : this.refs[ce] = ge), ce;
      }
      function $e(ce) {
        if (typeof ce == "string") {
          if (!S.test(ce))
            throw new Error(`invalid anchor "${ce}"`);
          ve.call(this, `#${ce}`);
        }
      }
    }), T;
    function D(U, ne, H) {
      if (ne !== void 0 && !t(U, ne))
        throw V(H);
    }
    function V(U) {
      return new Error(`reference "${U}" resolves to more than one schema`);
    }
  }
  return ra;
}
var UE;
function lb() {
  if (UE) return wu;
  UE = 1, Object.defineProperty(wu, "__esModule", { value: !0 }), wu.KeywordCxt = void 0, wu.validateFunctionCode = v, wu.getData = Ne;
  const e = $z(), t = vv(), r = a$(), n = vv(), o = Rz(), a = Iz(), i = Nz(), u = Ct(), c = Rs(), d = ab(), m = Mt(), g = ob();
  function v(N) {
    if (C(N) && (j(N), R(N))) {
      x(N);
      return;
    }
    S(N, () => (0, e.topBoolOrEmptySchema)(N));
  }
  function S({ gen: N, validateName: B, schema: oe, schemaEnv: ie, opts: he }, Z) {
    he.code.es5 ? N.func(B, (0, u._)`${c.default.data}, ${c.default.valCxt}`, ie.$async, () => {
      N.code((0, u._)`"use strict"; ${_(oe, he)}`), b(N, he), N.code(Z);
    }) : N.func(B, (0, u._)`${c.default.data}, ${k(he)}`, ie.$async, () => N.code(_(oe, he)).code(Z));
  }
  function k(N) {
    return (0, u._)`{${c.default.instancePath}="", ${c.default.parentData}, ${c.default.parentDataProperty}, ${c.default.rootData}=${c.default.data}${N.dynamicRef ? (0, u._)`, ${c.default.dynamicAnchors}={}` : u.nil}, ${c.default.isAllOfVariant} = 0}={}`;
  }
  function b(N, B) {
    N.if(c.default.valCxt, () => {
      N.var(c.default.instancePath, (0, u._)`${c.default.valCxt}.${c.default.instancePath}`), N.var(c.default.parentData, (0, u._)`${c.default.valCxt}.${c.default.parentData}`), N.var(c.default.parentDataProperty, (0, u._)`${c.default.valCxt}.${c.default.parentDataProperty}`), N.var(c.default.rootData, (0, u._)`${c.default.valCxt}.${c.default.rootData}`), N.var(c.default.isAllOfVariant, (0, u._)`${c.default.valCxt}.${c.default.isAllOfVariant}`), B.dynamicRef && N.var(c.default.dynamicAnchors, (0, u._)`${c.default.valCxt}.${c.default.dynamicAnchors}`);
    }, () => {
      N.var(c.default.instancePath, (0, u._)`""`), N.var(c.default.parentData, (0, u._)`undefined`), N.var(c.default.parentDataProperty, (0, u._)`undefined`), N.var(c.default.rootData, c.default.data), N.var(c.default.isAllOfVariant, (0, u._)`0`), B.dynamicRef && N.var(c.default.dynamicAnchors, (0, u._)`{}`);
    });
  }
  function x(N) {
    const { schema: B, opts: oe, gen: ie } = N;
    S(N, () => {
      oe.$comment && B.$comment && ae(N), U(N), ie.let(c.default.vErrors, null), ie.let(c.default.errors, 0), oe.unevaluated && A(N), D(N), ge(N);
    });
  }
  function A(N) {
    const { gen: B, validateName: oe } = N;
    N.evaluated = B.const("evaluated", (0, u._)`${oe}.evaluated`), B.if((0, u._)`${N.evaluated}.dynamicProps`, () => B.assign((0, u._)`${N.evaluated}.props`, (0, u._)`undefined`)), B.if((0, u._)`${N.evaluated}.dynamicItems`, () => B.assign((0, u._)`${N.evaluated}.items`, (0, u._)`undefined`));
  }
  function _(N, B) {
    const oe = typeof N == "object" && N[B.schemaId];
    return oe && (B.code.source || B.code.process) ? (0, u._)`/*# sourceURL=${oe} */` : u.nil;
  }
  function O(N, B) {
    if (C(N) && (j(N), R(N))) {
      T(N, B);
      return;
    }
    (0, e.boolOrEmptySchema)(N, B);
  }
  function R({ schema: N, self: B }) {
    if (typeof N == "boolean")
      return !N;
    for (const oe in N)
      if (B.RULES.all[oe])
        return !0;
    return !1;
  }
  function C(N) {
    return typeof N.schema != "boolean";
  }
  function T(N, B) {
    const { schema: oe, gen: ie, opts: he } = N;
    he.$comment && oe.$comment && ae(N), ne(N), H(N);
    const Z = ie.const("_errs", c.default.errors);
    D(N, Z), ie.var(B, (0, u._)`${Z} === ${c.default.errors}`);
  }
  function j(N) {
    (0, m.checkUnknownRules)(N), V(N);
  }
  function D(N, B) {
    if (N.opts.jtd)
      return ve(N, [], !1, B);
    const oe = (0, t.getSchemaTypes)(N.schema), ie = (0, t.coerceAndCheckDataType)(N, oe);
    ve(N, oe, !ie, B);
  }
  function V(N) {
    const { schema: B, errSchemaPath: oe, opts: ie, self: he } = N;
    B.$ref && ie.ignoreKeywordsWithRef && (0, m.schemaHasRulesButRef)(B, he.RULES) && he.logger.warn(`$ref: keywords ignored in schema at path "${oe}"`);
  }
  function U(N) {
    const { schema: B, opts: oe } = N;
    B.default !== void 0 && oe.useDefaults && oe.strictSchema && (0, m.checkStrictMode)(N, "default is ignored in the schema root");
  }
  function ne(N) {
    const B = N.schema[N.opts.schemaId];
    B && (N.baseId = (0, d.resolveUrl)(N.opts.uriResolver, N.baseId, B));
  }
  function H(N) {
    if (N.schema.$async && !N.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function ae({ gen: N, schemaEnv: B, schema: oe, errSchemaPath: ie, opts: he }) {
    const Z = oe.$comment;
    if (he.$comment === !0)
      N.code((0, u._)`${c.default.self}.logger.log(${Z})`);
    else if (typeof he.$comment == "function") {
      const re = (0, u.str)`${ie}/$comment`, Pe = N.scopeValue("root", { ref: B.root });
      N.code((0, u._)`${c.default.self}.opts.$comment(${Z}, ${re}, ${Pe}.schema)`);
    }
  }
  function ge(N) {
    const { gen: B, schemaEnv: oe, validateName: ie, ValidationError: he, opts: Z } = N;
    oe.$async ? B.if((0, u._)`${c.default.errors} === 0`, () => B.return(c.default.data), () => B.throw((0, u._)`new ${he}(${c.default.vErrors})`)) : (B.assign((0, u._)`${ie}.errors`, c.default.vErrors), Z.unevaluated && fe(N), B.return((0, u._)`${c.default.errors} === 0`));
  }
  function fe({ gen: N, evaluated: B, props: oe, items: ie }) {
    oe instanceof u.Name && N.assign((0, u._)`${B}.props`, oe), ie instanceof u.Name && N.assign((0, u._)`${B}.items`, ie);
  }
  function ve(N, B, oe, ie) {
    const { gen: he, schema: Z, data: re, allErrors: Pe, opts: Oe, self: qe } = N, { RULES: je } = qe;
    if (Z.$ref && (Oe.ignoreKeywordsWithRef || !(0, m.schemaHasRulesButRef)(Z, je))) {
      he.block(() => Q(N, "$ref", je.all.$ref.definition));
      return;
    }
    Oe.jtd || ce(N, B), he.block(() => {
      for (const K of je.rules)
        $(K);
      $(je.post);
    });
    function $(K) {
      (0, r.shouldUseGroup)(Z, K) && (K.type ? (he.if((0, n.checkDataType)(K.type, re, Oe.strictNumbers)), $e(N, K), B.length === 1 && B[0] === K.type && oe && (he.else(), (0, n.reportTypeError)(N)), he.endIf()) : $e(N, K), Pe || he.if((0, u._)`${c.default.errors} === ${ie || 0}`));
    }
  }
  function $e(N, B) {
    const { gen: oe, schema: ie, opts: { useDefaults: he } } = N;
    he && (0, o.assignDefaults)(N, B.type), oe.block(() => {
      for (const re of B.rules)
        ((0, r.shouldUseRule)(ie, re) || Z(ie, re)) && Q(N, re.keyword, re.definition, B.type);
    });
    function Z(re, Pe) {
      return !!(Pe.keyword === "unevaluatedProperties" && (re.properties || re.patternProperties) && !N.isAllOfVariant && N.opts.defaultUnevaluatedProperties === !1);
    }
  }
  function ce(N, B) {
    N.schemaEnv.meta || !N.opts.strictTypes || (se(N, B), N.opts.allowUnionTypes || te(N, B), F(N, N.dataTypes));
  }
  function se(N, B) {
    if (B.length) {
      if (!N.dataTypes.length) {
        N.dataTypes = B;
        return;
      }
      B.forEach((oe) => {
        W(N.dataTypes, oe) || q(N, `type "${oe}" not allowed by context "${N.dataTypes.join(",")}"`);
      }), N.dataTypes = N.dataTypes.filter((oe) => W(B, oe));
    }
  }
  function te(N, B) {
    B.length > 1 && !(B.length === 2 && B.includes("null")) && q(N, "use allowUnionTypes to allow union type keyword");
  }
  function F(N, B) {
    const oe = N.self.RULES.all;
    for (const ie in oe) {
      const he = oe[ie];
      if (typeof he == "object" && (0, r.shouldUseRule)(N.schema, he)) {
        const { type: Z } = he.definition;
        Z.length && !Z.some((re) => J(B, re)) && q(N, `missing type "${Z.join(",")}" for keyword "${ie}"`);
      }
    }
  }
  function J(N, B) {
    return N.includes(B) || B === "number" && N.includes("integer");
  }
  function W(N, B) {
    return N.includes(B) || B === "integer" && N.includes("number");
  }
  function q(N, B) {
    const oe = N.schemaEnv.baseId + N.errSchemaPath;
    B += ` at "${oe}" (strictTypes)`, (0, m.checkStrictMode)(N, B, N.opts.strictTypes);
  }
  class X {
    constructor(B, oe, ie) {
      if ((0, a.validateKeywordUsage)(B, oe, ie), this.gen = B.gen, this.allErrors = B.allErrors, this.keyword = ie, this.data = B.data, this.schema = B.schema[ie], this.$data = oe.$data && B.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, m.schemaRefOrVal)(B, this.schema, ie, this.$data), this.schemaType = oe.schemaType, this.parentSchema = B.schema, this.params = {}, this.it = B, this.def = oe, this.$data)
        this.schemaCode = B.gen.const("vSchema", Ne(this.$data, B));
      else if (this.schemaCode = this.schemaValue, !(0, a.validSchemaType)(this.schema, oe.schemaType, oe.allowUndefined))
        throw new Error(`${ie} value must be ${JSON.stringify(oe.schemaType)}`);
      ("code" in oe ? oe.trackErrors : oe.errors !== !1) && (this.errsCount = B.gen.const("_errs", c.default.errors));
    }
    result(B, oe, ie) {
      this.failResult((0, u.not)(B), oe, ie);
    }
    failResult(B, oe, ie) {
      this.gen.if(B), ie ? ie() : this.error(), oe ? (this.gen.else(), oe(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    pass(B, oe) {
      this.failResult((0, u.not)(B), void 0, oe);
    }
    fail(B) {
      if (B === void 0) {
        this.error(), this.allErrors || this.gen.if(!1);
        return;
      }
      this.gen.if(B), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    fail$data(B) {
      if (!this.$data)
        return this.fail(B);
      const { schemaCode: oe } = this;
      this.fail((0, u._)`${oe} !== undefined && (${(0, u.or)(this.invalid$data(), B)})`);
    }
    error(B, oe, ie) {
      if (oe) {
        this.setParams(oe), this._error(B, ie), this.setParams({});
        return;
      }
      this._error(B, ie);
    }
    _error(B, oe) {
      (B ? g.reportExtraError : g.reportError)(this, this.def.error, oe);
    }
    $dataError() {
      (0, g.reportError)(this, this.def.$dataError || g.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0)
        throw new Error('add "trackErrors" to keyword definition');
      (0, g.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(B) {
      this.allErrors || this.gen.if(B);
    }
    setParams(B, oe) {
      oe ? Object.assign(this.params, B) : this.params = B;
    }
    block$data(B, oe, ie = u.nil) {
      this.gen.block(() => {
        this.check$data(B, ie), oe();
      });
    }
    check$data(B = u.nil, oe = u.nil) {
      if (!this.$data)
        return;
      const { gen: ie, schemaCode: he, schemaType: Z, def: re } = this;
      ie.if((0, u.or)((0, u._)`${he} === undefined`, oe)), B !== u.nil && ie.assign(B, !0), (Z.length || re.validateSchema) && (ie.elseIf(this.invalid$data()), this.$dataError(), B !== u.nil && ie.assign(B, !1)), ie.else();
    }
    invalid$data() {
      const { gen: B, schemaCode: oe, schemaType: ie, def: he, it: Z } = this;
      return (0, u.or)(re(), Pe());
      function re() {
        if (ie.length) {
          if (!(oe instanceof u.Name))
            throw new Error("ajv implementation error");
          const Oe = Array.isArray(ie) ? ie : [ie];
          return (0, u._)`${(0, n.checkDataTypes)(Oe, oe, Z.opts.strictNumbers, n.DataType.Wrong)}`;
        }
        return u.nil;
      }
      function Pe() {
        if (he.validateSchema) {
          const Oe = B.scopeValue("validate$data", { ref: he.validateSchema });
          return (0, u._)`!${Oe}(${oe})`;
        }
        return u.nil;
      }
    }
    subschema(B, oe, ie) {
      const he = (0, i.getSubschema)(this.it, B);
      (0, i.extendSubschemaData)(he, this.it, B), (0, i.extendSubschemaMode)(he, B);
      const Z = {
        ...this.it,
        ...he,
        items: void 0,
        props: void 0,
        isAllOfVariant: ie
      };
      return O(Z, oe), Z;
    }
    mergeEvaluated(B, oe) {
      const { it: ie, gen: he } = this;
      ie.opts.unevaluated && (ie.props !== !0 && B.props !== void 0 && (ie.props = m.mergeEvaluated.props(he, B.props, ie.props, oe)), ie.items !== !0 && B.items !== void 0 && (ie.items = m.mergeEvaluated.items(he, B.items, ie.items, oe)));
    }
    mergeValidEvaluated(B, oe) {
      const { it: ie, gen: he } = this;
      if (ie.opts.unevaluated && (ie.props !== !0 || ie.items !== !0))
        return he.if(oe, () => this.mergeEvaluated(B, u.Name)), !0;
    }
  }
  wu.KeywordCxt = X;
  function Q(N, B, oe, ie) {
    const he = new X(N, oe, B);
    "code" in oe ? oe.code(he, ie) : he.$data && oe.validate ? (0, a.funcKeywordCode)(he, oe) : "macro" in oe ? (0, a.macroKeywordCode)(he, oe) : (oe.compile || oe.validate) && (0, a.funcKeywordCode)(he, oe);
  }
  const ye = /^\/(?:[^~]|~0|~1)*$/, Se = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function Ne(N, { dataLevel: B, dataNames: oe, dataPathArr: ie }) {
    let he, Z;
    if (N === "")
      return c.default.rootData;
    if (N[0] === "/") {
      if (!ye.test(N))
        throw new Error(`Invalid JSON-pointer: ${N}`);
      he = N, Z = c.default.rootData;
    } else {
      const qe = Se.exec(N);
      if (!qe)
        throw new Error(`Invalid JSON-pointer: ${N}`);
      const je = +qe[1];
      if (he = qe[2], he === "#") {
        if (je >= B)
          throw new Error(Oe("property/index", je));
        return ie[B - je];
      }
      if (je > B)
        throw new Error(Oe("data", je));
      if (Z = oe[B - je], !he)
        return Z;
    }
    let re = Z;
    const Pe = he.split("/");
    for (const qe of Pe)
      qe && (Z = (0, u._)`${Z}${(0, u.getProperty)((0, m.unescapeJsonPointer)(qe))}`, re = (0, u._)`${re} && ${Z}`);
    return re;
    function Oe(qe, je) {
      return `Cannot access ${qe} ${je} levels up, current level is ${B}`;
    }
  }
  return wu;
}
var $g = {}, VE;
function u$() {
  if (VE) return $g;
  VE = 1, Object.defineProperty($g, "__esModule", { value: !0 });
  class e extends Error {
    constructor(r) {
      super("validation failed"), this.errors = r, this.ajv = this.validation = !0;
    }
  }
  return $g.default = e, $g;
}
var Rg = {}, HE;
function c$() {
  if (HE) return Rg;
  HE = 1, Object.defineProperty(Rg, "__esModule", { value: !0 });
  const e = ab();
  class t extends Error {
    constructor(n, o, a, i) {
      super(i || `can't resolve reference ${a} from id ${o}`), this.missingRef = (0, e.resolveUrl)(n, o, a), this.missingSchema = (0, e.normalizeId)((0, e.getFullPath)(n, this.missingRef));
    }
  }
  return Rg.default = t, Rg;
}
var na = {}, WE;
function ub() {
  if (WE) return na;
  WE = 1, Object.defineProperty(na, "__esModule", { value: !0 }), na.SchemaEnv = void 0, na.compileSchema = u, na.resolveRef = c, na.getCompilingSchema = m, na.resolveSchema = S;
  const e = Ct(), t = u$(), r = Rs(), n = ab(), o = Mt(), a = lb();
  class i {
    constructor(A) {
      var _;
      this.refs = {}, this.dynamicAnchors = {};
      let O;
      typeof A.schema == "object" && (O = A.schema), this.schema = A.schema, this.schemaId = A.schemaId, this.root = A.root || this, this.baseId = (_ = A.baseId) !== null && _ !== void 0 ? _ : (0, n.normalizeId)(O == null ? void 0 : O[A.schemaId || "$id"]), this.schemaPath = A.schemaPath, this.localRefs = A.localRefs, this.meta = A.meta, this.$async = O == null ? void 0 : O.$async, this.refs = {};
    }
  }
  na.SchemaEnv = i;
  function u(x) {
    const A = m.call(this, x);
    if (A)
      return A;
    const _ = (0, n.getFullPath)(this.opts.uriResolver, x.root.baseId), { es5: O, lines: R } = this.opts.code, { ownProperties: C } = this.opts, T = new e.CodeGen(this.scope, { es5: O, lines: R, ownProperties: C });
    let j;
    x.$async && (j = T.scopeValue("Error", {
      ref: t.default,
      code: (0, e._)`require("ajv/dist/runtime/validation_error").default`
    }));
    const D = T.scopeName("validate");
    x.validateName = D;
    const V = {
      gen: T,
      allErrors: this.opts.allErrors,
      data: r.default.data,
      parentData: r.default.parentData,
      parentDataProperty: r.default.parentDataProperty,
      dataNames: [r.default.data],
      dataPathArr: [e.nil],
      // TODO can its length be used as dataLevel if nil is removed?
      dataLevel: 0,
      dataTypes: [],
      definedProperties: /* @__PURE__ */ new Set(),
      topSchemaRef: T.scopeValue("schema", this.opts.code.source === !0 ? { ref: x.schema, code: (0, e.stringify)(x.schema) } : { ref: x.schema }),
      validateName: D,
      ValidationError: j,
      schema: x.schema,
      schemaEnv: x,
      rootId: _,
      baseId: x.baseId || _,
      schemaPath: e.nil,
      errSchemaPath: x.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, e._)`""`,
      opts: this.opts,
      self: this
    };
    let U;
    try {
      this._compilations.add(x), (0, a.validateFunctionCode)(V), T.optimize(this.opts.code.optimize);
      const ne = T.toString();
      U = `const visitedNodesForRef = new WeakMap(); ${T.scopeRefs(r.default.scope)}return ${ne}`, this.opts.code.process && (U = this.opts.code.process(U, x));
      const ae = new Function(`${r.default.self}`, `${r.default.scope}`, U)(this, this.scope.get());
      if (this.scope.value(D, { ref: ae }), ae.errors = null, ae.schema = x.schema, ae.schemaEnv = x, x.$async && (ae.$async = !0), this.opts.code.source === !0 && (ae.source = { validateName: D, validateCode: ne, scopeValues: T._values }), this.opts.unevaluated) {
        const { props: ge, items: fe } = V;
        ae.evaluated = {
          props: ge instanceof e.Name ? void 0 : ge,
          items: fe instanceof e.Name ? void 0 : fe,
          dynamicProps: ge instanceof e.Name,
          dynamicItems: fe instanceof e.Name
        }, ae.source && (ae.source.evaluated = (0, e.stringify)(ae.evaluated));
      }
      return x.validate = ae, x;
    } catch (ne) {
      throw delete x.validate, delete x.validateName, U && this.logger.error("Error compiling schema, function code:", U), ne;
    } finally {
      this._compilations.delete(x);
    }
  }
  function c(x, A, _) {
    var O;
    const R = (0, n.resolveUrl)(this.opts.uriResolver, A, _), C = x.refs[R];
    if (C)
      return C;
    let T = v.call(this, x, R);
    if (T === void 0) {
      const j = (O = x.localRefs) === null || O === void 0 ? void 0 : O[R], { schemaId: D } = this.opts;
      j && (T = new i({ schema: j, schemaId: D, root: x, baseId: A }));
    }
    if (T === void 0 && this.opts.loadSchemaSync) {
      const j = this.opts.loadSchemaSync(A, _, R);
      j && !(this.refs[R] || this.schemas[R]) && (this.addSchema(j, R, void 0), T = v.call(this, x, R));
    }
    if (T !== void 0)
      return x.refs[R] = d.call(this, T);
  }
  function d(x) {
    return (0, n.inlineRef)(x.schema, this.opts.inlineRefs) ? x.schema : x.validate ? x : u.call(this, x);
  }
  function m(x) {
    for (const A of this._compilations)
      if (g(A, x))
        return A;
  }
  function g(x, A) {
    return x.schema === A.schema && x.root === A.root && x.baseId === A.baseId;
  }
  function v(x, A) {
    let _;
    for (; typeof (_ = this.refs[A]) == "string"; )
      A = _;
    return _ || this.schemas[A] || S.call(this, x, A);
  }
  function S(x, A) {
    const _ = this.opts.uriResolver.parse(A), O = (0, n._getFullPath)(this.opts.uriResolver, _);
    let R = (0, n.getFullPath)(this.opts.uriResolver, x.baseId, void 0);
    if (Object.keys(x.schema).length > 0 && O === R)
      return b.call(this, _, x);
    const C = (0, n.normalizeId)(O), T = this.refs[C] || this.schemas[C];
    if (typeof T == "string") {
      const j = S.call(this, x, T);
      return typeof (j == null ? void 0 : j.schema) != "object" ? void 0 : b.call(this, _, j);
    }
    if (typeof (T == null ? void 0 : T.schema) == "object") {
      if (T.validate || u.call(this, T), C === (0, n.normalizeId)(A)) {
        const { schema: j } = T, { schemaId: D } = this.opts, V = j[D];
        return V && (R = (0, n.resolveUrl)(this.opts.uriResolver, R, V)), new i({ schema: j, schemaId: D, root: x, baseId: R });
      }
      return b.call(this, _, T);
    }
  }
  const k = /* @__PURE__ */ new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function b(x, { baseId: A, schema: _, root: O }) {
    var R;
    if (((R = x.fragment) === null || R === void 0 ? void 0 : R[0]) !== "/")
      return;
    for (const j of x.fragment.slice(1).split("/")) {
      if (typeof _ == "boolean")
        return;
      const D = _[(0, o.unescapeFragment)(j)];
      if (D === void 0)
        return;
      _ = D;
      const V = typeof _ == "object" && _[this.opts.schemaId];
      !k.has(j) && V && (A = (0, n.resolveUrl)(this.opts.uriResolver, A, V));
    }
    let C;
    if (typeof _ != "boolean" && _.$ref && !(0, o.schemaHasRulesButRef)(_, this.RULES)) {
      const j = (0, n.resolveUrl)(this.opts.uriResolver, A, _.$ref);
      C = S.call(this, O, j);
    }
    const { schemaId: T } = this.opts;
    if (C = C || new i({ schema: _, schemaId: T, root: O, baseId: A }), C.schema !== C.root.schema)
      return C;
  }
  return na;
}
const Lz = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", Mz = "Meta-schema for $data reference (JSON AnySchema extension proposal)", Dz = "object", Fz = ["$data"], qz = { $data: { type: "string", anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }] } }, zz = !1, Bz = {
  $id: Lz,
  description: Mz,
  type: Dz,
  required: Fz,
  properties: qz,
  additionalProperties: zz
};
var Ig = {}, xu = {}, Id = {}, KE;
function TS() {
  if (KE) return Id;
  KE = 1, Object.defineProperty(Id, "__esModule", { value: !0 }), Id.serialize = void 0;
  function e(a) {
    let i = o(a), u;
    try {
      u = new URL(i.startUrl);
    } catch (d) {
      return d.message && console.error(d.message + " " + i.startUrl), "";
    }
    if (a.scheme !== void 0 && !i.temporarySchemeAndHostUsed && !i.temporarySchemeUsed ? u.protocol = a.scheme.toLowerCase() : u.protocol = "", a.host !== void 0 && !i.temporarySchemeAndHostUsed && !i.temporaryHostUsed ? u.host = a.host : u.host = "", a.port && (u.port = String(a.port)), a.path && (u.pathname = a.path), a.userinfo) {
      let d = a.userinfo.split(":");
      d[0] && (u.username = d[0]), d[1] && (u.password = d[1]);
    }
    a.query && (u.search = a.query), a.fragment && (u.hash = a.fragment);
    let c = u.toString();
    return !a.path && c.endsWith("/") && (c = c.slice(0, -1)), i.temporarySchemeAndHostUsed && (c = c.replace(n, ""), c.startsWith("/") && (c = c.slice(1))), i.temporaryHostUsed && (c = c.replace(r, "")), i.temporarySchemeUsed && (c = c.replace(t, "")), c;
  }
  Id.serialize = e;
  const t = "https:", r = "_remove_me_host_", n = t + "//" + r;
  function o(a) {
    let i = {
      startUrl: "",
      temporaryHostUsed: !1,
      temporarySchemeUsed: !1,
      temporarySchemeAndHostUsed: !1
    };
    return a.scheme && a.host ? (i.startUrl = a.scheme + "://" + a.host, i) : a.host ? (i.temporarySchemeUsed = !0, i.startUrl = t + a.host, i) : a.scheme ? a.path ? (i.startUrl = a.scheme + ":" + a.path, i) : (i.temporaryHostUsed = !0, i.startUrl = a.scheme + ":" + r, i) : (i.temporarySchemeAndHostUsed = !0, i.startUrl = n, i);
  }
  return Id;
}
var Nd = {}, QE;
function CS() {
  if (QE) return Nd;
  QE = 1, Object.defineProperty(Nd, "__esModule", { value: !0 }), Nd.parse = void 0;
  function e(n) {
    let o = {
      path: "",
      fragment: void 0,
      host: void 0,
      port: void 0,
      query: void 0,
      reference: void 0,
      scheme: void 0,
      userinfo: void 0
    };
    n.includes("#") && (o.fragment = "");
    let { parsed: a, addedDefaultScheme: i, addedTemporaryHost: u, error: c } = r(n);
    if (c || a === void 0)
      return o.error = c, o;
    if (typeof a.protocol !== void 0 && a.protocol !== "" && !i && (o.scheme = String(a.protocol).replace(":", "")), typeof a.username !== void 0 && a.username !== "") {
      let d = a.username;
      a.password && (d += ":" + a.password), o.userinfo = d;
    }
    return typeof a.hostname !== void 0 && a.hostname !== "" && !u && (o.host = a.hostname, o.host.startsWith("[") && (o.host = o.host.substring(1), o.host = o.host.slice(0, -1))), typeof a.port !== void 0 && a.port !== "" && (o.port = Number(a.port)), typeof a.pathname !== void 0 && a.pathname !== "/" && (o.path = a.pathname, u && o.path.startsWith("/") && (o.path = o.path.substring(1))), typeof a.search !== void 0 && a.search !== "" && (o.query = a.search.replace("?", "")), typeof a.hash !== void 0 && a.hash !== "" && (o.fragment = a.hash.replace("#", "")), o.scheme === void 0 && o.userinfo === void 0 && o.host === void 0 && o.port === void 0 && !o.path && o.query === void 0 ? o.reference = "same-document" : o.scheme === void 0 ? o.reference = "relative" : o.fragment === void 0 ? o.reference = "absolute" : o.reference = "uri", o;
  }
  Nd.parse = e;
  const t = "_remove_me_host/";
  function r(n) {
    let o = {
      parsed: void 0,
      addedDefaultScheme: !1,
      addedTemporaryHost: !1,
      error: void 0
    }, a;
    try {
      return o.parsed = new URL(n), o;
    } catch (i) {
      a = i;
    }
    if (n.startsWith("//"))
      try {
        return o.parsed = new URL("https:" + n), o.addedDefaultScheme = !0, o;
      } catch {
        return o.error = a.message, o;
      }
    try {
      return o.parsed = new URL("https://" + t + n), o.addedDefaultScheme = !0, o.addedTemporaryHost = !0, o;
    } catch {
    }
    return o.error = a.message, o;
  }
  return Nd;
}
var _u = {}, YE;
function Uz() {
  if (YE) return _u;
  YE = 1, Object.defineProperty(_u, "__esModule", { value: !0 }), _u.resolveComponents = _u.resolve = void 0;
  const e = CS(), t = TS();
  function r(a, i, u) {
    const c = Object.assign({ scheme: "null" }, u), d = n((0, e.parse)(a), (0, e.parse)(i), c, !0);
    return (0, t.serialize)(d);
  }
  _u.resolve = r;
  function n(a, i, u, c) {
    const d = {};
    return c || (a = (0, e.parse)((0, t.serialize)(a)), i = (0, e.parse)((0, t.serialize)(i))), u = u || {}, !u.tolerant && i.scheme ? (d.scheme = i.scheme, d.userinfo = i.userinfo, d.host = i.host, d.port = i.port, d.path = o(i.path || ""), d.query = i.query) : (i.userinfo !== void 0 || i.host !== void 0 || i.port !== void 0 ? (d.userinfo = i.userinfo, d.host = i.host, d.port = i.port, d.path = o(i.path || ""), d.query = i.query) : (i.path ? (i.path.charAt(0) === "/" ? d.path = o(i.path) : ((a.userinfo !== void 0 || a.host !== void 0 || a.port !== void 0) && !a.path ? d.path = "/" + i.path : a.path ? d.path = a.path.slice(0, a.path.lastIndexOf("/") + 1) + i.path : d.path = i.path, d.path = o(d.path)), d.query = i.query) : (d.path = a.path, i.query !== void 0 ? d.query = i.query : d.query = a.query), d.userinfo = a.userinfo, d.host = a.host, d.port = a.port), d.scheme = a.scheme), d.fragment = i.fragment, d;
  }
  _u.resolveComponents = n;
  function o(a) {
    const i = /^\.\.?\//u, u = /^\/\.(?:\/|$)/u, c = /^\/\.\.(?:\/|$)/u, d = /^\/?(?:.|\n)*?(?=\/|$)/u, m = [];
    for (; a.length; )
      if (a.match(i))
        a = a.replace(i, "");
      else if (a.match(u))
        a = a.replace(u, "/");
      else if (a.match(c))
        a = a.replace(c, "/"), m.pop();
      else if (a === "." || a === "..")
        a = "";
      else {
        const g = a.match(d);
        if (g) {
          const v = g[0];
          a = a.slice(v.length), m.push(v);
        } else
          throw new Error("Unexpected dot segment condition");
      }
    return m.join("");
  }
  return _u;
}
var GE;
function Vz() {
  return GE || (GE = 1, function(e) {
    var t = xu && xu.__createBinding || (Object.create ? function(u, c, d, m) {
      m === void 0 && (m = d);
      var g = Object.getOwnPropertyDescriptor(c, d);
      (!g || ("get" in g ? !c.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
        return c[d];
      } }), Object.defineProperty(u, m, g);
    } : function(u, c, d, m) {
      m === void 0 && (m = d), u[m] = c[d];
    }), r = xu && xu.__exportStar || function(u, c) {
      for (var d in u) d !== "default" && !Object.prototype.hasOwnProperty.call(c, d) && t(c, u, d);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.normalize = e.equal = void 0;
    const n = TS(), o = CS();
    r(Uz(), e), r(TS(), e), r(CS(), e);
    function a(u, c) {
      let d, m;
      return typeof u == "string" ? d = (0, n.serialize)((0, o.parse)(u)) : d = (0, n.serialize)(u), typeof c == "string" ? m = (0, n.serialize)((0, o.parse)(c)) : m = (0, n.serialize)(c), d.toLowerCase() === m.toLowerCase();
    }
    e.equal = a;
    function i(u) {
      return typeof u == "string" ? (0, n.serialize)((0, o.parse)(u)) : (0, o.parse)((0, n.serialize)(u));
    }
    e.normalize = i;
  }(xu)), xu;
}
var XE;
function Hz() {
  if (XE) return Ig;
  XE = 1, Object.defineProperty(Ig, "__esModule", { value: !0 });
  const e = Vz();
  return e.code = 'require("ajv/dist/runtime/uri").default', Ig.default = e, Ig;
}
var JE;
function Wz() {
  return JE || (JE = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
    var t = lb();
    Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
      return t.KeywordCxt;
    } });
    var r = Ct();
    Object.defineProperty(e, "_", { enumerable: !0, get: function() {
      return r._;
    } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
      return r.str;
    } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
      return r.stringify;
    } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
      return r.nil;
    } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
      return r.Name;
    } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
      return r.CodeGen;
    } });
    const n = u$(), o = c$(), a = o$(), i = ub(), u = Ct(), c = ab(), d = vv(), m = Mt(), g = Bz, v = Hz(), S = (te, F) => new RegExp(te, F);
    S.code = "new RegExp";
    const k = [
      "removeAdditional",
      "useDefaults",
      "coerceTypes",
      "defaultUnevaluatedProperties",
      "defaultAdditionalProperties"
    ], b = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]), x = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    }, A = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    }, _ = 200;
    function O(te) {
      var F, J, W, q, X, Q, ye, Se, Ne, N, B, oe, ie, he, Z, re, Pe, Oe, qe, je, $, K, me, Te, ke;
      const De = te.strict, Fe = (F = te.code) === null || F === void 0 ? void 0 : F.optimize, Xe = Fe === !0 || Fe === void 0 ? 1 : Fe || 0, ct = (W = (J = te.code) === null || J === void 0 ? void 0 : J.regExp) !== null && W !== void 0 ? W : S, mt = (q = te.uriResolver) !== null && q !== void 0 ? q : v.default;
      return {
        strictSchema: (Q = (X = te.strictSchema) !== null && X !== void 0 ? X : De) !== null && Q !== void 0 ? Q : !0,
        strictNumbers: (Se = (ye = te.strictNumbers) !== null && ye !== void 0 ? ye : De) !== null && Se !== void 0 ? Se : !0,
        strictTypes: (N = (Ne = te.strictTypes) !== null && Ne !== void 0 ? Ne : De) !== null && N !== void 0 ? N : "log",
        strictTuples: (oe = (B = te.strictTuples) !== null && B !== void 0 ? B : De) !== null && oe !== void 0 ? oe : "log",
        strictRequired: (he = (ie = te.strictRequired) !== null && ie !== void 0 ? ie : De) !== null && he !== void 0 ? he : !1,
        code: te.code ? { ...te.code, optimize: Xe, regExp: ct } : { optimize: Xe, regExp: ct },
        loopRequired: (Z = te.loopRequired) !== null && Z !== void 0 ? Z : _,
        loopEnum: (re = te.loopEnum) !== null && re !== void 0 ? re : _,
        meta: (Pe = te.meta) !== null && Pe !== void 0 ? Pe : !0,
        messages: (Oe = te.messages) !== null && Oe !== void 0 ? Oe : !0,
        inlineRefs: (qe = te.inlineRefs) !== null && qe !== void 0 ? qe : !0,
        schemaId: (je = te.schemaId) !== null && je !== void 0 ? je : "$id",
        addUsedSchema: ($ = te.addUsedSchema) !== null && $ !== void 0 ? $ : !0,
        validateSchema: (K = te.validateSchema) !== null && K !== void 0 ? K : !0,
        validateFormats: (me = te.validateFormats) !== null && me !== void 0 ? me : !0,
        unicodeRegExp: (Te = te.unicodeRegExp) !== null && Te !== void 0 ? Te : !0,
        int32range: (ke = te.int32range) !== null && ke !== void 0 ? ke : !0,
        uriResolver: mt
      };
    }
    class R {
      constructor(F = {}) {
        this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), F = this.opts = { ...F, ...O(F) };
        const { es5: J, lines: W } = this.opts.code;
        this.scope = new u.ValueScope({ scope: {}, prefixes: b, es5: J, lines: W }), this.logger = H(F.logger);
        const q = F.validateFormats;
        F.validateFormats = !1, this.RULES = (0, a.getRules)(), C.call(this, x, F, "NOT SUPPORTED"), C.call(this, A, F, "DEPRECATED", "warn"), this._metaOpts = U.call(this), F.formats && D.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), F.keywords && V.call(this, F.keywords), typeof F.meta == "object" && this.addMetaSchema(F.meta), j.call(this), F.validateFormats = q;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data: F, meta: J, schemaId: W } = this.opts;
        let q = g;
        W === "id" && (q = { ...g }, q.id = q.$id, delete q.$id), J && F && this.addMetaSchema(q, q[W], !1);
      }
      defaultMeta() {
        const { meta: F, schemaId: J } = this.opts;
        return this.opts.defaultMeta = typeof F == "object" ? F[J] || F : void 0;
      }
      validate(F, J) {
        let W;
        if (typeof F == "string") {
          if (W = this.getSchema(F), !W)
            throw new Error(`no schema with key or ref "${F}"`);
        } else
          W = this.compile(F);
        const q = W(J);
        return "$async" in W || (this.errors = W.errors), q;
      }
      compile(F, J) {
        const W = this._addSchema(F, J);
        return W.validate || this._compileSchemaEnv(W);
      }
      compileAsync(F, J) {
        if (typeof this.opts.loadSchema != "function")
          throw new Error("options.loadSchema should be a function");
        const { loadSchema: W } = this.opts;
        return q.call(this, F, J);
        async function q(N, B) {
          await X.call(this, N.$schema);
          const oe = this._addSchema(N, B);
          return oe.validate || Q.call(this, oe);
        }
        async function X(N) {
          N && !this.getSchema(N) && await q.call(this, { $ref: N }, !0);
        }
        async function Q(N) {
          try {
            return this._compileSchemaEnv(N);
          } catch (B) {
            if (!(B instanceof o.default))
              throw B;
            return ye.call(this, B), await Se.call(this, B.missingSchema), Q.call(this, N);
          }
        }
        function ye({ missingSchema: N, missingRef: B }) {
          if (this.refs[N])
            throw new Error(`AnySchema ${N} is loaded but ${B} cannot be resolved`);
        }
        async function Se(N) {
          const B = await Ne.call(this, N);
          this.refs[N] || await X.call(this, B.$schema), this.refs[N] || this.addSchema(B, N, J);
        }
        async function Ne(N) {
          const B = this._loading[N];
          if (B)
            return B;
          try {
            return await (this._loading[N] = W(N));
          } finally {
            delete this._loading[N];
          }
        }
      }
      // Adds schema to the instance
      addSchema(F, J, W, q = this.opts.validateSchema) {
        if (Array.isArray(F)) {
          for (const Q of F)
            this.addSchema(Q, void 0, W, q);
          return this;
        }
        let X;
        if (typeof F == "object") {
          const { schemaId: Q } = this.opts;
          if (X = F[Q], X !== void 0 && typeof X != "string")
            throw new Error(`schema ${Q} must be string`);
        }
        return J = (0, c.normalizeId)(J || X), this._checkUnique(J), this.schemas[J] = this._addSchema(F, W, J, q, !0), this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(F, J, W = this.opts.validateSchema) {
        return this.addSchema(F, J, !0, W), this;
      }
      //  Validate schema against its meta-schema
      validateSchema(F, J) {
        if (typeof F == "boolean")
          return !0;
        let W;
        if (W = F.$schema, W !== void 0 && typeof W != "string")
          throw new Error("$schema must be a string");
        if (W = W || this.opts.defaultMeta || this.defaultMeta(), !W)
          return this.logger.warn("meta-schema not available"), this.errors = null, !0;
        const q = this.validate(W, F);
        if (!q && J) {
          const X = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(X);
          else
            throw new Error(X);
        }
        return q;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(F) {
        let J;
        for (; typeof (J = T.call(this, F)) == "string"; )
          F = J;
        if (J === void 0) {
          const { schemaId: W } = this.opts, q = new i.SchemaEnv({ schema: {}, schemaId: W });
          if (J = i.resolveSchema.call(this, q, F), !J)
            return;
          this.refs[F] = J;
        }
        return J.validate || this._compileSchemaEnv(J);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(F) {
        if (F instanceof RegExp)
          return this._removeAllSchemas(this.schemas, F), this._removeAllSchemas(this.refs, F), this;
        switch (typeof F) {
          case "undefined":
            return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
          case "string": {
            const J = T.call(this, F);
            return typeof J == "object" && this._cache.delete(J.schema), delete this.schemas[F], delete this.refs[F], this;
          }
          case "object": {
            const J = F;
            this._cache.delete(J);
            let W = F[this.opts.schemaId];
            return W && (W = (0, c.normalizeId)(W), delete this.schemas[W], delete this.refs[W]), this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(F) {
        for (const J of F)
          this.addKeyword(J);
        return this;
      }
      addKeyword(F, J) {
        let W;
        if (typeof F == "string")
          W = F, typeof J == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), J.keyword = W);
        else if (typeof F == "object" && J === void 0) {
          if (J = F, W = J.keyword, Array.isArray(W) && !W.length)
            throw new Error("addKeywords: keyword must be string or non-empty array");
        } else
          throw new Error("invalid addKeywords parameters");
        if (ge.call(this, W, J), !J)
          return (0, m.eachItem)(W, (X) => fe.call(this, X)), this;
        $e.call(this, J);
        const q = {
          ...J,
          type: (0, d.getJSONTypes)(J.type),
          schemaType: (0, d.getJSONTypes)(J.schemaType)
        };
        return (0, m.eachItem)(W, q.type.length === 0 ? (X) => fe.call(this, X, q) : (X) => q.type.forEach((Q) => fe.call(this, X, q, Q))), this;
      }
      getKeyword(F) {
        const J = this.RULES.all[F];
        return typeof J == "object" ? J.definition : !!J;
      }
      // Remove keyword
      removeKeyword(F) {
        const { RULES: J } = this;
        delete J.keywords[F], delete J.all[F];
        for (const W of J.rules) {
          const q = W.rules.findIndex((X) => X.keyword === F);
          q >= 0 && W.rules.splice(q, 1);
        }
        return this;
      }
      // Add format
      addFormat(F, J) {
        return typeof J == "string" && (J = new RegExp(J)), this.formats[F] = J, this;
      }
      errorsText(F = this.errors, { separator: J = ", ", dataVar: W = "data" } = {}) {
        return !F || F.length === 0 ? "No errors" : F.map((q) => `${W}${q.instancePath} ${q.message}`).reduce((q, X) => q + J + X);
      }
      $dataMetaSchema(F, J) {
        const W = this.RULES.all;
        F = JSON.parse(JSON.stringify(F));
        for (const q of J) {
          const X = q.split("/").slice(1);
          let Q = F;
          for (const ye of X)
            Q = Q[ye];
          for (const ye in W) {
            const Se = W[ye];
            if (typeof Se != "object")
              continue;
            const { $data: Ne } = Se.definition, N = Q[ye];
            Ne && N && (Q[ye] = se(N));
          }
        }
        return F;
      }
      _removeAllSchemas(F, J) {
        for (const W in F) {
          const q = F[W];
          (!J || J.test(W)) && (typeof q == "string" ? delete F[W] : q && !q.meta && (this._cache.delete(q.schema), delete F[W]));
        }
      }
      _addSchema(F, J, W, q = this.opts.validateSchema, X = this.opts.addUsedSchema) {
        let Q;
        const { schemaId: ye } = this.opts;
        if (typeof F == "object")
          Q = F[ye];
        else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          if (typeof F != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let Se = this._cache.get(F);
        if (Se !== void 0)
          return Se;
        W = (0, c.normalizeId)(Q || W);
        const Ne = c.getSchemaRefs.call(this, F, W);
        return Se = new i.SchemaEnv({ schema: F, schemaId: ye, meta: J, baseId: W, localRefs: Ne }), this._cache.set(Se.schema, Se), X && !W.startsWith("#") && (W && this._checkUnique(W), this.refs[W] = Se), q && this.validateSchema(F, !0), Se;
      }
      _checkUnique(F) {
        if (this.schemas[F] || this.refs[F])
          throw new Error(`schema with key or id "${F}" already exists`);
      }
      _compileSchemaEnv(F) {
        if (F.meta ? this._compileMetaSchema(F) : i.compileSchema.call(this, F), !F.validate)
          throw new Error("ajv implementation error");
        return F.validate;
      }
      _compileMetaSchema(F) {
        const J = this.opts;
        this.opts = this._metaOpts;
        try {
          i.compileSchema.call(this, F);
        } finally {
          this.opts = J;
        }
      }
    }
    R.ValidationError = n.default, R.MissingRefError = o.default, e.default = R;
    function C(te, F, J, W = "error") {
      for (const q in te) {
        const X = q;
        X in F && this.logger[W](`${J}: option ${q}. ${te[X]}`);
      }
    }
    function T(te) {
      return te = (0, c.normalizeId)(te), this.schemas[te] || this.refs[te];
    }
    function j() {
      const te = this.opts.schemas;
      if (te)
        if (Array.isArray(te))
          this.addSchema(te);
        else
          for (const F in te)
            this.addSchema(te[F], F);
    }
    function D() {
      for (const te in this.opts.formats) {
        const F = this.opts.formats[te];
        F && this.addFormat(te, F);
      }
    }
    function V(te) {
      if (Array.isArray(te)) {
        this.addVocabulary(te);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const F in te) {
        const J = te[F];
        J.keyword || (J.keyword = F), this.addKeyword(J);
      }
    }
    function U() {
      const te = { ...this.opts };
      for (const F of k)
        delete te[F];
      return te;
    }
    const ne = { log() {
    }, warn() {
    }, error() {
    } };
    function H(te) {
      if (te === !1)
        return ne;
      if (te === void 0)
        return console;
      if (te.log && te.warn && te.error)
        return te;
      throw new Error("logger must implement log, warn and error methods");
    }
    const ae = /^[a-z_$][a-z0-9_$:-]*$/i;
    function ge(te, F) {
      const { RULES: J } = this;
      if ((0, m.eachItem)(te, (W) => {
        if (J.keywords[W])
          throw new Error(`Keyword ${W} is already defined`);
        if (!ae.test(W))
          throw new Error(`Keyword ${W} has invalid name`);
      }), !!F && F.$data && !("code" in F || "validate" in F))
        throw new Error('$data keyword must have "code" or "validate" function');
    }
    function fe(te, F, J) {
      var W;
      const q = F == null ? void 0 : F.post;
      if (J && q)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES: X } = this;
      let Q = q ? X.post : X.rules.find(({ type: Se }) => Se === J);
      if (Q || (Q = { type: J, rules: [] }, X.rules.push(Q)), X.keywords[te] = !0, !F)
        return;
      const ye = {
        keyword: te,
        definition: {
          ...F,
          type: (0, d.getJSONTypes)(F.type),
          schemaType: (0, d.getJSONTypes)(F.schemaType)
        }
      };
      F.before ? ve.call(this, Q, ye, F.before) : Q.rules.push(ye), X.all[te] = ye, (W = F.implements) === null || W === void 0 || W.forEach((Se) => this.addKeyword(Se));
    }
    function ve(te, F, J) {
      const W = te.rules.findIndex((q) => q.keyword === J);
      W >= 0 ? te.rules.splice(W, 0, F) : (te.rules.push(F), this.logger.warn(`rule ${J} is not defined`));
    }
    function $e(te) {
      let { metaSchema: F } = te;
      F !== void 0 && (te.$data && this.opts.$data && (F = se(F)), te.validateSchema = this.compile(F, !0));
    }
    const ce = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function se(te) {
      return { anyOf: [te, ce] };
    }
  }(uw)), uw;
}
var Ng = {}, jg = {}, Lg = {}, ZE;
function Kz() {
  if (ZE) return Lg;
  ZE = 1, Object.defineProperty(Lg, "__esModule", { value: !0 });
  const e = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  return Lg.default = e, Lg;
}
var lp = {}, eO;
function Tx() {
  if (eO) return lp;
  eO = 1, Object.defineProperty(lp, "__esModule", { value: !0 }), lp.getValidate = u, lp.callRef = c;
  const e = c$(), t = Is(), r = Ct(), n = Rs(), o = ub(), a = Mt(), i = {
    keyword: "$ref",
    schemaType: "string",
    code(d) {
      const { gen: m, schema: g, it: v } = d, { baseId: S, schemaEnv: k, validateName: b, opts: x, self: A } = v, { root: _ } = k;
      if ((g === "#" || g === "#/") && S === _.baseId)
        return R();
      const O = o.resolveRef.call(A, _, S, g);
      if (O === void 0)
        throw new e.default(v.opts.uriResolver, S, g);
      if (O instanceof o.SchemaEnv)
        return C(O);
      return T(O);
      function R() {
        if (k === _)
          return c(d, b, k, k.$async);
        const j = m.scopeValue("root", { ref: _ });
        return c(d, (0, r._)`${j}.validate`, _, _.$async);
      }
      function C(j) {
        const D = u(d, j);
        c(d, D, j, j.$async);
      }
      function T(j) {
        const D = m.scopeValue("schema", x.code.source === !0 ? { ref: j, code: (0, r.stringify)(j) } : { ref: j }), V = m.name("valid"), U = d.subschema(
          {
            schema: j,
            dataTypes: [],
            schemaPath: r.nil,
            topSchemaRef: D,
            errSchemaPath: g
          },
          V,
          v.isAllOfVariant
          // pass isAllOfVariant into inlined $ref
        );
        d.mergeEvaluated(U), d.ok(V);
      }
    }
  };
  function u(d, m) {
    const { gen: g } = d;
    return m.validate ? g.scopeValue("validate", { ref: m.validate }) : (0, r._)`${g.scopeValue("wrapper", { ref: m })}.validate`;
  }
  function c(d, m, g, v) {
    const { gen: S, it: k } = d, { allErrors: b, schemaEnv: x, opts: A } = k, _ = A.passContext ? n.default.this : r.nil;
    v ? O() : R();
    function O() {
      if (!x.$async)
        throw new Error("async schema referenced by sync schema");
      const j = S.let("valid");
      S.try(() => {
        S.code((0, r._)`await ${(0, t.callValidateCode)(d, m, _)}`), T(m), b || S.assign(j, !0);
      }, (D) => {
        S.if((0, r._)`!(${D} instanceof ${k.ValidationError})`, () => S.throw(D)), C(D), b || S.assign(j, !1);
      }), d.ok(j);
    }
    function R() {
      const j = S.name("visitedNodes");
      S.code((0, r._)`const ${j} = (typeof visitedNodesForRef !== 'undefined') && visitedNodesForRef.get(${m}) || new Set()`), S.if((0, r._)`!${j}.has(${d.data})`, () => {
        S.code((0, r._)`if (typeof visitedNodesForRef !== 'undefined') visitedNodesForRef.set(${m}, ${j})`), S.code((0, r._)`const dataNode = ${d.data}`), S.code((0, r._)`if (typeof dataNode === "object" && dataNode !== null) ${j}.add(dataNode)`);
        const D = d.result((0, t.callValidateCode)(d, m, _), () => T(m), () => C(m));
        return S.code((0, r._)`${j}.delete(dataNode)`), D;
      });
    }
    function C(j) {
      const D = (0, r._)`${j}.errors`;
      S.assign(n.default.vErrors, (0, r._)`${n.default.vErrors} === null ? ${D} : ${n.default.vErrors}.concat(${D})`), S.assign(n.default.errors, (0, r._)`${n.default.vErrors}.length`);
    }
    function T(j) {
      var D;
      if (!k.opts.unevaluated)
        return;
      const V = (D = g == null ? void 0 : g.validate) === null || D === void 0 ? void 0 : D.evaluated;
      if (k.props !== !0)
        if (V && !V.dynamicProps)
          V.props !== void 0 && (k.props = a.mergeEvaluated.props(S, V.props, k.props));
        else {
          const U = S.var("props", (0, r._)`${j}.evaluated.props`);
          k.props = a.mergeEvaluated.props(S, U, k.props, r.Name);
        }
      if (k.items !== !0)
        if (V && !V.dynamicItems)
          V.items !== void 0 && (k.items = a.mergeEvaluated.items(S, V.items, k.items));
        else {
          const U = S.var("items", (0, r._)`${j}.evaluated.items`);
          k.items = a.mergeEvaluated.items(S, U, k.items, r.Name);
        }
    }
  }
  return lp.default = i, lp;
}
var tO;
function Qz() {
  if (tO) return jg;
  tO = 1, Object.defineProperty(jg, "__esModule", { value: !0 });
  const e = Kz(), t = Tx(), r = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    e.default,
    t.default
  ];
  return jg.default = r, jg;
}
var Mg = {}, Dg = {}, rO;
function Yz() {
  if (rO) return Dg;
  rO = 1, Object.defineProperty(Dg, "__esModule", { value: !0 });
  const e = Ct(), t = e.operators, r = {
    maximum: { okStr: "<=", ok: t.LTE, fail: t.GT },
    minimum: { okStr: ">=", ok: t.GTE, fail: t.LT },
    exclusiveMaximum: { okStr: "<", ok: t.LT, fail: t.GTE },
    exclusiveMinimum: { okStr: ">", ok: t.GT, fail: t.LTE }
  }, n = {
    message: ({ keyword: a, schemaCode: i }) => (0, e.str)`must be ${r[a].okStr} ${i}`,
    params: ({ keyword: a, schemaCode: i }) => (0, e._)`{comparison: ${r[a].okStr}, limit: ${i}}`
  }, o = {
    keyword: Object.keys(r),
    type: "number",
    schemaType: "number",
    $data: !0,
    error: n,
    code(a) {
      const { keyword: i, data: u, schemaCode: c } = a;
      a.fail$data((0, e._)`${u} ${r[i].fail} ${c} || isNaN(${u})`);
    }
  };
  return Dg.default = o, Dg;
}
var Fg = {}, nO;
function Gz() {
  if (nO) return Fg;
  nO = 1, Object.defineProperty(Fg, "__esModule", { value: !0 });
  const e = Ct(), r = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: !0,
    error: {
      message: ({ schemaCode: n }) => (0, e.str)`must be multiple of ${n}`,
      params: ({ schemaCode: n }) => (0, e._)`{multipleOf: ${n}}`
    },
    code(n) {
      const { gen: o, data: a, schemaCode: i, it: u } = n, c = u.opts.multipleOfPrecision, d = o.let("res"), m = c ? (0, e._)`Math.abs(Math.round(${d}) - ${d}) > 1e-${c}` : (0, e._)`${d} !== parseInt(${d})`;
      n.fail$data((0, e._)`(${i} === 0 || (${d} = ${a}/${i}, ${m}))`);
    }
  };
  return Fg.default = r, Fg;
}
var qg = {}, zg = {}, iO;
function Xz() {
  if (iO) return zg;
  iO = 1, Object.defineProperty(zg, "__esModule", { value: !0 }), zg.default = e;
  function e(t) {
    const r = t.length;
    let n = 0, o = 0, a;
    for (; o < r; )
      n++, a = t.charCodeAt(o++), a >= 55296 && a <= 56319 && o < r && (a = t.charCodeAt(o), (a & 64512) === 56320 && o++);
    return n;
  }
  return e.code = 'require("ajv/dist/runtime/ucs2length").default', zg;
}
var sO;
function Jz() {
  if (sO) return qg;
  sO = 1, Object.defineProperty(qg, "__esModule", { value: !0 });
  const e = Ct(), t = Mt(), r = Xz(), o = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: a, schemaCode: i }) {
        const u = a === "maxLength" ? "more" : "fewer";
        return (0, e.str)`must NOT have ${u} than ${i} characters`;
      },
      params: ({ schemaCode: a }) => (0, e._)`{limit: ${a}}`
    },
    code(a) {
      const { keyword: i, data: u, schemaCode: c, it: d } = a, m = i === "maxLength" ? e.operators.GT : e.operators.LT, g = d.opts.unicode === !1 ? (0, e._)`${u}.length` : (0, e._)`${(0, t.useFunc)(a.gen, r.default)}(${u})`;
      a.fail$data((0, e._)`${g} ${m} ${c}`);
    }
  };
  return qg.default = o, qg;
}
var Bg = {}, oO;
function Zz() {
  if (oO) return Bg;
  oO = 1, Object.defineProperty(Bg, "__esModule", { value: !0 });
  const e = Is(), t = Ct(), n = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: o }) => (0, t.str)`must match pattern "${o}"`,
      params: ({ schemaCode: o }) => (0, t._)`{pattern: ${o}}`
    },
    code(o) {
      const { data: a, $data: i, schema: u, schemaCode: c, it: d } = o, m = d.opts.unicodeRegExp ? "u" : "", g = i ? (0, t._)`(new RegExp(${c}, ${m}))` : (0, e.usePattern)(o, u);
      o.fail$data((0, t._)`!${g}.test(${a})`);
    }
  };
  return Bg.default = n, Bg;
}
var Ug = {}, aO;
function eB() {
  if (aO) return Ug;
  aO = 1, Object.defineProperty(Ug, "__esModule", { value: !0 });
  const e = Ct(), r = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: n, schemaCode: o }) {
        const a = n === "maxProperties" ? "more" : "fewer";
        return (0, e.str)`must NOT have ${a} than ${o} properties`;
      },
      params: ({ schemaCode: n }) => (0, e._)`{limit: ${n}}`
    },
    code(n) {
      const { keyword: o, data: a, schemaCode: i } = n, u = o === "maxProperties" ? e.operators.GT : e.operators.LT;
      n.fail$data((0, e._)`Object.keys(${a}).length ${u} ${i}`);
    }
  };
  return Ug.default = r, Ug;
}
var Vg = {}, lO;
function tB() {
  if (lO) return Vg;
  lO = 1, Object.defineProperty(Vg, "__esModule", { value: !0 });
  const e = Is(), t = Ct(), r = Mt(), o = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: !0,
    error: {
      message: ({ params: { missingProperty: a } }) => (0, t.str)`must have required property '${a}'`,
      params: ({ params: { missingProperty: a } }) => (0, t._)`{missingProperty: ${a}}`
    },
    code(a) {
      const { gen: i, schema: u, schemaCode: c, data: d, $data: m, it: g } = a, { opts: v } = g;
      if (!m && u.length === 0)
        return;
      const S = u.length >= v.loopRequired;
      if (g.allErrors ? k() : b(), v.strictRequired) {
        const _ = a.parentSchema.properties, { definedProperties: O } = a.it;
        for (const R of u)
          if ((_ == null ? void 0 : _[R]) === void 0 && !O.has(R)) {
            const C = g.schemaEnv.baseId + g.errSchemaPath, T = `required property "${R}" is not defined at "${C}" (strictRequired)`;
            (0, r.checkStrictMode)(g, T, g.opts.strictRequired);
          }
      }
      function k() {
        if (S || m)
          a.block$data(t.nil, x);
        else
          for (const _ of u)
            (0, e.checkReportMissingProp)(a, _);
      }
      function b() {
        const _ = i.let("missing");
        if (S || m) {
          const O = i.let("valid", !0);
          a.block$data(O, () => A(_, O)), a.ok(O);
        } else
          i.if((0, e.checkMissingProp)(a, u, _)), (0, e.reportMissingProp)(a, _), i.else();
      }
      function x() {
        i.forOf("prop", c, (_) => {
          a.setParams({ missingProperty: _ }), i.if((0, e.noPropertyInData)(i, d, _, v.ownProperties), () => a.error());
        });
      }
      function A(_, O) {
        a.setParams({ missingProperty: _ }), i.forOf(_, c, () => {
          i.assign(O, (0, e.propertyInData)(i, d, _, v.ownProperties)), i.if((0, t.not)(O), () => {
            a.error(), i.break();
          });
        }, t.nil);
      }
    }
  };
  return Vg.default = o, Vg;
}
var Hg = {}, uO;
function rB() {
  if (uO) return Hg;
  uO = 1, Object.defineProperty(Hg, "__esModule", { value: !0 });
  const e = Ct(), r = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: n, schemaCode: o }) {
        const a = n === "maxItems" ? "more" : "fewer";
        return (0, e.str)`must NOT have ${a} than ${o} items`;
      },
      params: ({ schemaCode: n }) => (0, e._)`{limit: ${n}}`
    },
    code(n) {
      const { keyword: o, data: a, schemaCode: i } = n, u = o === "maxItems" ? e.operators.GT : e.operators.LT;
      n.fail$data((0, e._)`${a}.length ${u} ${i}`);
    }
  };
  return Hg.default = r, Hg;
}
var Wg = {}, Kg = {}, cO;
function Cx() {
  if (cO) return Kg;
  cO = 1, Object.defineProperty(Kg, "__esModule", { value: !0 });
  const e = l$();
  return e.code = 'require("ajv/dist/runtime/equal").default', Kg.default = e, Kg;
}
var pO;
function nB() {
  if (pO) return Wg;
  pO = 1, Object.defineProperty(Wg, "__esModule", { value: !0 });
  const e = vv(), t = Ct(), r = Mt(), n = Cx(), a = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: !0,
    error: {
      message: ({ params: { i, j: u } }) => (0, t.str)`must NOT have duplicate items (items ## ${u} and ${i} are identical)`,
      params: ({ params: { i, j: u } }) => (0, t._)`{i: ${i}, j: ${u}}`
    },
    code(i) {
      const { gen: u, data: c, $data: d, schema: m, parentSchema: g, schemaCode: v, it: S } = i;
      if (!d && !m)
        return;
      const k = u.let("valid"), b = g.items ? (0, e.getSchemaTypes)(g.items) : [];
      i.block$data(k, x, (0, t._)`${v} === false`), i.ok(k);
      function x() {
        const R = u.let("i", (0, t._)`${c}.length`), C = u.let("j");
        i.setParams({ i: R, j: C }), u.assign(k, !0), u.if((0, t._)`${R} > 1`, () => (A() ? _ : O)(R, C));
      }
      function A() {
        return b.length > 0 && !b.some((R) => R === "object" || R === "array");
      }
      function _(R, C) {
        const T = u.name("item"), j = (0, e.checkDataTypes)(b, T, S.opts.strictNumbers, e.DataType.Wrong), D = u.const("indices", (0, t._)`{}`);
        u.for((0, t._)`;${R}--;`, () => {
          u.let(T, (0, t._)`${c}[${R}]`), u.if(j, (0, t._)`continue`), b.length > 1 && u.if((0, t._)`typeof ${T} == "string"`, (0, t._)`${T} += "_"`), u.if((0, t._)`typeof ${D}[${T}] == "number"`, () => {
            u.assign(C, (0, t._)`${D}[${T}]`), i.error(), u.assign(k, !1).break();
          }).code((0, t._)`${D}[${T}] = ${R}`);
        });
      }
      function O(R, C) {
        const T = (0, r.useFunc)(u, n.default), j = u.name("outer");
        u.label(j).for((0, t._)`;${R}--;`, () => u.for((0, t._)`${C} = ${R}; ${C}--;`, () => u.if((0, t._)`${T}(${c}[${R}], ${c}[${C}])`, () => {
          i.error(), u.assign(k, !1).break(j);
        })));
      }
    }
  };
  return Wg.default = a, Wg;
}
var Qg = {}, fO;
function iB() {
  if (fO) return Qg;
  fO = 1, Object.defineProperty(Qg, "__esModule", { value: !0 });
  const e = Ct(), t = Mt(), r = Cx(), o = {
    keyword: "const",
    $data: !0,
    error: {
      message: "must be equal to constant",
      params: ({ schemaCode: a }) => (0, e._)`{allowedValue: ${a}}`
    },
    code(a) {
      const { gen: i, data: u, $data: c, schemaCode: d, schema: m } = a;
      c || m && typeof m == "object" ? a.fail$data((0, e._)`!${(0, t.useFunc)(i, r.default)}(${u}, ${d})`) : a.fail((0, e._)`${m} !== ${u}`);
    }
  };
  return Qg.default = o, Qg;
}
var Yg = {}, dO;
function sB() {
  if (dO) return Yg;
  dO = 1, Object.defineProperty(Yg, "__esModule", { value: !0 });
  const e = Ct(), t = Mt(), r = Cx(), o = {
    keyword: "enum",
    schemaType: "array",
    $data: !0,
    error: {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode: a }) => (0, e._)`{allowedValues: ${a}}`
    },
    code(a) {
      const { gen: i, data: u, $data: c, schema: d, schemaCode: m, it: g } = a;
      if (!c && d.length === 0)
        throw new Error("enum must have non-empty array");
      const v = d.length >= g.opts.loopEnum;
      let S;
      const k = () => S ?? (S = (0, t.useFunc)(i, r.default));
      let b;
      if (v || c)
        b = i.let("valid"), a.block$data(b, x);
      else {
        if (!Array.isArray(d))
          throw new Error("ajv implementation error");
        const _ = i.const("vSchema", m);
        b = (0, e.or)(...d.map((O, R) => A(_, R)));
      }
      a.pass(b);
      function x() {
        i.assign(b, !1), i.forOf("v", m, (_) => i.if((0, e._)`${k()}(${u}, ${_})`, () => i.assign(b, !0).break()));
      }
      function A(_, O) {
        const R = d[O];
        return typeof R == "object" && R !== null ? (0, e._)`${k()}(${u}, ${_}[${O}])` : (0, e._)`${u} === ${R}`;
      }
    }
  };
  return Yg.default = o, Yg;
}
var hO;
function oB() {
  if (hO) return Mg;
  hO = 1, Object.defineProperty(Mg, "__esModule", { value: !0 });
  const e = Yz(), t = Gz(), r = Jz(), n = Zz(), o = eB(), a = tB(), i = rB(), u = nB(), c = iB(), d = sB(), m = [
    // number
    e.default,
    t.default,
    // string
    r.default,
    n.default,
    // object
    o.default,
    a.default,
    // array
    i.default,
    u.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    c.default,
    d.default
  ];
  return Mg.default = m, Mg;
}
var Gg = {}, jd = {}, mO;
function p$() {
  if (mO) return jd;
  mO = 1, Object.defineProperty(jd, "__esModule", { value: !0 }), jd.validateAdditionalItems = o;
  const e = Ct(), t = Mt(), n = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: a } }) => (0, e.str)`must NOT have more than ${a} items`,
      params: ({ params: { len: a } }) => (0, e._)`{limit: ${a}}`
    },
    code(a) {
      const { parentSchema: i, it: u } = a, { items: c } = i;
      if (!Array.isArray(c)) {
        (0, t.checkStrictMode)(u, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      o(a, c);
    }
  };
  function o(a, i) {
    const { gen: u, schema: c, data: d, keyword: m, it: g } = a;
    g.items = !0;
    const v = u.const("len", (0, e._)`${d}.length`);
    if (c === !1)
      a.setParams({ len: i.length }), a.pass((0, e._)`${v} <= ${i.length}`);
    else if (typeof c == "object" && !(0, t.alwaysValidSchema)(g, c)) {
      const k = u.var("valid", (0, e._)`${v} <= ${i.length}`);
      u.if((0, e.not)(k), () => S(k)), a.ok(k);
    }
    function S(k) {
      u.forRange("i", i.length, v, (b) => {
        a.subschema({ keyword: m, dataProp: b, dataPropType: t.Type.Num }, k), g.allErrors || u.if((0, e.not)(k), () => u.break());
      });
    }
  }
  return jd.default = n, jd;
}
var Xg = {}, Ld = {}, gO;
function f$() {
  if (gO) return Ld;
  gO = 1, Object.defineProperty(Ld, "__esModule", { value: !0 }), Ld.validateTuple = o;
  const e = Ct(), t = Mt(), r = Is(), n = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(a) {
      const { schema: i, it: u } = a;
      if (Array.isArray(i))
        return o(a, "additionalItems", i);
      u.items = !0, !(0, t.alwaysValidSchema)(u, i) && a.ok((0, r.validateArray)(a));
    }
  };
  function o(a, i, u = a.schema) {
    const { gen: c, parentSchema: d, data: m, keyword: g, it: v } = a;
    b(d), v.opts.unevaluated && u.length && v.items !== !0 && (v.items = t.mergeEvaluated.items(c, u.length, v.items));
    const S = c.name("valid"), k = c.const("len", (0, e._)`${m}.length`);
    u.forEach((x, A) => {
      (0, t.alwaysValidSchema)(v, x) || (c.if((0, e._)`${k} > ${A}`, () => a.subschema({
        keyword: g,
        schemaProp: A,
        dataProp: A
      }, S)), a.ok(S));
    });
    function b(x) {
      const { opts: A, errSchemaPath: _ } = v, O = u.length, R = O === x.minItems && (O === x.maxItems || x[i] === !1);
      if (A.strictTuples && !R) {
        const C = `"${g}" is ${O}-tuple, but minItems or maxItems/${i} are not specified or different at path "${_}"`;
        (0, t.checkStrictMode)(v, C, A.strictTuples);
      }
    }
  }
  return Ld.default = n, Ld;
}
var yO;
function aB() {
  if (yO) return Xg;
  yO = 1, Object.defineProperty(Xg, "__esModule", { value: !0 });
  const e = f$(), t = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (r) => (0, e.validateTuple)(r, "items")
  };
  return Xg.default = t, Xg;
}
var Jg = {}, vO;
function lB() {
  if (vO) return Jg;
  vO = 1, Object.defineProperty(Jg, "__esModule", { value: !0 });
  const e = Ct(), t = Mt(), r = Is(), n = p$(), a = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: i } }) => (0, e.str)`must NOT have more than ${i} items`,
      params: ({ params: { len: i } }) => (0, e._)`{limit: ${i}}`
    },
    code(i) {
      const { schema: u, parentSchema: c, it: d } = i, { prefixItems: m } = c;
      d.items = !0, !(0, t.alwaysValidSchema)(d, u) && (m ? (0, n.validateAdditionalItems)(i, m) : i.ok((0, r.validateArray)(i)));
    }
  };
  return Jg.default = a, Jg;
}
var Zg = {}, bO;
function uB() {
  if (bO) return Zg;
  bO = 1, Object.defineProperty(Zg, "__esModule", { value: !0 });
  const e = Ct(), t = Mt(), n = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: !0,
    error: {
      message: ({ params: { min: o, max: a } }) => a === void 0 ? (0, e.str)`must contain at least ${o} valid item(s)` : (0, e.str)`must contain at least ${o} and no more than ${a} valid item(s)`,
      params: ({ params: { min: o, max: a } }) => a === void 0 ? (0, e._)`{minContains: ${o}}` : (0, e._)`{minContains: ${o}, maxContains: ${a}}`
    },
    code(o) {
      const { gen: a, schema: i, parentSchema: u, data: c, it: d } = o;
      let m, g;
      const { minContains: v, maxContains: S } = u;
      d.opts.next ? (m = v === void 0 ? 1 : v, g = S) : m = 1;
      const k = a.const("len", (0, e._)`${c}.length`);
      if (o.setParams({ min: m, max: g }), g === void 0 && m === 0) {
        (0, t.checkStrictMode)(d, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
        return;
      }
      if (g !== void 0 && m > g) {
        (0, t.checkStrictMode)(d, '"minContains" > "maxContains" is always invalid'), o.fail();
        return;
      }
      if ((0, t.alwaysValidSchema)(d, i)) {
        let O = (0, e._)`${k} >= ${m}`;
        g !== void 0 && (O = (0, e._)`${O} && ${k} <= ${g}`), o.pass(O);
        return;
      }
      d.items = !0;
      const b = a.name("valid");
      g === void 0 && m === 1 ? A(b, () => a.if(b, () => a.break())) : m === 0 ? (a.let(b, !0), g !== void 0 && a.if((0, e._)`${c}.length > 0`, x)) : (a.let(b, !1), x()), o.result(b, () => o.reset());
      function x() {
        const O = a.name("_valid"), R = a.let("count", 0);
        A(O, () => a.if(O, () => _(R)));
      }
      function A(O, R) {
        a.forRange("i", 0, k, (C) => {
          o.subschema({
            keyword: "contains",
            dataProp: C,
            dataPropType: t.Type.Num,
            compositeRule: !0
          }, O), R();
        });
      }
      function _(O) {
        a.code((0, e._)`${O}++`), g === void 0 ? a.if((0, e._)`${O} >= ${m}`, () => a.assign(b, !0).break()) : (a.if((0, e._)`${O} > ${g}`, () => a.assign(b, !1).break()), m === 1 ? a.assign(b, !0) : a.if((0, e._)`${O} >= ${m}`, () => a.assign(b, !0)));
      }
    }
  };
  return Zg.default = n, Zg;
}
var gw = {}, wO;
function $x() {
  return wO || (wO = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.error = void 0, e.validatePropertyDeps = i, e.validateSchemaDeps = u;
    const t = Ct(), r = Mt(), n = Is();
    e.error = {
      message: ({ params: { property: c, depsCount: d, deps: m } }) => {
        const g = d === 1 ? "property" : "properties";
        return (0, t.str)`must have ${g} ${m} when property ${c} is present`;
      },
      params: ({ params: { property: c, depsCount: d, deps: m, missingProperty: g } }) => (0, t._)`{property: ${c},
    missingProperty: ${g},
    depsCount: ${d},
    deps: ${m}}`
      // TODO change to reference
    };
    const o = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: e.error,
      code(c) {
        const [d, m] = a(c);
        i(c, d), u(c, m);
      }
    };
    function a({ schema: c }) {
      const d = {}, m = {};
      for (const g in c) {
        if (g === "__proto__")
          continue;
        const v = Array.isArray(c[g]) ? d : m;
        v[g] = c[g];
      }
      return [d, m];
    }
    function i(c, d = c.schema) {
      const { gen: m, data: g, it: v } = c;
      if (Object.keys(d).length === 0)
        return;
      const S = m.let("missing");
      for (const k in d) {
        const b = d[k];
        if (b.length === 0)
          continue;
        const x = (0, n.propertyInData)(m, g, k, v.opts.ownProperties);
        c.setParams({
          property: k,
          depsCount: b.length,
          deps: b.join(", ")
        }), v.allErrors ? m.if(x, () => {
          for (const A of b)
            (0, n.checkReportMissingProp)(c, A);
        }) : (m.if((0, t._)`${x} && (${(0, n.checkMissingProp)(c, b, S)})`), (0, n.reportMissingProp)(c, S), m.else());
      }
    }
    function u(c, d = c.schema) {
      const { gen: m, data: g, keyword: v, it: S } = c, k = m.name("valid");
      for (const b in d)
        (0, r.alwaysValidSchema)(S, d[b]) || (m.if(
          (0, n.propertyInData)(m, g, b, S.opts.ownProperties),
          () => {
            const x = c.subschema({ keyword: v, schemaProp: b }, k);
            c.mergeValidEvaluated(x, k);
          },
          () => m.var(k, !0)
          // TODO var
        ), c.ok(k));
    }
    e.default = o;
  }(gw)), gw;
}
var ey = {}, SO;
function cB() {
  if (SO) return ey;
  SO = 1, Object.defineProperty(ey, "__esModule", { value: !0 });
  const e = Ct(), t = Mt(), n = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: {
      message: "property name must be valid",
      params: ({ params: o }) => (0, e._)`{propertyName: ${o.propertyName}}`
    },
    code(o) {
      const { gen: a, schema: i, data: u, it: c } = o;
      if ((0, t.alwaysValidSchema)(c, i))
        return;
      const d = a.name("valid");
      a.forIn("key", u, (m) => {
        o.setParams({ propertyName: m }), o.subschema({
          keyword: "propertyNames",
          data: m,
          dataTypes: ["string"],
          propertyName: m,
          compositeRule: !0
        }, d), a.if((0, e.not)(d), () => {
          o.error(!0), c.allErrors || a.break();
        });
      }), o.ok(d);
    }
  };
  return ey.default = n, ey;
}
var ty = {}, xO;
function d$() {
  if (xO) return ty;
  xO = 1, Object.defineProperty(ty, "__esModule", { value: !0 });
  const e = Is(), t = Ct(), r = Rs(), n = Mt(), a = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: !0,
    trackErrors: !0,
    error: {
      message: "must NOT have additional properties",
      params: ({ params: i }) => (0, t._)`{additionalProperty: ${i.additionalProperty}}`
    },
    code(i) {
      const { gen: u, parentSchema: c, data: d, errsCount: m, it: g } = i, { schema: v = g.opts.defaultAdditionalProperties } = i;
      if (!m)
        throw new Error("ajv implementation error");
      const { allErrors: S, opts: k } = g;
      if (g.props = !0, k.removeAdditional !== "all" && (0, n.alwaysValidSchema)(g, v))
        return;
      const b = (0, e.allSchemaProperties)(c.properties), x = (0, e.allSchemaProperties)(c.patternProperties);
      A(), i.ok((0, t._)`${m} === ${r.default.errors}`);
      function A() {
        u.forIn("key", d, (T) => {
          !b.length && !x.length ? R(T) : u.if(_(T), () => R(T));
        });
      }
      function _(T) {
        let j;
        if (b.length > 8) {
          const D = (0, n.schemaRefOrVal)(g, c.properties, "properties");
          j = (0, e.isOwnProperty)(u, D, T);
        } else b.length ? j = (0, t.or)(...b.map((D) => (0, t._)`${T} === ${D}`)) : j = t.nil;
        return x.length && (j = (0, t.or)(j, ...x.map((D) => (0, t._)`${(0, e.usePattern)(i, D)}.test(${T})`))), (0, t.not)(j);
      }
      function O(T) {
        u.code((0, t._)`delete ${d}[${T}]`);
      }
      function R(T) {
        if (k.removeAdditional === "all" || k.removeAdditional && v === !1) {
          O(T);
          return;
        }
        if (v === !1) {
          i.setParams({ additionalProperty: T }), i.error(), S || u.break();
          return;
        }
        if (typeof v == "object" && !(0, n.alwaysValidSchema)(g, v)) {
          const j = u.name("valid");
          k.removeAdditional === "failing" ? (C(T, j, !1), u.if((0, t.not)(j), () => {
            i.reset(), O(T);
          })) : (C(T, j), S || u.if((0, t.not)(j), () => u.break()));
        }
      }
      function C(T, j, D) {
        const V = {
          keyword: "additionalProperties",
          dataProp: T,
          dataPropType: n.Type.Str
        };
        D === !1 && Object.assign(V, {
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }), i.subschema(V, j);
      }
    }
  };
  return ty.default = a, ty;
}
var ry = {}, _O;
function pB() {
  if (_O) return ry;
  _O = 1, Object.defineProperty(ry, "__esModule", { value: !0 });
  const e = lb(), t = Is(), r = Mt(), n = d$(), o = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(a) {
      const { gen: i, schema: u, parentSchema: c, data: d, it: m } = a;
      (m.opts.removeAdditional === "all" && c.additionalProperties === void 0 || m.opts.defaultAdditionalProperties === !1) && n.default.code(new e.KeywordCxt(m, n.default, "additionalProperties"));
      const g = (0, t.allSchemaProperties)(u);
      for (const x of g)
        m.definedProperties.add(x);
      m.opts.unevaluated && g.length && m.props !== !0 && (m.props = r.mergeEvaluated.props(i, (0, r.toHash)(g), m.props));
      const v = g.filter((x) => !(0, r.alwaysValidSchema)(m, u[x]));
      if (v.length === 0)
        return;
      const S = i.name("valid");
      for (const x of v)
        k(x) ? b(x) : (i.if((0, t.propertyInData)(i, d, x, m.opts.ownProperties)), b(x), m.allErrors || i.else().var(S, !0), i.endIf()), a.it.definedProperties.add(x), a.ok(S);
      function k(x) {
        return m.opts.useDefaults && !m.compositeRule && u[x].default !== void 0;
      }
      function b(x) {
        a.subschema({
          keyword: "properties",
          schemaProp: x,
          dataProp: x
        }, S);
      }
    }
  };
  return ry.default = o, ry;
}
var ny = {}, EO;
function fB() {
  if (EO) return ny;
  EO = 1, Object.defineProperty(ny, "__esModule", { value: !0 });
  const e = Is(), t = Ct(), r = Mt(), n = Mt(), o = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(a) {
      const { gen: i, schema: u, data: c, parentSchema: d, it: m } = a, { opts: g } = m, v = (0, e.allSchemaProperties)(u), S = v.filter((R) => (0, r.alwaysValidSchema)(m, u[R]));
      if (v.length === 0 || S.length === v.length && (!m.opts.unevaluated || m.props === !0))
        return;
      const k = g.strictSchema && !g.allowMatchingProperties && d.properties, b = i.name("valid");
      m.props !== !0 && !(m.props instanceof t.Name) && (m.props = (0, n.evaluatedPropsToName)(i, m.props));
      const { props: x } = m;
      A();
      function A() {
        for (const R of v)
          k && _(R), m.allErrors ? O(R) : (i.var(b, !0), O(R), i.if(b));
      }
      function _(R) {
        for (const C in k)
          new RegExp(R).test(C) && (0, r.checkStrictMode)(m, `property ${C} matches pattern ${R} (use allowMatchingProperties)`);
      }
      function O(R) {
        i.forIn("key", c, (C) => {
          i.if((0, t._)`${(0, e.usePattern)(a, R)}.test(${C})`, () => {
            const T = S.includes(R);
            T || a.subschema({
              keyword: "patternProperties",
              schemaProp: R,
              dataProp: C,
              dataPropType: n.Type.Str
            }, b), m.opts.unevaluated && x !== !0 ? i.assign((0, t._)`${x}[${C}]`, !0) : !T && !m.allErrors && i.if((0, t.not)(b), () => i.break());
          });
        });
      }
    }
  };
  return ny.default = o, ny;
}
var iy = {}, OO;
function dB() {
  if (OO) return iy;
  OO = 1, Object.defineProperty(iy, "__esModule", { value: !0 });
  const e = Mt(), t = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    code(r) {
      const { gen: n, schema: o, it: a } = r;
      if ((0, e.alwaysValidSchema)(a, o)) {
        r.fail();
        return;
      }
      const i = n.name("valid");
      r.subschema({
        keyword: "not",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, i), r.failResult(i, () => r.reset(), () => r.error());
    },
    error: { message: "must NOT be valid" }
  };
  return iy.default = t, iy;
}
var sy = {}, kO;
function hB() {
  if (kO) return sy;
  kO = 1, Object.defineProperty(sy, "__esModule", { value: !0 });
  const t = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: !0,
    code: Is().validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  return sy.default = t, sy;
}
var oy = {}, AO;
function mB() {
  if (AO) return oy;
  AO = 1, Object.defineProperty(oy, "__esModule", { value: !0 });
  const e = Ct(), t = Mt(), n = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: !0,
    error: {
      message: "must match exactly one schema in oneOf",
      params: ({ params: o }) => (0, e._)`{passingSchemas: ${o.passing}}`
    },
    code(o) {
      const { gen: a, schema: i, parentSchema: u, it: c } = o;
      if (!Array.isArray(i))
        throw new Error("ajv implementation error");
      if (c.opts.discriminator && u.discriminator)
        return;
      const d = i, m = a.let("valid", !1), g = a.let("passing", null), v = a.name("_valid");
      o.setParams({ passing: g }), a.block(S), o.result(m, () => o.reset(), () => o.error(!0));
      function S() {
        d.forEach((k, b) => {
          let x;
          (0, t.alwaysValidSchema)(c, k) ? a.var(v, !0) : x = o.subschema({
            keyword: "oneOf",
            schemaProp: b,
            compositeRule: !0
          }, v), b > 0 && a.if((0, e._)`${v} && ${m}`).assign(m, !1).assign(g, (0, e._)`[${g}, ${b}]`).else(), a.if(v, () => {
            a.assign(m, !0), a.assign(g, b), x && o.mergeEvaluated(x, e.Name);
          });
        });
      }
    }
  };
  return oy.default = n, oy;
}
var ay = {}, PO;
function gB() {
  if (PO) return ay;
  PO = 1, Object.defineProperty(ay, "__esModule", { value: !0 });
  const e = Mt(), t = {
    keyword: "allOf",
    schemaType: "array",
    code(r) {
      const { gen: n, schema: o, it: a } = r;
      if (!Array.isArray(o))
        throw new Error("ajv implementation error");
      const i = n.name("valid");
      o.forEach((u, c) => {
        if ((0, e.alwaysValidSchema)(a, u))
          return;
        const d = r.subschema({ keyword: "allOf", schemaProp: c }, i, !0);
        r.ok(i), r.mergeEvaluated(d);
      });
    }
  };
  return ay.default = t, ay;
}
var ly = {}, TO;
function yB() {
  if (TO) return ly;
  TO = 1, Object.defineProperty(ly, "__esModule", { value: !0 });
  const e = Ct(), t = Mt(), n = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    error: {
      message: ({ params: a }) => (0, e.str)`must match "${a.ifClause}" schema`,
      params: ({ params: a }) => (0, e._)`{failingKeyword: ${a.ifClause}}`
    },
    code(a) {
      const { gen: i, parentSchema: u, it: c } = a;
      u.then === void 0 && u.else === void 0 && (0, t.checkStrictMode)(c, '"if" without "then" and "else" is ignored');
      const d = o(c, "then"), m = o(c, "else");
      if (!d && !m)
        return;
      const g = i.let("valid", !0), v = i.name("_valid");
      if (S(), a.reset(), d && m) {
        const b = i.let("ifClause");
        a.setParams({ ifClause: b }), i.if(v, k("then", b), k("else", b));
      } else d ? i.if(v, k("then")) : i.if((0, e.not)(v), k("else"));
      a.pass(g, () => a.error(!0));
      function S() {
        const b = a.subschema({
          keyword: "if",
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }, v);
        a.mergeEvaluated(b);
      }
      function k(b, x) {
        return () => {
          const A = a.subschema({ keyword: b }, v);
          i.assign(g, v), a.mergeValidEvaluated(A, g), x ? i.assign(x, (0, e._)`${b}`) : a.setParams({ ifClause: b });
        };
      }
    }
  };
  function o(a, i) {
    const u = a.schema[i];
    return u !== void 0 && !(0, t.alwaysValidSchema)(a, u);
  }
  return ly.default = n, ly;
}
var uy = {}, CO;
function vB() {
  if (CO) return uy;
  CO = 1, Object.defineProperty(uy, "__esModule", { value: !0 });
  const e = Mt(), t = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword: r, parentSchema: n, it: o }) {
      n.if === void 0 && (0, e.checkStrictMode)(o, `"${r}" without "if" is ignored`);
    }
  };
  return uy.default = t, uy;
}
var $O;
function bB() {
  if ($O) return Gg;
  $O = 1, Object.defineProperty(Gg, "__esModule", { value: !0 }), Gg.default = x;
  const e = p$(), t = aB(), r = f$(), n = lB(), o = uB(), a = $x(), i = cB(), u = d$(), c = pB(), d = fB(), m = dB(), g = hB(), v = mB(), S = gB(), k = yB(), b = vB();
  function x(A = !1) {
    const _ = [
      // any
      m.default,
      g.default,
      v.default,
      S.default,
      k.default,
      b.default,
      // object
      i.default,
      u.default,
      a.default,
      c.default,
      d.default
    ];
    return A ? _.push(t.default, n.default) : _.push(e.default, r.default), _.push(o.default), _;
  }
  return Gg;
}
var cy = {}, Md = {}, RO;
function h$() {
  if (RO) return Md;
  RO = 1, Object.defineProperty(Md, "__esModule", { value: !0 }), Md.dynamicAnchor = a;
  const e = Ct(), t = Rs(), r = ub(), n = Tx(), o = {
    keyword: "$dynamicAnchor",
    schemaType: "string",
    code: (u) => a(u, u.schema)
  };
  function a(u, c) {
    const { gen: d, it: m } = u;
    m.schemaEnv.root.dynamicAnchors[c] = !0;
    const g = (0, e._)`${t.default.dynamicAnchors}${(0, e.getProperty)(c)}`, v = m.errSchemaPath === "#" ? m.validateName : i(u);
    d.if((0, e._)`!${g}`, () => d.assign(g, v));
  }
  function i(u) {
    const { schemaEnv: c, schema: d, self: m } = u.it, { root: g, baseId: v, localRefs: S, meta: k } = c.root, { schemaId: b } = m.opts, x = new r.SchemaEnv({ schema: d, schemaId: b, root: g, baseId: v, localRefs: S, meta: k });
    return r.compileSchema.call(m, x), (0, n.getValidate)(u, x);
  }
  return Md.default = o, Md;
}
var Dd = {}, IO;
function m$() {
  if (IO) return Dd;
  IO = 1, Object.defineProperty(Dd, "__esModule", { value: !0 }), Dd.dynamicRef = o;
  const e = Ct(), t = Rs(), r = Tx(), n = {
    keyword: "$dynamicRef",
    schemaType: "string",
    code: (a) => o(a, a.schema)
  };
  function o(a, i) {
    const { gen: u, keyword: c, it: d } = a;
    if (i[0] !== "#")
      throw new Error(`"${c}" only supports hash fragment reference`);
    const m = i.slice(1);
    if (d.allErrors)
      g();
    else {
      const S = u.let("valid", !1);
      g(S), a.ok(S);
    }
    function g(S) {
      if (d.schemaEnv.root.dynamicAnchors[m]) {
        const k = u.let("_v", (0, e._)`${t.default.dynamicAnchors}${(0, e.getProperty)(m)}`);
        u.if(k, v(k, S), v(d.validateName, S));
      } else
        v(d.validateName, S)();
    }
    function v(S, k) {
      return k ? () => u.block(() => {
        (0, r.callRef)(a, S), u.let(k, !0);
      }) : () => (0, r.callRef)(a, S);
    }
  }
  return Dd.default = n, Dd;
}
var py = {}, NO;
function wB() {
  if (NO) return py;
  NO = 1, Object.defineProperty(py, "__esModule", { value: !0 });
  const e = h$(), t = Mt(), r = {
    keyword: "$recursiveAnchor",
    schemaType: "boolean",
    code(n) {
      n.schema ? (0, e.dynamicAnchor)(n, "") : (0, t.checkStrictMode)(n.it, "$recursiveAnchor: false is ignored");
    }
  };
  return py.default = r, py;
}
var fy = {}, jO;
function SB() {
  if (jO) return fy;
  jO = 1, Object.defineProperty(fy, "__esModule", { value: !0 });
  const e = m$(), t = {
    keyword: "$recursiveRef",
    schemaType: "string",
    code: (r) => (0, e.dynamicRef)(r, r.schema)
  };
  return fy.default = t, fy;
}
var LO;
function xB() {
  if (LO) return cy;
  LO = 1, Object.defineProperty(cy, "__esModule", { value: !0 });
  const e = h$(), t = m$(), r = wB(), n = SB(), o = [e.default, t.default, r.default, n.default];
  return cy.default = o, cy;
}
var dy = {}, hy = {}, MO;
function _B() {
  if (MO) return hy;
  MO = 1, Object.defineProperty(hy, "__esModule", { value: !0 });
  const e = $x(), t = {
    keyword: "dependentRequired",
    type: "object",
    schemaType: "object",
    error: e.error,
    code: (r) => (0, e.validatePropertyDeps)(r)
  };
  return hy.default = t, hy;
}
var my = {}, DO;
function EB() {
  if (DO) return my;
  DO = 1, Object.defineProperty(my, "__esModule", { value: !0 });
  const e = $x(), t = {
    keyword: "dependentSchemas",
    type: "object",
    schemaType: "object",
    code: (r) => (0, e.validateSchemaDeps)(r)
  };
  return my.default = t, my;
}
var gy = {}, FO;
function OB() {
  if (FO) return gy;
  FO = 1, Object.defineProperty(gy, "__esModule", { value: !0 });
  const e = Mt(), t = {
    keyword: ["maxContains", "minContains"],
    type: "array",
    schemaType: "number",
    code({ keyword: r, parentSchema: n, it: o }) {
      n.contains === void 0 && (0, e.checkStrictMode)(o, `"${r}" without "contains" is ignored`);
    }
  };
  return gy.default = t, gy;
}
var qO;
function kB() {
  if (qO) return dy;
  qO = 1, Object.defineProperty(dy, "__esModule", { value: !0 });
  const e = _B(), t = EB(), r = OB(), n = [e.default, t.default, r.default];
  return dy.default = n, dy;
}
var yy = {}, vy = {}, zO;
function AB() {
  if (zO) return vy;
  zO = 1, Object.defineProperty(vy, "__esModule", { value: !0 });
  const e = Ct(), t = Mt(), r = Rs(), o = {
    keyword: "unevaluatedProperties",
    type: "object",
    schemaType: ["boolean", "object"],
    allowUndefined: !0,
    trackErrors: !0,
    error: {
      message: "must NOT have unevaluated properties",
      params: ({ params: a }) => (0, e._)`{unevaluatedProperty: ${a.unevaluatedProperty}}`
    },
    code(a) {
      const { gen: i, schema: u = a.it.opts.defaultUnevaluatedProperties, data: c, errsCount: d, it: m } = a, g = a.schema === void 0 && a.it.opts.defaultUnevaluatedProperties === !1;
      if (!d)
        throw new Error("ajv implementation error");
      const { allErrors: v, props: S } = m;
      if (S instanceof e.Name)
        i.if((0, e._)`${S} !== true`, () => i.forIn("key", c, (A) => i.if(b(S, A), () => k(A))));
      else if (S !== !0) {
        const A = () => i.forIn("key", c, (_) => S === void 0 ? k(_) : i.if(x(S, _), () => k(_)));
        g && m.errorPath.emptyStr() ? i.if((0, e._)`${r.default.isAllOfVariant} === 0`, A) : A();
      }
      g || (m.props = !0), a.ok((0, e._)`${d} === ${r.default.errors}`);
      function k(A) {
        if (u === !1) {
          a.setParams({ unevaluatedProperty: A }), a.error(), v || i.break();
          return;
        }
        if (!(0, t.alwaysValidSchema)(m, u)) {
          const _ = i.name("valid");
          a.subschema({
            keyword: "unevaluatedProperties",
            dataProp: A,
            dataPropType: t.Type.Str
          }, _), v || i.if((0, e.not)(_), () => i.break());
        }
      }
      function b(A, _) {
        return (0, e._)`!${A} || !${A}[${_}]`;
      }
      function x(A, _) {
        const O = [];
        for (const R in A)
          A[R] === !0 && O.push((0, e._)`${_} !== ${R}`);
        return (0, e.and)(...O);
      }
    }
  };
  return vy.default = o, vy;
}
var by = {}, BO;
function PB() {
  if (BO) return by;
  BO = 1, Object.defineProperty(by, "__esModule", { value: !0 });
  const e = Ct(), t = Mt(), n = {
    keyword: "unevaluatedItems",
    type: "array",
    schemaType: ["boolean", "object"],
    error: {
      message: ({ params: { len: o } }) => (0, e.str)`must NOT have more than ${o} items`,
      params: ({ params: { len: o } }) => (0, e._)`{limit: ${o}}`
    },
    code(o) {
      const { gen: a, schema: i, data: u, it: c } = o, d = c.items || 0;
      if (d === !0)
        return;
      const m = a.const("len", (0, e._)`${u}.length`);
      if (i === !1)
        o.setParams({ len: d }), o.fail((0, e._)`${m} > ${d}`);
      else if (typeof i == "object" && !(0, t.alwaysValidSchema)(c, i)) {
        const v = a.var("valid", (0, e._)`${m} <= ${d}`);
        a.if((0, e.not)(v), () => g(v, d)), o.ok(v);
      }
      c.items = !0;
      function g(v, S) {
        a.forRange("i", S, m, (k) => {
          o.subschema({ keyword: "unevaluatedItems", dataProp: k, dataPropType: t.Type.Num }, v), c.allErrors || a.if((0, e.not)(v), () => a.break());
        });
      }
    }
  };
  return by.default = n, by;
}
var UO;
function TB() {
  if (UO) return yy;
  UO = 1, Object.defineProperty(yy, "__esModule", { value: !0 });
  const e = AB(), t = PB(), r = [e.default, t.default];
  return yy.default = r, yy;
}
var wy = {}, Sy = {}, VO;
function CB() {
  if (VO) return Sy;
  VO = 1, Object.defineProperty(Sy, "__esModule", { value: !0 });
  const e = Ct(), r = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: n }) => (0, e.str)`must match format "${n}"`,
      params: ({ schemaCode: n }) => (0, e._)`{format: ${n}}`
    },
    code(n, o) {
      const { gen: a, data: i, $data: u, schema: c, schemaCode: d, it: m } = n, { opts: g, errSchemaPath: v, schemaEnv: S, self: k } = m;
      if (!g.validateFormats)
        return;
      u ? b() : x();
      function b() {
        const A = a.scopeValue("formats", {
          ref: k.formats,
          code: g.code.formats
        }), _ = a.const("fDef", (0, e._)`${A}[${d}]`), O = a.let("fType"), R = a.let("format");
        a.if((0, e._)`typeof ${_} == "object" && !(${_} instanceof RegExp)`, () => a.assign(O, (0, e._)`${_}.type || "string"`).assign(R, (0, e._)`${_}.validate`), () => a.assign(O, (0, e._)`"string"`).assign(R, _)), n.fail$data((0, e.or)(C(), T()));
        function C() {
          return g.strictSchema === !1 ? e.nil : (0, e._)`${d} && !${R}`;
        }
        function T() {
          const j = S.$async ? (0, e._)`(${_}.async ? await ${R}(${i}) : ${R}(${i}))` : (0, e._)`${R}(${i})`, D = (0, e._)`(typeof ${R} == "function" ? ${j} : ${R}.test(${i}))`;
          return (0, e._)`${R} && ${R} !== true && ${O} === ${o} && !${D}`;
        }
      }
      function x() {
        const A = k.formats[c];
        if (!A) {
          C();
          return;
        }
        if (A === !0)
          return;
        const [_, O, R] = T(A);
        _ === o && n.pass(j());
        function C() {
          if (g.strictSchema === !1) {
            k.logger.warn(D());
            return;
          }
          throw new Error(D());
          function D() {
            return `unknown format "${c}" ignored in schema at path "${v}"`;
          }
        }
        function T(D) {
          const V = D instanceof RegExp ? (0, e.regexpCode)(D) : g.code.formats ? (0, e._)`${g.code.formats}${(0, e.getProperty)(c)}` : void 0, U = a.scopeValue("formats", { key: c, ref: D, code: V });
          return typeof D == "object" && !(D instanceof RegExp) ? [D.type || "string", D.validate, (0, e._)`${U}.validate`] : ["string", D, U];
        }
        function j() {
          if (typeof A == "object" && !(A instanceof RegExp) && A.async) {
            if (!S.$async)
              throw new Error("async format in sync schema");
            return (0, e._)`await ${R}(${i})`;
          }
          return typeof O == "function" ? (0, e._)`${R}(${i})` : (0, e._)`${R}.test(${i})`;
        }
      }
    }
  };
  return Sy.default = r, Sy;
}
var HO;
function $B() {
  if (HO) return wy;
  HO = 1, Object.defineProperty(wy, "__esModule", { value: !0 });
  const t = [CB().default];
  return wy.default = t, wy;
}
var Eu = {}, WO;
function RB() {
  return WO || (WO = 1, Object.defineProperty(Eu, "__esModule", { value: !0 }), Eu.contentVocabulary = Eu.metadataVocabulary = void 0, Eu.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ], Eu.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ]), Eu;
}
var KO;
function IB() {
  if (KO) return Ng;
  KO = 1, Object.defineProperty(Ng, "__esModule", { value: !0 });
  const e = Qz(), t = oB(), r = bB(), n = xB(), o = kB(), a = TB(), i = $B(), u = RB(), c = [
    n.default,
    e.default,
    t.default,
    (0, r.default)(!0),
    i.default,
    u.metadataVocabulary,
    u.contentVocabulary,
    o.default,
    a.default
  ];
  return Ng.default = c, Ng;
}
var xy = {}, Fd = {}, QO;
function NB() {
  if (QO) return Fd;
  QO = 1, Object.defineProperty(Fd, "__esModule", { value: !0 }), Fd.DiscrError = void 0;
  var e;
  return function(t) {
    t.Tag = "tag", t.Mapping = "mapping";
  }(e || (Fd.DiscrError = e = {})), Fd;
}
var YO;
function jB() {
  if (YO) return xy;
  YO = 1, Object.defineProperty(xy, "__esModule", { value: !0 });
  const e = Ct(), t = NB(), r = ub(), n = Mt(), a = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: {
      message: ({ params: { discrError: i, tagName: u } }) => i === t.DiscrError.Tag ? `tag "${u}" must be string` : `value of tag "${u}" must be in oneOf or anyOf`,
      params: ({ params: { discrError: i, tag: u, tagName: c } }) => (0, e._)`{error: ${i}, tag: ${c}, tagValue: ${u}}`
    },
    code(i) {
      const { gen: u, data: c, schema: d, parentSchema: m, it: g } = i, v = m.oneOf ? "oneOf" : m.anyOf ? "anyOf" : void 0;
      if (!g.opts.discriminator)
        throw new Error("discriminator: requires discriminator option");
      const S = d.propertyName;
      if (typeof S != "string")
        throw new Error("discriminator: requires propertyName");
      if (!v)
        throw new Error("discriminator: requires oneOf or anyOf composite keyword");
      const k = m[v], b = u.let("valid", !1), x = u.const("tag", (0, e._)`${c}${(0, e.getProperty)(S)}`);
      u.if((0, e._)`typeof ${x} == "string"`, () => A(), () => i.error(!1, { discrError: t.DiscrError.Tag, tag: x, tagName: S })), i.ok(b);
      function A() {
        const R = O();
        u.if(!1);
        for (const C in R)
          u.elseIf((0, e._)`${x} === ${C}`), u.assign(b, _(R[C]));
        u.else(), i.error(!1, { discrError: t.DiscrError.Mapping, tag: x, tagName: S }), u.endIf();
      }
      function _(R) {
        const C = u.name("valid"), T = i.subschema({ keyword: v, schemaProp: R }, C);
        return i.mergeEvaluated(T, e.Name), C;
      }
      function O() {
        var R;
        const C = {}, T = D(m);
        let j = !0;
        for (let ne = 0; ne < k.length; ne++) {
          let H = k[ne];
          const ae = H == null ? void 0 : H.$ref;
          if (ae && d.mapping) {
            const { mapping: fe } = d, ve = Object.keys(fe).filter(($e) => fe[$e] === H.$ref);
            if (ve.length) {
              for (const $e of ve)
                U($e, ne);
              continue;
            }
          }
          ae && !(0, n.schemaHasRulesButRef)(H, g.self.RULES) && (H = r.resolveRef.call(g.self, g.schemaEnv.root, g.baseId, ae), H instanceof r.SchemaEnv && (H = H.schema));
          const ge = (R = H == null ? void 0 : H.properties) === null || R === void 0 ? void 0 : R[S];
          if (typeof ge != "object")
            throw new Error(`discriminator: ${v} subschemas (or referenced schemas) must have "properties/${S}" or match mapping`);
          j = j && (T || D(H)), V(ge, ne);
        }
        if (!j)
          throw new Error(`discriminator: "${S}" must be required`);
        return C;
        function D({ required: ne }) {
          return Array.isArray(ne) && ne.includes(S);
        }
        function V(ne, H) {
          if (ne.const)
            U(ne.const, H);
          else if (ne.enum)
            for (const ae of ne.enum)
              U(ae, H);
          else
            throw new Error(`discriminator: "properties/${S}" must have "const" or "enum"`);
        }
        function U(ne, H) {
          if (typeof ne != "string" || ne in C)
            throw new Error(`discriminator: "${S}" values must be unique strings`);
          C[ne] = H;
        }
      }
    }
  };
  return xy.default = a, xy;
}
var _y = {};
const LB = "https://json-schema.org/draft/2020-12/schema", MB = "https://json-schema.org/draft/2020-12/schema", DB = { "https://json-schema.org/draft/2020-12/vocab/core": !0, "https://json-schema.org/draft/2020-12/vocab/applicator": !0, "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0, "https://json-schema.org/draft/2020-12/vocab/validation": !0, "https://json-schema.org/draft/2020-12/vocab/meta-data": !0, "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0, "https://json-schema.org/draft/2020-12/vocab/content": !0 }, FB = "meta", qB = "Core and Validation specifications meta-schema", zB = [{ $ref: "meta/core" }, { $ref: "meta/applicator" }, { $ref: "meta/unevaluated" }, { $ref: "meta/validation" }, { $ref: "meta/meta-data" }, { $ref: "meta/format-annotation" }, { $ref: "meta/content" }], BB = ["object", "boolean"], UB = "This meta-schema also defines keywords that have appeared in previous drafts in order to prevent incompatible extensions as they remain in common use.", VB = { definitions: { $comment: '"definitions" has been replaced by "$defs".', type: "object", additionalProperties: { $dynamicRef: "#meta" }, deprecated: !0, default: {} }, dependencies: { $comment: '"dependencies" has been split and replaced by "dependentSchemas" and "dependentRequired" in order to serve their differing semantics.', type: "object", additionalProperties: { anyOf: [{ $dynamicRef: "#meta" }, { $ref: "meta/validation#/$defs/stringArray" }] }, deprecated: !0, default: {} }, $recursiveAnchor: { $comment: '"$recursiveAnchor" has been replaced by "$dynamicAnchor".', $ref: "meta/core#/$defs/anchorString", deprecated: !0 }, $recursiveRef: { $comment: '"$recursiveRef" has been replaced by "$dynamicRef".', $ref: "meta/core#/$defs/uriReferenceString", deprecated: !0 } }, HB = {
  $schema: LB,
  $id: MB,
  $vocabulary: DB,
  $dynamicAnchor: FB,
  title: qB,
  allOf: zB,
  type: BB,
  $comment: UB,
  properties: VB
}, WB = "https://json-schema.org/draft/2020-12/schema", KB = "https://json-schema.org/draft/2020-12/meta/applicator", QB = { "https://json-schema.org/draft/2020-12/vocab/applicator": !0 }, YB = "meta", GB = "Applicator vocabulary meta-schema", XB = ["object", "boolean"], JB = { prefixItems: { $ref: "#/$defs/schemaArray" }, items: { $dynamicRef: "#meta" }, contains: { $dynamicRef: "#meta" }, additionalProperties: { $dynamicRef: "#meta" }, properties: { type: "object", additionalProperties: { $dynamicRef: "#meta" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $dynamicRef: "#meta" }, propertyNames: { format: "regex" }, default: {} }, dependentSchemas: { type: "object", additionalProperties: { $dynamicRef: "#meta" }, default: {} }, propertyNames: { $dynamicRef: "#meta" }, if: { $dynamicRef: "#meta" }, then: { $dynamicRef: "#meta" }, else: { $dynamicRef: "#meta" }, allOf: { $ref: "#/$defs/schemaArray" }, anyOf: { $ref: "#/$defs/schemaArray" }, oneOf: { $ref: "#/$defs/schemaArray" }, not: { $dynamicRef: "#meta" } }, ZB = { schemaArray: { type: "array", minItems: 1, items: { $dynamicRef: "#meta" } } }, e3 = {
  $schema: WB,
  $id: KB,
  $vocabulary: QB,
  $dynamicAnchor: YB,
  title: GB,
  type: XB,
  properties: JB,
  $defs: ZB
}, t3 = "https://json-schema.org/draft/2020-12/schema", r3 = "https://json-schema.org/draft/2020-12/meta/unevaluated", n3 = { "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0 }, i3 = "meta", s3 = "Unevaluated applicator vocabulary meta-schema", o3 = ["object", "boolean"], a3 = { unevaluatedItems: { $dynamicRef: "#meta" }, unevaluatedProperties: { $dynamicRef: "#meta" } }, l3 = {
  $schema: t3,
  $id: r3,
  $vocabulary: n3,
  $dynamicAnchor: i3,
  title: s3,
  type: o3,
  properties: a3
}, u3 = "https://json-schema.org/draft/2020-12/schema", c3 = "https://json-schema.org/draft/2020-12/meta/content", p3 = { "https://json-schema.org/draft/2020-12/vocab/content": !0 }, f3 = "meta", d3 = "Content vocabulary meta-schema", h3 = ["object", "boolean"], m3 = { contentEncoding: { type: "string" }, contentMediaType: { type: "string" }, contentSchema: { $dynamicRef: "#meta" } }, g3 = {
  $schema: u3,
  $id: c3,
  $vocabulary: p3,
  $dynamicAnchor: f3,
  title: d3,
  type: h3,
  properties: m3
}, y3 = "https://json-schema.org/draft/2020-12/schema", v3 = "https://json-schema.org/draft/2020-12/meta/core", b3 = { "https://json-schema.org/draft/2020-12/vocab/core": !0 }, w3 = "meta", S3 = "Core vocabulary meta-schema", x3 = ["object", "boolean"], _3 = { $id: { $ref: "#/$defs/uriReferenceString", $comment: "Non-empty fragments not allowed.", pattern: "^[^#]*#?$" }, $schema: { $ref: "#/$defs/uriString" }, $ref: { $ref: "#/$defs/uriReferenceString" }, $anchor: { $ref: "#/$defs/anchorString" }, $dynamicRef: { $ref: "#/$defs/uriReferenceString" }, $dynamicAnchor: { $ref: "#/$defs/anchorString" }, $vocabulary: { type: "object", propertyNames: { $ref: "#/$defs/uriString" }, additionalProperties: { type: "boolean" } }, $comment: { type: "string" }, $defs: { type: "object", additionalProperties: { $dynamicRef: "#meta" } } }, E3 = { anchorString: { type: "string", pattern: "^[A-Za-z_][-A-Za-z0-9._]*$" }, uriString: { type: "string", format: "uri" }, uriReferenceString: { type: "string", format: "uri-reference" } }, O3 = {
  $schema: y3,
  $id: v3,
  $vocabulary: b3,
  $dynamicAnchor: w3,
  title: S3,
  type: x3,
  properties: _3,
  $defs: E3
}, k3 = "https://json-schema.org/draft/2020-12/schema", A3 = "https://json-schema.org/draft/2020-12/meta/format-annotation", P3 = { "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0 }, T3 = "meta", C3 = "Format vocabulary meta-schema for annotation results", $3 = ["object", "boolean"], R3 = { format: { type: "string" } }, I3 = {
  $schema: k3,
  $id: A3,
  $vocabulary: P3,
  $dynamicAnchor: T3,
  title: C3,
  type: $3,
  properties: R3
}, N3 = "https://json-schema.org/draft/2020-12/schema", j3 = "https://json-schema.org/draft/2020-12/meta/meta-data", L3 = { "https://json-schema.org/draft/2020-12/vocab/meta-data": !0 }, M3 = "meta", D3 = "Meta-data vocabulary meta-schema", F3 = ["object", "boolean"], q3 = { title: { type: "string" }, description: { type: "string" }, default: !0, deprecated: { type: "boolean", default: !1 }, readOnly: { type: "boolean", default: !1 }, writeOnly: { type: "boolean", default: !1 }, examples: { type: "array", items: !0 } }, z3 = {
  $schema: N3,
  $id: j3,
  $vocabulary: L3,
  $dynamicAnchor: M3,
  title: D3,
  type: F3,
  properties: q3
}, B3 = "https://json-schema.org/draft/2020-12/schema", U3 = "https://json-schema.org/draft/2020-12/meta/validation", V3 = { "https://json-schema.org/draft/2020-12/vocab/validation": !0 }, H3 = "meta", W3 = "Validation vocabulary meta-schema", K3 = ["object", "boolean"], Q3 = { type: { anyOf: [{ $ref: "#/$defs/simpleTypes" }, { type: "array", items: { $ref: "#/$defs/simpleTypes" }, minItems: 1, uniqueItems: !0 }] }, const: !0, enum: { type: "array", items: !0 }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/$defs/nonNegativeInteger" }, minLength: { $ref: "#/$defs/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, maxItems: { $ref: "#/$defs/nonNegativeInteger" }, minItems: { $ref: "#/$defs/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: !1 }, maxContains: { $ref: "#/$defs/nonNegativeInteger" }, minContains: { $ref: "#/$defs/nonNegativeInteger", default: 1 }, maxProperties: { $ref: "#/$defs/nonNegativeInteger" }, minProperties: { $ref: "#/$defs/nonNegativeIntegerDefault0" }, required: { $ref: "#/$defs/stringArray" }, dependentRequired: { type: "object", additionalProperties: { $ref: "#/$defs/stringArray" } } }, Y3 = { nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { $ref: "#/$defs/nonNegativeInteger", default: 0 }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] } }, G3 = {
  $schema: B3,
  $id: U3,
  $vocabulary: V3,
  $dynamicAnchor: H3,
  title: W3,
  type: K3,
  properties: Q3,
  $defs: Y3
};
var GO;
function X3() {
  if (GO) return _y;
  GO = 1, Object.defineProperty(_y, "__esModule", { value: !0 }), _y.default = d;
  const e = HB, t = e3, r = l3, n = g3, o = O3, a = I3, i = z3, u = G3, c = ["/properties"];
  function d(m) {
    return [
      e,
      t,
      r,
      n,
      o,
      g(this, a),
      i,
      g(this, u)
    ].forEach((v) => this.addMetaSchema(v, void 0, !1)), this;
    function g(v, S) {
      return m ? v.$dataMetaSchema(S, c) : S;
    }
  }
  return _y;
}
var XO;
function J3() {
  return XO || (XO = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = void 0;
    const r = Wz(), n = IB(), o = jB(), a = X3(), i = "https://json-schema.org/draft/2020-12/schema";
    class u extends r.default {
      constructor(g = {}) {
        super({
          ...g,
          dynamicRef: !0,
          next: !0,
          unevaluated: !0
        });
      }
      _addVocabularies() {
        super._addVocabularies(), n.default.forEach((g) => this.addVocabulary(g)), this.opts.discriminator && this.addKeyword(o.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        const { $data: g, meta: v } = this.opts;
        v && (a.default.call(this, g), this.refs["http://json-schema.org/schema"] = i);
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(i) ? i : void 0);
      }
    }
    e.exports = t = u, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = u;
    var c = lb();
    Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
      return c.KeywordCxt;
    } });
    var d = Ct();
    Object.defineProperty(t, "_", { enumerable: !0, get: function() {
      return d._;
    } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
      return d.str;
    } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
      return d.stringify;
    } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
      return d.nil;
    } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
      return d.Name;
    } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
      return d.CodeGen;
    } });
  }(Pg, Pg.exports)), Pg.exports;
}
var JO;
function Z3() {
  if (JO) return Ag;
  JO = 1, Object.defineProperty(Ag, "__esModule", { value: !0 }), Ag.getNodeTypesFromJSONSchema = i;
  const e = J3(), t = vi(), r = new e.default({
    strictSchema: !1,
    allowUnionTypes: !0,
    useDefaults: !0,
    allErrors: !0,
    discriminator: !0,
    strictTypes: !1,
    verbose: !0
  });
  function n(u, c) {
    if (c.some((d) => typeof d == "function"))
      throw new Error("Unexpected oneOf inside oneOf.");
    return (d) => {
      let m = u.findIndex((g) => r.validate(g, d));
      return m === -1 && (m = 0), c[m];
    };
  }
  function o(u, c, d) {
    var m;
    if (!c || typeof c == "boolean")
      throw new Error(`Unexpected schema in ${u}.`);
    if (c instanceof Array)
      throw new Error(`Unexpected array schema in ${u}. Try using oneOf instead.`);
    if (c.type === "null")
      throw new Error(`Unexpected null schema type in ${u} schema.`);
    if (c.type instanceof Array)
      throw new Error(`Unexpected array schema type in ${u} schema. Try using oneOf instead.`);
    if (c.type === "string" || c.type === "number" || c.type === "integer" || c.type === "boolean") {
      const { default: g, format: v, ...S } = c;
      return S;
    }
    if (c.type === "object" && !c.properties && !c.oneOf) {
      if (c.additionalProperties === void 0 || c.additionalProperties === !0)
        return { type: "object" };
      if (c.additionalProperties === !1)
        return { type: "object", properties: {} };
    }
    if (c.allOf)
      throw new Error(`Unexpected allOf in ${u}.`);
    if (c.anyOf)
      throw new Error(`Unexpected anyOf in ${u}.`);
    if ((0, t.isPlainObject)(c.properties) || (0, t.isPlainObject)(c.additionalProperties) || (0, t.isPlainObject)(c.items) && ((0, t.isPlainObject)(c.items.properties) || (0, t.isPlainObject)(c.items.additionalProperties) || c.items.oneOf))
      return a(u, c, d);
    if (c.oneOf)
      if (c.discriminator) {
        const g = (m = c.discriminator) == null ? void 0 : m.propertyName;
        if (!g)
          throw new Error(`Unexpected discriminator without a propertyName in ${u}.`);
        const v = c.oneOf.map((S, k) => {
          var A;
          if (typeof S == "boolean")
            throw new Error(`Unexpected boolean schema in ${u} at position ${k} in oneOf.`);
          const b = (A = S == null ? void 0 : S.properties) == null ? void 0 : A[g];
          if (!b || typeof b == "boolean")
            throw new Error(`Unexpected property '${b}' schema in ${u} at position ${k} in oneOf.`);
          const x = b.const;
          return o(x, S, d);
        });
        return (S, k) => {
          if ((0, t.isPlainObject)(S)) {
            const b = S[g];
            if (typeof b == "string" && d[b])
              return b;
          }
          return n(c.oneOf, v)(S, k);
        };
      } else {
        const g = c.oneOf.map((v, S) => o(u + "_" + S, v, d));
        return n(c.oneOf, g);
      }
    return c;
  }
  function a(u, c, d) {
    if (!c || typeof c == "boolean")
      throw new Error(`Unexpected schema in ${u}.`);
    if (c instanceof Array)
      throw new Error(`Unexpected array schema in ${u}. Try using oneOf instead.`);
    if (c.type === "null")
      throw new Error(`Unexpected null schema type in ${u} schema.`);
    if (c.type instanceof Array)
      throw new Error(`Unexpected array schema type in ${u} schema. Try using oneOf instead.`);
    const m = {};
    for (const [k, b] of Object.entries(c.properties || {}))
      m[k] = o(u + "." + k, b, d);
    let g;
    (0, t.isPlainObject)(c.additionalProperties) && (g = o(u + "_additionalProperties", c.additionalProperties, d)), c.additionalProperties === !0 && (g = {});
    let v;
    (0, t.isPlainObject)(c.items) && ((0, t.isPlainObject)(c.items.properties) || (0, t.isPlainObject)(c.items.additionalProperties) || c.items.oneOf) && (v = o(u + "_items", c.items, d));
    let S = c.required;
    return c.oneOf && c.oneOf.every((k) => !!k.required) && (S = (k) => {
      const b = c.oneOf.map((A) => [
        ...c.required || [],
        ...A.required
      ]);
      let x = b.findIndex((A) => A.every((_) => k[_] !== void 0));
      return x === -1 && (x = 0), b[x];
    }), d[u] = { properties: m, additionalProperties: g, items: v, required: S }, u;
  }
  function i(u, c) {
    const d = {};
    return o(u, c, d), d;
  }
  return Ag;
}
var ZO;
function eU() {
  return ZO || (ZO = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.NormalizedConfigTypes = e.ConfigTypes = void 0, e.createConfigTypes = Ye;
    const t = Cz, r = mi(), n = Ax(), o = vi(), a = Z3(), i = mi(), u = [
      "info-contact",
      "operation-operationId",
      "tag-description",
      "tags-alphabetical",
      "info-license-url",
      "info-license-strict",
      "info-license",
      "no-ambiguous-paths",
      "no-enum-type-mismatch",
      "no-http-verbs-in-paths",
      "no-identical-paths",
      "no-invalid-parameter-examples",
      "no-invalid-schema-examples",
      "no-path-trailing-slash",
      "operation-2xx-response",
      "operation-4xx-response",
      "operation-description",
      "operation-operationId-unique",
      "operation-operationId-url-safe",
      "operation-parameters-unique",
      "operation-singular-tag",
      "operation-summary",
      "operation-tag-defined",
      "parameter-description",
      "path-declaration-must-exist",
      "path-excludes-patterns",
      "path-http-verbs-order",
      "path-not-include-query",
      "path-params-defined",
      "path-parameters-defined",
      "path-segment-plural",
      "paths-kebab-case",
      "required-string-property-missing-min-length",
      "response-contains-header",
      "scalar-property-missing-example",
      "security-defined",
      "spec-strict-refs",
      "no-unresolved-refs",
      "no-required-schema-properties-undefined",
      "no-schema-type-mismatch",
      "boolean-parameter-prefixes",
      "request-mime-type",
      "response-contains-property",
      "response-mime-type"
    ], c = [
      "info-contact",
      "operation-operationId",
      "tag-description",
      "tags-alphabetical",
      "info-license-url",
      "info-license-strict",
      "info-license",
      "no-ambiguous-paths",
      "no-enum-type-mismatch",
      "no-http-verbs-in-paths",
      "no-identical-paths",
      "no-invalid-parameter-examples",
      "no-invalid-schema-examples",
      "no-path-trailing-slash",
      "operation-2xx-response",
      "operation-4xx-response",
      "operation-description",
      "operation-operationId-unique",
      "operation-operationId-url-safe",
      "operation-parameters-unique",
      "operation-singular-tag",
      "operation-summary",
      "operation-tag-defined",
      "parameter-description",
      "path-declaration-must-exist",
      "path-excludes-patterns",
      "path-http-verbs-order",
      "path-not-include-query",
      "path-params-defined",
      "path-parameters-defined",
      "path-segment-plural",
      "paths-kebab-case",
      "required-string-property-missing-min-length",
      "response-contains-header",
      "scalar-property-missing-example",
      "security-defined",
      "spec-strict-refs",
      "no-unresolved-refs",
      "no-required-schema-properties-undefined",
      "no-schema-type-mismatch",
      "boolean-parameter-prefixes",
      "component-name-unique",
      "no-empty-servers",
      "no-example-value-and-externalValue",
      "no-invalid-media-type-examples",
      "no-server-example.com",
      "no-server-trailing-slash",
      "no-server-variables-empty-enum",
      "no-undefined-server-variable",
      "no-unused-components",
      "operation-4xx-problem-details-rfc7807",
      "request-mime-type",
      "response-contains-property",
      "response-mime-type",
      "spec-components-invalid-map-name",
      "array-parameter-serialization"
    ], d = [
      "info-contact",
      "info-license-strict",
      "operation-operationId",
      "tag-description",
      "tags-alphabetical",
      "channels-kebab-case",
      "no-channel-trailing-slash"
    ], m = [
      "info-contact",
      "info-license-strict",
      "operation-operationId",
      "tag-description",
      "tags-alphabetical",
      "channels-kebab-case",
      "no-channel-trailing-slash"
    ], g = [
      "sourceDescription-type",
      "workflowId-unique",
      "stepId-unique",
      "sourceDescription-name-unique",
      "sourceDescriptions-not-empty",
      "workflow-dependsOn",
      "parameters-unique",
      "step-onSuccess-unique",
      "step-onFailure-unique",
      "respect-supported-versions",
      "requestBody-replacements-unique",
      "no-criteria-xpath",
      "criteria-unique"
    ], v = ["info-contact"], S = [
      ...u,
      ...c,
      ...d,
      ...m,
      ...g,
      ...v,
      "spec",
      // TODO: depricated in favor of struct
      "struct"
    ], k = {
      properties: {
        extends: {
          type: "array",
          items: {
            type: "string"
          }
        },
        rules: "Rules",
        oas2Rules: "Rules",
        oas3_0Rules: "Rules",
        oas3_1Rules: "Rules",
        async2Rules: "Rules",
        arazzo1Rules: "Rules",
        preprocessors: { type: "object" },
        oas2Preprocessors: { type: "object" },
        oas3_0Preprocessors: { type: "object" },
        oas3_1Preprocessors: { type: "object" },
        async2Preprocessors: { type: "object" },
        arazzoPreprocessors: { type: "object" },
        decorators: { type: "object" },
        oas2Decorators: { type: "object" },
        oas3_0Decorators: { type: "object" },
        oas3_1Decorators: { type: "object" },
        async2Decorators: { type: "object" },
        arazzo1Decorators: { type: "object" }
      }
    }, b = (Ge) => ({
      ...Ge.rootRedoclyConfigSchema,
      properties: {
        ...Ge.rootRedoclyConfigSchema.properties,
        ...k.properties,
        apis: "ConfigApis",
        // Override apis with internal format
        "features.openapi": "ConfigReferenceDocs",
        // deprecated
        "features.mockServer": "ConfigMockServer",
        // deprecated
        organization: { type: "string" },
        region: { enum: ["us", "eu"] },
        telemetry: { enum: ["on", "off"] },
        resolve: {
          properties: {
            http: "ConfigHTTP",
            doNotResolveExamples: { type: "boolean" }
          }
        },
        files: {
          type: "array",
          items: {
            type: "string"
          }
        }
      }
    }), x = {
      properties: {},
      additionalProperties: "ConfigApisProperties"
    }, A = (Ge) => {
      var bt;
      return {
        ...Ge["rootRedoclyConfigSchema.apis_additionalProperties"],
        properties: {
          ...(bt = Ge["rootRedoclyConfigSchema.apis_additionalProperties"]) == null ? void 0 : bt.properties,
          labels: {
            type: "array",
            items: {
              type: "string"
            }
          },
          ...k.properties,
          "features.openapi": "ConfigReferenceDocs",
          // deprecated
          "features.mockServer": "ConfigMockServer",
          // deprecated
          files: {
            type: "array",
            items: {
              type: "string"
            }
          }
        }
      };
    }, _ = {
      properties: {
        headers: {
          type: "array",
          items: {
            type: "string"
          }
        }
      }
    }, O = {
      properties: {},
      additionalProperties: (Ge, bt) => {
        if (bt.startsWith("rule/"))
          return typeof Ge == "string" ? { enum: ["error", "warn", "off"] } : "Assert";
        if (bt.startsWith("assert/"))
          return typeof Ge == "string" ? { enum: ["error", "warn", "off"] } : "Assert";
        if (S.includes(bt) || (0, o.isCustomRuleId)(bt))
          return typeof Ge == "string" ? { enum: ["error", "warn", "off"] } : "ObjectRule";
        if (bt === "metadata-schema" || bt === "custom-fields-schema")
          return "Schema";
      }
    }, R = {
      properties: {
        severity: { enum: ["error", "warn", "off"] }
      },
      additionalProperties: {},
      required: ["severity"]
    }, C = {
      properties: {},
      additionalProperties: {}
    };
    function T(Ge) {
      return {
        properties: {
          type: {
            enum: [.../* @__PURE__ */ new Set(["any", ...Ge, "SpecExtension"])]
          },
          property: (bt) => Array.isArray(bt) ? { type: "array", items: { type: "string" } } : bt === null ? null : { type: "string" },
          filterInParentKeys: { type: "array", items: { type: "string" } },
          filterOutParentKeys: { type: "array", items: { type: "string" } },
          matchParentKeys: { type: "string" }
        },
        required: ["type"]
      };
    }
    const j = {
      properties: {
        enum: { type: "array", items: { type: "string" } },
        pattern: { type: "string" },
        notPattern: { type: "string" },
        casing: {
          enum: [
            "camelCase",
            "kebab-case",
            "snake_case",
            "PascalCase",
            "MACRO_CASE",
            "COBOL-CASE",
            "flatcase"
          ]
        },
        mutuallyExclusive: { type: "array", items: { type: "string" } },
        mutuallyRequired: { type: "array", items: { type: "string" } },
        required: { type: "array", items: { type: "string" } },
        requireAny: { type: "array", items: { type: "string" } },
        disallowed: { type: "array", items: { type: "string" } },
        defined: { type: "boolean" },
        // undefined: { type: 'boolean' }, // TODO: Remove `undefined` assertion from codebase overall
        nonEmpty: { type: "boolean" },
        minLength: { type: "integer" },
        maxLength: { type: "integer" },
        ref: (Ge) => typeof Ge == "string" ? { type: "string" } : { type: "boolean" },
        const: (Ge) => {
          if (typeof Ge == "string")
            return { type: "string" };
          if (typeof Ge == "number")
            return { type: "number" };
          if (typeof Ge == "boolean")
            return { type: "boolean" };
        }
      },
      additionalProperties: (Ge, bt) => {
        if (/^\w+\/\w+$/.test(bt))
          return { type: "object" };
      }
    }, D = {
      properties: {
        subject: "AssertionDefinitionSubject",
        assertions: "AssertionDefinitionAssertions"
      },
      required: ["subject", "assertions"]
    }, V = {
      properties: {
        subject: "AssertionDefinitionSubject",
        assertions: "AssertionDefinitionAssertions",
        where: (0, r.listOf)("AssertDefinition"),
        message: { type: "string" },
        suggest: { type: "array", items: { type: "string" } },
        severity: { enum: ["error", "warn", "off"] }
      },
      required: ["subject", "assertions"]
    }, U = {
      properties: {
        label: { type: "string" },
        lang: {
          enum: [
            "curl",
            "C#",
            "Go",
            "Java",
            "Java8+Apache",
            "JavaScript",
            "Node.js",
            "PHP",
            "Python",
            "R",
            "Ruby"
          ]
        }
      },
      required: ["lang"]
    }, ne = {
      properties: {
        enum: { type: "string" },
        enumSingleValue: { type: "string" },
        enumArray: { type: "string" },
        default: { type: "string" },
        deprecated: { type: "string" },
        example: { type: "string" },
        examples: { type: "string" },
        nullable: { type: "string" },
        recursive: { type: "string" },
        arrayOf: { type: "string" },
        webhook: { type: "string" },
        authorizations: { type: "string" },
        tryItAuthBasicUsername: { type: "string" },
        tryItAuthBasicPassword: { type: "string" }
      }
    }, H = {
      properties: {
        beforeInfo: (0, r.listOf)("CommonConfigSidebarLinks"),
        end: (0, r.listOf)("CommonConfigSidebarLinks")
      }
    }, ae = {
      properties: {
        label: { type: "string" },
        link: { type: "string" },
        target: { type: "string" }
      },
      required: ["label", "link"]
    }, ge = {
      properties: {
        main: { type: "string" },
        light: { type: "string" },
        dark: { type: "string" },
        contrastText: { type: "string" }
      }
    }, fe = {
      properties: {
        backgroundColor: { type: "string" },
        borderColor: { type: "string" },
        color: { type: "string" },
        tabTextColor: { type: "string" }
      }
    }, ve = {
      properties: (0, o.pickObjectProps)(ge.properties, ["light", "dark"])
    }, $e = {
      properties: {
        basic: { type: "string" },
        delete: { type: "string" },
        get: { type: "string" },
        head: { type: "string" },
        link: { type: "string" },
        options: { type: "string" },
        patch: { type: "string" },
        post: { type: "string" },
        put: { type: "string" }
      }
    }, ce = {
      properties: {
        error: "CommonColorProps",
        info: "CommonColorProps",
        redirect: "CommonColorProps",
        success: "CommonColorProps"
      }
    }, se = {
      properties: (0, o.omitObjectProps)(ge.properties, ["dark"])
    }, te = {
      properties: {
        primary: { type: "string" },
        secondary: { type: "string" },
        light: { type: "string" }
      }
    }, F = {
      properties: {
        accent: "CommonThemeColors",
        border: "BorderThemeColors",
        error: "CommonThemeColors",
        http: "HttpColors",
        primary: "CommonThemeColors",
        responses: "ResponseColors",
        secondary: "SecondaryColors",
        success: "CommonThemeColors",
        text: "TextThemeColors",
        tonalOffset: { type: "number" },
        warning: "CommonThemeColors"
      }
    }, J = {
      properties: {
        fontSize: { type: "string" },
        padding: { type: "string" },
        minWidth: { type: "string" }
      }
    }, W = {
      properties: {
        small: "SizeProps",
        medium: "SizeProps",
        large: "SizeProps",
        xlarge: "SizeProps"
      }
    }, q = {
      properties: {
        fontFamily: { type: "string" },
        fontSize: { type: "string" },
        fontWeight: { type: "string" },
        lineHeight: { type: "string" }
      }
    }, X = {
      properties: {
        ...(0, o.omitObjectProps)(q.properties, ["fontSize", "lineHeight"]),
        borderRadius: { type: "string" },
        hoverStyle: { type: "string" },
        boxShadow: { type: "string" },
        hoverBoxShadow: { type: "string" },
        sizes: "Sizes"
      }
    }, Q = {
      properties: (0, o.pickObjectProps)(q.properties, ["fontSize", "lineHeight"])
    }, ye = {
      properties: {
        medium: "BadgeFontConfig",
        small: "BadgeFontConfig"
      }
    }, Se = {
      properties: {
        ...(0, o.omitObjectProps)(q.properties, ["fontSize", "lineHeight"]),
        borderRadius: { type: "string" },
        color: { type: "string" },
        sizes: "BadgeSizes"
      }
    }, Ne = {
      properties: {
        top: { type: "string" },
        width: { type: "string" },
        height: { type: "string" }
      }
    }, N = {
      properties: {
        borderRadius: { type: "string" },
        backgroundColor: { type: "string" }
      }
    }, B = {
      properties: {
        fullWidth: { type: "boolean" }
      }
    }, oe = {
      properties: {
        buttons: "ButtonsConfig",
        httpBadges: "HttpBadgesConfig",
        layoutControls: "LabelControls",
        panels: "Panels",
        tryItButton: "TryItButton",
        tryItSendButton: "TryItButton"
      }
    }, ie = {
      properties: {
        small: { type: "string" },
        medium: { type: "string" },
        large: { type: "string" }
      }
    }, he = {
      properties: {
        maxWidth: "Breakpoints"
      }
    }, Z = {
      properties: {
        maxWidth: "Breakpoints",
        middlePanelMaxWidth: "Breakpoints"
      }
    }, re = {
      properties: {
        showDarkRightPanel: { type: "boolean" },
        stacked: "StackedConfig",
        "three-panel": "ThreePanelConfig"
      }
    }, Pe = {
      properties: {
        backgroundColor: { type: "string" },
        border: { type: "string" }
      }
    }, Oe = {
      properties: {
        breakFieldNames: { type: "boolean" },
        caretColor: { type: "string" },
        caretSize: { type: "string" },
        constraints: "SchemaColorsConfig",
        defaultDetailsWidth: { type: "string" },
        examples: "SchemaColorsConfig",
        labelsTextSize: { type: "string" },
        linesColor: { type: "string" },
        nestedBackground: { type: "string" },
        nestingSpacing: { type: "string" },
        requireLabelColor: { type: "string" },
        typeNameColor: { type: "string" },
        typeTitleColor: { type: "string" }
      }
    }, qe = {
      properties: {
        subItemsColor: { type: "string" },
        textTransform: { type: "string" },
        fontWeight: { type: "string" }
      }
    }, je = {
      properties: (0, o.pickObjectProps)(qe.properties, ["textTransform"])
    }, $ = {
      properties: {
        unit: { type: "number" },
        paddingHorizontal: { type: "string" },
        paddingVertical: { type: "string" },
        offsetTop: { type: "string" },
        offsetLeft: { type: "string" },
        offsetNesting: { type: "string" }
      }
    }, K = {
      properties: {
        ...(0, o.omitObjectProps)(q.properties, ["fontWeight", "lineHeight"]),
        activeBgColor: { type: "string" },
        activeTextColor: { type: "string" },
        backgroundColor: { type: "string" },
        borderRadius: { type: "string" },
        breakPath: { type: "boolean" },
        caretColor: { type: "string" },
        caretSize: { type: "string" },
        groupItems: "GroupItemsConfig",
        level1items: "Level1Items",
        rightLineColor: { type: "string" },
        separatorLabelColor: { type: "string" },
        showAtBreakpoint: { type: "string" },
        spacing: "SpacingConfig",
        textColor: { type: "string" },
        width: { type: "string" }
      }
    }, me = {
      properties: {
        ...q.properties,
        color: { type: "string" },
        transform: { type: "string" }
      }
    }, Te = {
      properties: {
        ...q.properties,
        backgroundColor: { type: "string" },
        color: { type: "string" },
        wordBreak: {
          enum: [
            "break-all",
            "break-word",
            "keep-all",
            "normal",
            "revert",
            "unset",
            "inherit",
            "initial"
          ]
        },
        wrap: { type: "boolean" }
      }
    }, ke = {
      properties: (0, o.omitObjectProps)(q.properties, ["fontSize"])
    }, De = {
      properties: {
        color: { type: "string" },
        hover: { type: "string" },
        textDecoration: { type: "string" },
        hoverTextDecoration: { type: "string" },
        visited: { type: "string" }
      }
    }, Fe = {
      properties: {
        code: "CodeConfig",
        fieldName: "FontConfig",
        ...(0, o.pickObjectProps)(q.properties, ["fontSize", "fontFamily"]),
        fontWeightBold: { type: "string" },
        fontWeightLight: { type: "string" },
        fontWeightRegular: { type: "string" },
        heading1: "Heading",
        heading2: "Heading",
        heading3: "Heading",
        headings: "HeadingsConfig",
        lineHeight: { type: "string" },
        links: "LinksConfig",
        optimizeSpeed: { type: "boolean" },
        rightPanelHeading: "Heading",
        smoothing: { enum: ["auto", "none", "antialiased", "subpixel-antialiased", "grayscale"] }
      }
    }, Xe = {
      properties: {
        color: { type: "string" },
        ...(0, o.omitObjectProps)(q.properties, ["fontWeight"])
      }
    }, ct = {
      properties: {
        backgroundColor: { type: "string" },
        borderRadius: { type: "string" },
        tokens: "TokenProps"
      }
    }, mt = {
      properties: {
        gutter: { type: "string" },
        maxHeight: { type: "string" },
        maxWidth: { type: "string" }
      }
    }, st = {
      properties: {
        backgroundColor: { type: "string" },
        color: { type: "string" }
      }
    }, at = {
      properties: {
        custom: { type: "string" }
      }
    }, Vt = {
      properties: {
        DownloadButton: "ButtonOverrides",
        NextSectionButton: "ButtonOverrides"
      }
    }, Y = {
      properties: {
        backgroundColor: { type: "string" },
        panelBackgroundColor: { type: "string" },
        panelControlsBackgroundColor: { type: "string" },
        showAtBreakpoint: { type: "string" },
        textColor: { type: "string" },
        width: { type: "string" }
      }
    }, Ie = {
      properties: { borderRadius: { type: "string" } }
    }, Le = {
      properties: {
        sectionHorizontal: { type: "number" },
        sectionVertical: { type: "number" },
        unit: { type: "number" }
      }
    }, Me = {
      properties: {
        breakpoints: "Breakpoints",
        codeBlock: "CodeBlock",
        colors: "ThemeColors",
        components: "ConfigThemeComponents",
        layout: "Layout",
        logo: "ConfigThemeLogo",
        fab: "Fab",
        overrides: "Overrides",
        rightPanel: "RightPanel",
        schema: "ConfigThemeSchema",
        shape: "Shape",
        sidebar: "Sidebar",
        spacing: "ThemeSpacing",
        typography: "Typography",
        links: { properties: { color: { type: "string" } } },
        // deprecated
        codeSample: { properties: { backgroundColor: { type: "string" } } }
        // deprecated
      }
    }, ze = {
      properties: {
        skipOptionalParameters: { type: "boolean" },
        languages: (0, r.listOf)("ConfigLanguage")
      },
      required: ["languages"]
    }, He = {
      properties: {
        theme: "ConfigTheme",
        corsProxyUrl: { type: "string" },
        ctrlFHijack: { type: "boolean" },
        defaultSampleLanguage: { type: "string" },
        disableDeepLinks: { type: "boolean" },
        disableSearch: { type: "boolean" },
        disableSidebar: { type: "boolean" },
        downloadDefinitionUrl: { type: "string" },
        expandDefaultServerVariables: { type: "boolean" },
        enumSkipQuotes: { type: "boolean" },
        expandDefaultRequest: { type: "boolean" },
        expandDefaultResponse: { type: "boolean" },
        expandResponses: { type: "string" },
        expandSingleSchemaField: { type: "boolean" },
        generateCodeSamples: "GenerateCodeSamples",
        generatedPayloadSamplesMaxDepth: { type: "number" },
        hideDownloadButton: { type: "boolean" },
        hideHostname: { type: "boolean" },
        hideInfoSection: { type: "boolean" },
        hideLoading: { type: "boolean" },
        hideLogo: { type: "boolean" },
        hideRequestPayloadSample: { type: "boolean" },
        hideRightPanel: { type: "boolean" },
        hideSchemaPattern: { type: "boolean" },
        hideSchemaTitles: { type: "boolean" },
        hideSingleRequestSampleTab: { type: "boolean" },
        hideSecuritySection: { type: "boolean" },
        hideTryItPanel: { type: "boolean" },
        hideFab: { type: "boolean" },
        hideOneOfDescription: { type: "boolean" },
        htmlTemplate: { type: "string" },
        jsonSampleExpandLevel: (Ge) => typeof Ge == "number" ? { type: "number", minimum: 1 } : { type: "string" },
        labels: "ConfigLabels",
        layout: { enum: ["stacked", "three-panel"] },
        maxDisplayedEnumValues: { type: "number" },
        menuToggle: { type: "boolean" },
        nativeScrollbars: { type: "boolean" },
        noAutoAuth: { type: "boolean" },
        // deprecated
        oAuth2RedirectURI: { type: "string" },
        onDeepLinkClick: { type: "object" },
        onlyRequiredInSamples: { type: "boolean" },
        pagination: { enum: ["none", "section", "item"] },
        pathInMiddlePanel: { type: "boolean" },
        payloadSampleIdx: { type: "number", minimum: 0 },
        requestInterceptor: { type: "object" },
        requiredPropsFirst: { type: "boolean" },
        routingBasePath: { type: "string" },
        routingStrategy: { type: "string" },
        // deprecated
        samplesTabsMaxCount: { type: "number" },
        schemaExpansionLevel: (Ge) => typeof Ge == "number" ? { type: "number", minimum: 0 } : { type: "string" },
        schemaDefinitionsTagName: { type: "string" },
        minCharacterLengthToInitSearch: { type: "number", minimum: 1 },
        maxResponseHeadersToShowInTryIt: { type: "number", minimum: 0 },
        scrollYOffset: (Ge) => typeof Ge == "number" ? { type: "number" } : { type: "string" },
        searchAutoExpand: { type: "boolean" },
        searchFieldLevelBoost: { type: "number", minimum: 0 },
        searchMaxDepth: { type: "number", minimum: 1 },
        searchMode: { enum: ["default", "path-only"] },
        searchOperationTitleBoost: { type: "number" },
        searchTagTitleBoost: { type: "number" },
        sendXUserAgentInTryIt: { type: "boolean" },
        showChangeLayoutButton: { type: "boolean" },
        showConsole: { type: "boolean" },
        // deprecated
        showExtensions: (Ge) => typeof Ge == "boolean" ? { type: "boolean" } : {
          type: "array",
          items: {
            type: "string"
          }
        },
        showNextButton: { type: "boolean" },
        showRightPanelToggle: { type: "boolean" },
        showSecuritySchemeType: { type: "boolean" },
        showWebhookVerb: { type: "boolean" },
        showObjectSchemaExamples: { type: "boolean" },
        disableTryItRequestUrlEncoding: { type: "boolean" },
        sidebarLinks: "ConfigSidebarLinks",
        sideNavStyle: { enum: ["summary-only", "path-first", "id-only", "path-only"] },
        simpleOneOfTypeLabel: { type: "boolean" },
        sortEnumValuesAlphabetically: { type: "boolean" },
        sortOperationsAlphabetically: { type: "boolean" },
        sortPropsAlphabetically: { type: "boolean" },
        sortTagsAlphabetically: { type: "boolean" },
        suppressWarnings: { type: "boolean" },
        // deprecated
        unstable_externalDescription: { type: "boolean" },
        // deprecated
        unstable_ignoreMimeParameters: { type: "boolean" },
        untrustedDefinition: { type: "boolean" },
        mockServer: {
          properties: {
            url: { type: "string" },
            position: { enum: ["first", "last", "replace", "off"] },
            description: { type: "string" }
          }
        },
        showAccessMode: { type: "boolean" },
        preserveOriginalExtensionsName: { type: "boolean" },
        markdownHeadingsAnchorLevel: { type: "number" }
      },
      additionalProperties: {}
    }, rt = {
      properties: {
        strictExamples: { type: "boolean" },
        errorIfForcedExampleNotFound: { type: "boolean" }
      }
    };
    function Ye(Ge, bt) {
      const kt = Object.values(n.SpecVersion).flatMap((It) => {
        const Xr = bt != null && bt.styleguide ? bt.styleguide.extendTypes((0, n.getTypes)(It), It) : (0, n.getTypes)(It);
        return Object.keys(Xr);
      }), Tt = (0, a.getNodeTypesFromJSONSchema)("rootRedoclyConfigSchema", Ge);
      return {
        ...Ze,
        ConfigRoot: b(Tt),
        // This is the REAL config root type
        ConfigApisProperties: A(Tt),
        AssertionDefinitionSubject: T(kt),
        ...Tt
      };
    }
    const Ze = {
      Assert: V,
      ConfigApis: x,
      ConfigStyleguide: k,
      ConfigReferenceDocs: He,
      ConfigMockServer: rt,
      ConfigHTTP: _,
      ConfigLanguage: U,
      ConfigLabels: ne,
      ConfigSidebarLinks: H,
      CommonConfigSidebarLinks: ae,
      ConfigTheme: Me,
      AssertDefinition: D,
      ThemeColors: F,
      CommonThemeColors: ge,
      BorderThemeColors: ve,
      HttpColors: $e,
      ResponseColors: ce,
      SecondaryColors: se,
      TextThemeColors: te,
      Sizes: W,
      ButtonsConfig: X,
      CommonColorProps: fe,
      BadgeFontConfig: Q,
      BadgeSizes: ye,
      HttpBadgesConfig: Se,
      LabelControls: Ne,
      Panels: N,
      TryItButton: B,
      Breakpoints: ie,
      StackedConfig: he,
      ThreePanelConfig: Z,
      SchemaColorsConfig: Pe,
      SizeProps: J,
      Level1Items: je,
      SpacingConfig: $,
      FontConfig: q,
      CodeConfig: Te,
      HeadingsConfig: ke,
      LinksConfig: De,
      TokenProps: Xe,
      CodeBlock: ct,
      ConfigThemeLogo: mt,
      Fab: st,
      ButtonOverrides: at,
      Overrides: Vt,
      ObjectRule: R,
      Schema: C,
      RightPanel: Y,
      Rules: O,
      Shape: Ie,
      ThemeSpacing: Le,
      GenerateCodeSamples: ze,
      GroupItemsConfig: qe,
      ConfigThemeComponents: oe,
      Layout: re,
      ConfigThemeSchema: Oe,
      Sidebar: K,
      Heading: me,
      Typography: Fe,
      AssertionDefinitionAssertions: j
    };
    e.ConfigTypes = Ye(t.rootRedoclyConfigSchema), e.NormalizedConfigTypes = (0, i.normalizeTypes)(e.ConfigTypes);
  }(aw)), aw;
}
var ek;
function tU() {
  if (ek) return co;
  ek = 1, Object.defineProperty(co, "__esModule", { value: !0 }), co.OasVersion = void 0, co.bundleConfig = b, co.bundle = x, co.bundleFromString = A, co.bundleDocument = _, co.mapTypeToComponent = O;
  const e = Ox(), t = LF(), r = mi(), n = MF(), o = Ax(), a = Up(), i = UF(), u = VF(), c = vi(), d = HF(), m = WF(), g = KF(), v = eU();
  var S;
  (function(T) {
    T.Version2 = "oas2", T.Version3_0 = "oas3_0", T.Version3_1 = "oas3_1";
  })(S || (co.OasVersion = S = {}));
  const k = (0, t.normalizeVisitors)([
    {
      severity: "error",
      ruleId: "configBundler",
      visitor: {
        ref: {
          leave(T, j, D) {
            R(T, D, j);
          }
        }
      }
    }
  ], v.NormalizedConfigTypes);
  async function b(T, j) {
    const D = {
      problems: [],
      oasVersion: o.SpecVersion.OAS3_0,
      refTypes: /* @__PURE__ */ new Map(),
      visitorsData: {}
    };
    return (0, n.walkDocument)({
      document: T,
      rootType: v.NormalizedConfigTypes.ConfigRoot,
      normalizedVisitors: k,
      resolvedRefMap: j,
      ctx: D
    }), T.parsed ?? {};
  }
  async function x(T) {
    var H;
    const { ref: j, doc: D, externalRefResolver: V = new e.BaseResolver(T.config.resolve), base: U = null } = T;
    if (!(j || D))
      throw new Error(`Document or reference is required.
`);
    const ne = D === void 0 ? await V.resolveDocument(U, j, !0) : D;
    if (ne instanceof Error)
      throw ne;
    return (H = T.collectSpecData) == null || H.call(T, ne.parsed), _({
      document: ne,
      ...T,
      config: T.config.styleguide,
      externalRefResolver: V
    });
  }
  async function A(T) {
    const { source: j, absoluteRef: D, externalRefResolver: V = new e.BaseResolver(T.config.resolve) } = T, U = (0, e.makeDocumentFromString)(j, D || "/");
    return _({
      document: U,
      ...T,
      externalRefResolver: V,
      config: T.config.styleguide
    });
  }
  async function _(T) {
    const { document: j, config: D, customTypes: V, externalRefResolver: U, dereference: ne = !1, skipRedoclyRegistryRefs: H = !1, removeUnusedComponents: ae = !1, keepUrlRefs: ge = !1 } = T, fe = (0, o.detectSpec)(j.parsed), ve = (0, o.getMajorSpecVersion)(fe), $e = D.getRulesForSpecVersion(ve), ce = (0, r.normalizeTypes)(D.extendTypes(V ?? (0, o.getTypes)(fe), fe), D), se = (0, i.initRules)($e, D, "preprocessors", fe), te = (0, i.initRules)($e, D, "decorators", fe), F = {
      problems: [],
      oasVersion: fe,
      refTypes: /* @__PURE__ */ new Map(),
      visitorsData: {}
    };
    ae && te.push({
      severity: "error",
      ruleId: "remove-unused-components",
      visitor: ve === o.SpecMajorVersion.OAS2 ? (0, m.RemoveUnusedComponents)({}) : (0, g.RemoveUnusedComponents)({})
    });
    let J = await (0, e.resolveDocument)({
      rootDocument: j,
      rootType: ce.Root,
      externalRefResolver: U
    });
    se.length > 0 && ((0, n.walkDocument)({
      document: j,
      rootType: ce.Root,
      normalizedVisitors: (0, t.normalizeVisitors)(se, ce),
      resolvedRefMap: J,
      ctx: F
    }), J = await (0, e.resolveDocument)({
      rootDocument: j,
      rootType: ce.Root,
      externalRefResolver: U
    }));
    const W = (0, t.normalizeVisitors)([
      {
        severity: "error",
        ruleId: "bundler",
        visitor: C(ve, ne, H, j, J, ge)
      },
      ...te
    ], ce);
    return (0, n.walkDocument)({
      document: j,
      rootType: ce.Root,
      normalizedVisitors: W,
      resolvedRefMap: J,
      ctx: F
    }), {
      bundle: j,
      problems: F.problems.map((q) => D.addProblemToIgnore(q)),
      fileDependencies: U.getFiles(),
      rootType: ce.Root,
      refTypes: F.refTypes,
      visitorsData: F.visitorsData
    };
  }
  function O(T, j) {
    switch (j) {
      case o.SpecMajorVersion.OAS3:
        switch (T) {
          case "Schema":
            return "schemas";
          case "Parameter":
            return "parameters";
          case "Response":
            return "responses";
          case "Example":
            return "examples";
          case "RequestBody":
            return "requestBodies";
          case "Header":
            return "headers";
          case "SecuritySchema":
            return "securitySchemes";
          case "Link":
            return "links";
          case "Callback":
            return "callbacks";
          default:
            return null;
        }
      case o.SpecMajorVersion.OAS2:
        switch (T) {
          case "Schema":
            return "definitions";
          case "Parameter":
            return "parameters";
          case "Response":
            return "responses";
          default:
            return null;
        }
      case o.SpecMajorVersion.Async2:
        switch (T) {
          case "Schema":
            return "schemas";
          case "Parameter":
            return "parameters";
          default:
            return null;
        }
      case o.SpecMajorVersion.Async3:
        switch (T) {
          case "Schema":
            return "schemas";
          case "Parameter":
            return "parameters";
          default:
            return null;
        }
      case o.SpecMajorVersion.Arazzo1:
        switch (T) {
          case "Root.workflows_items.parameters_items":
          case "Root.workflows_items.steps_items.parameters_items":
            return "parameters";
          default:
            return null;
        }
      case o.SpecMajorVersion.Overlay1:
        return null;
    }
  }
  function R(T, j, D) {
    if (!(0, c.isPlainObject)(j.node))
      D.parent[D.key] = j.node;
    else {
      delete T.$ref;
      const V = Object.assign({}, j.node, T);
      Object.assign(T, V);
    }
  }
  function C(T, j, D, V, U, ne) {
    let H, ae;
    const ge = {
      ref: {
        leave(se, te, F) {
          if (!F.location || F.node === void 0) {
            (0, u.reportUnresolvedRef)(F, te.report, te.location);
            return;
          }
          if (F.location.source === V.source && F.location.source === te.location.source && te.type.name !== "scalar" && !j || D && (0, d.isRedoclyRegistryURL)(se.$ref) || ne && (0, a.isAbsoluteUrl)(se.$ref))
            return;
          const J = O(te.type.name, T);
          J ? j ? (ve(J, F, te), R(se, F, te)) : (se.$ref = ve(J, F, te), fe(se, F, te)) : R(se, F, te);
        }
      },
      Example: {
        leave(se, te) {
          if ((0, a.isExternalValue)(se) && se.value === void 0) {
            const F = te.resolve({ $ref: se.externalValue });
            if (!F.location || F.node === void 0) {
              (0, u.reportUnresolvedRef)(F, te.report, te.location);
              return;
            }
            if (ne && (0, a.isAbsoluteUrl)(se.externalValue))
              return;
            se.value = te.resolve({ $ref: se.externalValue }).node, delete se.externalValue;
          }
        }
      },
      Root: {
        enter(se, te) {
          ae = te.location, T === o.SpecMajorVersion.OAS3 ? H = se.components = se.components || {} : T === o.SpecMajorVersion.OAS2 ? H = se : T === o.SpecMajorVersion.Async2 ? H = se.components = se.components || {} : T === o.SpecMajorVersion.Async3 ? H = se.components = se.components || {} : T === o.SpecMajorVersion.Arazzo1 && (H = se.components = se.components || {});
        }
      }
    };
    T === o.SpecMajorVersion.OAS3 && (ge.DiscriminatorMapping = {
      leave(se, te) {
        for (const F of Object.keys(se)) {
          const J = se[F], W = te.resolve({ $ref: J });
          if (!W.location || W.node === void 0) {
            (0, u.reportUnresolvedRef)(W, te.report, te.location.child(F));
            return;
          }
          const q = O("Schema", T);
          se[F] = ve(q, W, te);
        }
      }
    });
    function fe(se, te, F) {
      const J = (0, e.makeRefId)(F.location.source.absoluteRef, se.$ref);
      U.set(J, {
        document: V,
        isRemote: !1,
        node: te.node,
        nodePointer: se.$ref,
        resolved: !0
      });
    }
    function ve(se, te, F) {
      H[se] = H[se] || {};
      const J = ce(te, se, F);
      return H[se][J] = te.node, T === o.SpecMajorVersion.OAS3 || T === o.SpecMajorVersion.Async2 || T === o.SpecMajorVersion.Async3 ? `#/components/${se}/${J}` : `#/${se}/${J}`;
    }
    function $e(se, te, F) {
      var J;
      return (0, a.isRef)(se) && ((J = F.resolve(se, ae.absolutePointer).location) == null ? void 0 : J.absolutePointer) === te.location.absolutePointer ? !0 : (0, c.dequal)(se, te.node);
    }
    function ce(se, te, F) {
      const [J, W] = [se.location.source.absoluteRef, se.location.pointer], q = H[te];
      let X = "";
      const Q = W.slice(2).split("/").filter(c.isTruthy);
      for (; Q.length > 0; )
        if (X = Q.pop() + (X ? `-${X}` : ""), !q || !q[X] || $e(q[X], se, F))
          return X;
      if (X = (0, a.refBaseName)(J) + (X ? `_${X}` : ""), !q[X] || $e(q[X], se, F))
        return X;
      const ye = X;
      let Se = 2;
      for (; q[X] && !$e(q[X], se, F); )
        X = `${ye}-${Se}`, Se++;
      return q[X] || F.report({
        message: `Two schemas are referenced with the same name but different content. Renamed ${ye} to ${X}.`,
        location: F.location,
        forceSeverity: "warn"
      }), X;
    }
    return ge;
  }
  return co;
}
var yw = {}, sn = {}, tk;
function rU() {
  if (tk) return sn;
  tk = 1, Object.defineProperty(sn, "__esModule", { value: !0 }), sn.ConfigValidationError = void 0, sn.parsePresetName = n, sn.transformApiDefinitionsToApis = o, sn.prefixRules = u, sn.mergeExtends = c, sn.getMergedConfig = d, sn.checkForDeprecatedFields = m, sn.transformConfig = g, sn.getResolveConfig = S, sn.getUniquePlugins = k, sn.deepCloneMapWithJSON = x, sn.isDeprecatedPluginFormat = A, sn.isCommonJsPlugin = _;
  const e = vi(), t = g$(), r = RC();
  function n(O) {
    if (O.indexOf("/") > -1) {
      const [R, C] = O.split("/");
      return { pluginId: R, configName: C };
    } else
      return { pluginId: "", configName: O };
  }
  function o(O) {
    if (!O)
      return;
    const R = {};
    for (const [C, T] of Object.entries(O))
      R[C] = { root: T };
    return R;
  }
  function a({ plugins: O, extends: R, rules: C, oas2Rules: T, oas3_0Rules: j, oas3_1Rules: D, async2Rules: V, async3Rules: U, arazzo1Rules: ne, overlay1Rules: H, preprocessors: ae, oas2Preprocessors: ge, oas3_0Preprocessors: fe, oas3_1Preprocessors: ve, async2Preprocessors: $e, async3Preprocessors: ce, arazzo1Preprocessors: se, overlay1Preprocessors: te, decorators: F, oas2Decorators: J, oas3_0Decorators: W, oas3_1Decorators: q, async2Decorators: X, async3Decorators: Q, arazzo1Decorators: ye, overlay1Decorators: Se, ...Ne }) {
    var B;
    const N = {
      plugins: O,
      extends: R,
      rules: C,
      oas2Rules: T,
      oas3_0Rules: j,
      oas3_1Rules: D,
      async2Rules: V,
      async3Rules: U,
      arazzo1Rules: ne,
      overlay1Rules: H,
      preprocessors: ae,
      oas2Preprocessors: ge,
      oas3_0Preprocessors: fe,
      oas3_1Preprocessors: ve,
      async2Preprocessors: $e,
      async3Preprocessors: ce,
      arazzo1Preprocessors: se,
      overlay1Preprocessors: te,
      decorators: F,
      oas2Decorators: J,
      oas3_0Decorators: W,
      oas3_1Decorators: q,
      async2Decorators: X,
      async3Decorators: Q,
      arazzo1Decorators: ye,
      overlay1Decorators: Se,
      doNotResolveExamples: (B = Ne.resolve) == null ? void 0 : B.doNotResolveExamples
    };
    if (Ne.lint && Ne.styleguide || Object.values(N).some(e.isDefined) && (Ne.lint || Ne.styleguide))
      throw new Error(`Do not use 'lint', 'styleguide' and flat syntax together. 
See more about the configuration in the docs: https://redocly.com/docs/cli/configuration/ 
`);
    return {
      styleguideConfig: Object.values(N).some(e.isDefined) ? N : void 0,
      rawConfigRest: Ne
    };
  }
  function i(O) {
    if (!O)
      return;
    const R = {};
    for (const [C, { lint: T, ...j }] of Object.entries(O)) {
      const { styleguideConfig: D, rawConfigRest: V } = a(j);
      R[C] = {
        styleguide: D || T,
        ...V
      };
    }
    return R;
  }
  function u(O, R) {
    if (!R)
      return O;
    const C = {};
    for (const T of Object.keys(O))
      C[`${R}/${T}`] = O[T];
    return C;
  }
  function c(O) {
    const R = {
      rules: {},
      oas2Rules: {},
      oas3_0Rules: {},
      oas3_1Rules: {},
      async2Rules: {},
      async3Rules: {},
      arazzo1Rules: {},
      overlay1Rules: {},
      preprocessors: {},
      oas2Preprocessors: {},
      oas3_0Preprocessors: {},
      oas3_1Preprocessors: {},
      async2Preprocessors: {},
      async3Preprocessors: {},
      arazzo1Preprocessors: {},
      overlay1Preprocessors: {},
      decorators: {},
      oas2Decorators: {},
      oas3_0Decorators: {},
      oas3_1Decorators: {},
      async2Decorators: {},
      async3Decorators: {},
      arazzo1Decorators: {},
      overlay1Decorators: {},
      plugins: [],
      pluginPaths: [],
      extendPaths: []
    };
    for (const C of O) {
      if (C.extends)
        throw new Error(`'extends' is not supported in shared configs yet:
${JSON.stringify(C, null, 2)}`);
      (0, e.assignConfig)(R.rules, C.rules), (0, e.assignConfig)(R.oas2Rules, C.oas2Rules), (0, e.assignOnlyExistingConfig)(R.oas2Rules, C.rules), (0, e.assignConfig)(R.oas3_0Rules, C.oas3_0Rules), (0, e.assignOnlyExistingConfig)(R.oas3_0Rules, C.rules), (0, e.assignConfig)(R.oas3_1Rules, C.oas3_1Rules), (0, e.assignOnlyExistingConfig)(R.oas3_1Rules, C.rules), (0, e.assignConfig)(R.async2Rules, C.async2Rules), (0, e.assignOnlyExistingConfig)(R.async2Rules, C.rules), (0, e.assignConfig)(R.async3Rules, C.async3Rules), (0, e.assignOnlyExistingConfig)(R.async3Rules, C.rules), (0, e.assignConfig)(R.arazzo1Rules, C.arazzo1Rules), (0, e.assignOnlyExistingConfig)(R.arazzo1Rules, C.rules), (0, e.assignConfig)(R.overlay1Rules, C.overlay1Rules), (0, e.assignOnlyExistingConfig)(R.overlay1Rules, C.rules), (0, e.assignConfig)(R.preprocessors, C.preprocessors), (0, e.assignConfig)(R.oas2Preprocessors, C.oas2Preprocessors), (0, e.assignOnlyExistingConfig)(R.oas2Preprocessors, C.preprocessors), (0, e.assignConfig)(R.oas3_0Preprocessors, C.oas3_0Preprocessors), (0, e.assignOnlyExistingConfig)(R.oas3_0Preprocessors, C.preprocessors), (0, e.assignConfig)(R.oas3_1Preprocessors, C.oas3_1Preprocessors), (0, e.assignOnlyExistingConfig)(R.oas3_1Preprocessors, C.preprocessors), (0, e.assignConfig)(R.async2Preprocessors, C.async2Preprocessors), (0, e.assignOnlyExistingConfig)(R.async2Preprocessors, C.preprocessors), (0, e.assignConfig)(R.async3Preprocessors, C.async3Preprocessors), (0, e.assignOnlyExistingConfig)(R.async3Preprocessors, C.preprocessors), (0, e.assignConfig)(R.arazzo1Preprocessors, C.arazzo1Preprocessors), (0, e.assignOnlyExistingConfig)(R.arazzo1Preprocessors, C.preprocessors), (0, e.assignConfig)(R.overlay1Preprocessors, C.overlay1Preprocessors), (0, e.assignOnlyExistingConfig)(R.overlay1Preprocessors, C.preprocessors), (0, e.assignConfig)(R.decorators, C.decorators), (0, e.assignConfig)(R.oas2Decorators, C.oas2Decorators), (0, e.assignOnlyExistingConfig)(R.oas2Decorators, C.decorators), (0, e.assignConfig)(R.oas3_0Decorators, C.oas3_0Decorators), (0, e.assignOnlyExistingConfig)(R.oas3_0Decorators, C.decorators), (0, e.assignConfig)(R.oas3_1Decorators, C.oas3_1Decorators), (0, e.assignOnlyExistingConfig)(R.oas3_1Decorators, C.decorators), (0, e.assignConfig)(R.async2Decorators, C.async2Decorators), (0, e.assignOnlyExistingConfig)(R.async2Decorators, C.decorators), (0, e.assignConfig)(R.async3Decorators, C.async3Decorators), (0, e.assignOnlyExistingConfig)(R.async3Decorators, C.decorators), (0, e.assignConfig)(R.arazzo1Decorators, C.arazzo1Decorators), (0, e.assignOnlyExistingConfig)(R.arazzo1Decorators, C.decorators), (0, e.assignConfig)(R.overlay1Decorators, C.overlay1Decorators), (0, e.assignOnlyExistingConfig)(R.overlay1Decorators, C.decorators), R.plugins.push(...C.plugins || []), R.pluginPaths.push(...C.pluginPaths || []), R.extendPaths.push(...new Set(C.extendPaths));
    }
    return R;
  }
  function d(O, R) {
    var j, D, V, U, ne, H, ae;
    const C = [
      ...Object.values(O.apis).map((ge) => {
        var fe;
        return (fe = ge == null ? void 0 : ge.styleguide) == null ? void 0 : fe.extendPaths;
      }),
      (D = (j = O.rawConfig) == null ? void 0 : j.styleguide) == null ? void 0 : D.extendPaths
    ].flat().filter(e.isTruthy), T = [
      ...Object.values(O.apis).map((ge) => {
        var fe;
        return (fe = ge == null ? void 0 : ge.styleguide) == null ? void 0 : fe.pluginPaths;
      }),
      (U = (V = O.rawConfig) == null ? void 0 : V.styleguide) == null ? void 0 : U.pluginPaths
    ].flat().filter(e.isTruthy);
    return R ? new t.Config({
      ...O.rawConfig,
      styleguide: {
        ...O.apis[R] ? O.apis[R].styleguide : O.rawConfig.styleguide,
        extendPaths: C,
        pluginPaths: T
      },
      theme: {
        ...O.rawConfig.theme,
        ...(ne = O.apis[R]) == null ? void 0 : ne.theme
      },
      files: [...O.files, ...((ae = (H = O.apis) == null ? void 0 : H[R]) == null ? void 0 : ae.files) ?? []]
      // TODO: merge everything else here
    }, O.configFile) : O;
  }
  function m(O, R, C, T, j) {
    const D = C.apis && Object.values(C.apis).some((V) => V[O]);
    C[O] && R === null && (0, e.showWarningForDeprecatedField)(O, void 0, T, j), C[O] && R && C[R] && (0, e.showErrorForDeprecatedField)(O, R), C[O] && T && C[T] && (0, e.showErrorForDeprecatedField)(O, R, T), (C[O] || D) && (0, e.showWarningForDeprecatedField)(O, R, T, j);
  }
  function g(O) {
    var ae, ge;
    const R = [
      ["apiDefinitions", "apis", void 0, void 0],
      ["referenceDocs", "openapi", "theme", void 0],
      [
        "lint",
        void 0,
        void 0,
        "https://redocly.com/docs/api-registry/guides/migration-guide-config-file/#changed-properties"
      ],
      [
        "styleguide",
        void 0,
        void 0,
        "https://redocly.com/docs/api-registry/guides/migration-guide-config-file/#changed-properties"
      ],
      ["features.openapi", "openapi", "theme", void 0]
    ];
    for (const [fe, ve, $e, ce] of R)
      m(fe, ve, O, $e, ce);
    const { apis: C, apiDefinitions: T, referenceDocs: j, lint: D, ...V } = O, { styleguideConfig: U, rawConfigRest: ne } = a(V), H = {
      theme: {
        openapi: {
          ...j,
          ...O["features.openapi"],
          ...(ae = O.theme) == null ? void 0 : ae.openapi
        },
        mockServer: {
          ...O["features.mockServer"],
          ...(ge = O.theme) == null ? void 0 : ge.mockServer
        }
      },
      apis: i(C) || o(T),
      styleguide: U || D,
      ...ne
    };
    return v(H), H;
  }
  function v(O) {
    var C, T;
    let R = { ...(C = O.styleguide) == null ? void 0 : C.rules };
    for (const j of Object.values(O.apis || {}))
      R = { ...R, ...(T = j == null ? void 0 : j.styleguide) == null ? void 0 : T.rules };
    for (const j of Object.keys(R))
      j.startsWith("assert/") && r.logger.warn(`
The 'assert/' syntax in ${j} is deprecated. Update your configuration to use 'rule/' instead. Examples and more information: https://redocly.com/docs/cli/rules/configurable-rules/
`);
  }
  function S(O) {
    var R;
    return {
      http: {
        headers: ((R = O == null ? void 0 : O.http) == null ? void 0 : R.headers) ?? [],
        customFetch: void 0
      }
    };
  }
  function k(O) {
    const R = /* @__PURE__ */ new Set(), C = [];
    for (const T of O)
      R.has(T.id) ? T.id && r.logger.warn(`Duplicate plugin id "${r.colorize.red(T.id)}".
`) : (C.push(T), R.add(T.id));
    return C;
  }
  class b extends Error {
  }
  sn.ConfigValidationError = b;
  function x(O) {
    return new Map(JSON.parse(JSON.stringify([...O])));
  }
  function A(O) {
    return O !== void 0 && typeof O == "object" && "id" in O;
  }
  function _(O) {
    return typeof O == "function";
  }
  return sn;
}
var rk;
function g$() {
  return rk || (rk = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Config = e.StyleguideConfig = e.IGNORE_FILE = void 0;
    const t = oh, r = xx(), n = xS(), o = vi(), a = Ax(), i = Ex(), u = rU(), c = Up();
    e.IGNORE_FILE = ".redocly.lint-ignore.yaml";
    const d = `# This file instructs Redocly's linter to ignore the rules contained for specific parts of your API.
# See https://redocly.com/docs/cli/ for more information.
`;
    function m(k) {
      return k ? (0, o.doesYamlFileExist)(k) ? r.join(r.dirname(k), e.IGNORE_FILE) : r.join(k, e.IGNORE_FILE) : i.isBrowser ? void 0 : r.join(process.cwd(), e.IGNORE_FILE);
    }
    class g {
      constructor(b, x) {
        this.rawConfig = b, this.configFile = x, this.ignore = {}, this._usedRules = /* @__PURE__ */ new Set(), this._usedVersions = /* @__PURE__ */ new Set(), this.plugins = b.plugins || [], this.doNotResolveExamples = !!b.doNotResolveExamples, this.recommendedFallback = b.recommendedFallback || !1, v([
          "rules",
          "oas2Rules",
          "oas3_0Rules",
          "oas3_1Rules",
          "async2Rules",
          "async3Rules",
          "arazzo1Rules",
          "overlay1Rules"
        ], b), this.rules = {
          [a.SpecVersion.OAS2]: { ...b.rules, ...b.oas2Rules },
          [a.SpecVersion.OAS3_0]: { ...b.rules, ...b.oas3_0Rules },
          [a.SpecVersion.OAS3_1]: { ...b.rules, ...b.oas3_1Rules },
          [a.SpecVersion.Async2]: { ...b.rules, ...b.async2Rules },
          [a.SpecVersion.Async3]: { ...b.rules, ...b.async3Rules },
          [a.SpecVersion.Arazzo1]: { ...b.rules, ...b.arazzo1Rules },
          [a.SpecVersion.Overlay1]: { ...b.rules, ...b.overlay1Rules }
        }, this.preprocessors = {
          [a.SpecVersion.OAS2]: { ...b.preprocessors, ...b.oas2Preprocessors },
          [a.SpecVersion.OAS3_0]: { ...b.preprocessors, ...b.oas3_0Preprocessors },
          [a.SpecVersion.OAS3_1]: { ...b.preprocessors, ...b.oas3_1Preprocessors },
          [a.SpecVersion.Async2]: { ...b.preprocessors, ...b.async2Preprocessors },
          [a.SpecVersion.Async3]: { ...b.preprocessors, ...b.async3Preprocessors },
          [a.SpecVersion.Arazzo1]: { ...b.arazzo1Preprocessors },
          [a.SpecVersion.Overlay1]: { ...b.preprocessors, ...b.overlay1Preprocessors }
        }, this.decorators = {
          [a.SpecVersion.OAS2]: { ...b.decorators, ...b.oas2Decorators },
          [a.SpecVersion.OAS3_0]: { ...b.decorators, ...b.oas3_0Decorators },
          [a.SpecVersion.OAS3_1]: { ...b.decorators, ...b.oas3_1Decorators },
          [a.SpecVersion.Async2]: { ...b.decorators, ...b.async2Decorators },
          [a.SpecVersion.Async3]: { ...b.decorators, ...b.async3Decorators },
          [a.SpecVersion.Arazzo1]: { ...b.arazzo1Decorators },
          [a.SpecVersion.Overlay1]: { ...b.decorators, ...b.overlay1Decorators }
        }, this.extendPaths = b.extendPaths || [], this.pluginPaths = b.pluginPaths || [], this.resolveIgnore(m(x));
      }
      resolveIgnore(b) {
        if (!(!b || !(0, o.doesYamlFileExist)(b))) {
          this.ignore = (0, n.parseYaml)(t.readFileSync(b, "utf-8")) || {}, v(Object.keys(this.ignore), this.ignore);
          for (const x of Object.keys(this.ignore)) {
            this.ignore[(0, c.isAbsoluteUrl)(x) ? x : r.resolve(r.dirname(b), x)] = this.ignore[x];
            for (const A of Object.keys(this.ignore[x]))
              this.ignore[x][A] = new Set(this.ignore[x][A]);
            (0, c.isAbsoluteUrl)(x) || delete this.ignore[x];
          }
        }
      }
      saveIgnore() {
        const b = this.configFile ? r.dirname(this.configFile) : process.cwd(), x = r.join(b, e.IGNORE_FILE), A = {};
        for (const _ of Object.keys(this.ignore)) {
          const O = (0, c.isAbsoluteUrl)(_) ? _ : (0, o.slash)(r.relative(b, _)), R = A[O] = this.ignore[_];
          for (const C of Object.keys(R))
            R[C] = Array.from(R[C]);
        }
        t.writeFileSync(x, d + (0, n.stringifyYaml)(A));
      }
      addIgnore(b) {
        const x = this.ignore, A = b.location[0];
        if (A.pointer === void 0)
          return;
        const _ = x[A.source.absoluteRef] = x[A.source.absoluteRef] || {};
        (_[b.ruleId] = _[b.ruleId] || /* @__PURE__ */ new Set()).add(A.pointer);
      }
      addProblemToIgnore(b) {
        const x = b.location[0];
        if (x.pointer === void 0)
          return b;
        const _ = (this.ignore[x.source.absoluteRef] || {})[b.ruleId], O = _ && _.has(x.pointer);
        return O ? {
          ...b,
          ignored: O
        } : b;
      }
      extendTypes(b, x) {
        let A = b;
        for (const _ of this.plugins)
          if (_.typeExtension !== void 0)
            switch (x) {
              case a.SpecVersion.OAS3_0:
              case a.SpecVersion.OAS3_1:
                if (!_.typeExtension.oas3)
                  continue;
                A = _.typeExtension.oas3(A, x);
                break;
              case a.SpecVersion.OAS2:
                if (!_.typeExtension.oas2)
                  continue;
                A = _.typeExtension.oas2(A, x);
                break;
              case a.SpecVersion.Async2:
                if (!_.typeExtension.async2)
                  continue;
                A = _.typeExtension.async2(A, x);
                break;
              case a.SpecVersion.Async3:
                if (!_.typeExtension.async3)
                  continue;
                A = _.typeExtension.async3(A, x);
                break;
              case a.SpecVersion.Arazzo1:
                if (!_.typeExtension.arazzo1)
                  continue;
                A = _.typeExtension.arazzo1(A, x);
                break;
              case a.SpecVersion.Overlay1:
                if (!_.typeExtension.overlay1)
                  continue;
                A = _.typeExtension.overlay1(A, x);
                break;
              default:
                throw new Error("Not implemented");
            }
        return A;
      }
      getRuleSettings(b, x) {
        this._usedRules.add(b), this._usedVersions.add(x);
        const A = this.rules[x][b] || "off";
        return typeof A == "string" ? {
          severity: A
        } : { severity: "error", ...A };
      }
      getPreprocessorSettings(b, x) {
        this._usedRules.add(b), this._usedVersions.add(x);
        const A = this.preprocessors[x][b] || "off";
        return typeof A == "string" ? {
          severity: A === "on" ? "error" : A
        } : { severity: "error", ...A };
      }
      getDecoratorSettings(b, x) {
        this._usedRules.add(b), this._usedVersions.add(x);
        const A = this.decorators[x][b] || "off";
        return typeof A == "string" ? {
          severity: A === "on" ? "error" : A
        } : { severity: "error", ...A };
      }
      getUnusedRules() {
        const b = [], x = [], A = [];
        for (const _ of Array.from(this._usedVersions))
          b.push(...Object.keys(this.rules[_]).filter((O) => !this._usedRules.has(O))), x.push(...Object.keys(this.decorators[_]).filter((O) => !this._usedRules.has(O))), A.push(...Object.keys(this.preprocessors[_]).filter((O) => !this._usedRules.has(O)));
        return {
          rules: b,
          preprocessors: A,
          decorators: x
        };
      }
      getRulesForSpecVersion(b) {
        switch (b) {
          case a.SpecMajorVersion.OAS3:
            const x = [];
            return this.plugins.forEach((T) => {
              var j;
              return ((j = T.preprocessors) == null ? void 0 : j.oas3) && x.push(T.preprocessors.oas3);
            }), this.plugins.forEach((T) => {
              var j;
              return ((j = T.rules) == null ? void 0 : j.oas3) && x.push(T.rules.oas3);
            }), this.plugins.forEach((T) => {
              var j;
              return ((j = T.decorators) == null ? void 0 : j.oas3) && x.push(T.decorators.oas3);
            }), x;
          case a.SpecMajorVersion.OAS2:
            const A = [];
            return this.plugins.forEach((T) => {
              var j;
              return ((j = T.preprocessors) == null ? void 0 : j.oas2) && A.push(T.preprocessors.oas2);
            }), this.plugins.forEach((T) => {
              var j;
              return ((j = T.rules) == null ? void 0 : j.oas2) && A.push(T.rules.oas2);
            }), this.plugins.forEach((T) => {
              var j;
              return ((j = T.decorators) == null ? void 0 : j.oas2) && A.push(T.decorators.oas2);
            }), A;
          case a.SpecMajorVersion.Async2:
            const _ = [];
            return this.plugins.forEach((T) => {
              var j;
              return ((j = T.preprocessors) == null ? void 0 : j.async2) && _.push(T.preprocessors.async2);
            }), this.plugins.forEach((T) => {
              var j;
              return ((j = T.rules) == null ? void 0 : j.async2) && _.push(T.rules.async2);
            }), this.plugins.forEach((T) => {
              var j;
              return ((j = T.decorators) == null ? void 0 : j.async2) && _.push(T.decorators.async2);
            }), _;
          case a.SpecMajorVersion.Async3:
            const O = [];
            return this.plugins.forEach((T) => {
              var j;
              return ((j = T.preprocessors) == null ? void 0 : j.async3) && O.push(T.preprocessors.async3);
            }), this.plugins.forEach((T) => {
              var j;
              return ((j = T.rules) == null ? void 0 : j.async3) && O.push(T.rules.async3);
            }), this.plugins.forEach((T) => {
              var j;
              return ((j = T.decorators) == null ? void 0 : j.async3) && O.push(T.decorators.async3);
            }), O;
          case a.SpecMajorVersion.Arazzo1:
            const R = [];
            return this.plugins.forEach((T) => {
              var j;
              return ((j = T.preprocessors) == null ? void 0 : j.arazzo1) && R.push(T.preprocessors.arazzo1);
            }), this.plugins.forEach((T) => {
              var j;
              return ((j = T.rules) == null ? void 0 : j.arazzo1) && R.push(T.rules.arazzo1);
            }), this.plugins.forEach((T) => {
              var j;
              return ((j = T.decorators) == null ? void 0 : j.arazzo1) && R.push(T.decorators.arazzo1);
            }), R;
          case a.SpecMajorVersion.Overlay1:
            const C = [];
            return this.plugins.forEach((T) => {
              var j;
              return ((j = T.preprocessors) == null ? void 0 : j.overlay1) && C.push(T.preprocessors.overlay1);
            }), this.plugins.forEach((T) => {
              var j;
              return ((j = T.rules) == null ? void 0 : j.overlay1) && C.push(T.rules.overlay1);
            }), this.plugins.forEach((T) => {
              var j;
              return ((j = T.decorators) == null ? void 0 : j.overlay1) && C.push(T.decorators.overlay1);
            }), C;
        }
      }
      skipRules(b) {
        for (const x of b || [])
          for (const A of Object.values(a.SpecVersion))
            if (this.rules[A][x])
              this.rules[A][x] = "off";
            else if (Array.isArray(this.rules[A].assertions))
              for (const _ of this.rules[A].assertions)
                _.assertionId === x && (_.severity = "off");
      }
      skipPreprocessors(b) {
        for (const x of b || [])
          for (const A of Object.values(a.SpecVersion))
            this.preprocessors[A][x] && (this.preprocessors[A][x] = "off");
      }
      skipDecorators(b) {
        for (const x of b || [])
          for (const A of Object.values(a.SpecVersion))
            this.decorators[A][x] && (this.decorators[A][x] = "off");
      }
    }
    e.StyleguideConfig = g;
    function v(k, b) {
      for (const x of k)
        b[x] && (0, o.isPlainObject)(b[x]) && "spec" in b[x] && ((0, o.showWarningForDeprecatedField)("spec", "struct"), b[x].struct = b[x].spec, delete b[x].spec);
    }
    class S {
      constructor(b, x) {
        this.rawConfig = b, this.configFile = x, this.apis = b.apis || {}, this.styleguide = new g(b.styleguide || {}, x), this.theme = b.theme || {}, this.resolve = (0, u.getResolveConfig)(b == null ? void 0 : b.resolve), this.region = b.region, this.organization = b.organization, this.files = b.files || [], this.telemetry = b.telemetry;
      }
    }
    e.Config = S;
  }(yw)), yw;
}
var Ey = {}, nk;
function nU() {
  return nk || (nk = 1, function(e) {
    (function(t, r) {
      r(e);
    })(Ey, function(t) {
      t.__esModule = !0;
      var r = {}, n = Object.prototype.hasOwnProperty, o = { memoize: function(g) {
        var v = arguments.length <= 1 || arguments[1] === void 0 ? r : arguments[1], S = v.cache || {};
        return function() {
          for (var k = arguments.length, b = Array(k), x = 0; x < k; x++)
            b[x] = arguments[x];
          var A = String(b[0]);
          return v.caseSensitive === !1 && (A = A.toLowerCase()), n.call(S, A) ? S[A] : S[A] = g.apply(this, b);
        };
      }, debounce: function(g, v) {
        if (typeof v == "function") {
          var S = g;
          g = v, v = S;
        }
        var k = v && v.delay || v || 0, b = void 0, x = void 0, A = void 0;
        return function() {
          for (var _ = arguments.length, O = Array(_), R = 0; R < _; R++)
            O[R] = arguments[R];
          b = O, x = this, A || (A = setTimeout(function() {
            g.apply(x, b), b = x = A = null;
          }, k));
        };
      }, bind: function(g, v, S) {
        var k = S.value;
        return { configurable: !0, get: function() {
          var x = k.bind(this);
          return Object.defineProperty(this, v, { value: x, configurable: !0, writable: !0 }), x;
        } };
      } }, a = c(o.memoize), i = c(o.debounce), u = c(function(m, g) {
        return m.bind(g);
      }, function() {
        return o.bind;
      });
      t.memoize = a, t.debounce = i, t.bind = u, t.default = { memoize: a, debounce: i, bind: u };
      function c(m, g) {
        g = g || m.decorate || d(m);
        var v = g();
        return function() {
          for (var S = arguments.length, k = Array(S), b = 0; b < S; b++)
            k[b] = arguments[b];
          var x = k.length;
          return (x < 2 ? g : x > 2 ? v : m).apply(void 0, k);
        };
      }
      function d(m) {
        return function(g) {
          return typeof g == "function" ? m(g) : function(v, S, k) {
            k.value = m(k.value, g, v, S, k);
          };
        };
      }
    });
  }(Ey)), Ey;
}
var vw = { exports: {} }, ik;
function iU() {
  return ik || (ik = 1, function(e) {
    var t = Object.prototype.hasOwnProperty, r = "~";
    function n() {
    }
    Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (r = !1));
    function o(c, d, m) {
      this.fn = c, this.context = d, this.once = m || !1;
    }
    function a(c, d, m, g, v) {
      if (typeof m != "function")
        throw new TypeError("The listener must be a function");
      var S = new o(m, g || c, v), k = r ? r + d : d;
      return c._events[k] ? c._events[k].fn ? c._events[k] = [c._events[k], S] : c._events[k].push(S) : (c._events[k] = S, c._eventsCount++), c;
    }
    function i(c, d) {
      --c._eventsCount === 0 ? c._events = new n() : delete c._events[d];
    }
    function u() {
      this._events = new n(), this._eventsCount = 0;
    }
    u.prototype.eventNames = function() {
      var d = [], m, g;
      if (this._eventsCount === 0) return d;
      for (g in m = this._events)
        t.call(m, g) && d.push(r ? g.slice(1) : g);
      return Object.getOwnPropertySymbols ? d.concat(Object.getOwnPropertySymbols(m)) : d;
    }, u.prototype.listeners = function(d) {
      var m = r ? r + d : d, g = this._events[m];
      if (!g) return [];
      if (g.fn) return [g.fn];
      for (var v = 0, S = g.length, k = new Array(S); v < S; v++)
        k[v] = g[v].fn;
      return k;
    }, u.prototype.listenerCount = function(d) {
      var m = r ? r + d : d, g = this._events[m];
      return g ? g.fn ? 1 : g.length : 0;
    }, u.prototype.emit = function(d, m, g, v, S, k) {
      var b = r ? r + d : d;
      if (!this._events[b]) return !1;
      var x = this._events[b], A = arguments.length, _, O;
      if (x.fn) {
        switch (x.once && this.removeListener(d, x.fn, void 0, !0), A) {
          case 1:
            return x.fn.call(x.context), !0;
          case 2:
            return x.fn.call(x.context, m), !0;
          case 3:
            return x.fn.call(x.context, m, g), !0;
          case 4:
            return x.fn.call(x.context, m, g, v), !0;
          case 5:
            return x.fn.call(x.context, m, g, v, S), !0;
          case 6:
            return x.fn.call(x.context, m, g, v, S, k), !0;
        }
        for (O = 1, _ = new Array(A - 1); O < A; O++)
          _[O - 1] = arguments[O];
        x.fn.apply(x.context, _);
      } else {
        var R = x.length, C;
        for (O = 0; O < R; O++)
          switch (x[O].once && this.removeListener(d, x[O].fn, void 0, !0), A) {
            case 1:
              x[O].fn.call(x[O].context);
              break;
            case 2:
              x[O].fn.call(x[O].context, m);
              break;
            case 3:
              x[O].fn.call(x[O].context, m, g);
              break;
            case 4:
              x[O].fn.call(x[O].context, m, g, v);
              break;
            default:
              if (!_) for (C = 1, _ = new Array(A - 1); C < A; C++)
                _[C - 1] = arguments[C];
              x[O].fn.apply(x[O].context, _);
          }
      }
      return !0;
    }, u.prototype.on = function(d, m, g) {
      return a(this, d, m, g, !1);
    }, u.prototype.once = function(d, m, g) {
      return a(this, d, m, g, !0);
    }, u.prototype.removeListener = function(d, m, g, v) {
      var S = r ? r + d : d;
      if (!this._events[S]) return this;
      if (!m)
        return i(this, S), this;
      var k = this._events[S];
      if (k.fn)
        k.fn === m && (!v || k.once) && (!g || k.context === g) && i(this, S);
      else {
        for (var b = 0, x = [], A = k.length; b < A; b++)
          (k[b].fn !== m || v && !k[b].once || g && k[b].context !== g) && x.push(k[b]);
        x.length ? this._events[S] = x.length === 1 ? x[0] : x : i(this, S);
      }
      return this;
    }, u.prototype.removeAllListeners = function(d) {
      var m;
      return d ? (m = r ? r + d : d, this._events[m] && i(this, m)) : (this._events = new n(), this._eventsCount = 0), this;
    }, u.prototype.off = u.prototype.removeListener, u.prototype.addListener = u.prototype.on, u.prefixed = r, u.EventEmitter = u, e.exports = u;
  }(vw)), vw.exports;
}
var bw, sk;
function sU() {
  if (sk) return bw;
  sk = 1;
  var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString;
  return bw = function(n, o, a) {
    if (t.call(o) !== "[object Function]")
      throw new TypeError("iterator must be a function");
    var i = n.length;
    if (i === +i)
      for (var u = 0; u < i; u++)
        o.call(a, n[u], u, n);
    else
      for (var c in n)
        e.call(n, c) && o.call(a, n[c], c, n);
  }, bw;
}
var ww, ok;
function y$() {
  if (ok) return ww;
  ok = 1;
  var e = sU();
  ww = t;
  function t(r, n, o) {
    if (arguments.length === 3)
      return t.set(r, n, o);
    if (arguments.length === 2)
      return t.get(r, n);
    var a = t.bind(t, r);
    for (var i in t)
      t.hasOwnProperty(i) && (a[i] = t[i].bind(a, r));
    return a;
  }
  return t.get = function(n, o) {
    for (var a = Array.isArray(o) ? o : t.parse(o), i = 0; i < a.length; ++i) {
      var u = a[i];
      if (!(typeof n == "object" && u in n))
        throw new Error("Invalid reference token: " + u);
      n = n[u];
    }
    return n;
  }, t.set = function(n, o, a) {
    var i = Array.isArray(o) ? o : t.parse(o), u = i[0];
    if (i.length === 0)
      throw Error("Can not set the root object");
    for (var c = 0; c < i.length - 1; ++c) {
      var d = i[c];
      typeof d != "string" && typeof d != "number" && (d = String(d)), !(d === "__proto__" || d === "constructor" || d === "prototype") && (d === "-" && Array.isArray(n) && (d = n.length), u = i[c + 1], d in n || (u.match(/^(\d+|-)$/) ? n[d] = [] : n[d] = {}), n = n[d]);
    }
    return u === "-" && Array.isArray(n) && (u = n.length), n[u] = a, this;
  }, t.remove = function(r, n) {
    var o = Array.isArray(n) ? n : t.parse(n), a = o[o.length - 1];
    if (a === void 0)
      throw new Error('Invalid JSON pointer for remove: "' + n + '"');
    var i = t.get(r, o.slice(0, -1));
    if (Array.isArray(i)) {
      var u = +a;
      if (a === "" && isNaN(u))
        throw new Error('Invalid array index: "' + a + '"');
      Array.prototype.splice.call(i, u, 1);
    } else
      delete i[a];
  }, t.dict = function(n, o) {
    var a = {};
    return t.walk(n, function(i, u) {
      a[u] = i;
    }, o), a;
  }, t.walk = function(n, o, a) {
    var i = [];
    a = a || function(u) {
      var c = Object.prototype.toString.call(u);
      return c === "[object Object]" || c === "[object Array]";
    }, function u(c) {
      e(c, function(d, m) {
        i.push(String(m)), a(d) ? u(d) : o(d, t.compile(i)), i.pop();
      });
    }(n);
  }, t.has = function(n, o) {
    try {
      t.get(n, o);
    } catch {
      return !1;
    }
    return !0;
  }, t.escape = function(n) {
    return n.toString().replace(/~/g, "~0").replace(/\//g, "~1");
  }, t.unescape = function(n) {
    return n.replace(/~1/g, "/").replace(/~0/g, "~");
  }, t.parse = function(n) {
    if (n === "")
      return [];
    if (n.charAt(0) !== "/")
      throw new Error("Invalid JSON pointer: " + n);
    return n.substring(1).split(/\//).map(t.unescape);
  }, t.compile = function(n) {
    return n.length === 0 ? "" : "/" + n.map(t.escape).join("/");
  }, ww;
}
var Uy = { exports: {} }, oU = Uy.exports, ak;
function aU() {
  return ak || (ak = 1, function(e, t) {
    (function(r, n) {
      e.exports = n();
    })(oU, function() {
      function r() {
      }
      return r.prototype.encodeReserved = function(n) {
        return n.split(/(%[0-9A-Fa-f]{2})/g).map(function(o) {
          return /%[0-9A-Fa-f]/.test(o) || (o = encodeURI(o).replace(/%5B/g, "[").replace(/%5D/g, "]")), o;
        }).join("");
      }, r.prototype.encodeUnreserved = function(n) {
        return encodeURIComponent(n).replace(/[!'()*]/g, function(o) {
          return "%" + o.charCodeAt(0).toString(16).toUpperCase();
        });
      }, r.prototype.encodeValue = function(n, o, a) {
        return o = n === "+" || n === "#" ? this.encodeReserved(o) : this.encodeUnreserved(o), a ? this.encodeUnreserved(a) + "=" + o : o;
      }, r.prototype.isDefined = function(n) {
        return n != null;
      }, r.prototype.isKeyOperator = function(n) {
        return n === ";" || n === "&" || n === "?";
      }, r.prototype.getValues = function(n, o, a, i) {
        var u = n[a], c = [];
        if (this.isDefined(u) && u !== "")
          if (typeof u == "string" || typeof u == "number" || typeof u == "boolean")
            u = u.toString(), i && i !== "*" && (u = u.substring(0, parseInt(i, 10))), c.push(this.encodeValue(o, u, this.isKeyOperator(o) ? a : null));
          else if (i === "*")
            Array.isArray(u) ? u.filter(this.isDefined).forEach(function(m) {
              c.push(this.encodeValue(o, m, this.isKeyOperator(o) ? a : null));
            }, this) : Object.keys(u).forEach(function(m) {
              this.isDefined(u[m]) && c.push(this.encodeValue(o, u[m], m));
            }, this);
          else {
            var d = [];
            Array.isArray(u) ? u.filter(this.isDefined).forEach(function(m) {
              d.push(this.encodeValue(o, m));
            }, this) : Object.keys(u).forEach(function(m) {
              this.isDefined(u[m]) && (d.push(this.encodeUnreserved(m)), d.push(this.encodeValue(o, u[m].toString())));
            }, this), this.isKeyOperator(o) ? c.push(this.encodeUnreserved(a) + "=" + d.join(",")) : d.length !== 0 && c.push(d.join(","));
          }
        else
          o === ";" ? this.isDefined(u) && c.push(this.encodeUnreserved(a)) : u === "" && (o === "&" || o === "?") ? c.push(this.encodeUnreserved(a) + "=") : u === "" && c.push("");
        return c;
      }, r.prototype.parse = function(n) {
        var o = this, a = ["+", "#", ".", "/", ";", "?", "&"];
        return {
          expand: function(i) {
            return n.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(u, c, d) {
              if (c) {
                var m = null, g = [];
                if (a.indexOf(c.charAt(0)) !== -1 && (m = c.charAt(0), c = c.substr(1)), c.split(/,/g).forEach(function(S) {
                  var k = /([^:\*]*)(?::(\d+)|(\*))?/.exec(S);
                  g.push.apply(g, o.getValues(i, m, k[1], k[2] || k[3]));
                }), m && m !== "+") {
                  var v = ",";
                  return m === "?" ? v = "&" : m !== "#" && (v = m), (g.length !== 0 ? m : "") + g.join(v);
                } else
                  return g.join(",");
              } else
                return o.encodeReserved(d);
            });
          }
        };
      }, new r();
    });
  }(Uy)), Uy.exports;
}
var Sw = { exports: {} }, lk;
function lU() {
  return lk || (lk = 1, function(e) {
    var t = typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {};
    /**
     * Prism: Lightweight, robust, elegant syntax highlighting
     *
     * @license MIT <https://opensource.org/licenses/MIT>
     * @author Lea Verou <https://lea.verou.me>
     * @namespace
     * @public
     */
    var r = function(n) {
      var o = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, a = 0, i = {}, u = {
        /**
         * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
         * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
         * additional languages or plugins yourself.
         *
         * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
         *
         * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.manual = true;
         * // add a new <script> to load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        manual: n.Prism && n.Prism.manual,
        /**
         * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
         * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
         * own worker, you don't want it to do this.
         *
         * By setting this value to `true`, Prism will not add its own listeners to the worker.
         *
         * You obviously have to change this value before Prism executes. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.disableWorkerMessageHandler = true;
         * // Load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        disableWorkerMessageHandler: n.Prism && n.Prism.disableWorkerMessageHandler,
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function _(O) {
            return O instanceof c ? new c(O.type, _(O.content), O.alias) : Array.isArray(O) ? O.map(_) : O.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(_) {
            return Object.prototype.toString.call(_).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(_) {
            return _.__id || Object.defineProperty(_, "__id", { value: ++a }), _.__id;
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function _(O, R) {
            R = R || {};
            var C, T;
            switch (u.util.type(O)) {
              case "Object":
                if (T = u.util.objId(O), R[T])
                  return R[T];
                C = /** @type {Record<string, any>} */
                {}, R[T] = C;
                for (var j in O)
                  O.hasOwnProperty(j) && (C[j] = _(O[j], R));
                return (
                  /** @type {any} */
                  C
                );
              case "Array":
                return T = u.util.objId(O), R[T] ? R[T] : (C = [], R[T] = C, /** @type {Array} */
                /** @type {any} */
                O.forEach(function(D, V) {
                  C[V] = _(D, R);
                }), /** @type {any} */
                C);
              default:
                return O;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(_) {
            for (; _; ) {
              var O = o.exec(_.className);
              if (O)
                return O[1].toLowerCase();
              _ = _.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(_, O) {
            _.className = _.className.replace(RegExp(o, "gi"), ""), _.classList.add("language-" + O);
          },
          /**
           * Returns the script element that is currently executing.
           *
           * This does __not__ work for line script element.
           *
           * @returns {HTMLScriptElement | null}
           */
          currentScript: function() {
            if (typeof document > "u")
              return null;
            if (document.currentScript && document.currentScript.tagName === "SCRIPT")
              return (
                /** @type {any} */
                document.currentScript
              );
            try {
              throw new Error();
            } catch (C) {
              var _ = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(C.stack) || [])[1];
              if (_) {
                var O = document.getElementsByTagName("script");
                for (var R in O)
                  if (O[R].src == _)
                    return O[R];
              }
              return null;
            }
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(_, O, R) {
            for (var C = "no-" + O; _; ) {
              var T = _.classList;
              if (T.contains(O))
                return !0;
              if (T.contains(C))
                return !1;
              _ = _.parentElement;
            }
            return !!R;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: i,
          plaintext: i,
          text: i,
          txt: i,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(_, O) {
            var R = u.util.clone(u.languages[_]);
            for (var C in O)
              R[C] = O[C];
            return R;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(_, O, R, C) {
            C = C || /** @type {any} */
            u.languages;
            var T = C[_], j = {};
            for (var D in T)
              if (T.hasOwnProperty(D)) {
                if (D == O)
                  for (var V in R)
                    R.hasOwnProperty(V) && (j[V] = R[V]);
                R.hasOwnProperty(D) || (j[D] = T[D]);
              }
            var U = C[_];
            return C[_] = j, u.languages.DFS(u.languages, function(ne, H) {
              H === U && ne != _ && (this[ne] = j);
            }), j;
          },
          // Traverse a language definition with Depth First Search
          DFS: function _(O, R, C, T) {
            T = T || {};
            var j = u.util.objId;
            for (var D in O)
              if (O.hasOwnProperty(D)) {
                R.call(O, D, O[D], C || D);
                var V = O[D], U = u.util.type(V);
                U === "Object" && !T[j(V)] ? (T[j(V)] = !0, _(V, R, null, T)) : U === "Array" && !T[j(V)] && (T[j(V)] = !0, _(V, R, D, T));
              }
          }
        },
        plugins: {},
        /**
         * This is the most high-level function in Prism’s API.
         * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
         * each one of them.
         *
         * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
         *
         * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
         * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
         * @memberof Prism
         * @public
         */
        highlightAll: function(_, O) {
          u.highlightAllUnder(document, _, O);
        },
        /**
         * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
         * {@link Prism.highlightElement} on each one of them.
         *
         * The following hooks will be run:
         * 1. `before-highlightall`
         * 2. `before-all-elements-highlight`
         * 3. All hooks of {@link Prism.highlightElement} for each element.
         *
         * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
         * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
         * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
         * @memberof Prism
         * @public
         */
        highlightAllUnder: function(_, O, R) {
          var C = {
            callback: R,
            container: _,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          u.hooks.run("before-highlightall", C), C.elements = Array.prototype.slice.apply(C.container.querySelectorAll(C.selector)), u.hooks.run("before-all-elements-highlight", C);
          for (var T = 0, j; j = C.elements[T++]; )
            u.highlightElement(j, O === !0, C.callback);
        },
        /**
         * Highlights the code inside a single element.
         *
         * The following hooks will be run:
         * 1. `before-sanity-check`
         * 2. `before-highlight`
         * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
         * 4. `before-insert`
         * 5. `after-highlight`
         * 6. `complete`
         *
         * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
         * the element's language.
         *
         * @param {Element} element The element containing the code.
         * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
         * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
         * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
         * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
         *
         * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
         * asynchronous highlighting to work. You can build your own bundle on the
         * [Download page](https://prismjs.com/download.html).
         * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
         * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
         * @memberof Prism
         * @public
         */
        highlightElement: function(_, O, R) {
          var C = u.util.getLanguage(_), T = u.languages[C];
          u.util.setLanguage(_, C);
          var j = _.parentElement;
          j && j.nodeName.toLowerCase() === "pre" && u.util.setLanguage(j, C);
          var D = _.textContent, V = {
            element: _,
            language: C,
            grammar: T,
            code: D
          };
          function U(H) {
            V.highlightedCode = H, u.hooks.run("before-insert", V), V.element.innerHTML = V.highlightedCode, u.hooks.run("after-highlight", V), u.hooks.run("complete", V), R && R.call(V.element);
          }
          if (u.hooks.run("before-sanity-check", V), j = V.element.parentElement, j && j.nodeName.toLowerCase() === "pre" && !j.hasAttribute("tabindex") && j.setAttribute("tabindex", "0"), !V.code) {
            u.hooks.run("complete", V), R && R.call(V.element);
            return;
          }
          if (u.hooks.run("before-highlight", V), !V.grammar) {
            U(u.util.encode(V.code));
            return;
          }
          if (O && n.Worker) {
            var ne = new Worker(u.filename);
            ne.onmessage = function(H) {
              U(H.data);
            }, ne.postMessage(JSON.stringify({
              language: V.language,
              code: V.code,
              immediateClose: !0
            }));
          } else
            U(u.highlight(V.code, V.grammar, V.language));
        },
        /**
         * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(_, O, R) {
          var C = {
            code: _,
            grammar: O,
            language: R
          };
          if (u.hooks.run("before-tokenize", C), !C.grammar)
            throw new Error('The language "' + C.language + '" has no grammar.');
          return C.tokens = u.tokenize(C.code, C.grammar), u.hooks.run("after-tokenize", C), c.stringify(u.util.encode(C.tokens), C.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(_, O) {
          var R = O.rest;
          if (R) {
            for (var C in R)
              O[C] = R[C];
            delete O.rest;
          }
          var T = new g();
          return v(T, T.head, _), m(_, T, O, T.head, 0), k(T);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(_, O) {
            var R = u.hooks.all;
            R[_] = R[_] || [], R[_].push(O);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(_, O) {
            var R = u.hooks.all[_];
            if (!(!R || !R.length))
              for (var C = 0, T; T = R[C++]; )
                T(O);
          }
        },
        Token: c
      };
      n.Prism = u;
      function c(_, O, R, C) {
        this.type = _, this.content = O, this.alias = R, this.length = (C || "").length | 0;
      }
      c.stringify = function _(O, R) {
        if (typeof O == "string")
          return O;
        if (Array.isArray(O)) {
          var C = "";
          return O.forEach(function(U) {
            C += _(U, R);
          }), C;
        }
        var T = {
          type: O.type,
          content: _(O.content, R),
          tag: "span",
          classes: ["token", O.type],
          attributes: {},
          language: R
        }, j = O.alias;
        j && (Array.isArray(j) ? Array.prototype.push.apply(T.classes, j) : T.classes.push(j)), u.hooks.run("wrap", T);
        var D = "";
        for (var V in T.attributes)
          D += " " + V + '="' + (T.attributes[V] || "").replace(/"/g, "&quot;") + '"';
        return "<" + T.tag + ' class="' + T.classes.join(" ") + '"' + D + ">" + T.content + "</" + T.tag + ">";
      };
      function d(_, O, R, C) {
        _.lastIndex = O;
        var T = _.exec(R);
        if (T && C && T[1]) {
          var j = T[1].length;
          T.index += j, T[0] = T[0].slice(j);
        }
        return T;
      }
      function m(_, O, R, C, T, j) {
        for (var D in R)
          if (!(!R.hasOwnProperty(D) || !R[D])) {
            var V = R[D];
            V = Array.isArray(V) ? V : [V];
            for (var U = 0; U < V.length; ++U) {
              if (j && j.cause == D + "," + U)
                return;
              var ne = V[U], H = ne.inside, ae = !!ne.lookbehind, ge = !!ne.greedy, fe = ne.alias;
              if (ge && !ne.pattern.global) {
                var ve = ne.pattern.toString().match(/[imsuy]*$/)[0];
                ne.pattern = RegExp(ne.pattern.source, ve + "g");
              }
              for (var $e = ne.pattern || ne, ce = C.next, se = T; ce !== O.tail && !(j && se >= j.reach); se += ce.value.length, ce = ce.next) {
                var te = ce.value;
                if (O.length > _.length)
                  return;
                if (!(te instanceof c)) {
                  var F = 1, J;
                  if (ge) {
                    if (J = d($e, se, _, ae), !J || J.index >= _.length)
                      break;
                    var Q = J.index, W = J.index + J[0].length, q = se;
                    for (q += ce.value.length; Q >= q; )
                      ce = ce.next, q += ce.value.length;
                    if (q -= ce.value.length, se = q, ce.value instanceof c)
                      continue;
                    for (var X = ce; X !== O.tail && (q < W || typeof X.value == "string"); X = X.next)
                      F++, q += X.value.length;
                    F--, te = _.slice(se, q), J.index -= se;
                  } else if (J = d($e, 0, te, ae), !J)
                    continue;
                  var Q = J.index, ye = J[0], Se = te.slice(0, Q), Ne = te.slice(Q + ye.length), N = se + te.length;
                  j && N > j.reach && (j.reach = N);
                  var B = ce.prev;
                  Se && (B = v(O, B, Se), se += Se.length), S(O, B, F);
                  var oe = new c(D, H ? u.tokenize(ye, H) : ye, fe, ye);
                  if (ce = v(O, B, oe), Ne && v(O, ce, Ne), F > 1) {
                    var ie = {
                      cause: D + "," + U,
                      reach: N
                    };
                    m(_, O, R, ce.prev, se, ie), j && ie.reach > j.reach && (j.reach = ie.reach);
                  }
                }
              }
            }
          }
      }
      function g() {
        var _ = { value: null, prev: null, next: null }, O = { value: null, prev: _, next: null };
        _.next = O, this.head = _, this.tail = O, this.length = 0;
      }
      function v(_, O, R) {
        var C = O.next, T = { value: R, prev: O, next: C };
        return O.next = T, C.prev = T, _.length++, T;
      }
      function S(_, O, R) {
        for (var C = O.next, T = 0; T < R && C !== _.tail; T++)
          C = C.next;
        O.next = C, C.prev = O, _.length -= T;
      }
      function k(_) {
        for (var O = [], R = _.head.next; R !== _.tail; )
          O.push(R.value), R = R.next;
        return O;
      }
      if (!n.document)
        return n.addEventListener && (u.disableWorkerMessageHandler || n.addEventListener("message", function(_) {
          var O = JSON.parse(_.data), R = O.language, C = O.code, T = O.immediateClose;
          n.postMessage(u.highlight(C, u.languages[R], R)), T && n.close();
        }, !1)), u;
      var b = u.util.currentScript();
      b && (u.filename = b.src, b.hasAttribute("data-manual") && (u.manual = !0));
      function x() {
        u.manual || u.highlightAll();
      }
      if (!u.manual) {
        var A = document.readyState;
        A === "loading" || A === "interactive" && b && b.defer ? document.addEventListener("DOMContentLoaded", x) : window.requestAnimationFrame ? window.requestAnimationFrame(x) : window.setTimeout(x, 16);
      }
      return u;
    }(t);
    e.exports && (e.exports = r), typeof r1 < "u" && (r1.Prism = r), r.languages.markup = {
      comment: {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: !0
      },
      prolog: {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: !0
      },
      doctype: {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: !0,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: !0,
            greedy: !0,
            inside: null
            // see below
          },
          string: {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: !0
          },
          punctuation: /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          name: /[^\s<>'"]+/
        }
      },
      cdata: {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: !0
      },
      tag: {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: !0,
        inside: {
          tag: {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              punctuation: /^<\/?/,
              namespace: /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: !0
                }
              ]
            }
          },
          punctuation: /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              namespace: /^[^\s>\/:]+:/
            }
          }
        }
      },
      entity: [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    }, r.languages.markup.tag.inside["attr-value"].inside.entity = r.languages.markup.entity, r.languages.markup.doctype.inside["internal-subset"].inside = r.languages.markup, r.hooks.add("wrap", function(n) {
      n.type === "entity" && (n.attributes.title = n.content.replace(/&amp;/, "&"));
    }), Object.defineProperty(r.languages.markup.tag, "addInlined", {
      /**
       * Adds an inlined language to markup.
       *
       * An example of an inlined language is CSS with `<style>` tags.
       *
       * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addInlined('style', 'css');
       */
      value: function(o, a) {
        var i = {};
        i["language-" + a] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: !0,
          inside: r.languages[a]
        }, i.cdata = /^<!\[CDATA\[|\]\]>$/i;
        var u = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: i
          }
        };
        u["language-" + a] = {
          pattern: /[\s\S]+/,
          inside: r.languages[a]
        };
        var c = {};
        c[o] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return o;
          }), "i"),
          lookbehind: !0,
          greedy: !0,
          inside: u
        }, r.languages.insertBefore("markup", "cdata", c);
      }
    }), Object.defineProperty(r.languages.markup.tag, "addAttribute", {
      /**
       * Adds an pattern to highlight languages embedded in HTML attributes.
       *
       * An example of an inlined language is CSS with `style` attributes.
       *
       * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addAttribute('style', 'css');
       */
      value: function(n, o) {
        r.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + n + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: !0,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                value: {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: !0,
                  alias: [o, "language-" + o],
                  inside: r.languages[o]
                },
                punctuation: [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    }), r.languages.html = r.languages.markup, r.languages.mathml = r.languages.markup, r.languages.svg = r.languages.markup, r.languages.xml = r.languages.extend("markup", {}), r.languages.ssml = r.languages.xml, r.languages.atom = r.languages.xml, r.languages.rss = r.languages.xml, function(n) {
      var o = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      n.languages.css = {
        comment: /\/\*[\s\S]*?\*\//,
        atrule: {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + o.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            rule: /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: !0,
              alias: "selector"
            },
            keyword: {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: !0
            }
            // See rest below
          }
        },
        url: {
          // https://drafts.csswg.org/css-values-3/#urls
          pattern: RegExp("\\burl\\((?:" + o.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: !0,
          inside: {
            function: /^url/i,
            punctuation: /^\(|\)$/,
            string: {
              pattern: RegExp("^" + o.source + "$"),
              alias: "url"
            }
          }
        },
        selector: {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + o.source + ")*(?=\\s*\\{)"),
          lookbehind: !0
        },
        string: {
          pattern: o,
          greedy: !0
        },
        property: {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: !0
        },
        important: /!important\b/i,
        function: {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: !0
        },
        punctuation: /[(){};:,]/
      }, n.languages.css.atrule.inside.rest = n.languages.css;
      var a = n.languages.markup;
      a && (a.tag.addInlined("style", "css"), a.tag.addAttribute("style", "css"));
    }(r), r.languages.clike = {
      comment: [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: !0,
        inside: {
          punctuation: /[.\\]/
        }
      },
      keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      boolean: /\b(?:false|true)\b/,
      function: /\b\w+(?=\()/,
      number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      punctuation: /[{}[\];(),.:]/
    }, r.languages.javascript = r.languages.extend("clike", {
      "class-name": [
        r.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: !0
        }
      ],
      keyword: [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: !0
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: !0
        }
      ],
      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
      function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      number: {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + // constant
          (/NaN|Infinity/.source + "|" + // binary integer
          /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
          /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: !0
      },
      operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    }), r.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, r.languages.insertBefore("javascript", "keyword", {
      regex: {
        pattern: RegExp(
          // lookbehind
          // eslint-disable-next-line regexp/no-dupe-characters-character-class
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
          // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
          // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
          // with the only syntax, so we have to define 2 different regex patterns.
          /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
          /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
          /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: !0,
            alias: "language-regex",
            inside: r.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      // This must be declared before keyword because we use "function" inside the look-forward
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      parameter: [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: !0,
          inside: r.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: !0,
          inside: r.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: !0,
          inside: r.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: !0,
          inside: r.languages.javascript
        }
      ],
      constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    }), r.languages.insertBefore("javascript", "string", {
      hashbang: {
        pattern: /^#!.*/,
        greedy: !0,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: !0,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: !0,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: r.languages.javascript
            }
          },
          string: /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: !0,
        greedy: !0,
        alias: "property"
      }
    }), r.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: !0,
        alias: "property"
      }
    }), r.languages.markup && (r.languages.markup.tag.addInlined("script", "javascript"), r.languages.markup.tag.addAttribute(
      /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
      "javascript"
    )), r.languages.js = r.languages.javascript, function() {
      if (typeof r > "u" || typeof document > "u")
        return;
      Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector);
      var n = "Loading…", o = function(b, x) {
        return "✖ Error " + b + " while fetching file: " + x;
      }, a = "✖ Error: File does not exist or is empty", i = {
        js: "javascript",
        py: "python",
        rb: "ruby",
        ps1: "powershell",
        psm1: "powershell",
        sh: "bash",
        bat: "batch",
        h: "c",
        tex: "latex"
      }, u = "data-src-status", c = "loading", d = "loaded", m = "failed", g = "pre[data-src]:not([" + u + '="' + d + '"]):not([' + u + '="' + c + '"])';
      function v(b, x, A) {
        var _ = new XMLHttpRequest();
        _.open("GET", b, !0), _.onreadystatechange = function() {
          _.readyState == 4 && (_.status < 400 && _.responseText ? x(_.responseText) : _.status >= 400 ? A(o(_.status, _.statusText)) : A(a));
        }, _.send(null);
      }
      function S(b) {
        var x = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(b || "");
        if (x) {
          var A = Number(x[1]), _ = x[2], O = x[3];
          return _ ? O ? [A, Number(O)] : [A, void 0] : [A, A];
        }
      }
      r.hooks.add("before-highlightall", function(b) {
        b.selector += ", " + g;
      }), r.hooks.add("before-sanity-check", function(b) {
        var x = (
          /** @type {HTMLPreElement} */
          b.element
        );
        if (x.matches(g)) {
          b.code = "", x.setAttribute(u, c);
          var A = x.appendChild(document.createElement("CODE"));
          A.textContent = n;
          var _ = x.getAttribute("data-src"), O = b.language;
          if (O === "none") {
            var R = (/\.(\w+)$/.exec(_) || [, "none"])[1];
            O = i[R] || R;
          }
          r.util.setLanguage(A, O), r.util.setLanguage(x, O);
          var C = r.plugins.autoloader;
          C && C.loadLanguages(O), v(
            _,
            function(T) {
              x.setAttribute(u, d);
              var j = S(x.getAttribute("data-range"));
              if (j) {
                var D = T.split(/\r\n?|\n/g), V = j[0], U = j[1] == null ? D.length : j[1];
                V < 0 && (V += D.length), V = Math.max(0, Math.min(V - 1, D.length)), U < 0 && (U += D.length), U = Math.max(0, Math.min(U, D.length)), T = D.slice(V, U).join(`
`), x.hasAttribute("data-start") || x.setAttribute("data-start", String(V + 1));
              }
              A.textContent = T, r.highlightElement(A);
            },
            function(T) {
              x.setAttribute(u, m), A.textContent = T;
            }
          );
        }
      }), r.plugins.fileHighlight = {
        /**
         * Executes the File Highlight plugin for all matching `pre` elements under the given container.
         *
         * Note: Elements which are already loaded or currently loading will not be touched by this method.
         *
         * @param {ParentNode} [container=document]
         */
        highlight: function(x) {
          for (var A = (x || document).querySelectorAll(g), _ = 0, O; O = A[_++]; )
            r.highlightElement(O);
        }
      };
      var k = !1;
      r.fileHighlight = function() {
        k || (console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead."), k = !0), r.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    }();
  }(Sw)), Sw.exports;
}
var uk = {}, ck;
function uU() {
  return ck || (ck = 1, function(e) {
    var t = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b", r = {
      pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
      lookbehind: !0,
      alias: "punctuation",
      // this looks reasonably well in all themes
      inside: null
      // see below
    }, n = {
      bash: r,
      environment: {
        pattern: RegExp("\\$" + t),
        alias: "constant"
      },
      variable: [
        // [0]: Arithmetic Environment
        {
          pattern: /\$?\(\([\s\S]+?\)\)/,
          greedy: !0,
          inside: {
            // If there is a $ sign at the beginning highlight $(( and )) as variable
            variable: [
              {
                pattern: /(^\$\(\([\s\S]+)\)\)/,
                lookbehind: !0
              },
              /^\$\(\(/
            ],
            number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
            // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
            operator: /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
            // If there is no $ sign at the beginning highlight (( and )) as punctuation
            punctuation: /\(\(?|\)\)?|,|;/
          }
        },
        // [1]: Command Substitution
        {
          pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
          greedy: !0,
          inside: {
            variable: /^\$\(|^`|\)$|`$/
          }
        },
        // [2]: Brace expansion
        {
          pattern: /\$\{[^}]+\}/,
          greedy: !0,
          inside: {
            operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
            punctuation: /[\[\]]/,
            environment: {
              pattern: RegExp("(\\{)" + t),
              lookbehind: !0,
              alias: "constant"
            }
          }
        },
        /\$(?:\w+|[#?*!@$])/
      ],
      // Escape sequences from echo and printf's manuals, and escaped quotes.
      entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
    };
    e.languages.bash = {
      shebang: {
        pattern: /^#!\s*\/.*/,
        alias: "important"
      },
      comment: {
        pattern: /(^|[^"{\\$])#.*/,
        lookbehind: !0
      },
      "function-name": [
        // a) function foo {
        // b) foo() {
        // c) function foo() {
        // but not “foo {”
        {
          // a) and c)
          pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
          lookbehind: !0,
          alias: "function"
        },
        {
          // b)
          pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
          alias: "function"
        }
      ],
      // Highlight variable names as variables in for and select beginnings.
      "for-or-select": {
        pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
        alias: "variable",
        lookbehind: !0
      },
      // Highlight variable names as variables in the left-hand part
      // of assignments (“=” and “+=”).
      "assign-left": {
        pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
        inside: {
          environment: {
            pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + t),
            lookbehind: !0,
            alias: "constant"
          }
        },
        alias: "variable",
        lookbehind: !0
      },
      // Highlight parameter names as variables
      parameter: {
        pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
        alias: "variable",
        lookbehind: !0
      },
      string: [
        // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
        {
          pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
          lookbehind: !0,
          greedy: !0,
          inside: n
        },
        // Here-document with quotes around the tag
        // → No expansion (so no “inside”).
        {
          pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
          lookbehind: !0,
          greedy: !0,
          inside: {
            bash: r
          }
        },
        // “Normal” string
        {
          // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
          pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
          lookbehind: !0,
          greedy: !0,
          inside: n
        },
        {
          // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
          pattern: /(^|[^$\\])'[^']*'/,
          lookbehind: !0,
          greedy: !0
        },
        {
          // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
          pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
          greedy: !0,
          inside: {
            entity: n.entity
          }
        }
      ],
      environment: {
        pattern: RegExp("\\$?" + t),
        alias: "constant"
      },
      variable: n.variable,
      function: {
        pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
        lookbehind: !0
      },
      keyword: {
        pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
        lookbehind: !0
      },
      // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
      builtin: {
        pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
        lookbehind: !0,
        // Alias added to make those easier to distinguish from strings.
        alias: "class-name"
      },
      boolean: {
        pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
        lookbehind: !0
      },
      "file-descriptor": {
        pattern: /\B&\d\b/,
        alias: "important"
      },
      operator: {
        // Lots of redirections here, but not just that.
        pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
        inside: {
          "file-descriptor": {
            pattern: /^\d/,
            alias: "important"
          }
        }
      },
      punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
      number: {
        pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
        lookbehind: !0
      }
    }, r.inside = e.languages.bash;
    for (var o = [
      "comment",
      "function-name",
      "for-or-select",
      "assign-left",
      "parameter",
      "string",
      "environment",
      "function",
      "keyword",
      "builtin",
      "boolean",
      "file-descriptor",
      "operator",
      "punctuation",
      "number"
    ], a = n.variable[1].inside, i = 0; i < o.length; i++)
      a[o[i]] = e.languages.bash[o[i]];
    e.languages.sh = e.languages.bash, e.languages.shell = e.languages.bash;
  }(Prism)), uk;
}
var pk = {}, fk;
function cU() {
  return fk || (fk = 1, Prism.languages.c = Prism.languages.extend("clike", {
    comment: {
      pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
      greedy: !0
    },
    string: {
      // https://en.cppreference.com/w/c/language/string_literal
      pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
      lookbehind: !0
    },
    keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
    operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
  }), Prism.languages.insertBefore("c", "string", {
    char: {
      // https://en.cppreference.com/w/c/language/character_constant
      pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
      greedy: !0
    }
  }), Prism.languages.insertBefore("c", "string", {
    macro: {
      // allow for multiline macro definitions
      // spaces after the # character compile fine with gcc
      pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
      lookbehind: !0,
      greedy: !0,
      alias: "property",
      inside: {
        string: [
          {
            // highlight the path of the include statement as a string
            pattern: /^(#\s*include\s*)<[^>]+>/,
            lookbehind: !0
          },
          Prism.languages.c.string
        ],
        char: Prism.languages.c.char,
        comment: Prism.languages.c.comment,
        "macro-name": [
          {
            pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
            lookbehind: !0
          },
          {
            pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
            lookbehind: !0,
            alias: "function"
          }
        ],
        // highlight macro directives as keywords
        directive: {
          pattern: /^(#\s*)[a-z]+/,
          lookbehind: !0,
          alias: "keyword"
        },
        "directive-hash": /^#/,
        punctuation: /##|\\(?=[\r\n])/,
        expression: {
          pattern: /\S[\s\S]*/,
          inside: Prism.languages.c
        }
      }
    }
  }), Prism.languages.insertBefore("c", "function", {
    // highlight predefined macros as constants
    constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
  }), delete Prism.languages.c.boolean), pk;
}
var dk = {}, hk;
function pU() {
  return hk || (hk = 1, Prism.languages.clike = {
    comment: [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0,
        greedy: !0
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: !0,
      inside: {
        punctuation: /[.\\]/
      }
    },
    keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    boolean: /\b(?:false|true)\b/,
    function: /\b\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    punctuation: /[{}[\];(),.:]/
  }), dk;
}
var mk = {}, gk;
function fU() {
  return gk || (gk = 1, function(e) {
    var t = /#(?!\{).+/, r = {
      pattern: /#\{[^}]+\}/,
      alias: "variable"
    };
    e.languages.coffeescript = e.languages.extend("javascript", {
      comment: t,
      string: [
        // Strings are multiline
        {
          pattern: /'(?:\\[\s\S]|[^\\'])*'/,
          greedy: !0
        },
        {
          // Strings are multiline
          pattern: /"(?:\\[\s\S]|[^\\"])*"/,
          greedy: !0,
          inside: {
            interpolation: r
          }
        }
      ],
      keyword: /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/,
      "class-member": {
        pattern: /@(?!\d)\w+/,
        alias: "variable"
      }
    }), e.languages.insertBefore("coffeescript", "comment", {
      "multiline-comment": {
        pattern: /###[\s\S]+?###/,
        alias: "comment"
      },
      // Block regexp can contain comments and interpolation
      "block-regex": {
        pattern: /\/{3}[\s\S]*?\/{3}/,
        alias: "regex",
        inside: {
          comment: t,
          interpolation: r
        }
      }
    }), e.languages.insertBefore("coffeescript", "string", {
      "inline-javascript": {
        pattern: /`(?:\\[\s\S]|[^\\`])*`/,
        inside: {
          delimiter: {
            pattern: /^`|`$/,
            alias: "punctuation"
          },
          script: {
            pattern: /[\s\S]+/,
            alias: "language-javascript",
            inside: e.languages.javascript
          }
        }
      },
      // Block strings
      "multiline-string": [
        {
          pattern: /'''[\s\S]*?'''/,
          greedy: !0,
          alias: "string"
        },
        {
          pattern: /"""[\s\S]*?"""/,
          greedy: !0,
          alias: "string",
          inside: {
            interpolation: r
          }
        }
      ]
    }), e.languages.insertBefore("coffeescript", "keyword", {
      // Object property
      property: /(?!\d)\w+(?=\s*:(?!:))/
    }), delete e.languages.coffeescript["template-string"], e.languages.coffee = e.languages.coffeescript;
  }(Prism)), mk;
}
var yk = {}, vk;
function dU() {
  return vk || (vk = 1, function(e) {
    var t = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, r = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
      return t.source;
    });
    e.languages.cpp = e.languages.extend("c", {
      "class-name": [
        {
          pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
            return t.source;
          })),
          lookbehind: !0
        },
        // This is intended to capture the class name of method implementations like:
        //   void foo::bar() const {}
        // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
        // it starts with an uppercase letter. This approximation should give decent results.
        /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
        // This will capture the class name before destructors like:
        //   Foo::~Foo() {}
        /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
        // This also intends to capture the class name of method implementations but here the class has template
        // parameters, so it can't be a namespace (until C++ adds generic namespaces).
        /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
      ],
      keyword: t,
      number: {
        pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
        greedy: !0
      },
      operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
      boolean: /\b(?:false|true)\b/
    }), e.languages.insertBefore("cpp", "string", {
      module: {
        // https://en.cppreference.com/w/cpp/language/modules
        pattern: RegExp(
          /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
          /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
          /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
            return r;
          }) + ")"
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          string: /^[<"][\s\S]+/,
          operator: /:/,
          punctuation: /\./
        }
      },
      "raw-string": {
        pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
        alias: "string",
        greedy: !0
      }
    }), e.languages.insertBefore("cpp", "keyword", {
      "generic-function": {
        pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
        inside: {
          function: /^\w+/,
          generic: {
            pattern: /<[\s\S]+/,
            alias: "class-name",
            inside: e.languages.cpp
          }
        }
      }
    }), e.languages.insertBefore("cpp", "operator", {
      "double-colon": {
        pattern: /::/,
        alias: "punctuation"
      }
    }), e.languages.insertBefore("cpp", "class-name", {
      // the base clause is an optional list of parent classes
      // https://en.cppreference.com/w/cpp/language/class
      "base-clause": {
        pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
        lookbehind: !0,
        greedy: !0,
        inside: e.languages.extend("cpp", {})
      }
    }), e.languages.insertBefore("inside", "double-colon", {
      // All untokenized words that are not namespaces should be class names
      "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
    }, e.languages.cpp["base-clause"]);
  }(Prism)), yk;
}
var bk = {}, wk;
function hU() {
  return wk || (wk = 1, function(e) {
    function t(se, te) {
      return se.replace(/<<(\d+)>>/g, function(F, J) {
        return "(?:" + te[+J] + ")";
      });
    }
    function r(se, te, F) {
      return RegExp(t(se, te), "");
    }
    function n(se, te) {
      for (var F = 0; F < te; F++)
        se = se.replace(/<<self>>/g, function() {
          return "(?:" + se + ")";
        });
      return se.replace(/<<self>>/g, "[^\\s\\S]");
    }
    var o = {
      // keywords which represent a return or variable type
      type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
      // keywords which are used to declare a type
      typeDeclaration: "class enum interface record struct",
      // contextual keywords
      // ("var" and "dynamic" are missing because they are used like types)
      contextual: "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
      // all other keywords
      other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
    };
    function a(se) {
      return "\\b(?:" + se.trim().replace(/ /g, "|") + ")\\b";
    }
    var i = a(o.typeDeclaration), u = RegExp(a(o.type + " " + o.typeDeclaration + " " + o.contextual + " " + o.other)), c = a(o.typeDeclaration + " " + o.contextual + " " + o.other), d = a(o.type + " " + o.typeDeclaration + " " + o.other), m = n(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2), g = n(/\((?:[^()]|<<self>>)*\)/.source, 2), v = /@?\b[A-Za-z_]\w*\b/.source, S = t(/<<0>>(?:\s*<<1>>)?/.source, [v, m]), k = t(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [c, S]), b = /\[\s*(?:,\s*)*\]/.source, x = t(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [k, b]), A = t(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [m, g, b]), _ = t(/\(<<0>>+(?:,<<0>>+)+\)/.source, [A]), O = t(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [_, k, b]), R = {
      keyword: u,
      punctuation: /[<>()?,.:[\]]/
    }, C = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source, T = /"(?:\\.|[^\\"\r\n])*"/.source, j = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
    e.languages.csharp = e.languages.extend("clike", {
      string: [
        {
          pattern: r(/(^|[^$\\])<<0>>/.source, [j]),
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: r(/(^|[^@$\\])<<0>>/.source, [T]),
          lookbehind: !0,
          greedy: !0
        }
      ],
      "class-name": [
        {
          // Using static
          // using static System.Math;
          pattern: r(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [k]),
          lookbehind: !0,
          inside: R
        },
        {
          // Using alias (type)
          // using Project = PC.MyCompany.Project;
          pattern: r(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [v, O]),
          lookbehind: !0,
          inside: R
        },
        {
          // Using alias (alias)
          // using Project = PC.MyCompany.Project;
          pattern: r(/(\busing\s+)<<0>>(?=\s*=)/.source, [v]),
          lookbehind: !0
        },
        {
          // Type declarations
          // class Foo<A, B>
          // interface Foo<out A, B>
          pattern: r(/(\b<<0>>\s+)<<1>>/.source, [i, S]),
          lookbehind: !0,
          inside: R
        },
        {
          // Single catch exception declaration
          // catch(Foo)
          // (things like catch(Foo e) is covered by variable declaration)
          pattern: r(/(\bcatch\s*\(\s*)<<0>>/.source, [k]),
          lookbehind: !0,
          inside: R
        },
        {
          // Name of the type parameter of generic constraints
          // where Foo : class
          pattern: r(/(\bwhere\s+)<<0>>/.source, [v]),
          lookbehind: !0
        },
        {
          // Casts and checks via as and is.
          // as Foo<A>, is Bar<B>
          // (things like if(a is Foo b) is covered by variable declaration)
          pattern: r(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [x]),
          lookbehind: !0,
          inside: R
        },
        {
          // Variable, field and parameter declaration
          // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)
          pattern: r(/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source, [O, d, v]),
          inside: R
        }
      ],
      keyword: u,
      // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals
      number: /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
      operator: />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
      punctuation: /\?\.?|::|[{}[\];(),.:]/
    }), e.languages.insertBefore("csharp", "number", {
      range: {
        pattern: /\.\./,
        alias: "operator"
      }
    }), e.languages.insertBefore("csharp", "punctuation", {
      "named-parameter": {
        pattern: r(/([(,]\s*)<<0>>(?=\s*:)/.source, [v]),
        lookbehind: !0,
        alias: "punctuation"
      }
    }), e.languages.insertBefore("csharp", "class-name", {
      namespace: {
        // namespace Foo.Bar {}
        // using Foo.Bar;
        pattern: r(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source, [v]),
        lookbehind: !0,
        inside: {
          punctuation: /\./
        }
      },
      "type-expression": {
        // default(Foo), typeof(Foo<Bar>), sizeof(int)
        pattern: r(/(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source, [g]),
        lookbehind: !0,
        alias: "class-name",
        inside: R
      },
      "return-type": {
        // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0
        // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];
        // int Foo => 0; int Foo { get; set } = 0;
        pattern: r(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source, [O, k]),
        inside: R,
        alias: "class-name"
      },
      "constructor-invocation": {
        // new List<Foo<Bar[]>> { }
        pattern: r(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [O]),
        lookbehind: !0,
        inside: R,
        alias: "class-name"
      },
      /*'explicit-implementation': {
      	// int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();
      	pattern: replace(/\b<<0>>(?=\.<<1>>)/, className, methodOrPropertyDeclaration),
      	inside: classNameInside,
      	alias: 'class-name'
      },*/
      "generic-method": {
        // foo<Bar>()
        pattern: r(/<<0>>\s*<<1>>(?=\s*\()/.source, [v, m]),
        inside: {
          function: r(/^<<0>>/.source, [v]),
          generic: {
            pattern: RegExp(m),
            alias: "class-name",
            inside: R
          }
        }
      },
      "type-list": {
        // The list of types inherited or of generic constraints
        // class Foo<F> : Bar, IList<FooBar>
        // where F : Bar, IList<int>
        pattern: r(
          /\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source,
          [i, S, v, O, u.source, g, /\bnew\s*\(\s*\)/.source]
        ),
        lookbehind: !0,
        inside: {
          "record-arguments": {
            pattern: r(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [S, g]),
            lookbehind: !0,
            greedy: !0,
            inside: e.languages.csharp
          },
          keyword: u,
          "class-name": {
            pattern: RegExp(O),
            greedy: !0,
            inside: R
          },
          punctuation: /[,()]/
        }
      },
      preprocessor: {
        pattern: /(^[\t ]*)#.*/m,
        lookbehind: !0,
        alias: "property",
        inside: {
          // highlight preprocessor directives as keywords
          directive: {
            pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
            lookbehind: !0,
            alias: "keyword"
          }
        }
      }
    });
    var D = T + "|" + C, V = t(/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source, [D]), U = n(t(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [V]), 2), ne = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source, H = t(/<<0>>(?:\s*\(<<1>>*\))?/.source, [k, U]);
    e.languages.insertBefore("csharp", "class-name", {
      attribute: {
        // Attributes
        // [Foo], [Foo(1), Bar(2, Prop = "foo")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]
        pattern: r(/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source, [ne, H]),
        lookbehind: !0,
        greedy: !0,
        inside: {
          target: {
            pattern: r(/^<<0>>(?=\s*:)/.source, [ne]),
            alias: "keyword"
          },
          "attribute-arguments": {
            pattern: r(/\(<<0>>*\)/.source, [U]),
            inside: e.languages.csharp
          },
          "class-name": {
            pattern: RegExp(k),
            inside: {
              punctuation: /\./
            }
          },
          punctuation: /[:,]/
        }
      }
    });
    var ae = /:[^}\r\n]+/.source, ge = n(t(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [V]), 2), fe = t(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [ge, ae]), ve = n(t(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [D]), 2), $e = t(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [ve, ae]);
    function ce(se, te) {
      return {
        interpolation: {
          pattern: r(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [se]),
          lookbehind: !0,
          inside: {
            "format-string": {
              pattern: r(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [te, ae]),
              lookbehind: !0,
              inside: {
                punctuation: /^:/
              }
            },
            punctuation: /^\{|\}$/,
            expression: {
              pattern: /[\s\S]+/,
              alias: "language-csharp",
              inside: e.languages.csharp
            }
          }
        },
        string: /[\s\S]+/
      };
    }
    e.languages.insertBefore("csharp", "string", {
      "interpolation-string": [
        {
          pattern: r(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source, [fe]),
          lookbehind: !0,
          greedy: !0,
          inside: ce(fe, ge)
        },
        {
          pattern: r(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [$e]),
          lookbehind: !0,
          greedy: !0,
          inside: ce($e, ve)
        }
      ],
      char: {
        pattern: RegExp(C),
        greedy: !0
      }
    }), e.languages.dotnet = e.languages.cs = e.languages.csharp;
  }(Prism)), bk;
}
var Sk = {}, xk;
function mU() {
  return xk || (xk = 1, Prism.languages.go = Prism.languages.extend("clike", {
    string: {
      pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
      lookbehind: !0,
      greedy: !0
    },
    keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
    boolean: /\b(?:_|false|iota|nil|true)\b/,
    number: [
      // binary and octal integers
      /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
      // hexadecimal integers and floats
      /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
      // decimal integers and floats
      /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
    ],
    operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
    builtin: /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
  }), Prism.languages.insertBefore("go", "string", {
    char: {
      pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
      greedy: !0
    }
  }), delete Prism.languages.go["class-name"]), Sk;
}
var _k = {}, Ek;
function gU() {
  return Ek || (Ek = 1, function(e) {
    function t(d) {
      return RegExp("(^(?:" + d + "):[ 	]*(?![ 	]))[^]+", "i");
    }
    e.languages.http = {
      "request-line": {
        pattern: /^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\s(?:https?:\/\/|\/)\S*\sHTTP\/[\d.]+/m,
        inside: {
          // HTTP Method
          method: {
            pattern: /^[A-Z]+\b/,
            alias: "property"
          },
          // Request Target e.g. http://example.com, /path/to/file
          "request-target": {
            pattern: /^(\s)(?:https?:\/\/|\/)\S*(?=\s)/,
            lookbehind: !0,
            alias: "url",
            inside: e.languages.uri
          },
          // HTTP Version
          "http-version": {
            pattern: /^(\s)HTTP\/[\d.]+/,
            lookbehind: !0,
            alias: "property"
          }
        }
      },
      "response-status": {
        pattern: /^HTTP\/[\d.]+ \d+ .+/m,
        inside: {
          // HTTP Version
          "http-version": {
            pattern: /^HTTP\/[\d.]+/,
            alias: "property"
          },
          // Status Code
          "status-code": {
            pattern: /^(\s)\d+(?=\s)/,
            lookbehind: !0,
            alias: "number"
          },
          // Reason Phrase
          "reason-phrase": {
            pattern: /^(\s).+/,
            lookbehind: !0,
            alias: "string"
          }
        }
      },
      header: {
        pattern: /^[\w-]+:.+(?:(?:\r\n?|\n)[ \t].+)*/m,
        inside: {
          "header-value": [
            {
              pattern: t(/Content-Security-Policy/.source),
              lookbehind: !0,
              alias: ["csp", "languages-csp"],
              inside: e.languages.csp
            },
            {
              pattern: t(/Public-Key-Pins(?:-Report-Only)?/.source),
              lookbehind: !0,
              alias: ["hpkp", "languages-hpkp"],
              inside: e.languages.hpkp
            },
            {
              pattern: t(/Strict-Transport-Security/.source),
              lookbehind: !0,
              alias: ["hsts", "languages-hsts"],
              inside: e.languages.hsts
            },
            {
              pattern: t(/[^:]+/.source),
              lookbehind: !0
            }
          ],
          "header-name": {
            pattern: /^[^:]+/,
            alias: "keyword"
          },
          punctuation: /^:/
        }
      }
    };
    var r = e.languages, n = {
      "application/javascript": r.javascript,
      "application/json": r.json || r.javascript,
      "application/xml": r.xml,
      "text/xml": r.xml,
      "text/html": r.html,
      "text/css": r.css,
      "text/plain": r.plain
    }, o = {
      "application/json": !0,
      "application/xml": !0
    };
    function a(d) {
      var m = d.replace(/^[a-z]+\//, ""), g = "\\w+/(?:[\\w.-]+\\+)+" + m + "(?![+\\w.-])";
      return "(?:" + d + "|" + g + ")";
    }
    var i;
    for (var u in n)
      if (n[u]) {
        i = i || {};
        var c = o[u] ? a(u) : u;
        i[u.replace(/\//g, "-")] = {
          pattern: RegExp(
            "(" + /content-type:\s*/.source + c + /(?:(?:\r\n?|\n)[\w-].*)*(?:\r(?:\n|(?!\n))|\n)/.source + ")" + // This is a little interesting:
            // The HTTP format spec required 1 empty line before the body to make everything unambiguous.
            // However, when writing code by hand (e.g. to display on a website) people can forget about this,
            // so we want to be liberal here. We will allow the empty line to be omitted if the first line of
            // the body does not start with a [\w-] character (as headers do).
            /[^ \t\w-][\s\S]*/.source,
            "i"
          ),
          lookbehind: !0,
          inside: n[u]
        };
      }
    i && e.languages.insertBefore("http", "header", i);
  }(Prism)), _k;
}
var Ok = {}, kk;
function yU() {
  return kk || (kk = 1, function(e) {
    var t = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/, r = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source, n = {
      pattern: RegExp(/(^|[^\w.])/.source + r + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
      lookbehind: !0,
      inside: {
        namespace: {
          pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
          inside: {
            punctuation: /\./
          }
        },
        punctuation: /\./
      }
    };
    e.languages.java = e.languages.extend("clike", {
      string: {
        pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
        lookbehind: !0,
        greedy: !0
      },
      "class-name": [
        n,
        {
          // variables, parameters, and constructor references
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(/(^|[^\w.])/.source + r + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
          lookbehind: !0,
          inside: n.inside
        },
        {
          // class names based on keyword
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + r + /[A-Z]\w*\b/.source),
          lookbehind: !0,
          inside: n.inside
        }
      ],
      keyword: t,
      function: [
        e.languages.clike.function,
        {
          pattern: /(::\s*)[a-z_]\w*/,
          lookbehind: !0
        }
      ],
      number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
      operator: {
        pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
        lookbehind: !0
      },
      constant: /\b[A-Z][A-Z_\d]+\b/
    }), e.languages.insertBefore("java", "string", {
      "triple-quoted-string": {
        // http://openjdk.java.net/jeps/355#Description
        pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
        greedy: !0,
        alias: "string"
      },
      char: {
        pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
        greedy: !0
      }
    }), e.languages.insertBefore("java", "class-name", {
      annotation: {
        pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
        lookbehind: !0,
        alias: "punctuation"
      },
      generics: {
        pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
        inside: {
          "class-name": n,
          keyword: t,
          punctuation: /[<>(),.:]/,
          operator: /[?&|]/
        }
      },
      import: [
        {
          pattern: RegExp(/(\bimport\s+)/.source + r + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
          lookbehind: !0,
          inside: {
            namespace: n.inside.namespace,
            punctuation: /\./,
            operator: /\*/,
            "class-name": /\w+/
          }
        },
        {
          pattern: RegExp(/(\bimport\s+static\s+)/.source + r + /(?:\w+|\*)(?=\s*;)/.source),
          lookbehind: !0,
          alias: "static",
          inside: {
            namespace: n.inside.namespace,
            static: /\b\w+$/,
            punctuation: /\./,
            operator: /\*/,
            "class-name": /\w+/
          }
        }
      ],
      namespace: {
        pattern: RegExp(
          /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
            return t.source;
          })
        ),
        lookbehind: !0,
        inside: {
          punctuation: /\./
        }
      }
    });
  }(Prism)), Ok;
}
var Ak = {}, Pk;
function vU() {
  return Pk || (Pk = 1, Prism.languages.lua = {
    comment: /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
    // \z may be used to skip the following space
    string: {
      pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
      greedy: !0
    },
    number: /\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
    keyword: /\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,
    function: /(?!\d)\w+(?=\s*(?:[({]))/,
    operator: [
      /[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/,
      {
        // Match ".." but don't break "..."
        pattern: /(^|[^.])\.\.(?!\.)/,
        lookbehind: !0
      }
    ],
    punctuation: /[\[\](){},;]|\.+|:+/
  }), Ak;
}
var Tk = {}, Ck;
function bU() {
  return Ck || (Ck = 1, function(e) {
    function t(r, n) {
      return "___" + r.toUpperCase() + n + "___";
    }
    Object.defineProperties(e.languages["markup-templating"] = {}, {
      buildPlaceholders: {
        /**
         * Tokenize all inline templating expressions matching `placeholderPattern`.
         *
         * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns
         * `true` will be replaced.
         *
         * @param {object} env The environment of the `before-tokenize` hook.
         * @param {string} language The language id.
         * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
         * @param {(match: string) => boolean} [replaceFilter]
         */
        value: function(r, n, o, a) {
          if (r.language === n) {
            var i = r.tokenStack = [];
            r.code = r.code.replace(o, function(u) {
              if (typeof a == "function" && !a(u))
                return u;
              for (var c = i.length, d; r.code.indexOf(d = t(n, c)) !== -1; )
                ++c;
              return i[c] = u, d;
            }), r.grammar = e.languages.markup;
          }
        }
      },
      tokenizePlaceholders: {
        /**
         * Replace placeholders with proper tokens after tokenizing.
         *
         * @param {object} env The environment of the `after-tokenize` hook.
         * @param {string} language The language id.
         */
        value: function(r, n) {
          if (r.language !== n || !r.tokenStack)
            return;
          r.grammar = e.languages[n];
          var o = 0, a = Object.keys(r.tokenStack);
          function i(u) {
            for (var c = 0; c < u.length && !(o >= a.length); c++) {
              var d = u[c];
              if (typeof d == "string" || d.content && typeof d.content == "string") {
                var m = a[o], g = r.tokenStack[m], v = typeof d == "string" ? d : d.content, S = t(n, m), k = v.indexOf(S);
                if (k > -1) {
                  ++o;
                  var b = v.substring(0, k), x = new e.Token(n, e.tokenize(g, r.grammar), "language-" + n, g), A = v.substring(k + S.length), _ = [];
                  b && _.push.apply(_, i([b])), _.push(x), A && _.push.apply(_, i([A])), typeof d == "string" ? u.splice.apply(u, [c, 1].concat(_)) : d.content = _;
                }
              } else d.content && i(d.content);
            }
            return u;
          }
          i(r.tokens);
        }
      }
    });
  }(Prism)), Tk;
}
var $k = {}, Rk;
function wU() {
  return Rk || (Rk = 1, Prism.languages.markup = {
    comment: {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: !0
    },
    prolog: {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: !0
    },
    doctype: {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: !0,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: !0,
          greedy: !0,
          inside: null
          // see below
        },
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: !0
        },
        punctuation: /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        name: /[^\s<>'"]+/
      }
    },
    cdata: {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: !0
    },
    tag: {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: !0,
      inside: {
        tag: {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            punctuation: /^<\/?/,
            namespace: /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            punctuation: [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: !0
              }
            ]
          }
        },
        punctuation: /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            namespace: /^[^\s>\/:]+:/
          }
        }
      }
    },
    entity: [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  }, Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity, Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup, Prism.hooks.add("wrap", function(e) {
    e.type === "entity" && (e.attributes.title = e.content.replace(/&amp;/, "&"));
  }), Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
    /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */
    value: function(t, r) {
      var n = {};
      n["language-" + r] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: !0,
        inside: Prism.languages[r]
      }, n.cdata = /^<!\[CDATA\[|\]\]>$/i;
      var o = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: n
        }
      };
      o["language-" + r] = {
        pattern: /[\s\S]+/,
        inside: Prism.languages[r]
      };
      var a = {};
      a[t] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
          return t;
        }), "i"),
        lookbehind: !0,
        greedy: !0,
        inside: o
      }, Prism.languages.insertBefore("markup", "cdata", a);
    }
  }), Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
    /**
     * Adds an pattern to highlight languages embedded in HTML attributes.
     *
     * An example of an inlined language is CSS with `style` attributes.
     *
     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addAttribute('style', 'css');
     */
    value: function(e, t) {
      Prism.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(
          /(^|["'\s])/.source + "(?:" + e + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
          "i"
        ),
        lookbehind: !0,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              value: {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: !0,
                alias: [t, "language-" + t],
                inside: Prism.languages[t]
              },
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  }), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend("markup", {}), Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml, Prism.languages.rss = Prism.languages.xml), $k;
}
var Ik = {}, Nk;
function SU() {
  return Nk || (Nk = 1, Prism.languages.objectivec = Prism.languages.extend("c", {
    string: {
      pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: !0
    },
    keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
    operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
  }), delete Prism.languages.objectivec["class-name"], Prism.languages.objc = Prism.languages.objectivec), Ik;
}
var jk = {}, Lk;
function xU() {
  return Lk || (Lk = 1, function(e) {
    var t = /(?:\((?:[^()\\]|\\[\s\S])*\)|\{(?:[^{}\\]|\\[\s\S])*\}|\[(?:[^[\]\\]|\\[\s\S])*\]|<(?:[^<>\\]|\\[\s\S])*>)/.source;
    e.languages.perl = {
      comment: [
        {
          // POD
          pattern: /(^\s*)=\w[\s\S]*?=cut.*/m,
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: /(^|[^\\$])#.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      // TODO Could be nice to handle Heredoc too.
      string: [
        {
          pattern: RegExp(
            /\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
              // q/.../
              /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
              // q a...a
              // eslint-disable-next-line regexp/strict
              /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
              // q(...)
              // q{...}
              // q[...]
              // q<...>
              t
            ].join("|") + ")"
          ),
          greedy: !0
        },
        // "...", `...`
        {
          pattern: /("|`)(?:(?!\1)[^\\]|\\[\s\S])*\1/,
          greedy: !0
        },
        // '...'
        // FIXME Multi-line single-quoted strings are not supported as they would break variables containing '
        {
          pattern: /'(?:[^'\\\r\n]|\\.)*'/,
          greedy: !0
        }
      ],
      regex: [
        {
          pattern: RegExp(
            /\b(?:m|qr)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
              // m/.../
              /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
              // m a...a
              // eslint-disable-next-line regexp/strict
              /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
              // m(...)
              // m{...}
              // m[...]
              // m<...>
              t
            ].join("|") + ")" + /[msixpodualngc]*/.source
          ),
          greedy: !0
        },
        // The lookbehinds prevent -s from breaking
        {
          pattern: RegExp(
            /(^|[^-])\b(?:s|tr|y)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
              // s/.../.../
              // eslint-disable-next-line regexp/strict
              /([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
              // s a...a...a
              // eslint-disable-next-line regexp/strict
              /([a-zA-Z0-9])(?:(?!\3)[^\\]|\\[\s\S])*\3(?:(?!\3)[^\\]|\\[\s\S])*\3/.source,
              // s(...)(...)
              // s{...}{...}
              // s[...][...]
              // s<...><...>
              // s(...)[...]
              t + /\s*/.source + t
            ].join("|") + ")" + /[msixpodualngcer]*/.source
          ),
          lookbehind: !0,
          greedy: !0
        },
        // /.../
        // The look-ahead tries to prevent two divisions on
        // the same line from being highlighted as regex.
        // This does not support multi-line regex.
        {
          pattern: /\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|x|xor)\b))/,
          greedy: !0
        }
      ],
      // FIXME Not sure about the handling of ::, ', and #
      variable: [
        // ${^POSTMATCH}
        /[&*$@%]\{\^[A-Z]+\}/,
        // $^V
        /[&*$@%]\^[A-Z_]/,
        // ${...}
        /[&*$@%]#?(?=\{)/,
        // $foo
        /[&*$@%]#?(?:(?:::)*'?(?!\d)[\w$]+(?![\w$]))+(?:::)*/,
        // $1
        /[&*$@%]\d+/,
        // $_, @_, %!
        // The negative lookahead prevents from breaking the %= operator
        /(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/
      ],
      filehandle: {
        // <>, <FOO>, _
        pattern: /<(?![<=])\S*?>|\b_\b/,
        alias: "symbol"
      },
      "v-string": {
        // v1.2, 1.2.3
        pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/,
        alias: "string"
      },
      function: {
        pattern: /(\bsub[ \t]+)\w+/,
        lookbehind: !0
      },
      keyword: /\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
      number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/,
      operator: /-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|xor)\b/,
      punctuation: /[{}[\];(),:]/
    };
  }(Prism)), jk;
}
var Mk = {}, Dk;
function _U() {
  return Dk || (Dk = 1, function(e) {
    var t = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/, r = [
      {
        pattern: /\b(?:false|true)\b/i,
        alias: "boolean"
      },
      {
        pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
        greedy: !0,
        lookbehind: !0
      },
      {
        pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
        greedy: !0,
        lookbehind: !0
      },
      /\b(?:null)\b/i,
      /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/
    ], n = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i, o = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/, a = /[{}\[\](),:;]/;
    e.languages.php = {
      delimiter: {
        pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
        alias: "important"
      },
      comment: t,
      variable: /\$+(?:\w+\b|(?=\{))/,
      package: {
        pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
        lookbehind: !0,
        inside: {
          punctuation: /\\/
        }
      },
      "class-name-definition": {
        pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
        lookbehind: !0,
        alias: "class-name"
      },
      "function-definition": {
        pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
        lookbehind: !0,
        alias: "function"
      },
      keyword: [
        {
          pattern: /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
          alias: "type-casting",
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
          alias: "type-hint",
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|never|object|self|static|string|void)\b/i,
          alias: "return-type",
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
          alias: "type-declaration",
          greedy: !0
        },
        {
          pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
          alias: "type-declaration",
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /\b(?:parent|self|static)(?=\s*::)/i,
          alias: "static-context",
          greedy: !0
        },
        {
          // yield from
          pattern: /(\byield\s+)from\b/i,
          lookbehind: !0
        },
        // `class` is always a keyword unlike other keywords
        /\bclass\b/i,
        {
          // https://www.php.net/manual/en/reserved.keywords.php
          //
          // keywords cannot be preceded by "->"
          // the complex lookbehind means `(?<!(?:->|::)\s*)`
          pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|never|new|or|parent|print|private|protected|public|readonly|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
          lookbehind: !0
        }
      ],
      "argument-name": {
        pattern: /([(,]\s*)\b[a-z_]\w*(?=\s*:(?!:))/i,
        lookbehind: !0
      },
      "class-name": [
        {
          pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
          greedy: !0
        },
        {
          pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
          alias: "class-name-fully-qualified",
          greedy: !0,
          lookbehind: !0,
          inside: {
            punctuation: /\\/
          }
        },
        {
          pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
          alias: "class-name-fully-qualified",
          greedy: !0,
          inside: {
            punctuation: /\\/
          }
        },
        {
          pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
          alias: "class-name-fully-qualified",
          greedy: !0,
          lookbehind: !0,
          inside: {
            punctuation: /\\/
          }
        },
        {
          pattern: /\b[a-z_]\w*(?=\s*\$)/i,
          alias: "type-declaration",
          greedy: !0
        },
        {
          pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
          alias: ["class-name-fully-qualified", "type-declaration"],
          greedy: !0,
          inside: {
            punctuation: /\\/
          }
        },
        {
          pattern: /\b[a-z_]\w*(?=\s*::)/i,
          alias: "static-context",
          greedy: !0
        },
        {
          pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
          alias: ["class-name-fully-qualified", "static-context"],
          greedy: !0,
          inside: {
            punctuation: /\\/
          }
        },
        {
          pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
          alias: "type-hint",
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
          alias: ["class-name-fully-qualified", "type-hint"],
          greedy: !0,
          lookbehind: !0,
          inside: {
            punctuation: /\\/
          }
        },
        {
          pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
          alias: "return-type",
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
          alias: ["class-name-fully-qualified", "return-type"],
          greedy: !0,
          lookbehind: !0,
          inside: {
            punctuation: /\\/
          }
        }
      ],
      constant: r,
      function: {
        pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
        lookbehind: !0,
        inside: {
          punctuation: /\\/
        }
      },
      property: {
        pattern: /(->\s*)\w+/,
        lookbehind: !0
      },
      number: n,
      operator: o,
      punctuation: a
    };
    var i = {
      pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
      lookbehind: !0,
      inside: e.languages.php
    }, u = [
      {
        pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
        alias: "nowdoc-string",
        greedy: !0,
        inside: {
          delimiter: {
            pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
            alias: "symbol",
            inside: {
              punctuation: /^<<<'?|[';]$/
            }
          }
        }
      },
      {
        pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
        alias: "heredoc-string",
        greedy: !0,
        inside: {
          delimiter: {
            pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
            alias: "symbol",
            inside: {
              punctuation: /^<<<"?|[";]$/
            }
          },
          interpolation: i
        }
      },
      {
        pattern: /`(?:\\[\s\S]|[^\\`])*`/,
        alias: "backtick-quoted-string",
        greedy: !0
      },
      {
        pattern: /'(?:\\[\s\S]|[^\\'])*'/,
        alias: "single-quoted-string",
        greedy: !0
      },
      {
        pattern: /"(?:\\[\s\S]|[^\\"])*"/,
        alias: "double-quoted-string",
        greedy: !0,
        inside: {
          interpolation: i
        }
      }
    ];
    e.languages.insertBefore("php", "variable", {
      string: u,
      attribute: {
        pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
        greedy: !0,
        inside: {
          "attribute-content": {
            pattern: /^(#\[)[\s\S]+(?=\]$)/,
            lookbehind: !0,
            // inside can appear subset of php
            inside: {
              comment: t,
              string: u,
              "attribute-class-name": [
                {
                  pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
                  alias: "class-name",
                  greedy: !0,
                  lookbehind: !0
                },
                {
                  pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
                  alias: [
                    "class-name",
                    "class-name-fully-qualified"
                  ],
                  greedy: !0,
                  lookbehind: !0,
                  inside: {
                    punctuation: /\\/
                  }
                }
              ],
              constant: r,
              number: n,
              operator: o,
              punctuation: a
            }
          },
          delimiter: {
            pattern: /^#\[|\]$/,
            alias: "punctuation"
          }
        }
      }
    }), e.hooks.add("before-tokenize", function(c) {
      if (/<\?/.test(c.code)) {
        var d = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
        e.languages["markup-templating"].buildPlaceholders(c, "php", d);
      }
    }), e.hooks.add("after-tokenize", function(c) {
      e.languages["markup-templating"].tokenizePlaceholders(c, "php");
    });
  }(Prism)), Mk;
}
var Fk = {}, qk;
function EU() {
  return qk || (qk = 1, Prism.languages.python = {
    comment: {
      pattern: /(^|[^\\])#.*/,
      lookbehind: !0,
      greedy: !0
    },
    "string-interpolation": {
      pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
      greedy: !0,
      inside: {
        interpolation: {
          // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
          pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
          lookbehind: !0,
          inside: {
            "format-spec": {
              pattern: /(:)[^:(){}]+(?=\}$)/,
              lookbehind: !0
            },
            "conversion-option": {
              pattern: /![sra](?=[:}]$)/,
              alias: "punctuation"
            },
            rest: null
          }
        },
        string: /[\s\S]+/
      }
    },
    "triple-quoted-string": {
      pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
      greedy: !0,
      alias: "string"
    },
    string: {
      pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
      greedy: !0
    },
    function: {
      pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
      lookbehind: !0
    },
    "class-name": {
      pattern: /(\bclass\s+)\w+/i,
      lookbehind: !0
    },
    decorator: {
      pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
      lookbehind: !0,
      alias: ["annotation", "punctuation"],
      inside: {
        punctuation: /\./
      }
    },
    keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
    builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
    boolean: /\b(?:False|None|True)\b/,
    number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
    operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
    punctuation: /[{}[\];(),.:]/
  }, Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python, Prism.languages.py = Prism.languages.python), Fk;
}
var zk = {}, Bk;
function OU() {
  return Bk || (Bk = 1, Prism.languages.q = {
    string: /"(?:\\.|[^"\\\r\n])*"/,
    comment: [
      // From http://code.kx.com/wiki/Reference/Slash:
      // When / is following a space (or a right parenthesis, bracket, or brace), it is ignored with the rest of the line.
      {
        pattern: /([\t )\]}])\/.*/,
        lookbehind: !0,
        greedy: !0
      },
      // From http://code.kx.com/wiki/Reference/Slash:
      // A line which has / as its first character and contains at least one other non-whitespace character is a whole-line comment and is ignored entirely.
      // A / on a line by itself begins a multiline comment which is terminated by the next \ on a line by itself.
      // If a / is not matched by a \, the multiline comment is unterminated and continues to end of file.
      // The / and \ must be the first char on the line, but may be followed by any amount of whitespace.
      {
        pattern: /(^|\r?\n|\r)\/[\t ]*(?:(?:\r?\n|\r)(?:.*(?:\r?\n|\r(?!\n)))*?(?:\\(?=[\t ]*(?:\r?\n|\r))|$)|\S.*)/,
        lookbehind: !0,
        greedy: !0
      },
      // From http://code.kx.com/wiki/Reference/Slash:
      // A \ on a line by itself with no preceding matching / will comment to end of file.
      {
        pattern: /^\\[\t ]*(?:\r?\n|\r)[\s\S]+/m,
        greedy: !0
      },
      {
        pattern: /^#!.+/m,
        greedy: !0
      }
    ],
    symbol: /`(?::\S+|[\w.]*)/,
    datetime: {
      pattern: /0N[mdzuvt]|0W[dtz]|\d{4}\.\d\d(?:m|\.\d\d(?:T(?:\d\d(?::\d\d(?::\d\d(?:[.:]\d\d\d)?)?)?)?)?[dz]?)|\d\d:\d\d(?::\d\d(?:[.:]\d\d\d)?)?[uvt]?/,
      alias: "number"
    },
    // The negative look-ahead prevents bad highlighting
    // of verbs 0: and 1:
    number: /\b(?![01]:)(?:0N[hje]?|0W[hj]?|0[wn]|0x[\da-fA-F]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?[hjfeb]?)/,
    keyword: /\\\w+\b|\b(?:abs|acos|aj0?|all|and|any|asc|asin|asof|atan|attr|avgs?|binr?|by|ceiling|cols|cor|cos|count|cov|cross|csv|cut|delete|deltas|desc|dev|differ|distinct|div|do|dsave|ej|enlist|eval|except|exec|exit|exp|fby|fills|first|fkeys|flip|floor|from|get|getenv|group|gtime|hclose|hcount|hdel|hopen|hsym|iasc|identity|idesc|if|ij|in|insert|inter|inv|keys?|last|like|list|ljf?|load|log|lower|lsq|ltime|ltrim|mavg|maxs?|mcount|md5|mdev|med|meta|mins?|mmax|mmin|mmu|mod|msum|neg|next|not|null|or|over|parse|peach|pj|plist|prds?|prev|prior|rand|rank|ratios|raze|read0|read1|reciprocal|reval|reverse|rload|rotate|rsave|rtrim|save|scan|scov|sdev|select|set|setenv|show|signum|sin|sqrt|ssr?|string|sublist|sums?|sv|svar|system|tables|tan|til|trim|txf|type|uj|ungroup|union|update|upper|upsert|value|var|views?|vs|wavg|where|while|within|wj1?|wsum|ww|xasc|xbar|xcols?|xdesc|xexp|xgroup|xkey|xlog|xprev|xrank)\b/,
    adverb: {
      pattern: /['\/\\]:?|\beach\b/,
      alias: "function"
    },
    verb: {
      pattern: /(?:\B\.\B|\b[01]:|<[=>]?|>=?|[:+\-*%,!?~=|$&#@^]):?|\b_\b:?/,
      alias: "operator"
    },
    punctuation: /[(){}\[\];.]/
  }), zk;
}
var Uk = {}, Vk;
function kU() {
  return Vk || (Vk = 1, function(e) {
    e.languages.ruby = e.languages.extend("clike", {
      comment: {
        pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
        greedy: !0
      },
      "class-name": {
        pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
        lookbehind: !0,
        inside: {
          punctuation: /[.\\]/
        }
      },
      keyword: /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
      operator: /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
      punctuation: /[(){}[\].,;]/
    }), e.languages.insertBefore("ruby", "operator", {
      "double-colon": {
        pattern: /::/,
        alias: "punctuation"
      }
    });
    var t = {
      pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
      lookbehind: !0,
      inside: {
        content: {
          pattern: /^(#\{)[\s\S]+(?=\}$)/,
          lookbehind: !0,
          inside: e.languages.ruby
        },
        delimiter: {
          pattern: /^#\{|\}$/,
          alias: "punctuation"
        }
      }
    };
    delete e.languages.ruby.function;
    var r = "(?:" + [
      /([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
      /\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source,
      /\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source,
      /\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source,
      /<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source
    ].join("|") + ")", n = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source;
    e.languages.insertBefore("ruby", "keyword", {
      "regex-literal": [
        {
          pattern: RegExp(/%r/.source + r + /[egimnosux]{0,6}/.source),
          greedy: !0,
          inside: {
            interpolation: t,
            regex: /[\s\S]+/
          }
        },
        {
          pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
          lookbehind: !0,
          greedy: !0,
          inside: {
            interpolation: t,
            regex: /[\s\S]+/
          }
        }
      ],
      variable: /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
      symbol: [
        {
          pattern: RegExp(/(^|[^:]):/.source + n),
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: RegExp(/([\r\n{(,][ \t]*)/.source + n + /(?=:(?!:))/.source),
          lookbehind: !0,
          greedy: !0
        }
      ],
      "method-definition": {
        pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
        lookbehind: !0,
        inside: {
          function: /\b\w+$/,
          keyword: /^self\b/,
          "class-name": /^\w+/,
          punctuation: /\./
        }
      }
    }), e.languages.insertBefore("ruby", "string", {
      "string-literal": [
        {
          pattern: RegExp(/%[qQiIwWs]?/.source + r),
          greedy: !0,
          inside: {
            interpolation: t,
            string: /[\s\S]+/
          }
        },
        {
          pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
          greedy: !0,
          inside: {
            interpolation: t,
            string: /[\s\S]+/
          }
        },
        {
          pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
          alias: "heredoc-string",
          greedy: !0,
          inside: {
            delimiter: {
              pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
              inside: {
                symbol: /\b\w+/,
                punctuation: /^<<[-~]?/
              }
            },
            interpolation: t,
            string: /[\s\S]+/
          }
        },
        {
          pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
          alias: "heredoc-string",
          greedy: !0,
          inside: {
            delimiter: {
              pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
              inside: {
                symbol: /\b\w+/,
                punctuation: /^<<[-~]?'|'$/
              }
            },
            string: /[\s\S]+/
          }
        }
      ],
      "command-literal": [
        {
          pattern: RegExp(/%x/.source + r),
          greedy: !0,
          inside: {
            interpolation: t,
            command: {
              pattern: /[\s\S]+/,
              alias: "string"
            }
          }
        },
        {
          pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
          greedy: !0,
          inside: {
            interpolation: t,
            command: {
              pattern: /[\s\S]+/,
              alias: "string"
            }
          }
        }
      ]
    }), delete e.languages.ruby.string, e.languages.insertBefore("ruby", "number", {
      builtin: /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
      constant: /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
    }), e.languages.rb = e.languages.ruby;
  }(Prism)), Uk;
}
var Hk = {}, Wk;
function AU() {
  return Wk || (Wk = 1, Prism.languages.scala = Prism.languages.extend("java", {
    "triple-quoted-string": {
      pattern: /"""[\s\S]*?"""/,
      greedy: !0,
      alias: "string"
    },
    string: {
      pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    keyword: /<-|=>|\b(?:abstract|case|catch|class|def|derives|do|else|enum|extends|extension|final|finally|for|forSome|given|if|implicit|import|infix|inline|lazy|match|new|null|object|opaque|open|override|package|private|protected|return|sealed|self|super|this|throw|trait|transparent|try|type|using|val|var|while|with|yield)\b/,
    number: /\b0x(?:[\da-f]*\.)?[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e\d+)?[dfl]?/i,
    builtin: /\b(?:Any|AnyRef|AnyVal|Boolean|Byte|Char|Double|Float|Int|Long|Nothing|Short|String|Unit)\b/,
    symbol: /'[^\d\s\\]\w*/
  }), Prism.languages.insertBefore("scala", "triple-quoted-string", {
    "string-interpolation": {
      pattern: /\b[a-z]\w*(?:"""(?:[^$]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*?"""|"(?:[^$"\r\n]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*")/i,
      greedy: !0,
      inside: {
        id: {
          pattern: /^\w+/,
          greedy: !0,
          alias: "function"
        },
        escape: {
          pattern: /\\\$"|\$[$"]/,
          greedy: !0,
          alias: "symbol"
        },
        interpolation: {
          pattern: /\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
          greedy: !0,
          inside: {
            punctuation: /^\$\{?|\}$/,
            expression: {
              pattern: /[\s\S]+/,
              inside: Prism.languages.scala
            }
          }
        },
        string: /[\s\S]+/
      }
    }
  }), delete Prism.languages.scala["class-name"], delete Prism.languages.scala.function, delete Prism.languages.scala.constant), Hk;
}
var Kk = {}, Qk;
function PU() {
  return Qk || (Qk = 1, Prism.languages.sql = {
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
      lookbehind: !0
    },
    variable: [
      {
        pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
        greedy: !0
      },
      /@[\w.$]+/
    ],
    string: {
      pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
      greedy: !0,
      lookbehind: !0
    },
    identifier: {
      pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
      greedy: !0,
      lookbehind: !0,
      inside: {
        punctuation: /^`|`$/
      }
    },
    function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
    // Should we highlight user defined functions too?
    keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
    boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
    number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
    operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
    punctuation: /[;[\]()`,.]/
  }), Kk;
}
var Yk = {}, Gk;
function TU() {
  return Gk || (Gk = 1, Prism.languages.swift = {
    comment: {
      // Nested comments are supported up to 2 levels
      pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
      lookbehind: !0,
      greedy: !0
    },
    "string-literal": [
      // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
      {
        pattern: RegExp(
          /(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
            lookbehind: !0,
            inside: null
            // see below
          },
          "interpolation-punctuation": {
            pattern: /^\)|\\\($/,
            alias: "punctuation"
          },
          punctuation: /\\(?=[\r\n])/,
          string: /[\s\S]+/
        }
      },
      {
        pattern: RegExp(
          /(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
            lookbehind: !0,
            inside: null
            // see below
          },
          "interpolation-punctuation": {
            pattern: /^\)|\\#+\($/,
            alias: "punctuation"
          },
          string: /[\s\S]+/
        }
      }
    ],
    directive: {
      // directives with conditions
      pattern: RegExp(
        /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
      ),
      alias: "property",
      inside: {
        "directive-name": /^#\w+/,
        boolean: /\b(?:false|true)\b/,
        number: /\b\d+(?:\.\d+)*\b/,
        operator: /!|&&|\|\||[<>]=?/,
        punctuation: /[(),]/
      }
    },
    literal: {
      pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
      alias: "constant"
    },
    "other-directive": {
      pattern: /#\w+\b/,
      alias: "property"
    },
    attribute: {
      pattern: /@\w+/,
      alias: "atrule"
    },
    "function-definition": {
      pattern: /(\bfunc\s+)\w+/,
      lookbehind: !0,
      alias: "function"
    },
    label: {
      // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
      pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
      lookbehind: !0,
      alias: "important"
    },
    keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
    boolean: /\b(?:false|true)\b/,
    nil: {
      pattern: /\bnil\b/,
      alias: "constant"
    },
    "short-argument": /\$\d+\b/,
    omit: {
      pattern: /\b_\b/,
      alias: "keyword"
    },
    number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
    // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
    "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
    // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
    // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
    // This regex only supports ASCII operators.
    operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
    punctuation: /[{}[\]();,.:\\]/
  }, Prism.languages.swift["string-literal"].forEach(function(e) {
    e.inside.interpolation.inside = Prism.languages.swift;
  })), Yk;
}
var Xk = {}, Jk;
function CU() {
  return Jk || (Jk = 1, function(e) {
    var t = /[*&][^\s[\]{},]+/, r = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/, n = "(?:" + r.source + "(?:[ 	]+" + t.source + ")?|" + t.source + "(?:[ 	]+" + r.source + ")?)", o = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
      return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
    }), a = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
    function i(u, c) {
      c = (c || "").replace(/m/g, "") + "m";
      var d = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
        return n;
      }).replace(/<<value>>/g, function() {
        return u;
      });
      return RegExp(d, c);
    }
    e.languages.yaml = {
      scalar: {
        pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
          return n;
        })),
        lookbehind: !0,
        alias: "string"
      },
      comment: /#.*/,
      key: {
        pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
          return n;
        }).replace(/<<key>>/g, function() {
          return "(?:" + o + "|" + a + ")";
        })),
        lookbehind: !0,
        greedy: !0,
        alias: "atrule"
      },
      directive: {
        pattern: /(^[ \t]*)%.+/m,
        lookbehind: !0,
        alias: "important"
      },
      datetime: {
        pattern: i(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
        lookbehind: !0,
        alias: "number"
      },
      boolean: {
        pattern: i(/false|true/.source, "i"),
        lookbehind: !0,
        alias: "important"
      },
      null: {
        pattern: i(/null|~/.source, "i"),
        lookbehind: !0,
        alias: "important"
      },
      string: {
        pattern: i(a),
        lookbehind: !0,
        greedy: !0
      },
      number: {
        pattern: i(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"),
        lookbehind: !0
      },
      tag: r,
      important: t,
      punctuation: /---|[:[\]{}\-,|>?]|\.\.\./
    }, e.languages.yml = e.languages.yaml;
  }(Prism)), Xk;
}
var Zk = {}, eA;
function $U() {
  return eA || (eA = 1, Prism.languages.csv = {
    value: /[^\r\n,"]+|"(?:[^"]|"")*"(?!")/,
    punctuation: /,/
  }), Zk;
}
var Vy = { exports: {} };
/*!***************************************************
* mark.js v8.11.1
* https://markjs.io/
* Copyright (c) 2014–2018, Julian Kühnel
* Released under the MIT license https://git.io/vwTVl
*****************************************************/
var RU = Vy.exports, tA;
function IU() {
  return tA || (tA = 1, function(e, t) {
    (function(r, n) {
      e.exports = n();
    })(RU, function() {
      var r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
        return typeof d;
      } : function(d) {
        return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
      }, n = function(d, m) {
        if (!(d instanceof m))
          throw new TypeError("Cannot call a class as a function");
      }, o = /* @__PURE__ */ function() {
        function d(m, g) {
          for (var v = 0; v < g.length; v++) {
            var S = g[v];
            S.enumerable = S.enumerable || !1, S.configurable = !0, "value" in S && (S.writable = !0), Object.defineProperty(m, S.key, S);
          }
        }
        return function(m, g, v) {
          return g && d(m.prototype, g), v && d(m, v), m;
        };
      }(), a = Object.assign || function(d) {
        for (var m = 1; m < arguments.length; m++) {
          var g = arguments[m];
          for (var v in g)
            Object.prototype.hasOwnProperty.call(g, v) && (d[v] = g[v]);
        }
        return d;
      }, i = function() {
        function d(m) {
          var g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], S = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5e3;
          n(this, d), this.ctx = m, this.iframes = g, this.exclude = v, this.iframesTimeout = S;
        }
        return o(d, [{
          key: "getContexts",
          value: function() {
            var g = void 0, v = [];
            return typeof this.ctx > "u" || !this.ctx ? g = [] : NodeList.prototype.isPrototypeOf(this.ctx) ? g = Array.prototype.slice.call(this.ctx) : Array.isArray(this.ctx) ? g = this.ctx : typeof this.ctx == "string" ? g = Array.prototype.slice.call(document.querySelectorAll(this.ctx)) : g = [this.ctx], g.forEach(function(S) {
              var k = v.filter(function(b) {
                return b.contains(S);
              }).length > 0;
              v.indexOf(S) === -1 && !k && v.push(S);
            }), v;
          }
        }, {
          key: "getIframeContents",
          value: function(g, v) {
            var S = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
            }, k = void 0;
            try {
              var b = g.contentWindow;
              if (k = b.document, !b || !k)
                throw new Error("iframe inaccessible");
            } catch {
              S();
            }
            k && v(k);
          }
        }, {
          key: "isIframeBlank",
          value: function(g) {
            var v = "about:blank", S = g.getAttribute("src").trim(), k = g.contentWindow.location.href;
            return k === v && S !== v && S;
          }
        }, {
          key: "observeIframeLoad",
          value: function(g, v, S) {
            var k = this, b = !1, x = null, A = function _() {
              if (!b) {
                b = !0, clearTimeout(x);
                try {
                  k.isIframeBlank(g) || (g.removeEventListener("load", _), k.getIframeContents(g, v, S));
                } catch {
                  S();
                }
              }
            };
            g.addEventListener("load", A), x = setTimeout(A, this.iframesTimeout);
          }
        }, {
          key: "onIframeReady",
          value: function(g, v, S) {
            try {
              g.contentWindow.document.readyState === "complete" ? this.isIframeBlank(g) ? this.observeIframeLoad(g, v, S) : this.getIframeContents(g, v, S) : this.observeIframeLoad(g, v, S);
            } catch {
              S();
            }
          }
        }, {
          key: "waitForIframes",
          value: function(g, v) {
            var S = this, k = 0;
            this.forEachIframe(g, function() {
              return !0;
            }, function(b) {
              k++, S.waitForIframes(b.querySelector("html"), function() {
                --k || v();
              });
            }, function(b) {
              b || v();
            });
          }
        }, {
          key: "forEachIframe",
          value: function(g, v, S) {
            var k = this, b = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function() {
            }, x = g.querySelectorAll("iframe"), A = x.length, _ = 0;
            x = Array.prototype.slice.call(x);
            var O = function() {
              --A <= 0 && b(_);
            };
            A || O(), x.forEach(function(R) {
              d.matches(R, k.exclude) ? O() : k.onIframeReady(R, function(C) {
                v(R) && (_++, S(C)), O();
              }, O);
            });
          }
        }, {
          key: "createIterator",
          value: function(g, v, S) {
            return document.createNodeIterator(g, v, S, !1);
          }
        }, {
          key: "createInstanceOnIframe",
          value: function(g) {
            return new d(g.querySelector("html"), this.iframes);
          }
        }, {
          key: "compareNodeIframe",
          value: function(g, v, S) {
            var k = g.compareDocumentPosition(S), b = Node.DOCUMENT_POSITION_PRECEDING;
            if (k & b)
              if (v !== null) {
                var x = v.compareDocumentPosition(S), A = Node.DOCUMENT_POSITION_FOLLOWING;
                if (x & A)
                  return !0;
              } else
                return !0;
            return !1;
          }
        }, {
          key: "getIteratorNode",
          value: function(g) {
            var v = g.previousNode(), S = void 0;
            return v === null ? S = g.nextNode() : S = g.nextNode() && g.nextNode(), {
              prevNode: v,
              node: S
            };
          }
        }, {
          key: "checkIframeFilter",
          value: function(g, v, S, k) {
            var b = !1, x = !1;
            return k.forEach(function(A, _) {
              A.val === S && (b = _, x = A.handled);
            }), this.compareNodeIframe(g, v, S) ? (b === !1 && !x ? k.push({
              val: S,
              handled: !0
            }) : b !== !1 && !x && (k[b].handled = !0), !0) : (b === !1 && k.push({
              val: S,
              handled: !1
            }), !1);
          }
        }, {
          key: "handleOpenIframes",
          value: function(g, v, S, k) {
            var b = this;
            g.forEach(function(x) {
              x.handled || b.getIframeContents(x.val, function(A) {
                b.createInstanceOnIframe(A).forEachNode(v, S, k);
              });
            });
          }
        }, {
          key: "iterateThroughNodes",
          value: function(g, v, S, k, b) {
            for (var x = this, A = this.createIterator(v, g, k), _ = [], O = [], R = void 0, C = void 0, T = function() {
              var D = x.getIteratorNode(A);
              return C = D.prevNode, R = D.node, R;
            }; T(); )
              this.iframes && this.forEachIframe(v, function(j) {
                return x.checkIframeFilter(R, C, j, _);
              }, function(j) {
                x.createInstanceOnIframe(j).forEachNode(g, function(D) {
                  return O.push(D);
                }, k);
              }), O.push(R);
            O.forEach(function(j) {
              S(j);
            }), this.iframes && this.handleOpenIframes(_, g, S, k), b();
          }
        }, {
          key: "forEachNode",
          value: function(g, v, S) {
            var k = this, b = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function() {
            }, x = this.getContexts(), A = x.length;
            A || b(), x.forEach(function(_) {
              var O = function() {
                k.iterateThroughNodes(g, _, v, S, function() {
                  --A <= 0 && b();
                });
              };
              k.iframes ? k.waitForIframes(_, O) : O();
            });
          }
        }], [{
          key: "matches",
          value: function(g, v) {
            var S = typeof v == "string" ? [v] : v, k = g.matches || g.matchesSelector || g.msMatchesSelector || g.mozMatchesSelector || g.oMatchesSelector || g.webkitMatchesSelector;
            if (k) {
              var b = !1;
              return S.every(function(x) {
                return k.call(g, x) ? (b = !0, !1) : !0;
              }), b;
            } else
              return !1;
          }
        }]), d;
      }(), u = function() {
        function d(m) {
          n(this, d), this.ctx = m, this.ie = !1;
          var g = window.navigator.userAgent;
          (g.indexOf("MSIE") > -1 || g.indexOf("Trident") > -1) && (this.ie = !0);
        }
        return o(d, [{
          key: "log",
          value: function(g) {
            var v = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "debug", S = this.opt.log;
            this.opt.debug && (typeof S > "u" ? "undefined" : r(S)) === "object" && typeof S[v] == "function" && S[v]("mark.js: " + g);
          }
        }, {
          key: "escapeStr",
          value: function(g) {
            return g.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
          }
        }, {
          key: "createRegExp",
          value: function(g) {
            return this.opt.wildcards !== "disabled" && (g = this.setupWildcardsRegExp(g)), g = this.escapeStr(g), Object.keys(this.opt.synonyms).length && (g = this.createSynonymsRegExp(g)), (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) && (g = this.setupIgnoreJoinersRegExp(g)), this.opt.diacritics && (g = this.createDiacriticsRegExp(g)), g = this.createMergedBlanksRegExp(g), (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) && (g = this.createJoinersRegExp(g)), this.opt.wildcards !== "disabled" && (g = this.createWildcardsRegExp(g)), g = this.createAccuracyRegExp(g), g;
          }
        }, {
          key: "createSynonymsRegExp",
          value: function(g) {
            var v = this.opt.synonyms, S = this.opt.caseSensitive ? "" : "i", k = this.opt.ignoreJoiners || this.opt.ignorePunctuation.length ? "\0" : "";
            for (var b in v)
              if (v.hasOwnProperty(b)) {
                var x = v[b], A = this.opt.wildcards !== "disabled" ? this.setupWildcardsRegExp(b) : this.escapeStr(b), _ = this.opt.wildcards !== "disabled" ? this.setupWildcardsRegExp(x) : this.escapeStr(x);
                A !== "" && _ !== "" && (g = g.replace(new RegExp("(" + this.escapeStr(A) + "|" + this.escapeStr(_) + ")", "gm" + S), k + ("(" + this.processSynomyms(A) + "|") + (this.processSynomyms(_) + ")") + k));
              }
            return g;
          }
        }, {
          key: "processSynomyms",
          value: function(g) {
            return (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) && (g = this.setupIgnoreJoinersRegExp(g)), g;
          }
        }, {
          key: "setupWildcardsRegExp",
          value: function(g) {
            return g = g.replace(/(?:\\)*\?/g, function(v) {
              return v.charAt(0) === "\\" ? "?" : "";
            }), g.replace(/(?:\\)*\*/g, function(v) {
              return v.charAt(0) === "\\" ? "*" : "";
            });
          }
        }, {
          key: "createWildcardsRegExp",
          value: function(g) {
            var v = this.opt.wildcards === "withSpaces";
            return g.replace(/\u0001/g, v ? "[\\S\\s]?" : "\\S?").replace(/\u0002/g, v ? "[\\S\\s]*?" : "\\S*");
          }
        }, {
          key: "setupIgnoreJoinersRegExp",
          value: function(g) {
            return g.replace(/[^(|)\\]/g, function(v, S, k) {
              var b = k.charAt(S + 1);
              return /[(|)\\]/.test(b) || b === "" ? v : v + "\0";
            });
          }
        }, {
          key: "createJoinersRegExp",
          value: function(g) {
            var v = [], S = this.opt.ignorePunctuation;
            return Array.isArray(S) && S.length && v.push(this.escapeStr(S.join(""))), this.opt.ignoreJoiners && v.push("\\u00ad\\u200b\\u200c\\u200d"), v.length ? g.split(/\u0000+/).join("[" + v.join("") + "]*") : g;
          }
        }, {
          key: "createDiacriticsRegExp",
          value: function(g) {
            var v = this.opt.caseSensitive ? "" : "i", S = this.opt.caseSensitive ? ["aàáảãạăằắẳẵặâầấẩẫậäåāą", "AÀÁẢÃẠĂẰẮẲẴẶÂẦẤẨẪẬÄÅĀĄ", "cçćč", "CÇĆČ", "dđď", "DĐĎ", "eèéẻẽẹêềếểễệëěēę", "EÈÉẺẼẸÊỀẾỂỄỆËĚĒĘ", "iìíỉĩịîïī", "IÌÍỈĨỊÎÏĪ", "lł", "LŁ", "nñňń", "NÑŇŃ", "oòóỏõọôồốổỗộơởỡớờợöøō", "OÒÓỎÕỌÔỒỐỔỖỘƠỞỠỚỜỢÖØŌ", "rř", "RŘ", "sšśșş", "SŠŚȘŞ", "tťțţ", "TŤȚŢ", "uùúủũụưừứửữựûüůū", "UÙÚỦŨỤƯỪỨỬỮỰÛÜŮŪ", "yýỳỷỹỵÿ", "YÝỲỶỸỴŸ", "zžżź", "ZŽŻŹ"] : ["aàáảãạăằắẳẵặâầấẩẫậäåāąAÀÁẢÃẠĂẰẮẲẴẶÂẦẤẨẪẬÄÅĀĄ", "cçćčCÇĆČ", "dđďDĐĎ", "eèéẻẽẹêềếểễệëěēęEÈÉẺẼẸÊỀẾỂỄỆËĚĒĘ", "iìíỉĩịîïīIÌÍỈĨỊÎÏĪ", "lłLŁ", "nñňńNÑŇŃ", "oòóỏõọôồốổỗộơởỡớờợöøōOÒÓỎÕỌÔỒỐỔỖỘƠỞỠỚỜỢÖØŌ", "rřRŘ", "sšśșşSŠŚȘŞ", "tťțţTŤȚŢ", "uùúủũụưừứửữựûüůūUÙÚỦŨỤƯỪỨỬỮỰÛÜŮŪ", "yýỳỷỹỵÿYÝỲỶỸỴŸ", "zžżźZŽŻŹ"], k = [];
            return g.split("").forEach(function(b) {
              S.every(function(x) {
                if (x.indexOf(b) !== -1) {
                  if (k.indexOf(x) > -1)
                    return !1;
                  g = g.replace(new RegExp("[" + x + "]", "gm" + v), "[" + x + "]"), k.push(x);
                }
                return !0;
              });
            }), g;
          }
        }, {
          key: "createMergedBlanksRegExp",
          value: function(g) {
            return g.replace(/[\s]+/gmi, "[\\s]+");
          }
        }, {
          key: "createAccuracyRegExp",
          value: function(g) {
            var v = this, S = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~¡¿", k = this.opt.accuracy, b = typeof k == "string" ? k : k.value, x = typeof k == "string" ? [] : k.limiters, A = "";
            switch (x.forEach(function(_) {
              A += "|" + v.escapeStr(_);
            }), b) {
              case "partially":
              default:
                return "()(" + g + ")";
              case "complementary":
                return A = "\\s" + (A || this.escapeStr(S)), "()([^" + A + "]*" + g + "[^" + A + "]*)";
              case "exactly":
                return "(^|\\s" + A + ")(" + g + ")(?=$|\\s" + A + ")";
            }
          }
        }, {
          key: "getSeparatedKeywords",
          value: function(g) {
            var v = this, S = [];
            return g.forEach(function(k) {
              v.opt.separateWordSearch ? k.split(" ").forEach(function(b) {
                b.trim() && S.indexOf(b) === -1 && S.push(b);
              }) : k.trim() && S.indexOf(k) === -1 && S.push(k);
            }), {
              keywords: S.sort(function(k, b) {
                return b.length - k.length;
              }),
              length: S.length
            };
          }
        }, {
          key: "isNumeric",
          value: function(g) {
            return Number(parseFloat(g)) == g;
          }
        }, {
          key: "checkRanges",
          value: function(g) {
            var v = this;
            if (!Array.isArray(g) || Object.prototype.toString.call(g[0]) !== "[object Object]")
              return this.log("markRanges() will only accept an array of objects"), this.opt.noMatch(g), [];
            var S = [], k = 0;
            return g.sort(function(b, x) {
              return b.start - x.start;
            }).forEach(function(b) {
              var x = v.callNoMatchOnInvalidRanges(b, k), A = x.start, _ = x.end, O = x.valid;
              O && (b.start = A, b.length = _ - A, S.push(b), k = _);
            }), S;
          }
        }, {
          key: "callNoMatchOnInvalidRanges",
          value: function(g, v) {
            var S = void 0, k = void 0, b = !1;
            return g && typeof g.start < "u" ? (S = parseInt(g.start, 10), k = S + parseInt(g.length, 10), this.isNumeric(g.start) && this.isNumeric(g.length) && k - v > 0 && k - S > 0 ? b = !0 : (this.log("Ignoring invalid or overlapping range: " + ("" + JSON.stringify(g))), this.opt.noMatch(g))) : (this.log("Ignoring invalid range: " + JSON.stringify(g)), this.opt.noMatch(g)), {
              start: S,
              end: k,
              valid: b
            };
          }
        }, {
          key: "checkWhitespaceRanges",
          value: function(g, v, S) {
            var k = void 0, b = !0, x = S.length, A = v - x, _ = parseInt(g.start, 10) - A;
            return _ = _ > x ? x : _, k = _ + parseInt(g.length, 10), k > x && (k = x, this.log("End range automatically set to the max value of " + x)), _ < 0 || k - _ < 0 || _ > x || k > x ? (b = !1, this.log("Invalid range: " + JSON.stringify(g)), this.opt.noMatch(g)) : S.substring(_, k).replace(/\s+/g, "") === "" && (b = !1, this.log("Skipping whitespace only range: " + JSON.stringify(g)), this.opt.noMatch(g)), {
              start: _,
              end: k,
              valid: b
            };
          }
        }, {
          key: "getTextNodes",
          value: function(g) {
            var v = this, S = "", k = [];
            this.iterator.forEachNode(NodeFilter.SHOW_TEXT, function(b) {
              k.push({
                start: S.length,
                end: (S += b.textContent).length,
                node: b
              });
            }, function(b) {
              return v.matchesExclude(b.parentNode) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
            }, function() {
              g({
                value: S,
                nodes: k
              });
            });
          }
        }, {
          key: "matchesExclude",
          value: function(g) {
            return i.matches(g, this.opt.exclude.concat(["script", "style", "title", "head", "html"]));
          }
        }, {
          key: "wrapRangeInTextNode",
          value: function(g, v, S) {
            var k = this.opt.element ? this.opt.element : "mark", b = g.splitText(v), x = b.splitText(S - v), A = document.createElement(k);
            return A.setAttribute("data-markjs", "true"), this.opt.className && A.setAttribute("class", this.opt.className), A.textContent = b.textContent, b.parentNode.replaceChild(A, b), x;
          }
        }, {
          key: "wrapRangeInMappedTextNode",
          value: function(g, v, S, k, b) {
            var x = this;
            g.nodes.every(function(A, _) {
              var O = g.nodes[_ + 1];
              if (typeof O > "u" || O.start > v) {
                if (!k(A.node))
                  return !1;
                var R = v - A.start, C = (S > A.end ? A.end : S) - A.start, T = g.value.substr(0, A.start), j = g.value.substr(C + A.start);
                if (A.node = x.wrapRangeInTextNode(A.node, R, C), g.value = T + j, g.nodes.forEach(function(D, V) {
                  V >= _ && (g.nodes[V].start > 0 && V !== _ && (g.nodes[V].start -= C), g.nodes[V].end -= C);
                }), S -= C, b(A.node.previousSibling, A.start), S > A.end)
                  v = A.end;
                else
                  return !1;
              }
              return !0;
            });
          }
        }, {
          key: "wrapMatches",
          value: function(g, v, S, k, b) {
            var x = this, A = v === 0 ? 0 : v + 1;
            this.getTextNodes(function(_) {
              _.nodes.forEach(function(O) {
                O = O.node;
                for (var R = void 0; (R = g.exec(O.textContent)) !== null && R[A] !== ""; )
                  if (S(R[A], O)) {
                    var C = R.index;
                    if (A !== 0)
                      for (var T = 1; T < A; T++)
                        C += R[T].length;
                    O = x.wrapRangeInTextNode(O, C, C + R[A].length), k(O.previousSibling), g.lastIndex = 0;
                  }
              }), b();
            });
          }
        }, {
          key: "wrapMatchesAcrossElements",
          value: function(g, v, S, k, b) {
            var x = this, A = v === 0 ? 0 : v + 1;
            this.getTextNodes(function(_) {
              for (var O = void 0; (O = g.exec(_.value)) !== null && O[A] !== ""; ) {
                var R = O.index;
                if (A !== 0)
                  for (var C = 1; C < A; C++)
                    R += O[C].length;
                var T = R + O[A].length;
                x.wrapRangeInMappedTextNode(_, R, T, function(j) {
                  return S(O[A], j);
                }, function(j, D) {
                  g.lastIndex = D, k(j);
                });
              }
              b();
            });
          }
        }, {
          key: "wrapRangeFromIndex",
          value: function(g, v, S, k) {
            var b = this;
            this.getTextNodes(function(x) {
              var A = x.value.length;
              g.forEach(function(_, O) {
                var R = b.checkWhitespaceRanges(_, A, x.value), C = R.start, T = R.end, j = R.valid;
                j && b.wrapRangeInMappedTextNode(x, C, T, function(D) {
                  return v(D, _, x.value.substring(C, T), O);
                }, function(D) {
                  S(D, _);
                });
              }), k();
            });
          }
        }, {
          key: "unwrapMatches",
          value: function(g) {
            for (var v = g.parentNode, S = document.createDocumentFragment(); g.firstChild; )
              S.appendChild(g.removeChild(g.firstChild));
            v.replaceChild(S, g), this.ie ? this.normalizeTextNode(v) : v.normalize();
          }
        }, {
          key: "normalizeTextNode",
          value: function(g) {
            if (g) {
              if (g.nodeType === 3)
                for (; g.nextSibling && g.nextSibling.nodeType === 3; )
                  g.nodeValue += g.nextSibling.nodeValue, g.parentNode.removeChild(g.nextSibling);
              else
                this.normalizeTextNode(g.firstChild);
              this.normalizeTextNode(g.nextSibling);
            }
          }
        }, {
          key: "markRegExp",
          value: function(g, v) {
            var S = this;
            this.opt = v, this.log('Searching with expression "' + g + '"');
            var k = 0, b = "wrapMatches", x = function(_) {
              k++, S.opt.each(_);
            };
            this.opt.acrossElements && (b = "wrapMatchesAcrossElements"), this[b](g, this.opt.ignoreGroups, function(A, _) {
              return S.opt.filter(_, A, k);
            }, x, function() {
              k === 0 && S.opt.noMatch(g), S.opt.done(k);
            });
          }
        }, {
          key: "mark",
          value: function(g, v) {
            var S = this;
            this.opt = v;
            var k = 0, b = "wrapMatches", x = this.getSeparatedKeywords(typeof g == "string" ? [g] : g), A = x.keywords, _ = x.length, O = this.opt.caseSensitive ? "" : "i", R = function C(T) {
              var j = new RegExp(S.createRegExp(T), "gm" + O), D = 0;
              S.log('Searching with expression "' + j + '"'), S[b](j, 1, function(V, U) {
                return S.opt.filter(U, T, k, D);
              }, function(V) {
                D++, k++, S.opt.each(V);
              }, function() {
                D === 0 && S.opt.noMatch(T), A[_ - 1] === T ? S.opt.done(k) : C(A[A.indexOf(T) + 1]);
              });
            };
            this.opt.acrossElements && (b = "wrapMatchesAcrossElements"), _ === 0 ? this.opt.done(k) : R(A[0]);
          }
        }, {
          key: "markRanges",
          value: function(g, v) {
            var S = this;
            this.opt = v;
            var k = 0, b = this.checkRanges(g);
            b && b.length ? (this.log("Starting to mark with the following ranges: " + JSON.stringify(b)), this.wrapRangeFromIndex(b, function(x, A, _, O) {
              return S.opt.filter(x, A, _, O);
            }, function(x, A) {
              k++, S.opt.each(x, A);
            }, function() {
              S.opt.done(k);
            })) : this.opt.done(k);
          }
        }, {
          key: "unmark",
          value: function(g) {
            var v = this;
            this.opt = g;
            var S = this.opt.element ? this.opt.element : "*";
            S += "[data-markjs]", this.opt.className && (S += "." + this.opt.className), this.log('Removal selector "' + S + '"'), this.iterator.forEachNode(NodeFilter.SHOW_ELEMENT, function(k) {
              v.unwrapMatches(k);
            }, function(k) {
              var b = i.matches(k, S), x = v.matchesExclude(k);
              return !b || x ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
            }, this.opt.done);
          }
        }, {
          key: "opt",
          set: function(g) {
            this._opt = a({}, {
              element: "",
              className: "",
              exclude: [],
              iframes: !1,
              iframesTimeout: 5e3,
              separateWordSearch: !0,
              diacritics: !0,
              synonyms: {},
              accuracy: "partially",
              acrossElements: !1,
              caseSensitive: !1,
              ignoreJoiners: !1,
              ignoreGroups: 0,
              ignorePunctuation: [],
              wildcards: "disabled",
              each: function() {
              },
              noMatch: function() {
              },
              filter: function() {
                return !0;
              },
              done: function() {
              },
              debug: !1,
              log: window.console
            }, g);
          },
          get: function() {
            return this._opt;
          }
        }, {
          key: "iterator",
          get: function() {
            return new i(this.ctx, this.opt.iframes, this.opt.exclude, this.opt.iframesTimeout);
          }
        }]), d;
      }();
      function c(d) {
        var m = this, g = new u(d);
        return this.mark = function(v, S) {
          return g.mark(v, S), m;
        }, this.markRegExp = function(v, S) {
          return g.markRegExp(v, S), m;
        }, this.markRanges = function(v, S) {
          return g.markRanges(v, S), m;
        }, this.unmark = function(v) {
          return g.unmark(v), m;
        }, this;
      }
      return c;
    });
  }(Vy)), Vy.exports;
}
function qd(e) {
  return e < 10 ? "0" + e : e;
}
function NU(e, t, r, n) {
  var o = r ? "" : e.getUTCFullYear() + "-" + qd(e.getUTCMonth() + 1) + "-" + qd(e.getUTCDate());
  return t || (o += "T" + qd(e.getUTCHours()) + ":" + qd(e.getUTCMinutes()) + ":" + qd(e.getUTCSeconds()) + "Z"), o;
}
function v$(e, t) {
  return t > e.length ? e.repeat(Math.trunc(t / e.length) + 1).substring(0, t) : e;
}
function bv(...e) {
  const t = (r) => r && typeof r == "object";
  return e.reduce((r, n) => (Object.keys(n || {}).forEach((o) => {
    const a = r[o], i = n[o];
    t(a) && t(i) ? r[o] = bv(a, i) : r[o] = i;
  }), r), Array.isArray(e[e.length - 1]) ? [] : {});
}
function jU(e) {
  var t = MU(e), r = DU(t, t, t, t), n = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (o) => {
    var a = r() * 16 % 16 | 0;
    return (o == "x" ? a : a & 3 | 8).toString(16);
  });
  return n;
}
function xw(e) {
  return {
    value: e === "object" ? {} : e === "array" ? [] : void 0
  };
}
function rl(e, t) {
  t && e.pop();
}
function LU(e) {
  var t, r, n, o, a;
  return {
    name: ((t = e == null ? void 0 : e.xml) == null ? void 0 : t.name) || "",
    prefix: ((r = e == null ? void 0 : e.xml) == null ? void 0 : r.prefix) || "",
    namespace: ((n = e == null ? void 0 : e.xml) == null ? void 0 : n.namespace) || null,
    attribute: ((o = e == null ? void 0 : e.xml) == null ? void 0 : o.attribute) ?? !1,
    wrapped: ((a = e == null ? void 0 : e.xml) == null ? void 0 : a.wrapped) ?? !1
  };
}
function wv(e, t = {}, r = {}) {
  var v, S;
  const { value: n } = e, { propertyName: o } = r, { name: a, prefix: i, namespace: u, attribute: c, wrapped: d } = LU(t);
  let m = a || o ? `${i ? i + ":" : ""}${a || o}` : null, g = typeof n == "object" ? Array.isArray(n) ? [...n] : { ...n } : n;
  return c && m && (m = `$${m}`), u && (typeof g == "object" ? g[`$xmlns${i ? ":" + i : ""}`] = u : g = { [`$xmlns${i ? ":" + i : ""}`]: u, "#text": g }), t.type === "array" && (d && Array.isArray(g) && (g = { [m]: [...g] }), d || (m = null), t.example !== void 0 && !d && (m = ((S = (v = t.items) == null ? void 0 : v.xml) == null ? void 0 : S.name) || m)), (t.oneOf || t.anyOf || t.allOf || t.$ref) && (m = null), {
    propertyName: m,
    value: g
  };
}
function MU(e) {
  var t = 0;
  if (e.length == 0) return t;
  for (var r = 0; r < e.length; r++) {
    var n = e.charCodeAt(r);
    t = (t << 5) - t + n, t = t & t;
  }
  return t;
}
function DU(e, t, r, n) {
  return function() {
    e |= 0, t |= 0, r |= 0, n |= 0;
    var o = e - (t << 27 | t >>> 5) | 0;
    return e = t ^ (r << 17 | r >>> 15), t = r + n | 0, r = n + o | 0, n = e + o | 0, (n >>> 0) / 4294967296;
  };
}
function FU(e, t, r, n, o) {
  let a = _s(e, r, n);
  const i = [];
  for (let u of t) {
    const { type: c, readOnly: d, writeOnly: m, value: g } = _s({ type: a.type, ...u }, r, n, o);
    a.type && c && c !== a.type && (console.warn("allOf: schemas with different types can't be merged"), a.type = c), a.type = a.type || c, a.readOnly = a.readOnly || d, a.writeOnly = a.writeOnly || m, g != null && i.push(g);
  }
  if (a.type === "object")
    return a.value = bv(a.value || {}, ...i.filter((u) => typeof u == "object")), a;
  {
    a.type === "array" && (r.quiet || console.warn('OpenAPI Sampler: found allOf with "array" type. Result may be incorrect'));
    const u = i[i.length - 1];
    return a.value = u ?? a.value, a;
  }
}
const rA = {
  multipleOf: "number",
  maximum: "number",
  exclusiveMaximum: "number",
  minimum: "number",
  exclusiveMinimum: "number",
  maxLength: "string",
  minLength: "string",
  pattern: "string",
  items: "array",
  maxItems: "array",
  minItems: "array",
  uniqueItems: "array",
  additionalItems: "array",
  maxProperties: "object",
  minProperties: "object",
  required: "object",
  additionalProperties: "object",
  properties: "object",
  patternProperties: "object",
  dependencies: "object"
};
function Ud(e) {
  if (e.type !== void 0)
    return Array.isArray(e.type) ? e.type.length === 0 ? null : e.type[0] : e.type;
  const t = Object.keys(rA);
  for (var r = 0; r < t.length; r++) {
    let n = t[r], o = rA[n];
    if (e[n] !== void 0)
      return o;
  }
  return null;
}
var qU = y$();
const zU = /* @__PURE__ */ NS(qU);
let Hy = {}, Ss = [];
function BU() {
  Hy = {}, Ss = [];
}
function b$(e) {
  let t;
  return e.const !== void 0 ? t = e.const : e.examples !== void 0 && e.examples.length ? t = e.examples[0] : e.enum !== void 0 && e.enum.length ? t = e.enum[0] : e.default !== void 0 && (t = e.default), t;
}
function nA(e) {
  const t = b$(e);
  if (t !== void 0)
    return {
      value: t,
      readOnly: e.readOnly,
      writeOnly: e.writeOnly,
      type: null
    };
}
function _s(e, t, r, n) {
  if (n) {
    if (Ss.includes(e)) return xw(Ud(e));
    Ss.push(e);
  }
  if (n && n.depth > t.maxSampleDepth)
    return rl(Ss, n), xw(Ud(e));
  if (e.$ref) {
    if (!r)
      throw new Error("Your schema contains $ref. You must provide full specification in the third parameter.");
    let u = decodeURIComponent(e.$ref);
    u.startsWith("#") && (u = u.substring(1));
    const c = zU.get(r, u);
    let d;
    if (Hy[u] !== !0) {
      Hy[u] = !0;
      const m = _s(c, t, r, n);
      if (t.format === "xml") {
        const { propertyName: g, value: v } = wv(m, c, n);
        d = { ...m, value: { [g || "root"]: v } };
      } else
        d = m;
      Hy[u] = !1;
    } else {
      const m = Ud(c);
      d = xw(m);
    }
    return rl(Ss, n), d;
  }
  if (e.example !== void 0)
    return rl(Ss, n), {
      value: e.example,
      readOnly: e.readOnly,
      writeOnly: e.writeOnly,
      type: e.type
    };
  if (e.allOf !== void 0)
    return rl(Ss, n), nA(e) || FU(
      { ...e, allOf: void 0 },
      e.allOf,
      t,
      r,
      n
    );
  if (e.oneOf && e.oneOf.length) {
    e.anyOf && (t.quiet || console.warn("oneOf and anyOf are not supported on the same level. Skipping anyOf")), rl(Ss, n);
    const u = Object.assign({
      readOnly: e.readOnly,
      writeOnly: e.writeOnly
    }, e.oneOf[0]);
    return i(e, u);
  }
  if (e.anyOf && e.anyOf.length) {
    rl(Ss, n);
    const u = Object.assign({
      readOnly: e.readOnly,
      writeOnly: e.writeOnly
    }, e.anyOf[0]);
    return i(e, u);
  }
  if (e.if && e.then) {
    rl(Ss, n);
    const { if: u, then: c, ...d } = e;
    return _s(bv(d, u, c), t, r, n);
  }
  let o = b$(e), a = null;
  if (o === void 0) {
    o = null, a = e.type, Array.isArray(a) && e.type.length > 0 && (a = e.type[0]), a || (a = Ud(e));
    let u = Nx[a];
    u && (o = u(e, t, r, n));
  }
  return rl(Ss, n), {
    value: o,
    readOnly: e.readOnly,
    writeOnly: e.writeOnly,
    type: a
  };
  function i(u, c) {
    const d = nA(u);
    if (d !== void 0)
      return d;
    const m = _s({ ...u, oneOf: void 0, anyOf: void 0 }, t, r, n), g = _s(c, t, r, n);
    if (typeof m.value == "object" && typeof g.value == "object") {
      const v = bv(m.value, g.value);
      return { ...g, value: v };
    }
    return g;
  }
}
function UU(e, t = {}, r, n) {
  const o = n && n.depth || 1;
  let a = Math.min(e.maxItems != null ? e.maxItems : 1 / 0, e.minItems || 1);
  const i = e.prefixItems || e.items || e.contains;
  Array.isArray(i) && (a = Math.max(a, i.length));
  let u = (d) => Array.isArray(i) ? i[d] || {} : i || {}, c = [];
  if (!i) return c;
  for (let d = 0; d < a; d++) {
    let m = u(d), { value: g } = _s(m, t, r, { depth: o + 1 });
    if ((t == null ? void 0 : t.format) === "xml") {
      const { value: v, propertyName: S } = wv({ value: g }, m, n);
      S ? (c != null && c[S] || (c = { ...c, [S]: [] }), c[S].push(v)) : c = { ...c, ...v };
    } else
      c.push(g);
  }
  if ((t == null ? void 0 : t.format) === "xml" && o === 1) {
    const { value: d, propertyName: m } = wv({ value: null }, e, n);
    m && (d ? c = Array.isArray(c) ? { [m]: { ...d, ...c.map((g) => ({ "#text": { ...g } })) } } : { [m]: { ...c, ...d } } : c = { [m]: c });
  }
  return c;
}
function VU(e) {
  return !0;
}
function w$(e) {
  let t = 0;
  if (e.type === "number" && (e.format === "float" || e.format === "double") && (t = 0.1), typeof e.exclusiveMinimum == "boolean" || typeof e.exclusiveMaximum == "boolean") {
    if (e.maximum && e.minimum)
      return t = e.exclusiveMinimum ? Math.floor(e.minimum) + 1 : e.minimum, (e.exclusiveMaximum && t >= e.maximum || !e.exclusiveMaximum && t > e.maximum) && (t = (e.maximum + e.minimum) / 2), t;
    if (e.minimum)
      return e.exclusiveMinimum ? Math.floor(e.minimum) + 1 : e.minimum;
    if (e.maximum)
      return e.exclusiveMaximum ? e.maximum > 0 ? 0 : Math.floor(e.maximum) - 1 : e.maximum > 0 ? 0 : e.maximum;
  } else {
    if (e.minimum)
      return e.minimum;
    e.exclusiveMinimum ? (t = Math.floor(e.exclusiveMinimum) + 1, t === e.exclusiveMaximum && (t = (t + Math.floor(e.exclusiveMaximum) - 1) / 2)) : e.exclusiveMaximum ? t = Math.floor(e.exclusiveMaximum) - 1 : e.maximum && (t = e.maximum);
  }
  return t;
}
function HU(e, t = {}, r, n) {
  let o = {};
  const a = n && n.depth || 1;
  if (e && typeof e.properties == "object") {
    const i = Array.isArray(e.required) ? e.required : [], u = {};
    for (const c of i)
      u[c] = !0;
    Object.keys(e.properties).forEach((c) => {
      if (t.skipNonRequired && !u.hasOwnProperty(c))
        return;
      const d = _s(e.properties[c], t, r, { propertyName: c, depth: a + 1 });
      if (!(t.skipReadOnly && d.readOnly) && !(t.skipWriteOnly && d.writeOnly))
        if ((t == null ? void 0 : t.format) === "xml") {
          const { propertyName: m, value: g } = wv(d, e.properties[c], { propertyName: c });
          m ? o[m] = g : o = { ...o, ...g };
        } else
          o[c] = d.value;
    });
  }
  if (e && typeof e.additionalProperties == "object") {
    const i = e.additionalProperties["x-additionalPropertiesName"] || "property";
    o[`${String(i)}1`] = _s(e.additionalProperties, t, r, { depth: a + 1 }).value, o[`${String(i)}2`] = _s(e.additionalProperties, t, r, { depth: a + 1 }).value;
  }
  if (e && typeof e.properties == "object" && e.maxProperties !== void 0 && Object.keys(o).length > e.maxProperties) {
    const i = {};
    let u = 0;
    (Array.isArray(e.required) ? e.required : []).forEach((d) => {
      o[d] !== void 0 && (i[d] = o[d], u++);
    }), Object.keys(o).forEach((d) => {
      u < e.maxProperties && !i.hasOwnProperty(d) && (i[d] = o[d], u++);
    }), o = i;
  }
  return o;
}
function Gd(e, t) {
  return e;
}
function iA(e, t, r) {
  let n = 1;
  if (e)
    switch (e) {
      case "?": {
        n = 0;
        break;
      }
      case "*": {
        n = Gd(0);
        break;
      }
      case "+": {
        n = Gd(1);
        break;
      }
      default:
        throw new Error("Unknown quantifier symbol provided.");
    }
  else t != null && r != null ? n = Gd(parseInt(t)) : t != null && r == null && (n = parseInt(t));
  return n;
}
function WU(e) {
  var g;
  let t = !1;
  e instanceof RegExp && (t = e.flags.includes("i"), e = e.toString(), e = ((g = e.match(/\/(.+?)\//)) == null ? void 0 : g[1]) ?? "");
  let r, n, o;
  const a = /([.A-Za-z0-9])(?:\{(\d+)(?:\,(\d+)|)\}|(\?|\*|\+))(?![^[]*]|[^{]*})/;
  let i = e.match(a);
  for (; i != null; ) {
    const v = i[2], S = i[3], k = i[4];
    o = iA(
      k,
      v,
      S
    ), e = e.slice(0, i.index) + i[1].repeat(o) + e.slice(i.index + i[0].length), i = e.match(a);
  }
  const u = /(\d-\d|\w-\w|\d|\w|[-!@#$&()`.+,/"])/, c = /\[(\^|)(-|)(.+?)\](?:\{(\d+)(?:\,(\d+)|)\}|(\?|\*|\+)|)/;
  for (i = e.match(c); i != null; ) {
    const v = i[1] === "^", S = i[2] === "-", k = i[4], b = i[5], x = i[6], A = [];
    let _ = i[3], O = _.match(u);
    for (S && A.push(45); O != null; ) {
      if (O[0].indexOf("-") === -1)
        t && isNaN(Number(O[0])) ? (A.push(O[0].toUpperCase().charCodeAt(0)), A.push(O[0].toLowerCase().charCodeAt(0))) : A.push(O[0].charCodeAt(0));
      else {
        const C = O[0].split("-").map((T) => T.charCodeAt(0));
        if (r = C[0], n = C[1], r > n)
          throw new Error("Character range provided is out of order.");
        for (let T = r; T <= n; T++)
          if (t && isNaN(Number(String.fromCharCode(T)))) {
            const j = String.fromCharCode(T);
            A.push(j.toUpperCase().charCodeAt(0)), A.push(j.toLowerCase().charCodeAt(0));
          } else
            A.push(T);
      }
      _ = _.substring(O[0].length), O = _.match(u);
    }
    if (o = iA(
      x,
      k,
      b
    ), v) {
      let C = -1;
      for (let T = 48; T <= 57; T++) {
        if (C = A.indexOf(T), C > -1) {
          A.splice(C, 1);
          continue;
        }
        A.push(T);
      }
      for (let T = 65; T <= 90; T++) {
        if (C = A.indexOf(T), C > -1) {
          A.splice(C, 1);
          continue;
        }
        A.push(T);
      }
      for (let T = 97; T <= 122; T++) {
        if (C = A.indexOf(T), C > -1) {
          A.splice(C, 1);
          continue;
        }
        A.push(T);
      }
    }
    const R = Array.from(
      { length: o },
      () => String.fromCharCode(A[Gd(0)])
    ).join("");
    e = e.slice(0, i.index) + R + e.slice(i.index + i[0].length), i = e.match(c);
  }
  const d = /(.)\{(\d+)\,(\d+)\}/;
  for (i = e.match(d); i != null; ) {
    if (r = parseInt(i[2]), n = parseInt(i[3]), r > n)
      throw new Error("Numbers out of order in {} quantifier.");
    o = Gd(r), e = e.slice(0, i.index) + i[1].repeat(o) + e.slice(i.index + i[0].length), i = e.match(d);
  }
  const m = /(.)\{(\d+)\}/;
  for (i = e.match(m); i != null; )
    o = parseInt(i[2]), e = e.slice(0, i.index) + i[1].repeat(o) + e.slice(i.index + i[0].length), i = e.match(m);
  return e;
}
const KU = "qwerty!@#$%^123456";
function QU() {
  return "user@example.com";
}
function YU() {
  return "пошта@укр.нет";
}
function GU(e, t) {
  let r = "pa$$word";
  return e > r.length && (r += "_", r += v$(KU, e - r.length).substring(0, e - r.length)), r;
}
function Rx({ min: e, max: t, omitTime: r, omitDate: n }) {
  let o = NU(/* @__PURE__ */ new Date("2019-08-24T14:15:22.123Z"), r, n);
  return o.length < e && console.warn(`Using minLength = ${e} is incorrect with format "date-time"`), t && o.length > t && console.warn(`Using maxLength = ${t} is incorrect with format "date-time"`), o;
}
function XU(e, t) {
  return Rx({ min: e, max: t, omitTime: !1, omitDate: !1 });
}
function JU(e, t) {
  return Rx({ min: e, max: t, omitTime: !0, omitDate: !1 });
}
function ZU(e, t) {
  return Rx({ min: e, max: t, omitTime: !1, omitDate: !0 }).slice(1);
}
function S$(e, t, r, n, o = !1) {
  if (n && o)
    return WU(n);
  let a = v$("string", e);
  return t && a.length > t && (a = a.substring(0, t)), a;
}
function e5() {
  return "192.168.0.1";
}
function t5() {
  return "2001:0db8:85a3:0000:0000:8a2e:0370:7334";
}
function r5() {
  return "example.com";
}
function n5() {
  return "приклад.укр";
}
function i5() {
  return "http://example.com";
}
function s5() {
  return "../dictionary";
}
function o5() {
  return "http://example.com/{endpoint}";
}
function a5() {
  return "http://example.com/entity/1";
}
function l5() {
  return "/entity/1";
}
function u5(e, t, r) {
  return jU(r || "id");
}
function c5() {
  return "/json/pointer";
}
function p5() {
  return "1/relative/json/pointer";
}
function f5() {
  return "/regex/";
}
const d5 = {
  email: QU,
  "idn-email": YU,
  // https://tools.ietf.org/html/rfc6531#section-3.3
  password: GU,
  "date-time": XU,
  date: JU,
  time: ZU,
  // full-time in https://tools.ietf.org/html/rfc3339#section-5.6
  ipv4: e5,
  ipv6: t5,
  hostname: r5,
  "idn-hostname": n5,
  // https://tools.ietf.org/html/rfc5890#section-2.3.2.3
  iri: a5,
  // https://tools.ietf.org/html/rfc3987
  "iri-reference": l5,
  uri: i5,
  "uri-reference": s5,
  // either a URI or relative-reference https://tools.ietf.org/html/rfc3986#section-4.1
  "uri-template": o5,
  uuid: u5,
  default: S$,
  "json-pointer": c5,
  "relative-json-pointer": p5,
  // https://tools.ietf.org/html/draft-handrews-relative-json-pointer-01
  regex: f5
};
function h5(e, t, r, n) {
  let o = e.format || "default", a = d5[o] || S$, i = n && n.propertyName;
  return a(
    e.minLength || 0,
    e.maxLength,
    i,
    e.pattern,
    t == null ? void 0 : t.enablePatterns
  );
}
var _w = {}, Ew = {}, sA;
function Ix() {
  return sA || (sA = 1, function(e) {
    const t = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", r = t + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040", n = "[" + t + "][" + r + "]*", o = new RegExp("^" + n + "$"), a = function(u, c) {
      const d = [];
      let m = c.exec(u);
      for (; m; ) {
        const g = [];
        g.startIndex = c.lastIndex - m[0].length;
        const v = m.length;
        for (let S = 0; S < v; S++)
          g.push(m[S]);
        d.push(g), m = c.exec(u);
      }
      return d;
    }, i = function(u) {
      const c = o.exec(u);
      return !(c === null || typeof c > "u");
    };
    e.isExist = function(u) {
      return typeof u < "u";
    }, e.isEmptyObject = function(u) {
      return Object.keys(u).length === 0;
    }, e.merge = function(u, c, d) {
      if (c) {
        const m = Object.keys(c), g = m.length;
        for (let v = 0; v < g; v++)
          d === "strict" ? u[m[v]] = [c[m[v]]] : u[m[v]] = c[m[v]];
      }
    }, e.getValue = function(u) {
      return e.isExist(u) ? u : "";
    }, e.isName = i, e.getAllMatches = a, e.nameRegexp = n;
  }(Ew)), Ew;
}
var oA;
function x$() {
  if (oA) return _w;
  oA = 1;
  const e = Ix(), t = {
    allowBooleanAttributes: !1,
    //A tag can have attributes without any value
    unpairedTags: []
  };
  _w.validate = function(A, _) {
    _ = Object.assign({}, t, _);
    const O = [];
    let R = !1, C = !1;
    A[0] === "\uFEFF" && (A = A.substr(1));
    for (let T = 0; T < A.length; T++)
      if (A[T] === "<" && A[T + 1] === "?") {
        if (T += 2, T = n(A, T), T.err) return T;
      } else if (A[T] === "<") {
        let j = T;
        if (T++, A[T] === "!") {
          T = o(A, T);
          continue;
        } else {
          let D = !1;
          A[T] === "/" && (D = !0, T++);
          let V = "";
          for (; T < A.length && A[T] !== ">" && A[T] !== " " && A[T] !== "	" && A[T] !== `
` && A[T] !== "\r"; T++)
            V += A[T];
          if (V = V.trim(), V[V.length - 1] === "/" && (V = V.substring(0, V.length - 1), T--), !k(V)) {
            let H;
            return V.trim().length === 0 ? H = "Invalid space after '<'." : H = "Tag '" + V + "' is an invalid name.", v("InvalidTag", H, b(A, T));
          }
          const U = u(A, T);
          if (U === !1)
            return v("InvalidAttr", "Attributes for '" + V + "' have open quote.", b(A, T));
          let ne = U.value;
          if (T = U.index, ne[ne.length - 1] === "/") {
            const H = T - ne.length;
            ne = ne.substring(0, ne.length - 1);
            const ae = d(ne, _);
            if (ae === !0)
              R = !0;
            else
              return v(ae.err.code, ae.err.msg, b(A, H + ae.err.line));
          } else if (D)
            if (U.tagClosed) {
              if (ne.trim().length > 0)
                return v("InvalidTag", "Closing tag '" + V + "' can't have attributes or invalid starting.", b(A, j));
              if (O.length === 0)
                return v("InvalidTag", "Closing tag '" + V + "' has not been opened.", b(A, j));
              {
                const H = O.pop();
                if (V !== H.tagName) {
                  let ae = b(A, H.tagStartPos);
                  return v(
                    "InvalidTag",
                    "Expected closing tag '" + H.tagName + "' (opened in line " + ae.line + ", col " + ae.col + ") instead of closing tag '" + V + "'.",
                    b(A, j)
                  );
                }
                O.length == 0 && (C = !0);
              }
            } else return v("InvalidTag", "Closing tag '" + V + "' doesn't have proper closing.", b(A, T));
          else {
            const H = d(ne, _);
            if (H !== !0)
              return v(H.err.code, H.err.msg, b(A, T - ne.length + H.err.line));
            if (C === !0)
              return v("InvalidXml", "Multiple possible root nodes found.", b(A, T));
            _.unpairedTags.indexOf(V) !== -1 || O.push({ tagName: V, tagStartPos: j }), R = !0;
          }
          for (T++; T < A.length; T++)
            if (A[T] === "<")
              if (A[T + 1] === "!") {
                T++, T = o(A, T);
                continue;
              } else if (A[T + 1] === "?") {
                if (T = n(A, ++T), T.err) return T;
              } else
                break;
            else if (A[T] === "&") {
              const H = g(A, T);
              if (H == -1)
                return v("InvalidChar", "char '&' is not expected.", b(A, T));
              T = H;
            } else if (C === !0 && !r(A[T]))
              return v("InvalidXml", "Extra text at the end", b(A, T));
          A[T] === "<" && T--;
        }
      } else {
        if (r(A[T]))
          continue;
        return v("InvalidChar", "char '" + A[T] + "' is not expected.", b(A, T));
      }
    if (R) {
      if (O.length == 1)
        return v("InvalidTag", "Unclosed tag '" + O[0].tagName + "'.", b(A, O[0].tagStartPos));
      if (O.length > 0)
        return v("InvalidXml", "Invalid '" + JSON.stringify(O.map((T) => T.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
    } else return v("InvalidXml", "Start tag expected.", 1);
    return !0;
  };
  function r(A) {
    return A === " " || A === "	" || A === `
` || A === "\r";
  }
  function n(A, _) {
    const O = _;
    for (; _ < A.length; _++)
      if (A[_] == "?" || A[_] == " ") {
        const R = A.substr(O, _ - O);
        if (_ > 5 && R === "xml")
          return v("InvalidXml", "XML declaration allowed only at the start of the document.", b(A, _));
        if (A[_] == "?" && A[_ + 1] == ">") {
          _++;
          break;
        } else
          continue;
      }
    return _;
  }
  function o(A, _) {
    if (A.length > _ + 5 && A[_ + 1] === "-" && A[_ + 2] === "-") {
      for (_ += 3; _ < A.length; _++)
        if (A[_] === "-" && A[_ + 1] === "-" && A[_ + 2] === ">") {
          _ += 2;
          break;
        }
    } else if (A.length > _ + 8 && A[_ + 1] === "D" && A[_ + 2] === "O" && A[_ + 3] === "C" && A[_ + 4] === "T" && A[_ + 5] === "Y" && A[_ + 6] === "P" && A[_ + 7] === "E") {
      let O = 1;
      for (_ += 8; _ < A.length; _++)
        if (A[_] === "<")
          O++;
        else if (A[_] === ">" && (O--, O === 0))
          break;
    } else if (A.length > _ + 9 && A[_ + 1] === "[" && A[_ + 2] === "C" && A[_ + 3] === "D" && A[_ + 4] === "A" && A[_ + 5] === "T" && A[_ + 6] === "A" && A[_ + 7] === "[") {
      for (_ += 8; _ < A.length; _++)
        if (A[_] === "]" && A[_ + 1] === "]" && A[_ + 2] === ">") {
          _ += 2;
          break;
        }
    }
    return _;
  }
  const a = '"', i = "'";
  function u(A, _) {
    let O = "", R = "", C = !1;
    for (; _ < A.length; _++) {
      if (A[_] === a || A[_] === i)
        R === "" ? R = A[_] : R !== A[_] || (R = "");
      else if (A[_] === ">" && R === "") {
        C = !0;
        break;
      }
      O += A[_];
    }
    return R !== "" ? !1 : {
      value: O,
      index: _,
      tagClosed: C
    };
  }
  const c = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
  function d(A, _) {
    const O = e.getAllMatches(A, c), R = {};
    for (let C = 0; C < O.length; C++) {
      if (O[C][1].length === 0)
        return v("InvalidAttr", "Attribute '" + O[C][2] + "' has no space in starting.", x(O[C]));
      if (O[C][3] !== void 0 && O[C][4] === void 0)
        return v("InvalidAttr", "Attribute '" + O[C][2] + "' is without value.", x(O[C]));
      if (O[C][3] === void 0 && !_.allowBooleanAttributes)
        return v("InvalidAttr", "boolean attribute '" + O[C][2] + "' is not allowed.", x(O[C]));
      const T = O[C][2];
      if (!S(T))
        return v("InvalidAttr", "Attribute '" + T + "' is an invalid name.", x(O[C]));
      if (!R.hasOwnProperty(T))
        R[T] = 1;
      else
        return v("InvalidAttr", "Attribute '" + T + "' is repeated.", x(O[C]));
    }
    return !0;
  }
  function m(A, _) {
    let O = /\d/;
    for (A[_] === "x" && (_++, O = /[\da-fA-F]/); _ < A.length; _++) {
      if (A[_] === ";")
        return _;
      if (!A[_].match(O))
        break;
    }
    return -1;
  }
  function g(A, _) {
    if (_++, A[_] === ";")
      return -1;
    if (A[_] === "#")
      return _++, m(A, _);
    let O = 0;
    for (; _ < A.length; _++, O++)
      if (!(A[_].match(/\w/) && O < 20)) {
        if (A[_] === ";")
          break;
        return -1;
      }
    return _;
  }
  function v(A, _, O) {
    return {
      err: {
        code: A,
        msg: _,
        line: O.line || O,
        col: O.col
      }
    };
  }
  function S(A) {
    return e.isName(A);
  }
  function k(A) {
    return e.isName(A);
  }
  function b(A, _) {
    const O = A.substring(0, _).split(/\r?\n/);
    return {
      line: O.length,
      // column number is last line's length + 1, because column numbering starts at 1:
      col: O[O.length - 1].length + 1
    };
  }
  function x(A) {
    return A.startIndex + A[1].length;
  }
  return _w;
}
var Oy = {}, aA;
function m5() {
  if (aA) return Oy;
  aA = 1;
  const e = {
    preserveOrder: !1,
    attributeNamePrefix: "@_",
    attributesGroupName: !1,
    textNodeName: "#text",
    ignoreAttributes: !0,
    removeNSPrefix: !1,
    // remove NS from tag name or attribute name if true
    allowBooleanAttributes: !1,
    //a tag can have attributes without any value
    //ignoreRootElement : false,
    parseTagValue: !0,
    parseAttributeValue: !1,
    trimValues: !0,
    //Trim string values of tag and attributes
    cdataPropName: !1,
    numberParseOptions: {
      hex: !0,
      leadingZeros: !0,
      eNotation: !0
    },
    tagValueProcessor: function(r, n) {
      return n;
    },
    attributeValueProcessor: function(r, n) {
      return n;
    },
    stopNodes: [],
    //nested tags will not be parsed even for errors
    alwaysCreateTextNode: !1,
    isArray: () => !1,
    commentPropName: !1,
    unpairedTags: [],
    processEntities: !0,
    htmlEntities: !1,
    ignoreDeclaration: !1,
    ignorePiTags: !1,
    transformTagName: !1,
    transformAttributeName: !1,
    updateTag: function(r, n, o) {
      return r;
    }
    // skipEmptyListItem: false
  }, t = function(r) {
    return Object.assign({}, e, r);
  };
  return Oy.buildOptions = t, Oy.defaultOptions = e, Oy;
}
var Ow, lA;
function g5() {
  if (lA) return Ow;
  lA = 1;
  class e {
    constructor(r) {
      this.tagname = r, this.child = [], this[":@"] = {};
    }
    add(r, n) {
      r === "__proto__" && (r = "#__proto__"), this.child.push({ [r]: n });
    }
    addChild(r) {
      r.tagname === "__proto__" && (r.tagname = "#__proto__"), r[":@"] && Object.keys(r[":@"]).length > 0 ? this.child.push({ [r.tagname]: r.child, ":@": r[":@"] }) : this.child.push({ [r.tagname]: r.child });
    }
  }
  return Ow = e, Ow;
}
var kw, uA;
function y5() {
  if (uA) return kw;
  uA = 1;
  const e = Ix();
  function t(d, m) {
    const g = {};
    if (d[m + 3] === "O" && d[m + 4] === "C" && d[m + 5] === "T" && d[m + 6] === "Y" && d[m + 7] === "P" && d[m + 8] === "E") {
      m = m + 9;
      let v = 1, S = !1, k = !1, b = "";
      for (; m < d.length; m++)
        if (d[m] === "<" && !k) {
          if (S && o(d, m)) {
            m += 7;
            let x, A;
            [x, A, m] = r(d, m + 1), A.indexOf("&") === -1 && (g[c(x)] = {
              regx: RegExp(`&${x};`, "g"),
              val: A
            });
          } else if (S && a(d, m)) m += 8;
          else if (S && i(d, m)) m += 8;
          else if (S && u(d, m)) m += 9;
          else if (n) k = !0;
          else throw new Error("Invalid DOCTYPE");
          v++, b = "";
        } else if (d[m] === ">") {
          if (k ? d[m - 1] === "-" && d[m - 2] === "-" && (k = !1, v--) : v--, v === 0)
            break;
        } else d[m] === "[" ? S = !0 : b += d[m];
      if (v !== 0)
        throw new Error("Unclosed DOCTYPE");
    } else
      throw new Error("Invalid Tag instead of DOCTYPE");
    return { entities: g, i: m };
  }
  function r(d, m) {
    let g = "";
    for (; m < d.length && d[m] !== "'" && d[m] !== '"'; m++)
      g += d[m];
    if (g = g.trim(), g.indexOf(" ") !== -1) throw new Error("External entites are not supported");
    const v = d[m++];
    let S = "";
    for (; m < d.length && d[m] !== v; m++)
      S += d[m];
    return [g, S, m];
  }
  function n(d, m) {
    return d[m + 1] === "!" && d[m + 2] === "-" && d[m + 3] === "-";
  }
  function o(d, m) {
    return d[m + 1] === "!" && d[m + 2] === "E" && d[m + 3] === "N" && d[m + 4] === "T" && d[m + 5] === "I" && d[m + 6] === "T" && d[m + 7] === "Y";
  }
  function a(d, m) {
    return d[m + 1] === "!" && d[m + 2] === "E" && d[m + 3] === "L" && d[m + 4] === "E" && d[m + 5] === "M" && d[m + 6] === "E" && d[m + 7] === "N" && d[m + 8] === "T";
  }
  function i(d, m) {
    return d[m + 1] === "!" && d[m + 2] === "A" && d[m + 3] === "T" && d[m + 4] === "T" && d[m + 5] === "L" && d[m + 6] === "I" && d[m + 7] === "S" && d[m + 8] === "T";
  }
  function u(d, m) {
    return d[m + 1] === "!" && d[m + 2] === "N" && d[m + 3] === "O" && d[m + 4] === "T" && d[m + 5] === "A" && d[m + 6] === "T" && d[m + 7] === "I" && d[m + 8] === "O" && d[m + 9] === "N";
  }
  function c(d) {
    if (e.isName(d))
      return d;
    throw new Error(`Invalid entity name ${d}`);
  }
  return kw = t, kw;
}
var Aw, cA;
function v5() {
  if (cA) return Aw;
  cA = 1;
  const e = /^[-+]?0x[a-fA-F0-9]+$/, t = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/, r = {
    hex: !0,
    // oct: false,
    leadingZeros: !0,
    decimalPoint: ".",
    eNotation: !0
    //skipLike: /regex/
  };
  function n(i, u = {}) {
    if (u = Object.assign({}, r, u), !i || typeof i != "string") return i;
    let c = i.trim();
    if (u.skipLike !== void 0 && u.skipLike.test(c)) return i;
    if (i === "0") return 0;
    if (u.hex && e.test(c))
      return a(c, 16);
    if (c.search(/[eE]/) !== -1) {
      const d = c.match(/^([-\+])?(0*)([0-9]*(\.[0-9]*)?[eE][-\+]?[0-9]+)$/);
      if (d) {
        if (u.leadingZeros)
          c = (d[1] || "") + d[3];
        else if (!(d[2] === "0" && d[3][0] === ".")) return i;
        return u.eNotation ? Number(c) : i;
      } else
        return i;
    } else {
      const d = t.exec(c);
      if (d) {
        const m = d[1], g = d[2];
        let v = o(d[3]);
        if (!u.leadingZeros && g.length > 0 && m && c[2] !== ".") return i;
        if (!u.leadingZeros && g.length > 0 && !m && c[1] !== ".") return i;
        if (u.leadingZeros && g === i) return 0;
        {
          const S = Number(c), k = "" + S;
          return k.search(/[eE]/) !== -1 ? u.eNotation ? S : i : c.indexOf(".") !== -1 ? k === "0" && v === "" || k === v || m && k === "-" + v ? S : i : g ? v === k || m + v === k ? S : i : c === k || c === m + k ? S : i;
        }
      } else
        return i;
    }
  }
  function o(i) {
    return i && i.indexOf(".") !== -1 && (i = i.replace(/0+$/, ""), i === "." ? i = "0" : i[0] === "." ? i = "0" + i : i[i.length - 1] === "." && (i = i.substr(0, i.length - 1))), i;
  }
  function a(i, u) {
    if (parseInt) return parseInt(i, u);
    if (Number.parseInt) return Number.parseInt(i, u);
    if (window && window.parseInt) return window.parseInt(i, u);
    throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
  }
  return Aw = n, Aw;
}
var Pw, pA;
function _$() {
  if (pA) return Pw;
  pA = 1;
  function e(t) {
    return typeof t == "function" ? t : Array.isArray(t) ? (r) => {
      for (const n of t)
        if (typeof n == "string" && r === n || n instanceof RegExp && n.test(r))
          return !0;
    } : () => !1;
  }
  return Pw = e, Pw;
}
var Tw, fA;
function b5() {
  if (fA) return Tw;
  fA = 1;
  const e = Ix(), t = g5(), r = y5(), n = v5(), o = _$();
  class a {
    constructor(T) {
      this.options = T, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = {
        apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
        gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
        lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
        quot: { regex: /&(quot|#34|#x22);/g, val: '"' }
      }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = {
        space: { regex: /&(nbsp|#160);/g, val: " " },
        // "lt" : { regex: /&(lt|#60);/g, val: "<" },
        // "gt" : { regex: /&(gt|#62);/g, val: ">" },
        // "amp" : { regex: /&(amp|#38);/g, val: "&" },
        // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
        // "apos" : { regex: /&(apos|#39);/g, val: "'" },
        cent: { regex: /&(cent|#162);/g, val: "¢" },
        pound: { regex: /&(pound|#163);/g, val: "£" },
        yen: { regex: /&(yen|#165);/g, val: "¥" },
        euro: { regex: /&(euro|#8364);/g, val: "€" },
        copyright: { regex: /&(copy|#169);/g, val: "©" },
        reg: { regex: /&(reg|#174);/g, val: "®" },
        inr: { regex: /&(inr|#8377);/g, val: "₹" },
        num_dec: { regex: /&#([0-9]{1,7});/g, val: (j, D) => String.fromCharCode(Number.parseInt(D, 10)) },
        num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (j, D) => String.fromCharCode(Number.parseInt(D, 16)) }
      }, this.addExternalEntities = i, this.parseXml = g, this.parseTextData = u, this.resolveNameSpace = c, this.buildAttributesMap = m, this.isItStopNode = b, this.replaceEntitiesValue = S, this.readStopNodeData = O, this.saveTextToParentTag = k, this.addChild = v, this.ignoreAttributesFn = o(this.options.ignoreAttributes);
    }
  }
  function i(C) {
    const T = Object.keys(C);
    for (let j = 0; j < T.length; j++) {
      const D = T[j];
      this.lastEntities[D] = {
        regex: new RegExp("&" + D + ";", "g"),
        val: C[D]
      };
    }
  }
  function u(C, T, j, D, V, U, ne) {
    if (C !== void 0 && (this.options.trimValues && !D && (C = C.trim()), C.length > 0)) {
      ne || (C = this.replaceEntitiesValue(C));
      const H = this.options.tagValueProcessor(T, C, j, V, U);
      return H == null ? C : typeof H != typeof C || H !== C ? H : this.options.trimValues ? R(C, this.options.parseTagValue, this.options.numberParseOptions) : C.trim() === C ? R(C, this.options.parseTagValue, this.options.numberParseOptions) : C;
    }
  }
  function c(C) {
    if (this.options.removeNSPrefix) {
      const T = C.split(":"), j = C.charAt(0) === "/" ? "/" : "";
      if (T[0] === "xmlns")
        return "";
      T.length === 2 && (C = j + T[1]);
    }
    return C;
  }
  const d = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
  function m(C, T, j) {
    if (this.options.ignoreAttributes !== !0 && typeof C == "string") {
      const D = e.getAllMatches(C, d), V = D.length, U = {};
      for (let ne = 0; ne < V; ne++) {
        const H = this.resolveNameSpace(D[ne][1]);
        if (this.ignoreAttributesFn(H, T))
          continue;
        let ae = D[ne][4], ge = this.options.attributeNamePrefix + H;
        if (H.length)
          if (this.options.transformAttributeName && (ge = this.options.transformAttributeName(ge)), ge === "__proto__" && (ge = "#__proto__"), ae !== void 0) {
            this.options.trimValues && (ae = ae.trim()), ae = this.replaceEntitiesValue(ae);
            const fe = this.options.attributeValueProcessor(H, ae, T);
            fe == null ? U[ge] = ae : typeof fe != typeof ae || fe !== ae ? U[ge] = fe : U[ge] = R(
              ae,
              this.options.parseAttributeValue,
              this.options.numberParseOptions
            );
          } else this.options.allowBooleanAttributes && (U[ge] = !0);
      }
      if (!Object.keys(U).length)
        return;
      if (this.options.attributesGroupName) {
        const ne = {};
        return ne[this.options.attributesGroupName] = U, ne;
      }
      return U;
    }
  }
  const g = function(C) {
    C = C.replace(/\r\n?/g, `
`);
    const T = new t("!xml");
    let j = T, D = "", V = "";
    for (let U = 0; U < C.length; U++)
      if (C[U] === "<")
        if (C[U + 1] === "/") {
          const H = A(C, ">", U, "Closing Tag is not closed.");
          let ae = C.substring(U + 2, H).trim();
          if (this.options.removeNSPrefix) {
            const ve = ae.indexOf(":");
            ve !== -1 && (ae = ae.substr(ve + 1));
          }
          this.options.transformTagName && (ae = this.options.transformTagName(ae)), j && (D = this.saveTextToParentTag(D, j, V));
          const ge = V.substring(V.lastIndexOf(".") + 1);
          if (ae && this.options.unpairedTags.indexOf(ae) !== -1)
            throw new Error(`Unpaired tag can not be used as closing tag: </${ae}>`);
          let fe = 0;
          ge && this.options.unpairedTags.indexOf(ge) !== -1 ? (fe = V.lastIndexOf(".", V.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : fe = V.lastIndexOf("."), V = V.substring(0, fe), j = this.tagsNodeStack.pop(), D = "", U = H;
        } else if (C[U + 1] === "?") {
          let H = _(C, U, !1, "?>");
          if (!H) throw new Error("Pi Tag is not closed.");
          if (D = this.saveTextToParentTag(D, j, V), !(this.options.ignoreDeclaration && H.tagName === "?xml" || this.options.ignorePiTags)) {
            const ae = new t(H.tagName);
            ae.add(this.options.textNodeName, ""), H.tagName !== H.tagExp && H.attrExpPresent && (ae[":@"] = this.buildAttributesMap(H.tagExp, V, H.tagName)), this.addChild(j, ae, V);
          }
          U = H.closeIndex + 1;
        } else if (C.substr(U + 1, 3) === "!--") {
          const H = A(C, "-->", U + 4, "Comment is not closed.");
          if (this.options.commentPropName) {
            const ae = C.substring(U + 4, H - 2);
            D = this.saveTextToParentTag(D, j, V), j.add(this.options.commentPropName, [{ [this.options.textNodeName]: ae }]);
          }
          U = H;
        } else if (C.substr(U + 1, 2) === "!D") {
          const H = r(C, U);
          this.docTypeEntities = H.entities, U = H.i;
        } else if (C.substr(U + 1, 2) === "![") {
          const H = A(C, "]]>", U, "CDATA is not closed.") - 2, ae = C.substring(U + 9, H);
          D = this.saveTextToParentTag(D, j, V);
          let ge = this.parseTextData(ae, j.tagname, V, !0, !1, !0, !0);
          ge == null && (ge = ""), this.options.cdataPropName ? j.add(this.options.cdataPropName, [{ [this.options.textNodeName]: ae }]) : j.add(this.options.textNodeName, ge), U = H + 2;
        } else {
          let H = _(C, U, this.options.removeNSPrefix), ae = H.tagName;
          const ge = H.rawTagName;
          let fe = H.tagExp, ve = H.attrExpPresent, $e = H.closeIndex;
          this.options.transformTagName && (ae = this.options.transformTagName(ae)), j && D && j.tagname !== "!xml" && (D = this.saveTextToParentTag(D, j, V, !1));
          const ce = j;
          if (ce && this.options.unpairedTags.indexOf(ce.tagname) !== -1 && (j = this.tagsNodeStack.pop(), V = V.substring(0, V.lastIndexOf("."))), ae !== T.tagname && (V += V ? "." + ae : ae), this.isItStopNode(this.options.stopNodes, V, ae)) {
            let se = "";
            if (fe.length > 0 && fe.lastIndexOf("/") === fe.length - 1)
              ae[ae.length - 1] === "/" ? (ae = ae.substr(0, ae.length - 1), V = V.substr(0, V.length - 1), fe = ae) : fe = fe.substr(0, fe.length - 1), U = H.closeIndex;
            else if (this.options.unpairedTags.indexOf(ae) !== -1)
              U = H.closeIndex;
            else {
              const F = this.readStopNodeData(C, ge, $e + 1);
              if (!F) throw new Error(`Unexpected end of ${ge}`);
              U = F.i, se = F.tagContent;
            }
            const te = new t(ae);
            ae !== fe && ve && (te[":@"] = this.buildAttributesMap(fe, V, ae)), se && (se = this.parseTextData(se, ae, V, !0, ve, !0, !0)), V = V.substr(0, V.lastIndexOf(".")), te.add(this.options.textNodeName, se), this.addChild(j, te, V);
          } else {
            if (fe.length > 0 && fe.lastIndexOf("/") === fe.length - 1) {
              ae[ae.length - 1] === "/" ? (ae = ae.substr(0, ae.length - 1), V = V.substr(0, V.length - 1), fe = ae) : fe = fe.substr(0, fe.length - 1), this.options.transformTagName && (ae = this.options.transformTagName(ae));
              const se = new t(ae);
              ae !== fe && ve && (se[":@"] = this.buildAttributesMap(fe, V, ae)), this.addChild(j, se, V), V = V.substr(0, V.lastIndexOf("."));
            } else {
              const se = new t(ae);
              this.tagsNodeStack.push(j), ae !== fe && ve && (se[":@"] = this.buildAttributesMap(fe, V, ae)), this.addChild(j, se, V), j = se;
            }
            D = "", U = $e;
          }
        }
      else
        D += C[U];
    return T.child;
  };
  function v(C, T, j) {
    const D = this.options.updateTag(T.tagname, j, T[":@"]);
    D === !1 || (typeof D == "string" && (T.tagname = D), C.addChild(T));
  }
  const S = function(C) {
    if (this.options.processEntities) {
      for (let T in this.docTypeEntities) {
        const j = this.docTypeEntities[T];
        C = C.replace(j.regx, j.val);
      }
      for (let T in this.lastEntities) {
        const j = this.lastEntities[T];
        C = C.replace(j.regex, j.val);
      }
      if (this.options.htmlEntities)
        for (let T in this.htmlEntities) {
          const j = this.htmlEntities[T];
          C = C.replace(j.regex, j.val);
        }
      C = C.replace(this.ampEntity.regex, this.ampEntity.val);
    }
    return C;
  };
  function k(C, T, j, D) {
    return C && (D === void 0 && (D = T.child.length === 0), C = this.parseTextData(
      C,
      T.tagname,
      j,
      !1,
      T[":@"] ? Object.keys(T[":@"]).length !== 0 : !1,
      D
    ), C !== void 0 && C !== "" && T.add(this.options.textNodeName, C), C = ""), C;
  }
  function b(C, T, j) {
    const D = "*." + j;
    for (const V in C) {
      const U = C[V];
      if (D === U || T === U) return !0;
    }
    return !1;
  }
  function x(C, T, j = ">") {
    let D, V = "";
    for (let U = T; U < C.length; U++) {
      let ne = C[U];
      if (D)
        ne === D && (D = "");
      else if (ne === '"' || ne === "'")
        D = ne;
      else if (ne === j[0])
        if (j[1]) {
          if (C[U + 1] === j[1])
            return {
              data: V,
              index: U
            };
        } else
          return {
            data: V,
            index: U
          };
      else ne === "	" && (ne = " ");
      V += ne;
    }
  }
  function A(C, T, j, D) {
    const V = C.indexOf(T, j);
    if (V === -1)
      throw new Error(D);
    return V + T.length - 1;
  }
  function _(C, T, j, D = ">") {
    const V = x(C, T + 1, D);
    if (!V) return;
    let U = V.data;
    const ne = V.index, H = U.search(/\s/);
    let ae = U, ge = !0;
    H !== -1 && (ae = U.substring(0, H), U = U.substring(H + 1).trimStart());
    const fe = ae;
    if (j) {
      const ve = ae.indexOf(":");
      ve !== -1 && (ae = ae.substr(ve + 1), ge = ae !== V.data.substr(ve + 1));
    }
    return {
      tagName: ae,
      tagExp: U,
      closeIndex: ne,
      attrExpPresent: ge,
      rawTagName: fe
    };
  }
  function O(C, T, j) {
    const D = j;
    let V = 1;
    for (; j < C.length; j++)
      if (C[j] === "<")
        if (C[j + 1] === "/") {
          const U = A(C, ">", j, `${T} is not closed`);
          if (C.substring(j + 2, U).trim() === T && (V--, V === 0))
            return {
              tagContent: C.substring(D, j),
              i: U
            };
          j = U;
        } else if (C[j + 1] === "?")
          j = A(C, "?>", j + 1, "StopNode is not closed.");
        else if (C.substr(j + 1, 3) === "!--")
          j = A(C, "-->", j + 3, "StopNode is not closed.");
        else if (C.substr(j + 1, 2) === "![")
          j = A(C, "]]>", j, "StopNode is not closed.") - 2;
        else {
          const U = _(C, j, ">");
          U && ((U && U.tagName) === T && U.tagExp[U.tagExp.length - 1] !== "/" && V++, j = U.closeIndex);
        }
  }
  function R(C, T, j) {
    if (T && typeof C == "string") {
      const D = C.trim();
      return D === "true" ? !0 : D === "false" ? !1 : n(C, j);
    } else
      return e.isExist(C) ? C : "";
  }
  return Tw = a, Tw;
}
var Cw = {}, dA;
function w5() {
  if (dA) return Cw;
  dA = 1;
  function e(a, i) {
    return t(a, i);
  }
  function t(a, i, u) {
    let c;
    const d = {};
    for (let m = 0; m < a.length; m++) {
      const g = a[m], v = r(g);
      let S = "";
      if (u === void 0 ? S = v : S = u + "." + v, v === i.textNodeName)
        c === void 0 ? c = g[v] : c += "" + g[v];
      else {
        if (v === void 0)
          continue;
        if (g[v]) {
          let k = t(g[v], i, S);
          const b = o(k, i);
          g[":@"] ? n(k, g[":@"], S, i) : Object.keys(k).length === 1 && k[i.textNodeName] !== void 0 && !i.alwaysCreateTextNode ? k = k[i.textNodeName] : Object.keys(k).length === 0 && (i.alwaysCreateTextNode ? k[i.textNodeName] = "" : k = ""), d[v] !== void 0 && d.hasOwnProperty(v) ? (Array.isArray(d[v]) || (d[v] = [d[v]]), d[v].push(k)) : i.isArray(v, S, b) ? d[v] = [k] : d[v] = k;
        }
      }
    }
    return typeof c == "string" ? c.length > 0 && (d[i.textNodeName] = c) : c !== void 0 && (d[i.textNodeName] = c), d;
  }
  function r(a) {
    const i = Object.keys(a);
    for (let u = 0; u < i.length; u++) {
      const c = i[u];
      if (c !== ":@") return c;
    }
  }
  function n(a, i, u, c) {
    if (i) {
      const d = Object.keys(i), m = d.length;
      for (let g = 0; g < m; g++) {
        const v = d[g];
        c.isArray(v, u + "." + v, !0, !0) ? a[v] = [i[v]] : a[v] = i[v];
      }
    }
  }
  function o(a, i) {
    const { textNodeName: u } = i, c = Object.keys(a).length;
    return !!(c === 0 || c === 1 && (a[u] || typeof a[u] == "boolean" || a[u] === 0));
  }
  return Cw.prettify = e, Cw;
}
var $w, hA;
function S5() {
  if (hA) return $w;
  hA = 1;
  const { buildOptions: e } = m5(), t = b5(), { prettify: r } = w5(), n = x$();
  class o {
    constructor(i) {
      this.externalEntities = {}, this.options = e(i);
    }
    /**
     * Parse XML dats to JS object 
     * @param {string|Buffer} xmlData 
     * @param {boolean|Object} validationOption 
     */
    parse(i, u) {
      if (typeof i != "string") if (i.toString)
        i = i.toString();
      else
        throw new Error("XML data is accepted in String or Bytes[] form.");
      if (u) {
        u === !0 && (u = {});
        const m = n.validate(i, u);
        if (m !== !0)
          throw Error(`${m.err.msg}:${m.err.line}:${m.err.col}`);
      }
      const c = new t(this.options);
      c.addExternalEntities(this.externalEntities);
      const d = c.parseXml(i);
      return this.options.preserveOrder || d === void 0 ? d : r(d, this.options);
    }
    /**
     * Add Entity which is not by default supported by this library
     * @param {string} key 
     * @param {string} value 
     */
    addEntity(i, u) {
      if (u.indexOf("&") !== -1)
        throw new Error("Entity value can't have '&'");
      if (i.indexOf("&") !== -1 || i.indexOf(";") !== -1)
        throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
      if (u === "&")
        throw new Error("An entity with value '&' is not permitted");
      this.externalEntities[i] = u;
    }
  }
  return $w = o, $w;
}
var Rw, mA;
function x5() {
  if (mA) return Rw;
  mA = 1;
  const e = `
`;
  function t(u, c) {
    let d = "";
    return c.format && c.indentBy.length > 0 && (d = e), r(u, c, "", d);
  }
  function r(u, c, d, m) {
    let g = "", v = !1;
    for (let S = 0; S < u.length; S++) {
      const k = u[S], b = n(k);
      if (b === void 0) continue;
      let x = "";
      if (d.length === 0 ? x = b : x = `${d}.${b}`, b === c.textNodeName) {
        let C = k[b];
        a(x, c) || (C = c.tagValueProcessor(b, C), C = i(C, c)), v && (g += m), g += C, v = !1;
        continue;
      } else if (b === c.cdataPropName) {
        v && (g += m), g += `<![CDATA[${k[b][0][c.textNodeName]}]]>`, v = !1;
        continue;
      } else if (b === c.commentPropName) {
        g += m + `<!--${k[b][0][c.textNodeName]}-->`, v = !0;
        continue;
      } else if (b[0] === "?") {
        const C = o(k[":@"], c), T = b === "?xml" ? "" : m;
        let j = k[b][0][c.textNodeName];
        j = j.length !== 0 ? " " + j : "", g += T + `<${b}${j}${C}?>`, v = !0;
        continue;
      }
      let A = m;
      A !== "" && (A += c.indentBy);
      const _ = o(k[":@"], c), O = m + `<${b}${_}`, R = r(k[b], c, x, A);
      c.unpairedTags.indexOf(b) !== -1 ? c.suppressUnpairedNode ? g += O + ">" : g += O + "/>" : (!R || R.length === 0) && c.suppressEmptyNode ? g += O + "/>" : R && R.endsWith(">") ? g += O + `>${R}${m}</${b}>` : (g += O + ">", R && m !== "" && (R.includes("/>") || R.includes("</")) ? g += m + c.indentBy + R + m : g += R, g += `</${b}>`), v = !0;
    }
    return g;
  }
  function n(u) {
    const c = Object.keys(u);
    for (let d = 0; d < c.length; d++) {
      const m = c[d];
      if (u.hasOwnProperty(m) && m !== ":@")
        return m;
    }
  }
  function o(u, c) {
    let d = "";
    if (u && !c.ignoreAttributes)
      for (let m in u) {
        if (!u.hasOwnProperty(m)) continue;
        let g = c.attributeValueProcessor(m, u[m]);
        g = i(g, c), g === !0 && c.suppressBooleanAttributes ? d += ` ${m.substr(c.attributeNamePrefix.length)}` : d += ` ${m.substr(c.attributeNamePrefix.length)}="${g}"`;
      }
    return d;
  }
  function a(u, c) {
    u = u.substr(0, u.length - c.textNodeName.length - 1);
    let d = u.substr(u.lastIndexOf(".") + 1);
    for (let m in c.stopNodes)
      if (c.stopNodes[m] === u || c.stopNodes[m] === "*." + d) return !0;
    return !1;
  }
  function i(u, c) {
    if (u && u.length > 0 && c.processEntities)
      for (let d = 0; d < c.entities.length; d++) {
        const m = c.entities[d];
        u = u.replace(m.regex, m.val);
      }
    return u;
  }
  return Rw = t, Rw;
}
var Iw, gA;
function _5() {
  if (gA) return Iw;
  gA = 1;
  const e = x5(), t = _$(), r = {
    attributeNamePrefix: "@_",
    attributesGroupName: !1,
    textNodeName: "#text",
    ignoreAttributes: !0,
    cdataPropName: !1,
    format: !1,
    indentBy: "  ",
    suppressEmptyNode: !1,
    suppressUnpairedNode: !0,
    suppressBooleanAttributes: !0,
    tagValueProcessor: function(u, c) {
      return c;
    },
    attributeValueProcessor: function(u, c) {
      return c;
    },
    preserveOrder: !1,
    commentPropName: !1,
    unpairedTags: [],
    entities: [
      { regex: new RegExp("&", "g"), val: "&amp;" },
      //it must be on top
      { regex: new RegExp(">", "g"), val: "&gt;" },
      { regex: new RegExp("<", "g"), val: "&lt;" },
      { regex: new RegExp("'", "g"), val: "&apos;" },
      { regex: new RegExp('"', "g"), val: "&quot;" }
    ],
    processEntities: !0,
    stopNodes: [],
    // transformTagName: false,
    // transformAttributeName: false,
    oneListGroup: !1
  };
  function n(u) {
    this.options = Object.assign({}, r, u), this.options.ignoreAttributes === !0 || this.options.attributesGroupName ? this.isAttribute = function() {
      return !1;
    } : (this.ignoreAttributesFn = t(this.options.ignoreAttributes), this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = i), this.processTextOrObjNode = o, this.options.format ? (this.indentate = a, this.tagEndChar = `>
`, this.newLine = `
`) : (this.indentate = function() {
      return "";
    }, this.tagEndChar = ">", this.newLine = "");
  }
  n.prototype.build = function(u) {
    return this.options.preserveOrder ? e(u, this.options) : (Array.isArray(u) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (u = {
      [this.options.arrayNodeName]: u
    }), this.j2x(u, 0, []).val);
  }, n.prototype.j2x = function(u, c, d) {
    let m = "", g = "";
    const v = d.join(".");
    for (let S in u)
      if (Object.prototype.hasOwnProperty.call(u, S))
        if (typeof u[S] > "u")
          this.isAttribute(S) && (g += "");
        else if (u[S] === null)
          this.isAttribute(S) || S === this.options.cdataPropName ? g += "" : S[0] === "?" ? g += this.indentate(c) + "<" + S + "?" + this.tagEndChar : g += this.indentate(c) + "<" + S + "/" + this.tagEndChar;
        else if (u[S] instanceof Date)
          g += this.buildTextValNode(u[S], S, "", c);
        else if (typeof u[S] != "object") {
          const k = this.isAttribute(S);
          if (k && !this.ignoreAttributesFn(k, v))
            m += this.buildAttrPairStr(k, "" + u[S]);
          else if (!k)
            if (S === this.options.textNodeName) {
              let b = this.options.tagValueProcessor(S, "" + u[S]);
              g += this.replaceEntitiesValue(b);
            } else
              g += this.buildTextValNode(u[S], S, "", c);
        } else if (Array.isArray(u[S])) {
          const k = u[S].length;
          let b = "", x = "";
          for (let A = 0; A < k; A++) {
            const _ = u[S][A];
            if (!(typeof _ > "u")) if (_ === null)
              S[0] === "?" ? g += this.indentate(c) + "<" + S + "?" + this.tagEndChar : g += this.indentate(c) + "<" + S + "/" + this.tagEndChar;
            else if (typeof _ == "object")
              if (this.options.oneListGroup) {
                const O = this.j2x(_, c + 1, d.concat(S));
                b += O.val, this.options.attributesGroupName && _.hasOwnProperty(this.options.attributesGroupName) && (x += O.attrStr);
              } else
                b += this.processTextOrObjNode(_, S, c, d);
            else if (this.options.oneListGroup) {
              let O = this.options.tagValueProcessor(S, _);
              O = this.replaceEntitiesValue(O), b += O;
            } else
              b += this.buildTextValNode(_, S, "", c);
          }
          this.options.oneListGroup && (b = this.buildObjectNode(b, S, x, c)), g += b;
        } else if (this.options.attributesGroupName && S === this.options.attributesGroupName) {
          const k = Object.keys(u[S]), b = k.length;
          for (let x = 0; x < b; x++)
            m += this.buildAttrPairStr(k[x], "" + u[S][k[x]]);
        } else
          g += this.processTextOrObjNode(u[S], S, c, d);
    return { attrStr: m, val: g };
  }, n.prototype.buildAttrPairStr = function(u, c) {
    return c = this.options.attributeValueProcessor(u, "" + c), c = this.replaceEntitiesValue(c), this.options.suppressBooleanAttributes && c === "true" ? " " + u : " " + u + '="' + c + '"';
  };
  function o(u, c, d, m) {
    const g = this.j2x(u, d + 1, m.concat(c));
    return u[this.options.textNodeName] !== void 0 && Object.keys(u).length === 1 ? this.buildTextValNode(u[this.options.textNodeName], c, g.attrStr, d) : this.buildObjectNode(g.val, c, g.attrStr, d);
  }
  n.prototype.buildObjectNode = function(u, c, d, m) {
    if (u === "")
      return c[0] === "?" ? this.indentate(m) + "<" + c + d + "?" + this.tagEndChar : this.indentate(m) + "<" + c + d + this.closeTag(c) + this.tagEndChar;
    {
      let g = "</" + c + this.tagEndChar, v = "";
      return c[0] === "?" && (v = "?", g = ""), (d || d === "") && u.indexOf("<") === -1 ? this.indentate(m) + "<" + c + d + v + ">" + u + g : this.options.commentPropName !== !1 && c === this.options.commentPropName && v.length === 0 ? this.indentate(m) + `<!--${u}-->` + this.newLine : this.indentate(m) + "<" + c + d + v + this.tagEndChar + u + this.indentate(m) + g;
    }
  }, n.prototype.closeTag = function(u) {
    let c = "";
    return this.options.unpairedTags.indexOf(u) !== -1 ? this.options.suppressUnpairedNode || (c = "/") : this.options.suppressEmptyNode ? c = "/" : c = `></${u}`, c;
  }, n.prototype.buildTextValNode = function(u, c, d, m) {
    if (this.options.cdataPropName !== !1 && c === this.options.cdataPropName)
      return this.indentate(m) + `<![CDATA[${u}]]>` + this.newLine;
    if (this.options.commentPropName !== !1 && c === this.options.commentPropName)
      return this.indentate(m) + `<!--${u}-->` + this.newLine;
    if (c[0] === "?")
      return this.indentate(m) + "<" + c + d + "?" + this.tagEndChar;
    {
      let g = this.options.tagValueProcessor(c, u);
      return g = this.replaceEntitiesValue(g), g === "" ? this.indentate(m) + "<" + c + d + this.closeTag(c) + this.tagEndChar : this.indentate(m) + "<" + c + d + ">" + g + "</" + c + this.tagEndChar;
    }
  }, n.prototype.replaceEntitiesValue = function(u) {
    if (u && u.length > 0 && this.options.processEntities)
      for (let c = 0; c < this.options.entities.length; c++) {
        const d = this.options.entities[c];
        u = u.replace(d.regex, d.val);
      }
    return u;
  };
  function a(u) {
    return this.options.indentBy.repeat(u);
  }
  function i(u) {
    return u.startsWith(this.options.attributeNamePrefix) && u !== this.options.textNodeName ? u.substr(this.attrPrefixLen) : !1;
  }
  return Iw = n, Iw;
}
var Nw, yA;
function E5() {
  if (yA) return Nw;
  yA = 1;
  const e = x$(), t = S5(), r = _5();
  return Nw = {
    XMLParser: t,
    XMLValidator: e,
    XMLBuilder: r
  }, Nw;
}
var O5 = E5(), Nx = {};
const k5 = {
  skipReadOnly: !1,
  maxSampleDepth: 15
};
function A5(e, t) {
  var n;
  if (!e)
    throw new Error("Unknown format output for building XML.");
  return (Array.isArray(e) || Object.keys(e).length > 1) && (e = { [((n = t == null ? void 0 : t.xml) == null ? void 0 : n.name) || "root"]: e }), new O5.XMLBuilder({
    ignoreAttributes: !1,
    format: !0,
    attributeNamePrefix: "$",
    textNodeName: "#text"
  }).build(e);
}
function P5(e, t, r) {
  let n = Object.assign({}, k5, t);
  BU();
  let o = _s(e, n, r).value;
  return (n == null ? void 0 : n.format) === "xml" ? A5(o, e) : o;
}
function Hu(e, t) {
  Nx[e] = t;
}
Hu("array", UU);
Hu("boolean", VU);
Hu("integer", w$);
Hu("number", w$);
Hu("object", HU);
Hu("string", h5);
const T5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _registerSampler: Hu,
  _samplers: Nx,
  inferType: Ud,
  sample: P5
}, Symbol.toStringTag, { value: "Module" })), C5 = /* @__PURE__ */ _o(T5);
var E$ = /* @__PURE__ */ gT();
function jx(e) {
  return (t) => !!t.type && t.type.tabsRole === e;
}
const Ah = jx("Tab"), cb = jx("TabList"), pb = jx("TabPanel");
function $5(e) {
  return Ah(e) || cb(e) || pb(e);
}
function $S(e, t) {
  return Pt.Children.map(e, (r) => r === null ? null : $5(r) ? t(r) : r.props && r.props.children && typeof r.props.children == "object" ? Pt.cloneElement(r, Object.assign({}, r.props, { children: $S(r.props.children, t) })) : r);
}
function Sv(e, t) {
  return Pt.Children.forEach(e, (r) => {
    r !== null && (Ah(r) || pb(r) ? t(r) : r.props && r.props.children && typeof r.props.children == "object" && (cb(r) && t(r), Sv(r.props.children, t)));
  });
}
function O$(e, t, r) {
  let n, o = 0, a = 0, i = !1;
  const u = [], c = e[t];
  return Sv(c, (d) => {
    cb(d) && (d.props && d.props.children && typeof d.props.children == "object" && Sv(d.props.children, (m) => u.push(m)), i && (n = new Error("Found multiple 'TabList' components inside 'Tabs'. Only one is allowed.")), i = !0), Ah(d) ? ((!i || u.indexOf(d) === -1) && (n = new Error("Found a 'Tab' component outside of the 'TabList' component. 'Tab' components have to be inside the 'TabList' component.")), o++) : pb(d) && a++;
  }), !n && o !== a && (n = new Error(`There should be an equal number of 'Tab' and 'TabPanel' in \`${r}\`. Received ${o} 'Tab' and ${a} 'TabPanel'.`)), n;
}
function R5(e, t, r, n, o) {
  const a = e[t], i = o || t;
  let u = null;
  return a && typeof a != "function" ? u = new Error(`Invalid ${n} \`${i}\` of type \`${typeof a}\` supplied to \`${r}\`, expected \`function\`.`) : e.selectedIndex != null && a == null && (u = new Error(`The ${n} \`${i}\` is marked as required in \`${r}\`, but its value is \`undefined\` or \`null\`.
\`onSelect\` is required when \`selectedIndex\` is also set. Not doing so will make the tabs not do anything, as \`selectedIndex\` indicates that you want to handle the selected tab yourself.
If you only want to set the inital tab replace \`selectedIndex\` with \`defaultIndex\`.`)), u;
}
function I5(e, t, r, n, o) {
  const a = e[t], i = o || t;
  let u = null;
  if (a != null && typeof a != "number")
    u = new Error(`Invalid ${n} \`${i}\` of type \`${typeof a}\` supplied to \`${r}\`, expected \`number\`.`);
  else if (e.defaultIndex != null && a != null)
    return new Error(`The ${n} \`${i}\` cannot be used together with \`defaultIndex\` in \`${r}\`.
Either remove \`${i}\` to let \`${r}\` handle the selected tab internally or remove \`defaultIndex\` to handle it yourself.`);
  return u;
}
function k$(e) {
  var t, r, n = "";
  if (typeof e == "string" || typeof e == "number") n += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (r = k$(e[t])) && (n && (n += " "), n += r);
  } else for (r in e) e[r] && (n && (n += " "), n += r);
  return n;
}
function fb() {
  for (var e, t, r = 0, n = "", o = arguments.length; r < o; r++) (e = arguments[r]) && (t = k$(e)) && (n && (n += " "), n += t);
  return n;
}
function A$(e) {
  let t = 0;
  return Sv(e, (r) => {
    Ah(r) && t++;
  }), t;
}
const N5 = ["children", "className", "disabledTabClassName", "domRef", "focus", "forceRenderTabPanel", "onSelect", "selectedIndex", "selectedTabClassName", "selectedTabPanelClassName", "environment", "disableUpDownKeys", "disableLeftRightKeys"];
function j5(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e) if ({}.hasOwnProperty.call(e, n)) {
    if (t.includes(n)) continue;
    r[n] = e[n];
  }
  return r;
}
function P$(e) {
  return e && "getAttribute" in e;
}
function vA(e) {
  return P$(e) && e.getAttribute("data-rttab");
}
function Ou(e) {
  return P$(e) && e.getAttribute("aria-disabled") === "true";
}
let xv;
function L5(e) {
  const t = e || (typeof window < "u" ? window : void 0);
  try {
    xv = !!(typeof t < "u" && t.document && t.document.activeElement);
  } catch {
    xv = !1;
  }
}
const M5 = { className: "react-tabs", focus: !1 }, D5 = { children: O$ }, F5 = (e) => {
  E$.checkPropTypes(D5, e, "prop", "UncontrolledTabs");
  let t = Pt.useRef([]), r = Pt.useRef([]);
  const n = Pt.useRef();
  function o(O, R) {
    if (O < 0 || O >= d()) return;
    const { onSelect: C, selectedIndex: T } = e;
    C(O, T, R);
  }
  function a(O) {
    const R = d();
    for (let C = O + 1; C < R; C++)
      if (!Ou(m(C)))
        return C;
    for (let C = 0; C < O; C++)
      if (!Ou(m(C)))
        return C;
    return O;
  }
  function i(O) {
    let R = O;
    for (; R--; )
      if (!Ou(m(R)))
        return R;
    for (R = d(); R-- > O; )
      if (!Ou(m(R)))
        return R;
    return O;
  }
  function u() {
    const O = d();
    for (let R = 0; R < O; R++)
      if (!Ou(m(R)))
        return R;
    return null;
  }
  function c() {
    let O = d();
    for (; O--; )
      if (!Ou(m(O)))
        return O;
    return null;
  }
  function d() {
    const { children: O } = e;
    return A$(O);
  }
  function m(O) {
    return t.current[`tabs-${O}`];
  }
  function g() {
    let O = 0;
    const { children: R, disabledTabClassName: C, focus: T, forceRenderTabPanel: j, selectedIndex: D, selectedTabClassName: V, selectedTabPanelClassName: U, environment: ne } = e;
    r.current = r.current || [];
    let H = r.current.length - d();
    const ae = Pt.useId();
    for (; H++ < 0; )
      r.current.push(`${ae}${r.current.length}`);
    return $S(R, (ge) => {
      let fe = ge;
      if (cb(ge)) {
        let ve = 0, $e = !1;
        xv == null && L5(ne);
        const ce = ne || (typeof window < "u" ? window : void 0);
        xv && ce && ($e = Rt.Children.toArray(ge.props.children).filter(Ah).some((se, te) => ce.document.activeElement === m(te))), fe = Pt.cloneElement(ge, { children: $S(ge.props.children, (se) => {
          const te = `tabs-${ve}`, F = D === ve, J = { tabRef: (W) => {
            t.current[te] = W;
          }, id: r.current[ve], selected: F, focus: F && (T || $e) };
          return V && (J.selectedClassName = V), C && (J.disabledClassName = C), ve++, Pt.cloneElement(se, J);
        }) });
      } else if (pb(ge)) {
        const ve = { id: r.current[O], selected: D === O };
        j && (ve.forceRender = j), U && (ve.selectedClassName = U), O++, fe = Pt.cloneElement(ge, ve);
      }
      return fe;
    });
  }
  function v(O) {
    const { direction: R, disableUpDownKeys: C, disableLeftRightKeys: T } = e;
    if (k(O.target)) {
      let { selectedIndex: j } = e, D = !1, V = !1;
      (O.code === "Space" || O.keyCode === 32 || O.code === "Enter" || O.keyCode === 13) && (D = !0, V = !1, S(O)), !T && (O.keyCode === 37 || O.code === "ArrowLeft") || !C && (O.keyCode === 38 || O.code === "ArrowUp") ? (R === "rtl" ? j = a(j) : j = i(j), D = !0, V = !0) : !T && (O.keyCode === 39 || O.code === "ArrowRight") || !C && (O.keyCode === 40 || O.code === "ArrowDown") ? (R === "rtl" ? j = i(j) : j = a(j), D = !0, V = !0) : O.keyCode === 35 || O.code === "End" ? (j = c(), D = !0, V = !0) : (O.keyCode === 36 || O.code === "Home") && (j = u(), D = !0, V = !0), D && O.preventDefault(), V && o(j, O);
    }
  }
  function S(O) {
    let R = O.target;
    do
      if (k(R)) {
        if (Ou(R))
          return;
        const C = [].slice.call(R.parentNode.children).filter(vA).indexOf(R);
        o(C, O);
        return;
      }
    while ((R = R.parentNode) != null);
  }
  function k(O) {
    if (!vA(O))
      return !1;
    let R = O.parentElement;
    do {
      if (R === n.current) return !0;
      if (R.getAttribute("data-rttabs")) break;
      R = R.parentElement;
    } while (R);
    return !1;
  }
  const b = Object.assign({}, M5, e), { className: x, domRef: A } = b, _ = j5(b, N5);
  return Rt.createElement("div", Object.assign({}, _, { className: fb(x), onClick: S, onKeyDown: v, ref: (O) => {
    n.current = O, A && A(O);
  }, "data-rttabs": !0 }), g());
}, q5 = ["children", "defaultFocus", "defaultIndex", "focusTabOnClick", "onSelect"];
function z5(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e) if ({}.hasOwnProperty.call(e, n)) {
    if (t.includes(n)) continue;
    r[n] = e[n];
  }
  return r;
}
const B5 = 0, Wy = 1, U5 = { children: O$, onSelect: R5, selectedIndex: I5 }, V5 = { defaultFocus: !1, focusTabOnClick: !0, forceRenderTabPanel: !1, selectedIndex: null, defaultIndex: null, environment: null, disableUpDownKeys: !1, disableLeftRightKeys: !1 }, H5 = (e) => e.selectedIndex === null ? Wy : B5, T$ = (e) => {
  E$.checkPropTypes(U5, e, "prop", "Tabs");
  const t = Object.assign({}, V5, e), { children: r, defaultFocus: n, defaultIndex: o, focusTabOnClick: a, onSelect: i } = t, u = z5(t, q5), [c, d] = Pt.useState(n), [m] = Pt.useState(H5(u)), [g, v] = Pt.useState(m === Wy ? o || 0 : null);
  if (Pt.useEffect(() => {
    d(!1);
  }, []), m === Wy) {
    const b = A$(r);
    Pt.useEffect(() => {
      if (g != null) {
        const x = Math.max(0, b - 1);
        v(Math.min(g, x));
      }
    }, [b]);
  }
  const S = (b, x, A) => {
    typeof i == "function" && i(b, x, A) === !1 || (a && d(!0), m === Wy && v(b));
  };
  let k = Object.assign({}, e, u);
  return k.focus = c, k.onSelect = S, g != null && (k.selectedIndex = g), delete k.defaultFocus, delete k.defaultIndex, delete k.focusTabOnClick, Rt.createElement(F5, k, r);
};
T$.tabsRole = "Tabs";
const W5 = ["children", "className"];
function K5(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e) if ({}.hasOwnProperty.call(e, n)) {
    if (t.includes(n)) continue;
    r[n] = e[n];
  }
  return r;
}
const Q5 = { className: "react-tabs__tab-list" }, C$ = (e) => {
  const t = Object.assign({}, Q5, e), { children: r, className: n } = t, o = K5(t, W5);
  return Rt.createElement("ul", Object.assign({}, o, { className: fb(n), role: "tablist" }), r);
};
C$.tabsRole = "TabList";
const Y5 = ["children", "className", "disabled", "disabledClassName", "focus", "id", "selected", "selectedClassName", "tabIndex", "tabRef"];
function G5(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e) if ({}.hasOwnProperty.call(e, n)) {
    if (t.includes(n)) continue;
    r[n] = e[n];
  }
  return r;
}
const jw = "react-tabs__tab", X5 = { className: jw, disabledClassName: `${jw}--disabled`, focus: !1, id: null, selected: !1, selectedClassName: `${jw}--selected` }, $$ = (e) => {
  let t = Pt.useRef();
  const r = Object.assign({}, X5, e), { children: n, className: o, disabled: a, disabledClassName: i, focus: u, id: c, selected: d, selectedClassName: m, tabIndex: g, tabRef: v } = r, S = G5(r, Y5);
  return Pt.useEffect(() => {
    d && u && t.current.focus();
  }, [d, u]), Rt.createElement("li", Object.assign({}, S, { className: fb(o, { [m]: d, [i]: a }), ref: (k) => {
    t.current = k, v && v(k);
  }, role: "tab", id: `tab${c}`, "aria-selected": d ? "true" : "false", "aria-disabled": a ? "true" : "false", "aria-controls": `panel${c}`, tabIndex: g || (d ? "0" : null), "data-rttab": !0 }), n);
};
$$.tabsRole = "Tab";
const J5 = ["children", "className", "forceRender", "id", "selected", "selectedClassName"];
function Z5(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e) if ({}.hasOwnProperty.call(e, n)) {
    if (t.includes(n)) continue;
    r[n] = e[n];
  }
  return r;
}
const bA = "react-tabs__tab-panel", e4 = { className: bA, forceRender: !1, selectedClassName: `${bA}--selected` }, R$ = (e) => {
  const t = Object.assign({}, e4, e), { children: r, className: n, forceRender: o, id: a, selected: i, selectedClassName: u } = t, c = Z5(t, J5);
  return Rt.createElement("div", Object.assign({}, c, { className: fb(n, { [u]: i }), role: "tabpanel", id: `panel${a}`, "aria-labelledby": `tab${a}` }), o || i ? r : null);
};
R$.tabsRole = "TabPanel";
const t4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Tab: $$,
  TabList: C$,
  TabPanel: R$,
  Tabs: T$
}, Symbol.toStringTag, { value: "Module" })), r4 = /* @__PURE__ */ _o(t4);
/*!
 * perfect-scrollbar v1.5.6
 * Copyright 2024 Hyunje Jun, MDBootstrap and Contributors
 * Licensed under MIT
 */
function yo(e) {
  return getComputedStyle(e);
}
function Jn(e, t) {
  for (var r in t) {
    var n = t[r];
    typeof n == "number" && (n = n + "px"), e.style[r] = n;
  }
  return e;
}
function ky(e) {
  var t = document.createElement("div");
  return t.className = e, t;
}
var wA = typeof Element < "u" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
function ll(e, t) {
  if (!wA)
    throw new Error("No element matching method supported");
  return wA.call(e, t);
}
function vp(e) {
  e.remove ? e.remove() : e.parentNode && e.parentNode.removeChild(e);
}
function SA(e, t) {
  return Array.prototype.filter.call(
    e.children,
    function(r) {
      return ll(r, t);
    }
  );
}
var Nr = {
  main: "ps",
  rtl: "ps__rtl",
  element: {
    thumb: function(e) {
      return "ps__thumb-" + e;
    },
    rail: function(e) {
      return "ps__rail-" + e;
    },
    consuming: "ps__child--consume"
  },
  state: {
    focus: "ps--focus",
    clicking: "ps--clicking",
    active: function(e) {
      return "ps--active-" + e;
    },
    scrolling: function(e) {
      return "ps--scrolling-" + e;
    }
  }
}, I$ = { x: null, y: null };
function N$(e, t) {
  var r = e.element.classList, n = Nr.state.scrolling(t);
  r.contains(n) ? clearTimeout(I$[t]) : r.add(n);
}
function j$(e, t) {
  I$[t] = setTimeout(
    function() {
      return e.isAlive && e.element.classList.remove(Nr.state.scrolling(t));
    },
    e.settings.scrollingThreshold
  );
}
function n4(e, t) {
  N$(e, t), j$(e, t);
}
var Ph = function(t) {
  this.element = t, this.handlers = {};
}, L$ = { isEmpty: { configurable: !0 } };
Ph.prototype.bind = function(t, r) {
  typeof this.handlers[t] > "u" && (this.handlers[t] = []), this.handlers[t].push(r), this.element.addEventListener(t, r, !1);
};
Ph.prototype.unbind = function(t, r) {
  var n = this;
  this.handlers[t] = this.handlers[t].filter(function(o) {
    return r && o !== r ? !0 : (n.element.removeEventListener(t, o, !1), !1);
  });
};
Ph.prototype.unbindAll = function() {
  for (var t in this.handlers)
    this.unbind(t);
};
L$.isEmpty.get = function() {
  var e = this;
  return Object.keys(this.handlers).every(
    function(t) {
      return e.handlers[t].length === 0;
    }
  );
};
Object.defineProperties(Ph.prototype, L$);
var Hp = function() {
  this.eventElements = [];
};
Hp.prototype.eventElement = function(t) {
  var r = this.eventElements.filter(function(n) {
    return n.element === t;
  })[0];
  return r || (r = new Ph(t), this.eventElements.push(r)), r;
};
Hp.prototype.bind = function(t, r, n) {
  this.eventElement(t).bind(r, n);
};
Hp.prototype.unbind = function(t, r, n) {
  var o = this.eventElement(t);
  o.unbind(r, n), o.isEmpty && this.eventElements.splice(this.eventElements.indexOf(o), 1);
};
Hp.prototype.unbindAll = function() {
  this.eventElements.forEach(function(t) {
    return t.unbindAll();
  }), this.eventElements = [];
};
Hp.prototype.once = function(t, r, n) {
  var o = this.eventElement(t), a = function(i) {
    o.unbind(r, a), n(i);
  };
  o.bind(r, a);
};
function Ay(e) {
  if (typeof window.CustomEvent == "function")
    return new CustomEvent(e);
  var t = document.createEvent("CustomEvent");
  return t.initCustomEvent(e, !1, !1, void 0), t;
}
function _v(e, t, r, n, o) {
  n === void 0 && (n = !0), o === void 0 && (o = !1);
  var a;
  if (t === "top")
    a = ["contentHeight", "containerHeight", "scrollTop", "y", "up", "down"];
  else if (t === "left")
    a = ["contentWidth", "containerWidth", "scrollLeft", "x", "left", "right"];
  else
    throw new Error("A proper axis should be provided");
  i4(e, r, a, n, o);
}
function i4(e, t, r, n, o) {
  var a = r[0], i = r[1], u = r[2], c = r[3], d = r[4], m = r[5];
  n === void 0 && (n = !0), o === void 0 && (o = !1);
  var g = e.element;
  e.reach[c] = null, g[u] < 1 && (e.reach[c] = "start"), g[u] > e[a] - e[i] - 1 && (e.reach[c] = "end"), t && (g.dispatchEvent(Ay("ps-scroll-" + c)), t < 0 ? g.dispatchEvent(Ay("ps-scroll-" + d)) : t > 0 && g.dispatchEvent(Ay("ps-scroll-" + m)), n && n4(e, c)), e.reach[c] && (t || o) && g.dispatchEvent(Ay("ps-" + c + "-reach-" + e.reach[c]));
}
function vr(e) {
  return parseInt(e, 10) || 0;
}
function s4(e) {
  return ll(e, "input,[contenteditable]") || ll(e, "select,[contenteditable]") || ll(e, "textarea,[contenteditable]") || ll(e, "button,[contenteditable]");
}
function o4(e) {
  var t = yo(e);
  return vr(t.width) + vr(t.paddingLeft) + vr(t.paddingRight) + vr(t.borderLeftWidth) + vr(t.borderRightWidth);
}
var cp = {
  isWebKit: typeof document < "u" && "WebkitAppearance" in document.documentElement.style,
  supportsTouch: typeof window < "u" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: typeof navigator < "u" && navigator.msMaxTouchPoints,
  isChrome: typeof navigator < "u" && /Chrome/i.test(navigator && navigator.userAgent)
};
function ga(e) {
  var t = e.element, r = Math.floor(t.scrollTop), n = t.getBoundingClientRect();
  e.containerWidth = Math.floor(n.width), e.containerHeight = Math.floor(n.height), e.contentWidth = t.scrollWidth, e.contentHeight = t.scrollHeight, t.contains(e.scrollbarXRail) || (SA(t, Nr.element.rail("x")).forEach(function(o) {
    return vp(o);
  }), t.appendChild(e.scrollbarXRail)), t.contains(e.scrollbarYRail) || (SA(t, Nr.element.rail("y")).forEach(function(o) {
    return vp(o);
  }), t.appendChild(e.scrollbarYRail)), !e.settings.suppressScrollX && e.containerWidth + e.settings.scrollXMarginOffset < e.contentWidth ? (e.scrollbarXActive = !0, e.railXWidth = e.containerWidth - e.railXMarginWidth, e.railXRatio = e.containerWidth / e.railXWidth, e.scrollbarXWidth = xA(e, vr(e.railXWidth * e.containerWidth / e.contentWidth)), e.scrollbarXLeft = vr(
    (e.negativeScrollAdjustment + t.scrollLeft) * (e.railXWidth - e.scrollbarXWidth) / (e.contentWidth - e.containerWidth)
  )) : e.scrollbarXActive = !1, !e.settings.suppressScrollY && e.containerHeight + e.settings.scrollYMarginOffset < e.contentHeight ? (e.scrollbarYActive = !0, e.railYHeight = e.containerHeight - e.railYMarginHeight, e.railYRatio = e.containerHeight / e.railYHeight, e.scrollbarYHeight = xA(
    e,
    vr(e.railYHeight * e.containerHeight / e.contentHeight)
  ), e.scrollbarYTop = vr(
    r * (e.railYHeight - e.scrollbarYHeight) / (e.contentHeight - e.containerHeight)
  )) : e.scrollbarYActive = !1, e.scrollbarXLeft >= e.railXWidth - e.scrollbarXWidth && (e.scrollbarXLeft = e.railXWidth - e.scrollbarXWidth), e.scrollbarYTop >= e.railYHeight - e.scrollbarYHeight && (e.scrollbarYTop = e.railYHeight - e.scrollbarYHeight), a4(t, e), e.scrollbarXActive ? t.classList.add(Nr.state.active("x")) : (t.classList.remove(Nr.state.active("x")), e.scrollbarXWidth = 0, e.scrollbarXLeft = 0, t.scrollLeft = e.isRtl === !0 ? e.contentWidth : 0), e.scrollbarYActive ? t.classList.add(Nr.state.active("y")) : (t.classList.remove(Nr.state.active("y")), e.scrollbarYHeight = 0, e.scrollbarYTop = 0, t.scrollTop = 0);
}
function xA(e, t) {
  return e.settings.minScrollbarLength && (t = Math.max(t, e.settings.minScrollbarLength)), e.settings.maxScrollbarLength && (t = Math.min(t, e.settings.maxScrollbarLength)), t;
}
function a4(e, t) {
  var r = { width: t.railXWidth }, n = Math.floor(e.scrollTop);
  t.isRtl ? r.left = t.negativeScrollAdjustment + e.scrollLeft + t.containerWidth - t.contentWidth : r.left = e.scrollLeft, t.isScrollbarXUsingBottom ? r.bottom = t.scrollbarXBottom - n : r.top = t.scrollbarXTop + n, Jn(t.scrollbarXRail, r);
  var o = { top: n, height: t.railYHeight };
  t.isScrollbarYUsingRight ? t.isRtl ? o.right = t.contentWidth - (t.negativeScrollAdjustment + e.scrollLeft) - t.scrollbarYRight - t.scrollbarYOuterWidth - 9 : o.right = t.scrollbarYRight - e.scrollLeft : t.isRtl ? o.left = t.negativeScrollAdjustment + e.scrollLeft + t.containerWidth * 2 - t.contentWidth - t.scrollbarYLeft - t.scrollbarYOuterWidth : o.left = t.scrollbarYLeft + e.scrollLeft, Jn(t.scrollbarYRail, o), Jn(t.scrollbarX, {
    left: t.scrollbarXLeft,
    width: t.scrollbarXWidth - t.railBorderXWidth
  }), Jn(t.scrollbarY, {
    top: t.scrollbarYTop,
    height: t.scrollbarYHeight - t.railBorderYWidth
  });
}
function l4(e) {
  e.event.bind(e.scrollbarY, "mousedown", function(t) {
    return t.stopPropagation();
  }), e.event.bind(e.scrollbarYRail, "mousedown", function(t) {
    var r = t.pageY - window.pageYOffset - e.scrollbarYRail.getBoundingClientRect().top, n = r > e.scrollbarYTop ? 1 : -1;
    e.element.scrollTop += n * e.containerHeight, ga(e), t.stopPropagation();
  }), e.event.bind(e.scrollbarX, "mousedown", function(t) {
    return t.stopPropagation();
  }), e.event.bind(e.scrollbarXRail, "mousedown", function(t) {
    var r = t.pageX - window.pageXOffset - e.scrollbarXRail.getBoundingClientRect().left, n = r > e.scrollbarXLeft ? 1 : -1;
    e.element.scrollLeft += n * e.containerWidth, ga(e), t.stopPropagation();
  });
}
var Py = null;
function u4(e) {
  _A(e, [
    "containerHeight",
    "contentHeight",
    "pageY",
    "railYHeight",
    "scrollbarY",
    "scrollbarYHeight",
    "scrollTop",
    "y",
    "scrollbarYRail"
  ]), _A(e, [
    "containerWidth",
    "contentWidth",
    "pageX",
    "railXWidth",
    "scrollbarX",
    "scrollbarXWidth",
    "scrollLeft",
    "x",
    "scrollbarXRail"
  ]);
}
function _A(e, t) {
  var r = t[0], n = t[1], o = t[2], a = t[3], i = t[4], u = t[5], c = t[6], d = t[7], m = t[8], g = e.element, v = null, S = null, k = null;
  function b(_) {
    _.touches && _.touches[0] && (_[o] = _.touches[0]["page" + d.toUpperCase()]), Py === i && (g[c] = v + k * (_[o] - S), N$(e, d), ga(e), _.stopPropagation(), _.preventDefault());
  }
  function x() {
    j$(e, d), e[m].classList.remove(Nr.state.clicking), document.removeEventListener("mousemove", b), document.removeEventListener("mouseup", x), document.removeEventListener("touchmove", b), document.removeEventListener("touchend", x), Py = null;
  }
  function A(_) {
    Py === null && (Py = i, v = g[c], _.touches && (_[o] = _.touches[0]["page" + d.toUpperCase()]), S = _[o], k = (e[n] - e[r]) / (e[a] - e[u]), _.touches ? (document.addEventListener("touchmove", b, { passive: !1 }), document.addEventListener("touchend", x)) : (document.addEventListener("mousemove", b), document.addEventListener("mouseup", x)), e[m].classList.add(Nr.state.clicking)), _.stopPropagation(), _.cancelable && _.preventDefault();
  }
  e[i].addEventListener("mousedown", A), e[i].addEventListener("touchstart", A);
}
function c4(e) {
  var t = e.element, r = function() {
    return ll(t, ":hover");
  }, n = function() {
    return ll(e.scrollbarX, ":focus") || ll(e.scrollbarY, ":focus");
  };
  function o(a, i) {
    var u = Math.floor(t.scrollTop);
    if (a === 0) {
      if (!e.scrollbarYActive)
        return !1;
      if (u === 0 && i > 0 || u >= e.contentHeight - e.containerHeight && i < 0)
        return !e.settings.wheelPropagation;
    }
    var c = t.scrollLeft;
    if (i === 0) {
      if (!e.scrollbarXActive)
        return !1;
      if (c === 0 && a < 0 || c >= e.contentWidth - e.containerWidth && a > 0)
        return !e.settings.wheelPropagation;
    }
    return !0;
  }
  e.event.bind(e.ownerDocument, "keydown", function(a) {
    if (!(a.isDefaultPrevented && a.isDefaultPrevented() || a.defaultPrevented) && !(!r() && !n())) {
      var i = document.activeElement ? document.activeElement : e.ownerDocument.activeElement;
      if (i) {
        if (i.tagName === "IFRAME")
          i = i.contentDocument.activeElement;
        else
          for (; i.shadowRoot; )
            i = i.shadowRoot.activeElement;
        if (s4(i))
          return;
      }
      var u = 0, c = 0;
      switch (a.which) {
        case 37:
          a.metaKey ? u = -e.contentWidth : a.altKey ? u = -e.containerWidth : u = -30;
          break;
        case 38:
          a.metaKey ? c = e.contentHeight : a.altKey ? c = e.containerHeight : c = 30;
          break;
        case 39:
          a.metaKey ? u = e.contentWidth : a.altKey ? u = e.containerWidth : u = 30;
          break;
        case 40:
          a.metaKey ? c = -e.contentHeight : a.altKey ? c = -e.containerHeight : c = -30;
          break;
        case 32:
          a.shiftKey ? c = e.containerHeight : c = -e.containerHeight;
          break;
        case 33:
          c = e.containerHeight;
          break;
        case 34:
          c = -e.containerHeight;
          break;
        case 36:
          c = e.contentHeight;
          break;
        case 35:
          c = -e.contentHeight;
          break;
        default:
          return;
      }
      e.settings.suppressScrollX && u !== 0 || e.settings.suppressScrollY && c !== 0 || (t.scrollTop -= c, t.scrollLeft += u, ga(e), o(u, c) && a.preventDefault());
    }
  });
}
function p4(e) {
  var t = e.element;
  function r(i, u) {
    var c = Math.floor(t.scrollTop), d = t.scrollTop === 0, m = c + t.offsetHeight === t.scrollHeight, g = t.scrollLeft === 0, v = t.scrollLeft + t.offsetWidth === t.scrollWidth, S;
    return Math.abs(u) > Math.abs(i) ? S = d || m : S = g || v, S ? !e.settings.wheelPropagation : !0;
  }
  function n(i) {
    var u = i.deltaX, c = -1 * i.deltaY;
    return (typeof u > "u" || typeof c > "u") && (u = -1 * i.wheelDeltaX / 6, c = i.wheelDeltaY / 6), i.deltaMode && i.deltaMode === 1 && (u *= 10, c *= 10), u !== u && c !== c && (u = 0, c = i.wheelDelta), i.shiftKey ? [-c, -u] : [u, c];
  }
  function o(i, u, c) {
    if (!cp.isWebKit && t.querySelector("select:focus"))
      return !0;
    if (!t.contains(i))
      return !1;
    for (var d = i; d && d !== t; ) {
      if (d.classList.contains(Nr.element.consuming))
        return !0;
      var m = yo(d);
      if (c && m.overflowY.match(/(scroll|auto)/)) {
        var g = d.scrollHeight - d.clientHeight;
        if (g > 0 && (d.scrollTop > 0 && c < 0 || d.scrollTop < g && c > 0))
          return !0;
      }
      if (u && m.overflowX.match(/(scroll|auto)/)) {
        var v = d.scrollWidth - d.clientWidth;
        if (v > 0 && (d.scrollLeft > 0 && u < 0 || d.scrollLeft < v && u > 0))
          return !0;
      }
      d = d.parentNode;
    }
    return !1;
  }
  function a(i) {
    var u = n(i), c = u[0], d = u[1];
    if (!o(i.target, c, d)) {
      var m = !1;
      e.settings.useBothWheelAxes ? e.scrollbarYActive && !e.scrollbarXActive ? (d ? t.scrollTop -= d * e.settings.wheelSpeed : t.scrollTop += c * e.settings.wheelSpeed, m = !0) : e.scrollbarXActive && !e.scrollbarYActive && (c ? t.scrollLeft += c * e.settings.wheelSpeed : t.scrollLeft -= d * e.settings.wheelSpeed, m = !0) : (t.scrollTop -= d * e.settings.wheelSpeed, t.scrollLeft += c * e.settings.wheelSpeed), ga(e), m = m || r(c, d), m && !i.ctrlKey && (i.stopPropagation(), i.preventDefault());
    }
  }
  typeof window.onwheel < "u" ? e.event.bind(t, "wheel", a) : typeof window.onmousewheel < "u" && e.event.bind(t, "mousewheel", a);
}
function f4(e) {
  if (!cp.supportsTouch && !cp.supportsIePointer)
    return;
  var t = e.element, r = {
    startOffset: {},
    startTime: 0,
    speed: {},
    easingLoop: null
  };
  function n(g, v) {
    var S = Math.floor(t.scrollTop), k = t.scrollLeft, b = Math.abs(g), x = Math.abs(v);
    if (x > b) {
      if (v < 0 && S === e.contentHeight - e.containerHeight || v > 0 && S === 0)
        return window.scrollY === 0 && v > 0 && cp.isChrome;
    } else if (b > x && (g < 0 && k === e.contentWidth - e.containerWidth || g > 0 && k === 0))
      return !0;
    return !0;
  }
  function o(g, v) {
    t.scrollTop -= v, t.scrollLeft -= g, ga(e);
  }
  function a(g) {
    return g.targetTouches ? g.targetTouches[0] : g;
  }
  function i(g) {
    return g.target === e.scrollbarX || g.target === e.scrollbarY || g.pointerType && g.pointerType === "pen" && g.buttons === 0 ? !1 : !!(g.targetTouches && g.targetTouches.length === 1 || g.pointerType && g.pointerType !== "mouse" && g.pointerType !== g.MSPOINTER_TYPE_MOUSE);
  }
  function u(g) {
    if (i(g)) {
      var v = a(g);
      r.startOffset.pageX = v.pageX, r.startOffset.pageY = v.pageY, r.startTime = (/* @__PURE__ */ new Date()).getTime(), r.easingLoop !== null && clearInterval(r.easingLoop);
    }
  }
  function c(g, v, S) {
    if (!t.contains(g))
      return !1;
    for (var k = g; k && k !== t; ) {
      if (k.classList.contains(Nr.element.consuming))
        return !0;
      var b = yo(k);
      if (S && b.overflowY.match(/(scroll|auto)/)) {
        var x = k.scrollHeight - k.clientHeight;
        if (x > 0 && (k.scrollTop > 0 && S < 0 || k.scrollTop < x && S > 0))
          return !0;
      }
      if (v && b.overflowX.match(/(scroll|auto)/)) {
        var A = k.scrollWidth - k.clientWidth;
        if (A > 0 && (k.scrollLeft > 0 && v < 0 || k.scrollLeft < A && v > 0))
          return !0;
      }
      k = k.parentNode;
    }
    return !1;
  }
  function d(g) {
    if (i(g)) {
      var v = a(g), S = { pageX: v.pageX, pageY: v.pageY }, k = S.pageX - r.startOffset.pageX, b = S.pageY - r.startOffset.pageY;
      if (c(g.target, k, b))
        return;
      o(k, b), r.startOffset = S;
      var x = (/* @__PURE__ */ new Date()).getTime(), A = x - r.startTime;
      A > 0 && (r.speed.x = k / A, r.speed.y = b / A, r.startTime = x), n(k, b) && g.cancelable && g.preventDefault();
    }
  }
  function m() {
    e.settings.swipeEasing && (clearInterval(r.easingLoop), r.easingLoop = setInterval(function() {
      if (e.isInitialized) {
        clearInterval(r.easingLoop);
        return;
      }
      if (!r.speed.x && !r.speed.y) {
        clearInterval(r.easingLoop);
        return;
      }
      if (Math.abs(r.speed.x) < 0.01 && Math.abs(r.speed.y) < 0.01) {
        clearInterval(r.easingLoop);
        return;
      }
      o(r.speed.x * 30, r.speed.y * 30), r.speed.x *= 0.8, r.speed.y *= 0.8;
    }, 10));
  }
  cp.supportsTouch ? (e.event.bind(t, "touchstart", u), e.event.bind(t, "touchmove", d), e.event.bind(t, "touchend", m)) : cp.supportsIePointer && (window.PointerEvent ? (e.event.bind(t, "pointerdown", u), e.event.bind(t, "pointermove", d), e.event.bind(t, "pointerup", m)) : window.MSPointerEvent && (e.event.bind(t, "MSPointerDown", u), e.event.bind(t, "MSPointerMove", d), e.event.bind(t, "MSPointerUp", m)));
}
var d4 = function() {
  return {
    handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
    maxScrollbarLength: null,
    minScrollbarLength: null,
    scrollingThreshold: 1e3,
    scrollXMarginOffset: 0,
    scrollYMarginOffset: 0,
    suppressScrollX: !1,
    suppressScrollY: !1,
    swipeEasing: !0,
    useBothWheelAxes: !1,
    wheelPropagation: !0,
    wheelSpeed: 1
  };
}, h4 = {
  "click-rail": l4,
  "drag-thumb": u4,
  keyboard: c4,
  wheel: p4,
  touch: f4
}, Th = function(t, r) {
  var n = this;
  if (r === void 0 && (r = {}), typeof t == "string" && (t = document.querySelector(t)), !t || !t.nodeName)
    throw new Error("no element is specified to initialize PerfectScrollbar");
  this.element = t, t.classList.add(Nr.main), this.settings = d4();
  for (var o in r)
    this.settings[o] = r[o];
  this.containerWidth = null, this.containerHeight = null, this.contentWidth = null, this.contentHeight = null;
  var a = function() {
    return t.classList.add(Nr.state.focus);
  }, i = function() {
    return t.classList.remove(Nr.state.focus);
  };
  this.isRtl = yo(t).direction === "rtl", this.isRtl === !0 && t.classList.add(Nr.rtl), this.isNegativeScroll = function() {
    var d = t.scrollLeft, m = null;
    return t.scrollLeft = -1, m = t.scrollLeft < 0, t.scrollLeft = d, m;
  }(), this.negativeScrollAdjustment = this.isNegativeScroll ? t.scrollWidth - t.clientWidth : 0, this.event = new Hp(), this.ownerDocument = t.ownerDocument || document, this.scrollbarXRail = ky(Nr.element.rail("x")), t.appendChild(this.scrollbarXRail), this.scrollbarX = ky(Nr.element.thumb("x")), this.scrollbarXRail.appendChild(this.scrollbarX), this.scrollbarX.setAttribute("tabindex", 0), this.event.bind(this.scrollbarX, "focus", a), this.event.bind(this.scrollbarX, "blur", i), this.scrollbarXActive = null, this.scrollbarXWidth = null, this.scrollbarXLeft = null;
  var u = yo(this.scrollbarXRail);
  this.scrollbarXBottom = parseInt(u.bottom, 10), isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = !1, this.scrollbarXTop = vr(u.top)) : this.isScrollbarXUsingBottom = !0, this.railBorderXWidth = vr(u.borderLeftWidth) + vr(u.borderRightWidth), Jn(this.scrollbarXRail, { display: "block" }), this.railXMarginWidth = vr(u.marginLeft) + vr(u.marginRight), Jn(this.scrollbarXRail, { display: "" }), this.railXWidth = null, this.railXRatio = null, this.scrollbarYRail = ky(Nr.element.rail("y")), t.appendChild(this.scrollbarYRail), this.scrollbarY = ky(Nr.element.thumb("y")), this.scrollbarYRail.appendChild(this.scrollbarY), this.scrollbarY.setAttribute("tabindex", 0), this.event.bind(this.scrollbarY, "focus", a), this.event.bind(this.scrollbarY, "blur", i), this.scrollbarYActive = null, this.scrollbarYHeight = null, this.scrollbarYTop = null;
  var c = yo(this.scrollbarYRail);
  this.scrollbarYRight = parseInt(c.right, 10), isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = !1, this.scrollbarYLeft = vr(c.left)) : this.isScrollbarYUsingRight = !0, this.scrollbarYOuterWidth = this.isRtl ? o4(this.scrollbarY) : null, this.railBorderYWidth = vr(c.borderTopWidth) + vr(c.borderBottomWidth), Jn(this.scrollbarYRail, { display: "block" }), this.railYMarginHeight = vr(c.marginTop) + vr(c.marginBottom), Jn(this.scrollbarYRail, { display: "" }), this.railYHeight = null, this.railYRatio = null, this.reach = {
    x: t.scrollLeft <= 0 ? "start" : t.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
    y: t.scrollTop <= 0 ? "start" : t.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
  }, this.isAlive = !0, this.settings.handlers.forEach(function(d) {
    return h4[d](n);
  }), this.lastScrollTop = Math.floor(t.scrollTop), this.lastScrollLeft = t.scrollLeft, this.event.bind(this.element, "scroll", function(d) {
    return n.onScroll(d);
  }), ga(this);
};
Th.prototype.update = function() {
  this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0, Jn(this.scrollbarXRail, { display: "block" }), Jn(this.scrollbarYRail, { display: "block" }), this.railXMarginWidth = vr(yo(this.scrollbarXRail).marginLeft) + vr(yo(this.scrollbarXRail).marginRight), this.railYMarginHeight = vr(yo(this.scrollbarYRail).marginTop) + vr(yo(this.scrollbarYRail).marginBottom), Jn(this.scrollbarXRail, { display: "none" }), Jn(this.scrollbarYRail, { display: "none" }), ga(this), _v(this, "top", 0, !1, !0), _v(this, "left", 0, !1, !0), Jn(this.scrollbarXRail, { display: "" }), Jn(this.scrollbarYRail, { display: "" }));
};
Th.prototype.onScroll = function(t) {
  this.isAlive && (ga(this), _v(this, "top", this.element.scrollTop - this.lastScrollTop), _v(this, "left", this.element.scrollLeft - this.lastScrollLeft), this.lastScrollTop = Math.floor(this.element.scrollTop), this.lastScrollLeft = this.element.scrollLeft);
};
Th.prototype.destroy = function() {
  this.isAlive && (this.event.unbindAll(), vp(this.scrollbarX), vp(this.scrollbarY), vp(this.scrollbarXRail), vp(this.scrollbarYRail), this.removePsClasses(), this.element = null, this.scrollbarX = null, this.scrollbarY = null, this.scrollbarXRail = null, this.scrollbarYRail = null, this.isAlive = !1);
};
Th.prototype.removePsClasses = function() {
  this.element.className = this.element.className.split(" ").filter(function(t) {
    return !t.match(/^ps([-_].+|)$/);
  }).join(" ");
};
const m4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Th
}, Symbol.toStringTag, { value: "Module" })), g4 = /* @__PURE__ */ _o(m4);
/*! @license DOMPurify 3.2.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.5/LICENSE */
var Lw, EA;
function y4() {
  if (EA) return Lw;
  EA = 1;
  const {
    entries: e,
    setPrototypeOf: t,
    isFrozen: r,
    getPrototypeOf: n,
    getOwnPropertyDescriptor: o
  } = Object;
  let {
    freeze: a,
    seal: i,
    create: u
  } = Object, {
    apply: c,
    construct: d
  } = typeof Reflect < "u" && Reflect;
  a || (a = function(me) {
    return me;
  }), i || (i = function(me) {
    return me;
  }), c || (c = function(me, Te, ke) {
    return me.apply(Te, ke);
  }), d || (d = function(me, Te) {
    return new me(...Te);
  });
  const m = D(Array.prototype.forEach), g = D(Array.prototype.lastIndexOf), v = D(Array.prototype.pop), S = D(Array.prototype.push), k = D(Array.prototype.splice), b = D(String.prototype.toLowerCase), x = D(String.prototype.toString), A = D(String.prototype.match), _ = D(String.prototype.replace), O = D(String.prototype.indexOf), R = D(String.prototype.trim), C = D(Object.prototype.hasOwnProperty), T = D(RegExp.prototype.test), j = V(TypeError);
  function D(K) {
    return function(me) {
      me instanceof RegExp && (me.lastIndex = 0);
      for (var Te = arguments.length, ke = new Array(Te > 1 ? Te - 1 : 0), De = 1; De < Te; De++)
        ke[De - 1] = arguments[De];
      return c(K, me, ke);
    };
  }
  function V(K) {
    return function() {
      for (var me = arguments.length, Te = new Array(me), ke = 0; ke < me; ke++)
        Te[ke] = arguments[ke];
      return d(K, Te);
    };
  }
  function U(K, me) {
    let Te = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : b;
    t && t(K, null);
    let ke = me.length;
    for (; ke--; ) {
      let De = me[ke];
      if (typeof De == "string") {
        const Fe = Te(De);
        Fe !== De && (r(me) || (me[ke] = Fe), De = Fe);
      }
      K[De] = !0;
    }
    return K;
  }
  function ne(K) {
    for (let me = 0; me < K.length; me++)
      C(K, me) || (K[me] = null);
    return K;
  }
  function H(K) {
    const me = u(null);
    for (const [Te, ke] of e(K))
      C(K, Te) && (Array.isArray(ke) ? me[Te] = ne(ke) : ke && typeof ke == "object" && ke.constructor === Object ? me[Te] = H(ke) : me[Te] = ke);
    return me;
  }
  function ae(K, me) {
    for (; K !== null; ) {
      const ke = o(K, me);
      if (ke) {
        if (ke.get)
          return D(ke.get);
        if (typeof ke.value == "function")
          return D(ke.value);
      }
      K = n(K);
    }
    function Te() {
      return null;
    }
    return Te;
  }
  const ge = a(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), fe = a(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), ve = a(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), $e = a(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), ce = a(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), se = a(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), te = a(["#text"]), F = a(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), J = a(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), W = a(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), q = a(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), X = i(/\{\{[\w\W]*|[\w\W]*\}\}/gm), Q = i(/<%[\w\W]*|[\w\W]*%>/gm), ye = i(/\$\{[\w\W]*/gm), Se = i(/^data-[\-\w.\u00B7-\uFFFF]+$/), Ne = i(/^aria-[\-\w]+$/), N = i(
    /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
    // eslint-disable-line no-useless-escape
  ), B = i(/^(?:\w+script|data):/i), oe = i(
    /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
    // eslint-disable-line no-control-regex
  ), ie = i(/^html$/i), he = i(/^[a-z][.\w]*(-[.\w]+)+$/i);
  var Z = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ARIA_ATTR: Ne,
    ATTR_WHITESPACE: oe,
    CUSTOM_ELEMENT: he,
    DATA_ATTR: Se,
    DOCTYPE_NAME: ie,
    ERB_EXPR: Q,
    IS_ALLOWED_URI: N,
    IS_SCRIPT_OR_DATA: B,
    MUSTACHE_EXPR: X,
    TMPLIT_EXPR: ye
  });
  const re = {
    element: 1,
    text: 3,
    // Deprecated
    progressingInstruction: 7,
    comment: 8,
    document: 9
  }, Pe = function() {
    return typeof window > "u" ? null : window;
  }, Oe = function(me, Te) {
    if (typeof me != "object" || typeof me.createPolicy != "function")
      return null;
    let ke = null;
    const De = "data-tt-policy-suffix";
    Te && Te.hasAttribute(De) && (ke = Te.getAttribute(De));
    const Fe = "dompurify" + (ke ? "#" + ke : "");
    try {
      return me.createPolicy(Fe, {
        createHTML(Xe) {
          return Xe;
        },
        createScriptURL(Xe) {
          return Xe;
        }
      });
    } catch {
      return console.warn("TrustedTypes policy " + Fe + " could not be created."), null;
    }
  }, qe = function() {
    return {
      afterSanitizeAttributes: [],
      afterSanitizeElements: [],
      afterSanitizeShadowDOM: [],
      beforeSanitizeAttributes: [],
      beforeSanitizeElements: [],
      beforeSanitizeShadowDOM: [],
      uponSanitizeAttribute: [],
      uponSanitizeElement: [],
      uponSanitizeShadowNode: []
    };
  };
  function je() {
    let K = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Pe();
    const me = (ft) => je(ft);
    if (me.version = "3.2.5", me.removed = [], !K || !K.document || K.document.nodeType !== re.document || !K.Element)
      return me.isSupported = !1, me;
    let {
      document: Te
    } = K;
    const ke = Te, De = ke.currentScript, {
      DocumentFragment: Fe,
      HTMLTemplateElement: Xe,
      Node: ct,
      Element: mt,
      NodeFilter: st,
      NamedNodeMap: at = K.NamedNodeMap || K.MozNamedAttrMap,
      HTMLFormElement: Vt,
      DOMParser: Y,
      trustedTypes: Ie
    } = K, Le = mt.prototype, Me = ae(Le, "cloneNode"), ze = ae(Le, "remove"), He = ae(Le, "nextSibling"), rt = ae(Le, "childNodes"), Ye = ae(Le, "parentNode");
    if (typeof Xe == "function") {
      const ft = Te.createElement("template");
      ft.content && ft.content.ownerDocument && (Te = ft.content.ownerDocument);
    }
    let Ze, Ge = "";
    const {
      implementation: bt,
      createNodeIterator: kt,
      createDocumentFragment: Tt,
      getElementsByTagName: It
    } = Te, {
      importNode: Xr
    } = ke;
    let er = qe();
    me.isSupported = typeof e == "function" && typeof Ye == "function" && bt && bt.createHTMLDocument !== void 0;
    const {
      MUSTACHE_EXPR: Xi,
      ERB_EXPR: Ns,
      TMPLIT_EXPR: Ji,
      DATA_ATTR: Kp,
      ARIA_ATTR: js,
      IS_SCRIPT_OR_DATA: In,
      ATTR_WHITESPACE: Zi,
      CUSTOM_ELEMENT: ya
    } = Z;
    let {
      IS_ALLOWED_URI: xl
    } = Z, cr = null;
    const Wu = U({}, [...ge, ...fe, ...ve, ...ce, ...te]);
    let Ht = null;
    const va = U({}, [...F, ...J, ...W, ...q]);
    let Xt = Object.seal(u(null, {
      tagNameCheck: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: null
      },
      attributeNameCheck: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: !1
      }
    })), Ls = null, Ms = null, es = !0, Eo = !0, ba = !1, _l = !0, Nn = !1, Kt = !0, ri = !1, Ds = !1, bi = !1, jn = !1, Oo = !1, ts = !1, rs = !0, Jr = !1;
    const Ku = "user-content-";
    let Mr = !0, ns = !1, wi = {}, is = null;
    const Fs = U({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
    let qs = null;
    const Si = U({}, ["audio", "video", "img", "source", "image", "track"]);
    let ss = null;
    const El = U({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), ko = "http://www.w3.org/1998/Math/MathML", Ln = "http://www.w3.org/2000/svg", Mn = "http://www.w3.org/1999/xhtml";
    let Dn = Mn, xi = !1, os = null;
    const wa = U({}, [ko, Ln, Mn], x);
    let Lt = U({}, ["mi", "mo", "mn", "ms", "mtext"]), ni = U({}, ["annotation-xml"]);
    const Ol = U({}, ["title", "style", "font", "a", "script"]);
    let _i = null;
    const Sa = ["application/xhtml+xml", "text/html"], kl = "text/html";
    let mr = null, Ei = null;
    const xa = Te.createElement("form"), ii = function(_e) {
      return _e instanceof RegExp || _e instanceof Function;
    }, Fn = function() {
      let _e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!(Ei && Ei === _e)) {
        if ((!_e || typeof _e != "object") && (_e = {}), _e = H(_e), _i = // eslint-disable-next-line unicorn/prefer-includes
        Sa.indexOf(_e.PARSER_MEDIA_TYPE) === -1 ? kl : _e.PARSER_MEDIA_TYPE, mr = _i === "application/xhtml+xml" ? x : b, cr = C(_e, "ALLOWED_TAGS") ? U({}, _e.ALLOWED_TAGS, mr) : Wu, Ht = C(_e, "ALLOWED_ATTR") ? U({}, _e.ALLOWED_ATTR, mr) : va, os = C(_e, "ALLOWED_NAMESPACES") ? U({}, _e.ALLOWED_NAMESPACES, x) : wa, ss = C(_e, "ADD_URI_SAFE_ATTR") ? U(H(El), _e.ADD_URI_SAFE_ATTR, mr) : El, qs = C(_e, "ADD_DATA_URI_TAGS") ? U(H(Si), _e.ADD_DATA_URI_TAGS, mr) : Si, is = C(_e, "FORBID_CONTENTS") ? U({}, _e.FORBID_CONTENTS, mr) : Fs, Ls = C(_e, "FORBID_TAGS") ? U({}, _e.FORBID_TAGS, mr) : {}, Ms = C(_e, "FORBID_ATTR") ? U({}, _e.FORBID_ATTR, mr) : {}, wi = C(_e, "USE_PROFILES") ? _e.USE_PROFILES : !1, es = _e.ALLOW_ARIA_ATTR !== !1, Eo = _e.ALLOW_DATA_ATTR !== !1, ba = _e.ALLOW_UNKNOWN_PROTOCOLS || !1, _l = _e.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Nn = _e.SAFE_FOR_TEMPLATES || !1, Kt = _e.SAFE_FOR_XML !== !1, ri = _e.WHOLE_DOCUMENT || !1, jn = _e.RETURN_DOM || !1, Oo = _e.RETURN_DOM_FRAGMENT || !1, ts = _e.RETURN_TRUSTED_TYPE || !1, bi = _e.FORCE_BODY || !1, rs = _e.SANITIZE_DOM !== !1, Jr = _e.SANITIZE_NAMED_PROPS || !1, Mr = _e.KEEP_CONTENT !== !1, ns = _e.IN_PLACE || !1, xl = _e.ALLOWED_URI_REGEXP || N, Dn = _e.NAMESPACE || Mn, Lt = _e.MATHML_TEXT_INTEGRATION_POINTS || Lt, ni = _e.HTML_INTEGRATION_POINTS || ni, Xt = _e.CUSTOM_ELEMENT_HANDLING || {}, _e.CUSTOM_ELEMENT_HANDLING && ii(_e.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Xt.tagNameCheck = _e.CUSTOM_ELEMENT_HANDLING.tagNameCheck), _e.CUSTOM_ELEMENT_HANDLING && ii(_e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Xt.attributeNameCheck = _e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), _e.CUSTOM_ELEMENT_HANDLING && typeof _e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Xt.allowCustomizedBuiltInElements = _e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Nn && (Eo = !1), Oo && (jn = !0), wi && (cr = U({}, te), Ht = [], wi.html === !0 && (U(cr, ge), U(Ht, F)), wi.svg === !0 && (U(cr, fe), U(Ht, J), U(Ht, q)), wi.svgFilters === !0 && (U(cr, ve), U(Ht, J), U(Ht, q)), wi.mathMl === !0 && (U(cr, ce), U(Ht, W), U(Ht, q))), _e.ADD_TAGS && (cr === Wu && (cr = H(cr)), U(cr, _e.ADD_TAGS, mr)), _e.ADD_ATTR && (Ht === va && (Ht = H(Ht)), U(Ht, _e.ADD_ATTR, mr)), _e.ADD_URI_SAFE_ATTR && U(ss, _e.ADD_URI_SAFE_ATTR, mr), _e.FORBID_CONTENTS && (is === Fs && (is = H(is)), U(is, _e.FORBID_CONTENTS, mr)), Mr && (cr["#text"] = !0), ri && U(cr, ["html", "head", "body"]), cr.table && (U(cr, ["tbody"]), delete Ls.tbody), _e.TRUSTED_TYPES_POLICY) {
          if (typeof _e.TRUSTED_TYPES_POLICY.createHTML != "function")
            throw j('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
          if (typeof _e.TRUSTED_TYPES_POLICY.createScriptURL != "function")
            throw j('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
          Ze = _e.TRUSTED_TYPES_POLICY, Ge = Ze.createHTML("");
        } else
          Ze === void 0 && (Ze = Oe(Ie, De)), Ze !== null && typeof Ge == "string" && (Ge = Ze.createHTML(""));
        a && a(_e), Ei = _e;
      }
    }, qn = U({}, [...fe, ...ve, ...$e]), zs = U({}, [...ce, ...se]), Ao = function(_e) {
      let Ke = Ye(_e);
      (!Ke || !Ke.tagName) && (Ke = {
        namespaceURI: Dn,
        tagName: "template"
      });
      const lt = b(_e.tagName), qt = b(Ke.tagName);
      return os[_e.namespaceURI] ? _e.namespaceURI === Ln ? Ke.namespaceURI === Mn ? lt === "svg" : Ke.namespaceURI === ko ? lt === "svg" && (qt === "annotation-xml" || Lt[qt]) : !!qn[lt] : _e.namespaceURI === ko ? Ke.namespaceURI === Mn ? lt === "math" : Ke.namespaceURI === Ln ? lt === "math" && ni[qt] : !!zs[lt] : _e.namespaceURI === Mn ? Ke.namespaceURI === Ln && !ni[qt] || Ke.namespaceURI === ko && !Lt[qt] ? !1 : !zs[lt] && (Ol[lt] || !qn[lt]) : !!(_i === "application/xhtml+xml" && os[_e.namespaceURI]) : !1;
    }, br = function(_e) {
      S(me.removed, {
        element: _e
      });
      try {
        Ye(_e).removeChild(_e);
      } catch {
        ze(_e);
      }
    }, Po = function(_e, Ke) {
      try {
        S(me.removed, {
          attribute: Ke.getAttributeNode(_e),
          from: Ke
        });
      } catch {
        S(me.removed, {
          attribute: null,
          from: Ke
        });
      }
      if (Ke.removeAttribute(_e), _e === "is")
        if (jn || Oo)
          try {
            br(Ke);
          } catch {
          }
        else
          try {
            Ke.setAttribute(_e, "");
          } catch {
          }
    }, _a = function(_e) {
      let Ke = null, lt = null;
      if (bi)
        _e = "<remove></remove>" + _e;
      else {
        const Sr = A(_e, /^[\r\n\t ]+/);
        lt = Sr && Sr[0];
      }
      _i === "application/xhtml+xml" && Dn === Mn && (_e = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + _e + "</body></html>");
      const qt = Ze ? Ze.createHTML(_e) : _e;
      if (Dn === Mn)
        try {
          Ke = new Y().parseFromString(qt, _i);
        } catch {
        }
      if (!Ke || !Ke.documentElement) {
        Ke = bt.createDocument(Dn, "template", null);
        try {
          Ke.documentElement.innerHTML = xi ? Ge : qt;
        } catch {
        }
      }
      const wr = Ke.body || Ke.documentElement;
      return _e && lt && wr.insertBefore(Te.createTextNode(lt), wr.childNodes[0] || null), Dn === Mn ? It.call(Ke, ri ? "html" : "body")[0] : ri ? Ke.documentElement : wr;
    }, si = function(_e) {
      return kt.call(
        _e.ownerDocument || _e,
        _e,
        // eslint-disable-next-line no-bitwise
        st.SHOW_ELEMENT | st.SHOW_COMMENT | st.SHOW_TEXT | st.SHOW_PROCESSING_INSTRUCTION | st.SHOW_CDATA_SECTION,
        null
      );
    }, Oi = function(_e) {
      return _e instanceof Vt && (typeof _e.nodeName != "string" || typeof _e.textContent != "string" || typeof _e.removeChild != "function" || !(_e.attributes instanceof at) || typeof _e.removeAttribute != "function" || typeof _e.setAttribute != "function" || typeof _e.namespaceURI != "string" || typeof _e.insertBefore != "function" || typeof _e.hasChildNodes != "function");
    }, To = function(_e) {
      return typeof ct == "function" && _e instanceof ct;
    };
    function ln(ft, _e, Ke) {
      m(ft, (lt) => {
        lt.call(me, _e, Ke, Ei);
      });
    }
    const Al = function(_e) {
      let Ke = null;
      if (ln(er.beforeSanitizeElements, _e, null), Oi(_e))
        return br(_e), !0;
      const lt = mr(_e.nodeName);
      if (ln(er.uponSanitizeElement, _e, {
        tagName: lt,
        allowedTags: cr
      }), _e.hasChildNodes() && !To(_e.firstElementChild) && T(/<[/\w!]/g, _e.innerHTML) && T(/<[/\w!]/g, _e.textContent) || _e.nodeType === re.progressingInstruction || Kt && _e.nodeType === re.comment && T(/<[/\w]/g, _e.data))
        return br(_e), !0;
      if (!cr[lt] || Ls[lt]) {
        if (!Ls[lt] && ki(lt) && (Xt.tagNameCheck instanceof RegExp && T(Xt.tagNameCheck, lt) || Xt.tagNameCheck instanceof Function && Xt.tagNameCheck(lt)))
          return !1;
        if (Mr && !is[lt]) {
          const qt = Ye(_e) || _e.parentNode, wr = rt(_e) || _e.childNodes;
          if (wr && qt) {
            const Sr = wr.length;
            for (let tr = Sr - 1; tr >= 0; --tr) {
              const Ut = Me(wr[tr], !0);
              Ut.__removalCount = (_e.__removalCount || 0) + 1, qt.insertBefore(Ut, He(_e));
            }
          }
        }
        return br(_e), !0;
      }
      return _e instanceof mt && !Ao(_e) || (lt === "noscript" || lt === "noembed" || lt === "noframes") && T(/<\/no(script|embed|frames)/i, _e.innerHTML) ? (br(_e), !0) : (Nn && _e.nodeType === re.text && (Ke = _e.textContent, m([Xi, Ns, Ji], (qt) => {
        Ke = _(Ke, qt, " ");
      }), _e.textContent !== Ke && (S(me.removed, {
        element: _e.cloneNode()
      }), _e.textContent = Ke)), ln(er.afterSanitizeElements, _e, null), !1);
    }, Ea = function(_e, Ke, lt) {
      if (rs && (Ke === "id" || Ke === "name") && (lt in Te || lt in xa))
        return !1;
      if (!(Eo && !Ms[Ke] && T(Kp, Ke))) {
        if (!(es && T(js, Ke))) {
          if (!Ht[Ke] || Ms[Ke]) {
            if (
              // First condition does a very basic check if a) it's basically a valid custom element tagname AND
              // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
              !(ki(_e) && (Xt.tagNameCheck instanceof RegExp && T(Xt.tagNameCheck, _e) || Xt.tagNameCheck instanceof Function && Xt.tagNameCheck(_e)) && (Xt.attributeNameCheck instanceof RegExp && T(Xt.attributeNameCheck, Ke) || Xt.attributeNameCheck instanceof Function && Xt.attributeNameCheck(Ke)) || // Alternative, second condition checks if it's an `is`-attribute, AND
              // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              Ke === "is" && Xt.allowCustomizedBuiltInElements && (Xt.tagNameCheck instanceof RegExp && T(Xt.tagNameCheck, lt) || Xt.tagNameCheck instanceof Function && Xt.tagNameCheck(lt)))
            ) return !1;
          } else if (!ss[Ke]) {
            if (!T(xl, _(lt, Zi, ""))) {
              if (!((Ke === "src" || Ke === "xlink:href" || Ke === "href") && _e !== "script" && O(lt, "data:") === 0 && qs[_e])) {
                if (!(ba && !T(In, _(lt, Zi, "")))) {
                  if (lt)
                    return !1;
                }
              }
            }
          }
        }
      }
      return !0;
    }, ki = function(_e) {
      return _e !== "annotation-xml" && A(_e, ya);
    }, oi = function(_e) {
      ln(er.beforeSanitizeAttributes, _e, null);
      const {
        attributes: Ke
      } = _e;
      if (!Ke || Oi(_e))
        return;
      const lt = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: Ht,
        forceKeepAttr: void 0
      };
      let qt = Ke.length;
      for (; qt--; ) {
        const wr = Ke[qt], {
          name: Sr,
          namespaceURI: tr,
          value: Ut
        } = wr, Ai = mr(Sr);
        let Or = Sr === "value" ? Ut : R(Ut);
        if (lt.attrName = Ai, lt.attrValue = Or, lt.keepAttr = !0, lt.forceKeepAttr = void 0, ln(er.uponSanitizeAttribute, _e, lt), Or = lt.attrValue, Jr && (Ai === "id" || Ai === "name") && (Po(Sr, _e), Or = Ku + Or), Kt && T(/((--!?|])>)|<\/(style|title)/i, Or)) {
          Po(Sr, _e);
          continue;
        }
        if (lt.forceKeepAttr || (Po(Sr, _e), !lt.keepAttr))
          continue;
        if (!_l && T(/\/>/i, Or)) {
          Po(Sr, _e);
          continue;
        }
        Nn && m([Xi, Ns, Ji], (Dt) => {
          Or = _(Or, Dt, " ");
        });
        const Co = mr(_e.nodeName);
        if (Ea(Co, Ai, Or)) {
          if (Ze && typeof Ie == "object" && typeof Ie.getAttributeType == "function" && !tr)
            switch (Ie.getAttributeType(Co, Ai)) {
              case "TrustedHTML": {
                Or = Ze.createHTML(Or);
                break;
              }
              case "TrustedScriptURL": {
                Or = Ze.createScriptURL(Or);
                break;
              }
            }
          try {
            tr ? _e.setAttributeNS(tr, Sr, Or) : _e.setAttribute(Sr, Or), Oi(_e) ? br(_e) : v(me.removed);
          } catch {
          }
        }
      }
      ln(er.afterSanitizeAttributes, _e, null);
    }, as = function ft(_e) {
      let Ke = null;
      const lt = si(_e);
      for (ln(er.beforeSanitizeShadowDOM, _e, null); Ke = lt.nextNode(); )
        ln(er.uponSanitizeShadowNode, Ke, null), Al(Ke), oi(Ke), Ke.content instanceof Fe && ft(Ke.content);
      ln(er.afterSanitizeShadowDOM, _e, null);
    };
    return me.sanitize = function(ft) {
      let _e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Ke = null, lt = null, qt = null, wr = null;
      if (xi = !ft, xi && (ft = "<!-->"), typeof ft != "string" && !To(ft))
        if (typeof ft.toString == "function") {
          if (ft = ft.toString(), typeof ft != "string")
            throw j("dirty is not a string, aborting");
        } else
          throw j("toString is not a function");
      if (!me.isSupported)
        return ft;
      if (Ds || Fn(_e), me.removed = [], typeof ft == "string" && (ns = !1), ns) {
        if (ft.nodeName) {
          const Ut = mr(ft.nodeName);
          if (!cr[Ut] || Ls[Ut])
            throw j("root node is forbidden and cannot be sanitized in-place");
        }
      } else if (ft instanceof ct)
        Ke = _a("<!---->"), lt = Ke.ownerDocument.importNode(ft, !0), lt.nodeType === re.element && lt.nodeName === "BODY" || lt.nodeName === "HTML" ? Ke = lt : Ke.appendChild(lt);
      else {
        if (!jn && !Nn && !ri && // eslint-disable-next-line unicorn/prefer-includes
        ft.indexOf("<") === -1)
          return Ze && ts ? Ze.createHTML(ft) : ft;
        if (Ke = _a(ft), !Ke)
          return jn ? null : ts ? Ge : "";
      }
      Ke && bi && br(Ke.firstChild);
      const Sr = si(ns ? ft : Ke);
      for (; qt = Sr.nextNode(); )
        Al(qt), oi(qt), qt.content instanceof Fe && as(qt.content);
      if (ns)
        return ft;
      if (jn) {
        if (Oo)
          for (wr = Tt.call(Ke.ownerDocument); Ke.firstChild; )
            wr.appendChild(Ke.firstChild);
        else
          wr = Ke;
        return (Ht.shadowroot || Ht.shadowrootmode) && (wr = Xr.call(ke, wr, !0)), wr;
      }
      let tr = ri ? Ke.outerHTML : Ke.innerHTML;
      return ri && cr["!doctype"] && Ke.ownerDocument && Ke.ownerDocument.doctype && Ke.ownerDocument.doctype.name && T(ie, Ke.ownerDocument.doctype.name) && (tr = "<!DOCTYPE " + Ke.ownerDocument.doctype.name + `>
` + tr), Nn && m([Xi, Ns, Ji], (Ut) => {
        tr = _(tr, Ut, " ");
      }), Ze && ts ? Ze.createHTML(tr) : tr;
    }, me.setConfig = function() {
      let ft = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      Fn(ft), Ds = !0;
    }, me.clearConfig = function() {
      Ei = null, Ds = !1;
    }, me.isValidAttribute = function(ft, _e, Ke) {
      Ei || Fn({});
      const lt = mr(ft), qt = mr(_e);
      return Ea(lt, qt, Ke);
    }, me.addHook = function(ft, _e) {
      typeof _e == "function" && S(er[ft], _e);
    }, me.removeHook = function(ft, _e) {
      if (_e !== void 0) {
        const Ke = g(er[ft], _e);
        return Ke === -1 ? void 0 : k(er[ft], Ke, 1)[0];
      }
      return v(er[ft]);
    }, me.removeHooks = function(ft) {
      er[ft] = [];
    }, me.removeAllHooks = function() {
      er = qe();
    }, me;
  }
  var $ = je();
  return Lw = $, Lw;
}
if (!Pt.useState)
  throw new Error("mobx-react-lite requires React with Hooks support");
if (!uC)
  throw new Error("mobx-react-lite@3 requires mobx at least version 6 to be available");
function v4(e) {
  e();
}
function M$(e) {
  e || (e = v4), ZT({ reactionScheduler: e });
}
function b4(e) {
  return eC(e);
}
var D$ = !1;
function F$(e) {
  D$ = e;
}
function Ip() {
  return D$;
}
var w4 = 1e4, S4 = 1e4, x4 = (
  /** @class */
  function() {
    function e(t) {
      var r = this;
      Object.defineProperty(this, "finalize", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
      }), Object.defineProperty(this, "registrations", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /* @__PURE__ */ new Map()
      }), Object.defineProperty(this, "sweepTimeout", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "sweep", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: function(n) {
          n === void 0 && (n = w4), clearTimeout(r.sweepTimeout), r.sweepTimeout = void 0;
          var o = Date.now();
          r.registrations.forEach(function(a, i) {
            o - a.registeredAt >= n && (r.finalize(a.value), r.registrations.delete(i));
          }), r.registrations.size > 0 && r.scheduleSweep();
        }
      }), Object.defineProperty(this, "finalizeAllImmediately", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: function() {
          r.sweep(0);
        }
      });
    }
    return Object.defineProperty(e.prototype, "register", {
      enumerable: !1,
      configurable: !0,
      writable: !0,
      value: function(t, r, n) {
        this.registrations.set(n, {
          value: r,
          registeredAt: Date.now()
        }), this.scheduleSweep();
      }
    }), Object.defineProperty(e.prototype, "unregister", {
      enumerable: !1,
      configurable: !0,
      writable: !0,
      value: function(t) {
        this.registrations.delete(t);
      }
    }), Object.defineProperty(e.prototype, "scheduleSweep", {
      enumerable: !1,
      configurable: !0,
      writable: !0,
      value: function() {
        this.sweepTimeout === void 0 && (this.sweepTimeout = setTimeout(this.sweep, S4));
      }
    }), e;
  }()
), _4 = typeof FinalizationRegistry < "u" ? FinalizationRegistry : x4, uh = new _4(function(e) {
  var t;
  (t = e.reaction) === null || t === void 0 || t.dispose(), e.reaction = null;
}), Mw = { exports: {} }, Dw = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var OA;
function E4() {
  if (OA) return Dw;
  OA = 1;
  var e = ch();
  function t(g, v) {
    return g === v && (g !== 0 || 1 / g === 1 / v) || g !== g && v !== v;
  }
  var r = typeof Object.is == "function" ? Object.is : t, n = e.useState, o = e.useEffect, a = e.useLayoutEffect, i = e.useDebugValue;
  function u(g, v) {
    var S = v(), k = n({ inst: { value: S, getSnapshot: v } }), b = k[0].inst, x = k[1];
    return a(
      function() {
        b.value = S, b.getSnapshot = v, c(b) && x({ inst: b });
      },
      [g, S, v]
    ), o(
      function() {
        return c(b) && x({ inst: b }), g(function() {
          c(b) && x({ inst: b });
        });
      },
      [g]
    ), i(S), S;
  }
  function c(g) {
    var v = g.getSnapshot;
    g = g.value;
    try {
      var S = v();
      return !r(g, S);
    } catch {
      return !0;
    }
  }
  function d(g, v) {
    return v();
  }
  var m = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? d : u;
  return Dw.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : m, Dw;
}
var kA;
function O4() {
  return kA || (kA = 1, Mw.exports = E4()), Mw.exports;
}
var k4 = O4();
function AA(e) {
  e.reaction = new Yi("observer".concat(e.name), function() {
    var t;
    e.stateVersion = Symbol(), (t = e.onStoreChange) === null || t === void 0 || t.call(e);
  });
}
function Lx(e, t) {
  if (t === void 0 && (t = "observed"), Ip())
    return e();
  var r = Rt.useRef(null);
  if (!r.current) {
    var n = {
      reaction: null,
      onStoreChange: null,
      stateVersion: Symbol(),
      name: t,
      subscribe: function(u) {
        return uh.unregister(n), n.onStoreChange = u, n.reaction || (AA(n), n.stateVersion = Symbol()), function() {
          var c;
          n.onStoreChange = null, (c = n.reaction) === null || c === void 0 || c.dispose(), n.reaction = null;
        };
      },
      getSnapshot: function() {
        return n.stateVersion;
      }
    };
    r.current = n;
  }
  var o = r.current;
  o.reaction || (AA(o), uh.register(r, o, o)), Rt.useDebugValue(o.reaction, b4), k4.useSyncExternalStore(
    // Both of these must be stable, otherwise it would keep resubscribing every render.
    o.subscribe,
    o.getSnapshot,
    o.getSnapshot
  );
  var a, i;
  if (o.reaction.track(function() {
    try {
      a = e();
    } catch (u) {
      i = u;
    }
  }), i)
    throw i;
  return a;
}
var Fw, qw, q$ = typeof Symbol == "function" && Symbol.for, A4 = (qw = (Fw = Object.getOwnPropertyDescriptor(function() {
}, "name")) === null || Fw === void 0 ? void 0 : Fw.configurable) !== null && qw !== void 0 ? qw : !1, PA = q$ ? Symbol.for("react.forward_ref") : typeof Pt.forwardRef == "function" && Pt.forwardRef(function(e) {
  return null;
}).$$typeof, TA = q$ ? Symbol.for("react.memo") : typeof Pt.memo == "function" && Pt.memo(function(e) {
  return null;
}).$$typeof;
function P4(e, t) {
  var r;
  if (TA && e.$$typeof === TA)
    throw new Error("[mobx-react-lite] You are trying to use `observer` on a function component wrapped in either another `observer` or `React.memo`. The observer already applies 'React.memo' for you.");
  if (Ip())
    return e;
  var n = (r = void 0) !== null && r !== void 0 ? r : !1, o = e, a = e.displayName || e.name;
  if (PA && e.$$typeof === PA && (n = !0, o = e.render, typeof o != "function"))
    throw new Error("[mobx-react-lite] `render` property of ForwardRef was not a function");
  var i = function(u, c) {
    return Lx(function() {
      return o(u, c);
    }, a);
  };
  return i.displayName = e.displayName, A4 && Object.defineProperty(i, "name", {
    value: e.name,
    writable: !0,
    configurable: !0
  }), e.contextTypes && (i.contextTypes = e.contextTypes), n && (i = Pt.forwardRef(i)), i = Pt.memo(i), C4(e, i), i;
}
var T4 = {
  $$typeof: !0,
  render: !0,
  compare: !0,
  type: !0,
  // Don't redefine `displayName`,
  // it's defined as getter-setter pair on `memo` (see #3192).
  displayName: !0
};
function C4(e, t) {
  Object.keys(e).forEach(function(r) {
    T4[r] || Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(e, r));
  });
}
function z$(e) {
  var t = e.children, r = e.render;
  t && r && console.error("MobX Observer: Do not use children and render in the same time in `Observer`");
  var n = t || r;
  return typeof n != "function" ? null : Lx(n);
}
z$.displayName = "Observer";
function $4(e, t) {
  return Pt.useState(function() {
    return Er(e(), t, { autoBind: !0 });
  })[0];
}
function B$(e) {
  var t = Pt.useState(function() {
    return Er(e, {}, { deep: !1 });
  })[0];
  return wS(function() {
    Object.assign(t, e);
  }), t;
}
function R4(e, t) {
  var r = t && B$(t);
  return Pt.useState(function() {
    return Er(e(r), void 0, { autoBind: !0 });
  })[0];
}
var zw;
M$(zA.unstable_batchedUpdates);
zw = uh.finalizeAllImmediately;
function I4(e, t) {
  return t === void 0 && (t = "observed"), Lx(e, t);
}
function N4(e) {
  F$(e);
}
function j4(e, t) {
  if (CA(e, t))
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  var r = Object.keys(e), n = Object.keys(t);
  if (r.length !== n.length)
    return !1;
  for (var o = 0; o < r.length; o++)
    if (!Object.hasOwnProperty.call(t, r[o]) || !CA(e[r[o]], t[r[o]]))
      return !1;
  return !0;
}
function CA(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
var L4 = {
  $$typeof: 1,
  render: 1,
  compare: 1,
  type: 1,
  childContextTypes: 1,
  contextType: 1,
  contextTypes: 1,
  defaultProps: 1,
  getDefaultProps: 1,
  getDerivedStateFromError: 1,
  getDerivedStateFromProps: 1,
  mixins: 1,
  displayName: 1,
  propTypes: 1
};
function M4(e, t) {
  var r = Object.getOwnPropertyNames(Object.getPrototypeOf(e));
  Object.getOwnPropertyNames(e).forEach(function(n) {
    !L4[n] && r.indexOf(n) === -1 && Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(e, n));
  });
}
var $A = /* @__PURE__ */ Symbol("patchMixins"), U$ = /* @__PURE__ */ Symbol("patchedDefinition");
function D4(e, t) {
  var r = e[$A] = e[$A] || {}, n = r[t] = r[t] || {};
  return n.locks = n.locks || 0, n.methods = n.methods || [], n;
}
function RA(e, t) {
  for (var r = this, n = arguments.length, o = new Array(n > 2 ? n - 2 : 0), a = 2; a < n; a++)
    o[a - 2] = arguments[a];
  t.locks++;
  try {
    var i;
    return e != null && (i = e.apply(this, o)), i;
  } finally {
    t.locks--, t.locks === 0 && t.methods.forEach(function(u) {
      u.apply(r, o);
    });
  }
}
function IA(e, t) {
  var r = function() {
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    RA.call.apply(RA, [this, e, t].concat(a));
  };
  return r;
}
function V$(e, t, r) {
  var n = D4(e, t);
  n.methods.indexOf(r) < 0 && n.methods.push(r);
  var o = Object.getOwnPropertyDescriptor(e, t);
  if (!(o && o[U$])) {
    var a = e[t], i = H$(e, t, o ? o.enumerable : void 0, n, a);
    Object.defineProperty(e, t, i);
  }
}
function H$(e, t, r, n, o) {
  var a, i = IA(o, n);
  return a = {}, a[U$] = !0, a.get = function() {
    return i;
  }, a.set = function(c) {
    if (this === e)
      i = IA(c, n);
    else {
      var d = H$(this, t, r, n, c);
      Object.defineProperty(this, t, d);
    }
  }, a.configurable = !0, a.enumerable = r, a;
}
var NA = /* @__PURE__ */ Symbol("ObserverAdministration"), jA = /* @__PURE__ */ Symbol("isMobXReactObserver");
function RS(e) {
  var t;
  return (t = e[NA]) != null ? t : e[NA] = {
    reaction: null,
    mounted: !1,
    reactionInvalidatedBeforeMount: !1,
    forceUpdate: null,
    name: IS(e.constructor),
    state: void 0,
    props: void 0,
    context: void 0
  };
}
function F4(e) {
  var t = e.prototype;
  if (e[jA]) {
    var r = IS(e);
    throw new Error("The provided component class (" + r + ") has already been declared as an observer component.");
  } else
    e[jA] = !0;
  if (t.componentWillReact)
    throw new Error("The componentWillReact life-cycle event is no longer supported");
  if (e.__proto__ !== Pt.PureComponent) {
    if (!t.shouldComponentUpdate)
      t.shouldComponentUpdate = LA;
    else if (t.shouldComponentUpdate !== LA)
      throw new Error("It is not allowed to use shouldComponentUpdate in observer based components.");
  }
  var n = t.render;
  if (typeof n != "function") {
    var o = IS(e);
    throw new Error("[mobx-react] class component (" + o + ") is missing `render` method.\n`observer` requires `render` being a function defined on prototype.\n`render = () => {}` or `render = function() {}` is not supported.");
  }
  t.render = function() {
    return Object.defineProperty(this, "render", {
      // There is no safe way to replace render, therefore it's forbidden.
      configurable: !1,
      writable: !1,
      value: Ip() ? n : q4.call(this, n)
    }), this.render();
  };
  var a = t.componentDidMount;
  return t.componentDidMount = function() {
    var i = this, u = RS(this);
    return u.mounted = !0, uh.unregister(this), u.forceUpdate = function() {
      return i.forceUpdate();
    }, (!u.reaction || u.reactionInvalidatedBeforeMount) && u.forceUpdate(), a == null ? void 0 : a.apply(this, arguments);
  }, V$(t, "componentWillUnmount", function() {
    var i;
    if (!Ip()) {
      var u = RS(this);
      (i = u.reaction) == null || i.dispose(), u.reaction = null, u.forceUpdate = null, u.mounted = !1, u.reactionInvalidatedBeforeMount = !1;
    }
  }), e;
}
function IS(e) {
  return e.displayName || e.name || "<component>";
}
function q4(e) {
  var t = e.bind(this), r = RS(this);
  function n() {
    r.reaction || (r.reaction = z4(r), r.mounted || uh.register(this, r, this));
    var o = void 0, a = void 0;
    if (r.reaction.track(function() {
      try {
        a = Jv(!1, t);
      } catch (i) {
        o = i;
      }
    }), o)
      throw o;
    return a;
  }
  return n;
}
function z4(e) {
  return new Yi(e.name + ".render()", function() {
    if (!e.mounted) {
      e.reactionInvalidatedBeforeMount = !0;
      return;
    }
    try {
      e.forceUpdate == null || e.forceUpdate();
    } catch {
      var t;
      (t = e.reaction) == null || t.dispose(), e.reaction = null;
    }
  });
}
function LA(e, t) {
  return Ip() && console.warn("[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side."), this.state !== t ? !0 : !j4(this.props, e);
}
function W$(e, t) {
  if (t && t.kind !== "class")
    throw new Error("The @observer decorator can be used on classes only");
  return e.isMobxInjector === !0 && console.warn("Mobx observer: You are trying to use `observer` on a component that already has `inject`. Please apply `observer` before applying `inject`"), Object.prototype.isPrototypeOf.call(Pt.Component, e) || Object.prototype.isPrototypeOf.call(Pt.PureComponent, e) ? F4(e) : P4(e);
}
function Ev() {
  return Ev = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r) ({}).hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Ev.apply(null, arguments);
}
function B4(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e) if ({}.hasOwnProperty.call(e, n)) {
    if (t.indexOf(n) >= 0) continue;
    r[n] = e[n];
  }
  return r;
}
var U4 = ["children"], Ov = /* @__PURE__ */ Rt.createContext({});
function K$(e) {
  var t = e.children, r = B4(e, U4), n = Rt.useContext(Ov), o = Rt.useRef(Ev({}, n, r)), a = o.current;
  return Rt.createElement(Ov.Provider, {
    value: a
  }, t);
}
K$.displayName = "MobXProvider";
function MA(e, t, r, n) {
  var o = Rt.forwardRef(function(a, i) {
    var u = Ev({}, a), c = Rt.useContext(Ov);
    return Object.assign(u, e(c || {}, u) || {}), i && (u.ref = i), Rt.createElement(t, u);
  });
  return n && (o = W$(o)), o.isMobxInjector = !0, M4(t, o), o.wrappedComponent = t, o.displayName = V4(t, r), o;
}
function V4(e, t) {
  var r, n = e.displayName || e.name || e.constructor && e.constructor.name || "Component";
  return t ? r = "inject-with-" + t + "(" + n + ")" : r = "inject(" + n + ")", r;
}
function H4(e) {
  return function(t, r) {
    return e.forEach(function(n) {
      if (!(n in r)) {
        if (!(n in t)) throw new Error("MobX injector: Store '" + n + "' is not available! Make sure it is provided by some Provider");
        r[n] = t[n];
      }
    }), r;
  };
}
function W4() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  if (typeof arguments[0] == "function") {
    var n = arguments[0];
    return function(o) {
      return MA(n, o, n.name, !0);
    };
  } else
    return function(o) {
      return MA(H4(t), o, t.join("-"), !1);
    };
}
var K4 = /* @__PURE__ */ Number.parseInt(Rt.version.split(".")[0]), DA = !1, Ky = /* @__PURE__ */ Symbol("disposeOnUnmountProto"), Qy = /* @__PURE__ */ Symbol("disposeOnUnmountInst");
function Q4() {
  var e = this;
  [].concat(this[Ky] || [], this[Qy] || []).forEach(function(t) {
    var r = typeof t == "string" ? e[t] : t;
    r != null && (Array.isArray(r) ? r.map(function(n) {
      return n();
    }) : r());
  });
}
function Q$(e, t) {
  if (Array.isArray(t))
    return t.map(function(c) {
      return Q$(e, c);
    });
  DA || (K4 >= 18 ? console.error("[mobx-react] disposeOnUnmount is not compatible with React 18 and higher. Don't use it.") : console.warn("[mobx-react] disposeOnUnmount is deprecated. It won't work correctly with React 18 and higher."), DA = !0);
  var r = Object.getPrototypeOf(e).constructor, n = Object.getPrototypeOf(e.constructor), o = Object.getPrototypeOf(Object.getPrototypeOf(e));
  if (!(r === Rt.Component || r === Rt.PureComponent || n === Rt.Component || n === Rt.PureComponent || o === Rt.Component || o === Rt.PureComponent))
    throw new Error("[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent.");
  if (typeof t != "string" && typeof t != "function" && !Array.isArray(t))
    throw new Error("[mobx-react] disposeOnUnmount only works if the parameter is either a property key or a function.");
  var a = typeof t == "string", i = !!e[Ky] || !!e[Qy], u = a ? (
    // decorators are added to the prototype store
    e[Ky] || (e[Ky] = [])
  ) : (
    // functions are added to the instance store
    e[Qy] || (e[Qy] = [])
  );
  if (u.push(t), i || V$(e, "componentWillUnmount", Q4), typeof t != "string")
    return t;
}
function Y$(e) {
  function t(n, o, a, i, u, c) {
    for (var d = arguments.length, m = new Array(d > 6 ? d - 6 : 0), g = 6; g < d; g++)
      m[g - 6] = arguments[g];
    return Bp(function() {
      if (i = i || "<<anonymous>>", c = c || a, o[a] == null) {
        if (n) {
          var v = o[a] === null ? "null" : "undefined";
          return new Error("The " + u + " `" + c + "` is marked as required in `" + i + "`, but its value is `" + v + "`.");
        }
        return null;
      } else
        return e.apply(void 0, [o, a, i, u, c].concat(m));
    });
  }
  var r = t.bind(null, !1);
  return r.isRequired = t.bind(null, !0), r;
}
function Y4(e, t) {
  return e === "symbol" || t["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && t instanceof Symbol;
}
function G$(e) {
  var t = typeof e;
  return Array.isArray(e) ? "array" : e instanceof RegExp ? "object" : Y4(t, e) ? "symbol" : t;
}
function G4(e) {
  var t = G$(e);
  if (t === "object") {
    if (e instanceof Date)
      return "date";
    if (e instanceof RegExp)
      return "regexp";
  }
  return t;
}
function Wp(e, t) {
  return Y$(function(r, n, o, a, i) {
    return Bp(function() {
      if (e && G$(r[n]) === t.toLowerCase())
        return null;
      var u;
      switch (t) {
        case "Array":
          u = $n;
          break;
        case "Object":
          u = Yr;
          break;
        case "Map":
          u = Gr;
          break;
        default:
          throw new Error("Unexpected mobxType: " + t);
      }
      var c = r[n];
      if (!u(c)) {
        var d = G4(c), m = e ? " or javascript `" + t.toLowerCase() + "`" : "";
        return new Error("Invalid prop `" + i + "` of type `" + d + "` supplied to `" + o + "`, expected `mobx.Observable" + t + "`" + m + ".");
      }
      return null;
    });
  });
}
function X$(e, t) {
  return Y$(function(r, n, o, a, i) {
    for (var u = arguments.length, c = new Array(u > 5 ? u - 5 : 0), d = 5; d < u; d++)
      c[d - 5] = arguments[d];
    return Bp(function() {
      if (typeof t != "function")
        return new Error("Property `" + i + "` of component `" + o + "` has invalid PropType notation.");
      var m = Wp(e, "Array")(r, n, o, a, i);
      if (m instanceof Error) return m;
      for (var g = r[n], v = 0; v < g.length; v++)
        if (m = t.apply(void 0, [g, v, o, a, i + "[" + v + "]"].concat(c)), m instanceof Error) return m;
      return null;
    });
  });
}
var X4 = /* @__PURE__ */ Wp(!1, "Array"), J4 = /* @__PURE__ */ X$.bind(null, !1), Z4 = /* @__PURE__ */ Wp(!1, "Map"), eV = /* @__PURE__ */ Wp(!1, "Object"), tV = /* @__PURE__ */ Wp(!0, "Array"), rV = /* @__PURE__ */ X$.bind(null, !0), nV = /* @__PURE__ */ Wp(!0, "Object"), iV = {
  observableArray: X4,
  observableArrayOf: J4,
  observableMap: Z4,
  observableObject: eV,
  arrayOrObservableArray: tV,
  arrayOrObservableArrayOf: rV,
  objectOrObservableObject: nV
};
if (!Pt.Component)
  throw new Error("mobx-react requires React to be available");
if (!Er)
  throw new Error("mobx-react requires mobx to be available");
const sV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MobXProviderContext: Ov,
  Observer: z$,
  PropTypes: iV,
  Provider: K$,
  disposeOnUnmount: Q$,
  enableStaticRendering: F$,
  inject: W4,
  isUsingStaticRendering: Ip,
  observer: W$,
  observerBatching: M$,
  useAsObservableSource: B$,
  useLocalObservable: $4,
  useLocalStore: R4,
  useObserver: I4,
  useStaticRendering: N4
}, Symbol.toStringTag, { value: "Module" })), oV = /* @__PURE__ */ _o(sV);
var Bw = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
var FA;
function aV() {
  return FA || (FA = 1, function(e) {
    (function() {
      var t = {}.hasOwnProperty;
      function r() {
        for (var a = "", i = 0; i < arguments.length; i++) {
          var u = arguments[i];
          u && (a = o(a, n(u)));
        }
        return a;
      }
      function n(a) {
        if (typeof a == "string" || typeof a == "number")
          return a;
        if (typeof a != "object")
          return "";
        if (Array.isArray(a))
          return r.apply(null, a);
        if (a.toString !== Object.prototype.toString && !a.toString.toString().includes("[native code]"))
          return a.toString();
        var i = "";
        for (var u in a)
          t.call(a, u) && a[u] && (i = o(i, u));
        return i;
      }
      function o(a, i) {
        return i ? a ? a + " " + i : a + i : a;
      }
      e.exports ? (r.default = r, e.exports = r) : window.classNames = r;
    })();
  }(Bw)), Bw.exports;
}
/*! For license information please see redoc.browser.lib.js.LICENSE.txt */
var lV = Ty.exports, qA;
function uV() {
  return qA || (qA = 1, function(e, t) {
    (function(r, n) {
      e.exports = n();
    })(lV, function() {
      return function() {
        var r = { 997: function(i, u, c) {
          var d = c(991), m = c.n(d), g = c(314), v = c.n(g)()(m());
          v.push([i.id, `.ps{overflow:hidden!important;overflow-anchor:none;-ms-overflow-style:none;touch-action:auto;-ms-touch-action:auto}.ps__rail-x{display:none;opacity:0;transition:background-color .2s linear,opacity .2s linear;-webkit-transition:background-color .2s linear,opacity .2s linear;height:15px;bottom:0;position:absolute}.ps__rail-y{display:none;opacity:0;transition:background-color .2s linear,opacity .2s linear;-webkit-transition:background-color .2s linear,opacity .2s linear;width:15px;right:0;position:absolute}.ps--active-x>.ps__rail-x,.ps--active-y>.ps__rail-y{display:block;background-color:transparent}.ps:hover>.ps__rail-x,.ps:hover>.ps__rail-y,.ps--focus>.ps__rail-x,.ps--focus>.ps__rail-y,.ps--scrolling-x>.ps__rail-x,.ps--scrolling-y>.ps__rail-y{opacity:.6}.ps .ps__rail-x:hover,.ps .ps__rail-y:hover,.ps .ps__rail-x:focus,.ps .ps__rail-y:focus,.ps .ps__rail-x.ps--clicking,.ps .ps__rail-y.ps--clicking{background-color:#eee;opacity:.9}.ps__thumb-x{background-color:#aaa;border-radius:6px;transition:background-color .2s linear,height .2s ease-in-out;-webkit-transition:background-color .2s linear,height .2s ease-in-out;height:6px;bottom:2px;position:absolute}.ps__thumb-y{background-color:#aaa;border-radius:6px;transition:background-color .2s linear,width .2s ease-in-out;-webkit-transition:background-color .2s linear,width .2s ease-in-out;width:6px;right:2px;position:absolute}.ps__rail-x:hover>.ps__thumb-x,.ps__rail-x:focus>.ps__thumb-x,.ps__rail-x.ps--clicking .ps__thumb-x{background-color:#999;height:11px}.ps__rail-y:hover>.ps__thumb-y,.ps__rail-y:focus>.ps__thumb-y,.ps__rail-y.ps--clicking .ps__thumb-y{background-color:#999;width:11px}@supports (-ms-overflow-style: none){.ps{overflow:auto!important}}@media screen and (-ms-high-contrast: active),(-ms-high-contrast: none){.ps{overflow:auto!important}}
`, "", { version: 3, sources: ["webpack://./node_modules/perfect-scrollbar/css/perfect-scrollbar.css"], names: [], mappings: "AAGA,IACE,yBAAU,CACV,oBAAiB,CACjB,uBAAoB,CACpB,iBAAc,CACd,qBACF,CAKA,YACE,YAAS,CACT,SAAS,CACT,yDAAqD,CACrD,iEAA6D,CAC7D,WAAQ,CAER,QAAQ,CAER,iBACF,CAEA,YACE,YAAS,CACT,SAAS,CACT,yDAAqD,CACrD,iEAA6D,CAC7D,UAAO,CAEP,OAAO,CAEP,iBACF,CAEA,oDAEE,aAAS,CACT,4BACF,CAEA,oJAME,UACF,CAEA,kJAME,qBAAkB,CAClB,UACF,CAKA,aACE,qBAAkB,CAnEpB,iBAoEiB,CACf,6DAAoD,CACpD,qEAA4D,CAC5D,UAAQ,CAER,UAAQ,CAER,iBACF,CAEA,aACE,qBAAkB,CA/EpB,iBAgFiB,CACf,4DAAmD,CACnD,oEAA2D,CAC3D,SAAO,CAEP,SAAO,CAEP,iBACF,CAEA,oGAGE,qBAAkB,CAClB,WACF,CAEA,oGAGE,qBAAkB,CAClB,UACF,CAGA,qCACE,IACE,uBACF,CACF,CAEA,wEACE,IACE,uBACF,CACF", sourcesContent: [`/*
 * Container style
 */
.ps {
  overflow: hidden !important;
  overflow-anchor: none;
  -ms-overflow-style: none;
  touch-action: auto;
  -ms-touch-action: auto;
}

/*
 * Scrollbar rail styles
 */
.ps__rail-x {
  display: none;
  opacity: 0;
  transition: background-color .2s linear, opacity .2s linear;
  -webkit-transition: background-color .2s linear, opacity .2s linear;
  height: 15px;
  /* there must be 'bottom' or 'top' for ps__rail-x */
  bottom: 0px;
  /* please don't change 'position' */
  position: absolute;
}

.ps__rail-y {
  display: none;
  opacity: 0;
  transition: background-color .2s linear, opacity .2s linear;
  -webkit-transition: background-color .2s linear, opacity .2s linear;
  width: 15px;
  /* there must be 'right' or 'left' for ps__rail-y */
  right: 0;
  /* please don't change 'position' */
  position: absolute;
}

.ps--active-x > .ps__rail-x,
.ps--active-y > .ps__rail-y {
  display: block;
  background-color: transparent;
}

.ps:hover > .ps__rail-x,
.ps:hover > .ps__rail-y,
.ps--focus > .ps__rail-x,
.ps--focus > .ps__rail-y,
.ps--scrolling-x > .ps__rail-x,
.ps--scrolling-y > .ps__rail-y {
  opacity: 0.6;
}

.ps .ps__rail-x:hover,
.ps .ps__rail-y:hover,
.ps .ps__rail-x:focus,
.ps .ps__rail-y:focus,
.ps .ps__rail-x.ps--clicking,
.ps .ps__rail-y.ps--clicking {
  background-color: #eee;
  opacity: 0.9;
}

/*
 * Scrollbar thumb styles
 */
.ps__thumb-x {
  background-color: #aaa;
  border-radius: 6px;
  transition: background-color .2s linear, height .2s ease-in-out;
  -webkit-transition: background-color .2s linear, height .2s ease-in-out;
  height: 6px;
  /* there must be 'bottom' for ps__thumb-x */
  bottom: 2px;
  /* please don't change 'position' */
  position: absolute;
}

.ps__thumb-y {
  background-color: #aaa;
  border-radius: 6px;
  transition: background-color .2s linear, width .2s ease-in-out;
  -webkit-transition: background-color .2s linear, width .2s ease-in-out;
  width: 6px;
  /* there must be 'right' for ps__thumb-y */
  right: 2px;
  /* please don't change 'position' */
  position: absolute;
}

.ps__rail-x:hover > .ps__thumb-x,
.ps__rail-x:focus > .ps__thumb-x,
.ps__rail-x.ps--clicking .ps__thumb-x {
  background-color: #999;
  height: 11px;
}

.ps__rail-y:hover > .ps__thumb-y,
.ps__rail-y:focus > .ps__thumb-y,
.ps__rail-y.ps--clicking .ps__thumb-y {
  background-color: #999;
  width: 11px;
}

/* MS supports */
@supports (-ms-overflow-style: none) {
  .ps {
    overflow: auto !important;
  }
}

@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {
  .ps {
    overflow: auto !important;
  }
}
`], sourceRoot: "" }]), u.A = v;
        }, 314: function(i) {
          i.exports = function(u) {
            var c = [];
            return c.toString = function() {
              return this.map(function(d) {
                var m = u(d);
                return d[2] ? "@media ".concat(d[2], " {").concat(m, "}") : m;
              }).join("");
            }, c.i = function(d, m, g) {
              typeof d == "string" && (d = [[null, d, ""]]);
              var v = {};
              if (g) for (var S = 0; S < this.length; S++) {
                var k = this[S][0];
                k != null && (v[k] = !0);
              }
              for (var b = 0; b < d.length; b++) {
                var x = [].concat(d[b]);
                g && v[x[0]] || (m && (x[2] ? x[2] = "".concat(m, " and ").concat(x[2]) : x[2] = m), c.push(x));
              }
            }, c;
          };
        }, 991: function(i) {
          function u(c, d) {
            (d == null || d > c.length) && (d = c.length);
            for (var m = 0, g = new Array(d); m < d; m++) g[m] = c[m];
            return g;
          }
          i.exports = function(c) {
            var d, m, g = (m = 4, function(_) {
              if (Array.isArray(_)) return _;
            }(d = c) || function(_, O) {
              var R = _ && (typeof Symbol < "u" && _[Symbol.iterator] || _["@@iterator"]);
              if (R != null) {
                var C, T, j = [], D = !0, V = !1;
                try {
                  for (R = R.call(_); !(D = (C = R.next()).done) && (j.push(C.value), !O || j.length !== O); D = !0) ;
                } catch (U) {
                  V = !0, T = U;
                } finally {
                  try {
                    D || R.return == null || R.return();
                  } finally {
                    if (V) throw T;
                  }
                }
                return j;
              }
            }(d, m) || function(_, O) {
              if (_) {
                if (typeof _ == "string") return u(_, O);
                var R = Object.prototype.toString.call(_).slice(8, -1);
                return R === "Object" && _.constructor && (R = _.constructor.name), R === "Map" || R === "Set" ? Array.from(_) : R === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(R) ? u(_, O) : void 0;
              }
            }(d, m) || function() {
              throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }()), v = g[1], S = g[3];
            if (typeof btoa == "function") {
              var k = btoa(unescape(encodeURIComponent(JSON.stringify(S)))), b = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(k), x = "/*# ".concat(b, " */"), A = S.sources.map(function(_) {
                return "/*# sourceURL=".concat(S.sourceRoot || "").concat(_, " */");
              });
              return [v].concat(A).concat([x]).join(`
`);
            }
            return [v].join(`
`);
          };
        }, 364: function(i) {
          i.exports = {};
        }, 353: function(i, u, c) {
          c.d(u, { Ay: function() {
            return g;
          } });
          var d = VR(), m = (V, U, ne) => new Promise((H, ae) => {
            var ge = ($e) => {
              try {
                ve(ne.next($e));
              } catch (ce) {
                ae(ce);
              }
            }, fe = ($e) => {
              try {
                ve(ne.throw($e));
              } catch (ce) {
                ae(ce);
              }
            }, ve = ($e) => $e.done ? H($e.value) : Promise.resolve($e.value).then(ge, fe);
            ve((ne = ne.apply(V, U)).next());
          });
          class g {
            constructor() {
              this.add = _, this.done = O, this.search = D, this.toJS = R, this.load = T, this.dispose = j, this.fromExternalJS = C;
            }
          }
          let v, S, k, b = [];
          function x() {
            v = new d.Builder(), v.field("title"), v.field("description"), v.ref("ref"), v.pipeline.add(d.trimmer, d.stopWordFilter, d.stemmer), k = new Promise((V) => {
              S = V;
            });
          }
          d.tokenizer.separator = /\s+/, x();
          const A = (V) => {
            const U = d.trimmer(new d.Token(V, {}));
            return "*" + d.stemmer(U) + "*";
          };
          function _(V, U, ne) {
            const H = b.push(ne) - 1, ae = { title: V.toLowerCase(), description: U.toLowerCase(), ref: H };
            v.add(ae);
          }
          function O() {
            return m(this, null, function* () {
              S(v.build());
            });
          }
          function R() {
            return m(this, null, function* () {
              return { store: b, index: (yield k).toJSON() };
            });
          }
          function C(V, U) {
            return m(this, null, function* () {
              try {
                if (importScripts(V), !self[U]) throw new Error("Broken index file format");
                T(self[U]);
              } catch (ne) {
                console.error("Failed to load search index: " + ne.message);
              }
            });
          }
          function T(V) {
            return m(this, null, function* () {
              b = V.store, S(d.Index.load(V.index));
            });
          }
          function j() {
            return m(this, null, function* () {
              b = [], x();
            });
          }
          function D(V, U = 0) {
            return m(this, null, function* () {
              if (V.trim().length === 0) return [];
              let ne = (yield k).query((H) => {
                V.trim().toLowerCase().split(/\s+/).forEach((ae) => {
                  if (ae.length === 1) return;
                  const ge = A(ae);
                  H.term(ge, {});
                });
              });
              return U > 0 && (ne = ne.slice(0, U)), ne.map((H) => ({ meta: b[H.ref], score: H.score }));
            });
          }
        }, 435: function(i, u, c) {
          const d = c(648), m = {}.NODE_DISABLE_COLORS ? { red: "", yellow: "", green: "", normal: "" } : { red: "\x1B[31m", yellow: "\x1B[33;1m", green: "\x1B[32m", normal: "\x1B[0m" };
          function g(S, k) {
            function b(x, A) {
              return d.stringify(x) === d.stringify(Object.assign({}, x, A));
            }
            return b(S, k) && b(k, S);
          }
          function v(S) {
            let k = (S = S.replace("[]", "Array")).split("/");
            return k[0] = k[0].replace(/[^A-Za-z0-9_\-\.]+|\s+/gm, "_"), k.join("/");
          }
          String.prototype.toCamelCase = function() {
            return this.toLowerCase().replace(/[-_ \/\.](.)/g, function(S, k) {
              return k.toUpperCase();
            });
          }, i.exports = { colour: m, uniqueOnly: function(S, k, b) {
            return b.indexOf(S) === k;
          }, hasDuplicates: function(S) {
            return new Set(S).size !== S.length;
          }, allSame: function(S) {
            return new Set(S).size <= 1;
          }, distinctArray: function(S) {
            return S.length === function(k) {
              let b = [];
              for (let x of k) b.find(function(A, _, O) {
                return g(A, x);
              }) || b.push(x);
              return b;
            }(S).length;
          }, firstDupe: function(S) {
            return S.find(function(k, b, x) {
              return S.indexOf(k) < b;
            });
          }, hash: function(S) {
            let k, b = 0;
            if (S.length === 0) return b;
            for (let x = 0; x < S.length; x++) k = S.charCodeAt(x), b = (b << 5) - b + k, b |= 0;
            return b;
          }, parameterTypeProperties: ["format", "minimum", "maximum", "exclusiveMinimum", "exclusiveMaximum", "minLength", "maxLength", "multipleOf", "minItems", "maxItems", "uniqueItems", "minProperties", "maxProperties", "additionalProperties", "pattern", "enum", "default"], arrayProperties: ["items", "minItems", "maxItems", "uniqueItems"], httpMethods: ["get", "post", "put", "delete", "patch", "head", "options", "trace"], sanitise: v, sanitiseAll: function(S) {
            return v(S.split("/").join("_"));
          } };
        }, 751: function(i, u, c) {
          const d = c(364), m = c(975), g = c(725), v = c(725), S = c(115), k = c(33).jptr, b = c(880).recurse, x = c(920).clone, A = c(737).dereference, _ = c(264).isRef, O = c(435);
          function R(U, ne, H, ae, ge, fe) {
            let ve = fe.externalRefs[H + ae].paths[0], $e = g.parse(ge), ce = {}, se = 1;
            for (; se; ) se = 0, b(U, { identityDetection: !0 }, function(te, F, J) {
              if (_(te, F)) {
                if (te[F].startsWith("#")) if (ce[te[F]] || te.$fixed) {
                  if (!te.$fixed) {
                    let W = (ve + "/" + ce[te[F]]).split("/#/").join("/");
                    J.parent[J.pkey] = { $ref: W, "x-miro": te[F], $fixed: !0 }, fe.verbose > 1 && console.warn("Replacing with", W), se++;
                  }
                } else {
                  let W = x(k(ne, te[F]));
                  if (fe.verbose > 1 && console.warn((W === !1 ? O.colour.red : O.colour.green) + "Fragment resolution", te[F], O.colour.normal), W === !1) {
                    if (J.parent[J.pkey] = {}, fe.fatal) {
                      let q = new Error("Fragment $ref resolution failed " + te[F]);
                      if (!fe.promise) throw q;
                      fe.promise.reject(q);
                    }
                  } else se++, J.parent[J.pkey] = W, ce[te[F]] = J.path.replace("/%24ref", "");
                }
                else if ($e.protocol) {
                  let W = g.resolve(ge, te[F]).toString();
                  fe.verbose > 1 && console.warn(O.colour.yellow + "Rewriting external url ref", te[F], "as", W, O.colour.normal), te["x-miro"] = te[F], fe.externalRefs[te[F]] && (fe.externalRefs[W] || (fe.externalRefs[W] = fe.externalRefs[te[F]]), fe.externalRefs[W].failed = fe.externalRefs[te[F]].failed), te[F] = W;
                } else if (!te["x-miro"]) {
                  let W = g.resolve(ge, te[F]).toString(), q = !1;
                  fe.externalRefs[te[F]] && (q = fe.externalRefs[te[F]].failed), q || (fe.verbose > 1 && console.warn(O.colour.yellow + "Rewriting external ref", te[F], "as", W, O.colour.normal), te["x-miro"] = te[F], te[F] = W);
                }
              }
            });
            return b(U, {}, function(te, F, J) {
              _(te, F) && te.$fixed !== void 0 && delete te.$fixed;
            }), fe.verbose > 1 && console.warn("Finished fragment resolution"), U;
          }
          function C(U, ne) {
            if (!ne.filters || !ne.filters.length) return U;
            for (let H of ne.filters) U = H(U, ne);
            return U;
          }
          function T(U, ne, H, ae) {
            var ge = g.parse(H.source), fe = H.source.split("\\").join("/").split("/");
            fe.pop() || fe.pop();
            let ve = "", $e = ne.split("#");
            $e.length > 1 && (ve = "#" + $e[1], ne = $e[0]), fe = fe.join("/");
            let ce = (se = g.parse(ne).protocol, te = ge.protocol, se && se.length > 2 ? se : te && te.length > 2 ? te : "file:");
            var se, te;
            let F;
            if (F = ce === "file:" ? m.resolve(fe ? fe + "/" : "", ne) : g.resolve(fe ? fe + "/" : "", ne), H.cache[F]) {
              H.verbose && console.warn("CACHED", F, ve);
              let J = x(H.cache[F]), W = H.externalRef = J;
              if (ve && (W = k(W, ve), W === !1 && (W = {}, H.fatal))) {
                let q = new Error("Cached $ref resolution failed " + F + ve);
                if (!H.promise) throw q;
                H.promise.reject(q);
              }
              return W = R(W, J, ne, ve, F, H), W = C(W, H), ae(x(W), F, H), Promise.resolve(W);
            }
            if (H.verbose && console.warn("GET", F, ve), H.handlers && H.handlers[ce]) return H.handlers[ce](fe, ne, ve, H).then(function(J) {
              return H.externalRef = J, J = C(J, H), H.cache[F] = J, ae(J, F, H), J;
            }).catch(function(J) {
              throw H.verbose && console.warn(J), J;
            });
            if (ce && ce.startsWith("http")) {
              const J = Object.assign({}, H.fetchOptions, { agent: H.agent });
              return H.fetch(F, J).then(function(W) {
                if (W.status !== 200) {
                  if (H.ignoreIOErrors) return H.verbose && console.warn("FAILED", ne), H.externalRefs[ne].failed = !0, '{"$ref":"' + ne + '"}';
                  throw new Error(`Received status code ${W.status}: ${F}`);
                }
                return W.text();
              }).then(function(W) {
                try {
                  let q = S.parse(W, { schema: "core", prettyErrors: !0 });
                  if (W = H.externalRef = q, H.cache[F] = x(W), ve && (W = k(W, ve)) === !1 && (W = {}, H.fatal)) {
                    let X = new Error("Remote $ref resolution failed " + F + ve);
                    if (!H.promise) throw X;
                    H.promise.reject(X);
                  }
                  W = C(W = R(W, q, ne, ve, F, H), H);
                } catch (q) {
                  if (H.verbose && console.warn(q), !H.promise || !H.fatal) throw q;
                  H.promise.reject(q);
                }
                return ae(W, F, H), W;
              }).catch(function(W) {
                if (H.verbose && console.warn(W), H.cache[F] = {}, !H.promise || !H.fatal) throw W;
                H.promise.reject(W);
              });
            }
            {
              const J = '{"$ref":"' + ne + '"}';
              return function(W, q, X, Q, ye) {
                return new Promise(function(Se, Ne) {
                  d.readFile(W, q, function(N, B) {
                    N ? X.ignoreIOErrors && ye ? (X.verbose && console.warn("FAILED", Q), X.externalRefs[Q].failed = !0, Se(ye)) : Ne(N) : Se(B);
                  });
                });
              }(F, H.encoding || "utf8", H, ne, J).then(function(W) {
                try {
                  let q = S.parse(W, { schema: "core", prettyErrors: !0 });
                  if (W = H.externalRef = q, H.cache[F] = x(W), ve && (W = k(W, ve)) === !1 && (W = {}, H.fatal)) {
                    let X = new Error("File $ref resolution failed " + F + ve);
                    if (!H.promise) throw X;
                    H.promise.reject(X);
                  }
                  W = C(W = R(W, q, ne, ve, F, H), H);
                } catch (q) {
                  if (H.verbose && console.warn(q), !H.promise || !H.fatal) throw q;
                  H.promise.reject(q);
                }
                return ae(W, F, H), W;
              }).catch(function(W) {
                if (H.verbose && console.warn(W), !H.promise || !H.fatal) throw W;
                H.promise.reject(W);
              });
            }
          }
          function j(U) {
            return new Promise(function(ne, H) {
              (function(ge) {
                return new Promise(function(fe, ve) {
                  function $e(se, te, F) {
                    if (se[te] && _(se[te], "$ref")) {
                      let J = se[te].$ref;
                      if (!J.startsWith("#")) {
                        let W = "";
                        if (!ce[J]) {
                          let q = Object.keys(ce).find(function(X, Q, ye) {
                            return J.startsWith(X + "/");
                          });
                          q && (ge.verbose && console.warn("Found potential subschema at", q), W = "/" + (J.split("#")[1] || "").replace(q.split("#")[1] || ""), W = W.split("/undefined").join(""), J = q);
                        }
                        if (ce[J] || (ce[J] = { resolved: !1, paths: [], extras: {}, description: se[te].description }), ce[J].resolved) {
                          if (!ce[J].failed) if (ge.rewriteRefs) {
                            let q = ce[J].resolvedAt;
                            ge.verbose > 1 && console.warn("Rewriting ref", J, q), se[te]["x-miro"] = J, se[te].$ref = q + W;
                          } else se[te] = x(ce[J].data);
                        } else ce[J].paths.push(F.path), ce[J].extras[F.path] = W;
                      }
                    }
                  }
                  let ce = ge.externalRefs;
                  if (ge.resolver.depth > 0 && ge.source === ge.resolver.base) return fe(ce);
                  b(ge.openapi.definitions, { identityDetection: !0, path: "#/definitions" }, $e), b(ge.openapi.components, { identityDetection: !0, path: "#/components" }, $e), b(ge.openapi, { identityDetection: !0 }, $e), fe(ce);
                });
              })(U).then(function(ge) {
                for (let fe in ge) if (!ge[fe].resolved) {
                  let ve = U.resolver.depth;
                  ve > 0 && ve++, U.resolver.actions[ve].push(function() {
                    return T(U.openapi, fe, U, function($e, ce, se) {
                      if (!ge[fe].resolved) {
                        let W = {};
                        W.context = ge[fe], W.$ref = fe, W.original = x($e), W.updated = $e, W.source = ce, se.externals.push(W), ge[fe].resolved = !0;
                      }
                      let te = Object.assign({}, se, { source: "", resolver: { actions: se.resolver.actions, depth: se.resolver.actions.length - 1, base: se.resolver.base } });
                      se.patch && ge[fe].description && !$e.description && typeof $e == "object" && ($e.description = ge[fe].description), ge[fe].data = $e;
                      let F = (J = ge[fe].paths, [...new Set(J)]);
                      var J;
                      F = F.sort(function(W, q) {
                        const X = W.startsWith("#/components/") || W.startsWith("#/definitions/"), Q = q.startsWith("#/components/") || q.startsWith("#/definitions/");
                        return X && !Q ? -1 : Q && !X ? 1 : 0;
                      });
                      for (let W of F) if (ge[fe].resolvedAt && W !== ge[fe].resolvedAt && W.indexOf("x-ms-examples/") < 0) se.verbose > 1 && console.warn("Creating pointer to data at", W), k(se.openapi, W, { $ref: ge[fe].resolvedAt + ge[fe].extras[W], "x-miro": fe + ge[fe].extras[W] });
                      else {
                        ge[fe].resolvedAt ? se.verbose > 1 && console.warn("Avoiding circular reference") : (ge[fe].resolvedAt = W, se.verbose > 1 && console.warn("Creating initial clone of data at", W));
                        let q = x($e);
                        k(se.openapi, W, q);
                      }
                      se.resolver.actions[te.resolver.depth].length === 0 && se.resolver.actions[te.resolver.depth].push(function() {
                        return j(te);
                      });
                    });
                  });
                }
              }).catch(function(ge) {
                U.verbose && console.warn(ge), H(ge);
              });
              let ae = { options: U };
              ae.actions = U.resolver.actions[U.resolver.depth], ne(ae);
            });
          }
          function D(U, ne, H) {
            U.resolver.actions.push([]), j(U).then(function(ae) {
              var ge;
              (ge = ae.actions, ge.reduce((fe, ve) => fe.then(($e) => ve().then(Array.prototype.concat.bind($e))), Promise.resolve([]))).then(function() {
                if (U.resolver.depth >= U.resolver.actions.length) return console.warn("Ran off the end of resolver actions"), ne(!0);
                U.resolver.depth++, U.resolver.actions[U.resolver.depth].length ? setTimeout(function() {
                  D(ae.options, ne, H);
                }, 0) : (U.verbose > 1 && console.warn(O.colour.yellow + "Finished external resolution!", O.colour.normal), U.resolveInternal && (U.verbose > 1 && console.warn(O.colour.yellow + "Starting internal resolution!", O.colour.normal), U.openapi = A(U.openapi, U.original, { verbose: U.verbose - 1 }), U.verbose > 1 && console.warn(O.colour.yellow + "Finished internal resolution!", O.colour.normal)), b(U.openapi, {}, function(fe, ve, $e) {
                  _(fe, ve) && (U.preserveMiro || delete fe["x-miro"]);
                }), ne(U));
              }).catch(function(fe) {
                U.verbose && console.warn(fe), H(fe);
              });
            }).catch(function(ae) {
              U.verbose && console.warn(ae), H(ae);
            });
          }
          function V(U) {
            if (U.cache || (U.cache = {}), U.fetch || (U.fetch = v), U.source) {
              let ne = g.parse(U.source);
              (!ne.protocol || ne.protocol.length <= 2) && (U.source = m.resolve(U.source));
            }
            U.externals = [], U.externalRefs = {}, U.rewriteRefs = !0, U.resolver = {}, U.resolver.depth = 0, U.resolver.base = U.source, U.resolver.actions = [[]];
          }
          i.exports = { optionalResolve: function(U) {
            return V(U), new Promise(function(ne, H) {
              U.resolve ? D(U, ne, H) : ne(U);
            });
          }, resolve: function(U, ne, H) {
            return H || (H = {}), H.openapi = U, H.source = ne, H.resolve = !0, V(H), new Promise(function(ae, ge) {
              D(H, ae, ge);
            });
          } };
        }, 319: function(i) {
          function u() {
            return { depth: 0, seen: /* @__PURE__ */ new WeakMap(), top: !0, combine: !1, allowRefSiblings: !1 };
          }
          i.exports = { getDefaultState: u, walkSchema: function c(d, m, g, v) {
            if (g.depth === void 0 && (g = u()), d == null) return d;
            if (d.$ref !== void 0) {
              let S = { $ref: d.$ref };
              return g.allowRefSiblings && d.description && (S.description = d.description), v(S, m, g), S;
            }
            if (g.combine && (d.allOf && Array.isArray(d.allOf) && d.allOf.length === 1 && delete (d = Object.assign({}, d.allOf[0], d)).allOf, d.anyOf && Array.isArray(d.anyOf) && d.anyOf.length === 1 && delete (d = Object.assign({}, d.anyOf[0], d)).anyOf, d.oneOf && Array.isArray(d.oneOf) && d.oneOf.length === 1 && delete (d = Object.assign({}, d.oneOf[0], d)).oneOf), v(d, m, g), g.seen.has(d)) return d;
            if (typeof d == "object" && d !== null && g.seen.set(d, !0), g.top = !1, g.depth++, d.items !== void 0 && (g.property = "items", c(d.items, d, g, v)), d.additionalItems && typeof d.additionalItems == "object" && (g.property = "additionalItems", c(d.additionalItems, d, g, v)), d.additionalProperties && typeof d.additionalProperties == "object" && (g.property = "additionalProperties", c(d.additionalProperties, d, g, v)), d.properties) for (let S in d.properties) {
              let k = d.properties[S];
              g.property = "properties/" + S, c(k, d, g, v);
            }
            if (d.patternProperties) for (let S in d.patternProperties) {
              let k = d.patternProperties[S];
              g.property = "patternProperties/" + S, c(k, d, g, v);
            }
            if (d.allOf) for (let S in d.allOf) {
              let k = d.allOf[S];
              g.property = "allOf/" + S, c(k, d, g, v);
            }
            if (d.anyOf) for (let S in d.anyOf) {
              let k = d.anyOf[S];
              g.property = "anyOf/" + S, c(k, d, g, v);
            }
            if (d.oneOf) for (let S in d.oneOf) {
              let k = d.oneOf[S];
              g.property = "oneOf/" + S, c(k, d, g, v);
            }
            return d.not && (g.property = "not", c(d.not, d, g, v)), g.depth--, d;
          } };
        }, 975: function(i) {
          function u(m) {
            if (typeof m != "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(m));
          }
          function c(m, g) {
            for (var v, S = "", k = 0, b = -1, x = 0, A = 0; A <= m.length; ++A) {
              if (A < m.length) v = m.charCodeAt(A);
              else {
                if (v === 47) break;
                v = 47;
              }
              if (v === 47) {
                if (!(b === A - 1 || x === 1)) if (b !== A - 1 && x === 2) {
                  if (S.length < 2 || k !== 2 || S.charCodeAt(S.length - 1) !== 46 || S.charCodeAt(S.length - 2) !== 46) {
                    if (S.length > 2) {
                      var _ = S.lastIndexOf("/");
                      if (_ !== S.length - 1) {
                        _ === -1 ? (S = "", k = 0) : k = (S = S.slice(0, _)).length - 1 - S.lastIndexOf("/"), b = A, x = 0;
                        continue;
                      }
                    } else if (S.length === 2 || S.length === 1) {
                      S = "", k = 0, b = A, x = 0;
                      continue;
                    }
                  }
                  g && (S.length > 0 ? S += "/.." : S = "..", k = 2);
                } else S.length > 0 ? S += "/" + m.slice(b + 1, A) : S = m.slice(b + 1, A), k = A - b - 1;
                b = A, x = 0;
              } else v === 46 && x !== -1 ? ++x : x = -1;
            }
            return S;
          }
          var d = { resolve: function() {
            for (var m, g = "", v = !1, S = arguments.length - 1; S >= -1 && !v; S--) {
              var k;
              S >= 0 ? k = arguments[S] : (m === void 0 && (m = process.cwd()), k = m), u(k), k.length !== 0 && (g = k + "/" + g, v = k.charCodeAt(0) === 47);
            }
            return g = c(g, !v), v ? g.length > 0 ? "/" + g : "/" : g.length > 0 ? g : ".";
          }, normalize: function(m) {
            if (u(m), m.length === 0) return ".";
            var g = m.charCodeAt(0) === 47, v = m.charCodeAt(m.length - 1) === 47;
            return (m = c(m, !g)).length !== 0 || g || (m = "."), m.length > 0 && v && (m += "/"), g ? "/" + m : m;
          }, isAbsolute: function(m) {
            return u(m), m.length > 0 && m.charCodeAt(0) === 47;
          }, join: function() {
            if (arguments.length === 0) return ".";
            for (var m, g = 0; g < arguments.length; ++g) {
              var v = arguments[g];
              u(v), v.length > 0 && (m === void 0 ? m = v : m += "/" + v);
            }
            return m === void 0 ? "." : d.normalize(m);
          }, relative: function(m, g) {
            if (u(m), u(g), m === g || (m = d.resolve(m)) === (g = d.resolve(g))) return "";
            for (var v = 1; v < m.length && m.charCodeAt(v) === 47; ++v) ;
            for (var S = m.length, k = S - v, b = 1; b < g.length && g.charCodeAt(b) === 47; ++b) ;
            for (var x = g.length - b, A = k < x ? k : x, _ = -1, O = 0; O <= A; ++O) {
              if (O === A) {
                if (x > A) {
                  if (g.charCodeAt(b + O) === 47) return g.slice(b + O + 1);
                  if (O === 0) return g.slice(b + O);
                } else k > A && (m.charCodeAt(v + O) === 47 ? _ = O : O === 0 && (_ = 0));
                break;
              }
              var R = m.charCodeAt(v + O);
              if (R !== g.charCodeAt(b + O)) break;
              R === 47 && (_ = O);
            }
            var C = "";
            for (O = v + _ + 1; O <= S; ++O) O !== S && m.charCodeAt(O) !== 47 || (C.length === 0 ? C += ".." : C += "/..");
            return C.length > 0 ? C + g.slice(b + _) : (b += _, g.charCodeAt(b) === 47 && ++b, g.slice(b));
          }, _makeLong: function(m) {
            return m;
          }, dirname: function(m) {
            if (u(m), m.length === 0) return ".";
            for (var g = m.charCodeAt(0), v = g === 47, S = -1, k = !0, b = m.length - 1; b >= 1; --b) if ((g = m.charCodeAt(b)) === 47) {
              if (!k) {
                S = b;
                break;
              }
            } else k = !1;
            return S === -1 ? v ? "/" : "." : v && S === 1 ? "//" : m.slice(0, S);
          }, basename: function(m, g) {
            if (g !== void 0 && typeof g != "string") throw new TypeError('"ext" argument must be a string');
            u(m);
            var v, S = 0, k = -1, b = !0;
            if (g !== void 0 && g.length > 0 && g.length <= m.length) {
              if (g.length === m.length && g === m) return "";
              var x = g.length - 1, A = -1;
              for (v = m.length - 1; v >= 0; --v) {
                var _ = m.charCodeAt(v);
                if (_ === 47) {
                  if (!b) {
                    S = v + 1;
                    break;
                  }
                } else A === -1 && (b = !1, A = v + 1), x >= 0 && (_ === g.charCodeAt(x) ? --x == -1 && (k = v) : (x = -1, k = A));
              }
              return S === k ? k = A : k === -1 && (k = m.length), m.slice(S, k);
            }
            for (v = m.length - 1; v >= 0; --v) if (m.charCodeAt(v) === 47) {
              if (!b) {
                S = v + 1;
                break;
              }
            } else k === -1 && (b = !1, k = v + 1);
            return k === -1 ? "" : m.slice(S, k);
          }, extname: function(m) {
            u(m);
            for (var g = -1, v = 0, S = -1, k = !0, b = 0, x = m.length - 1; x >= 0; --x) {
              var A = m.charCodeAt(x);
              if (A !== 47) S === -1 && (k = !1, S = x + 1), A === 46 ? g === -1 ? g = x : b !== 1 && (b = 1) : g !== -1 && (b = -1);
              else if (!k) {
                v = x + 1;
                break;
              }
            }
            return g === -1 || S === -1 || b === 0 || b === 1 && g === S - 1 && g === v + 1 ? "" : m.slice(g, S);
          }, format: function(m) {
            if (m === null || typeof m != "object") throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof m);
            return function(g, v) {
              var S = v.dir || v.root, k = v.base || (v.name || "") + (v.ext || "");
              return S ? S === v.root ? S + k : S + "/" + k : k;
            }(0, m);
          }, parse: function(m) {
            u(m);
            var g = { root: "", dir: "", base: "", ext: "", name: "" };
            if (m.length === 0) return g;
            var v, S = m.charCodeAt(0), k = S === 47;
            k ? (g.root = "/", v = 1) : v = 0;
            for (var b = -1, x = 0, A = -1, _ = !0, O = m.length - 1, R = 0; O >= v; --O) if ((S = m.charCodeAt(O)) !== 47) A === -1 && (_ = !1, A = O + 1), S === 46 ? b === -1 ? b = O : R !== 1 && (R = 1) : b !== -1 && (R = -1);
            else if (!_) {
              x = O + 1;
              break;
            }
            return b === -1 || A === -1 || R === 0 || R === 1 && b === A - 1 && b === x + 1 ? A !== -1 && (g.base = g.name = x === 0 && k ? m.slice(1, A) : m.slice(x, A)) : (x === 0 && k ? (g.name = m.slice(1, b), g.base = m.slice(1, A)) : (g.name = m.slice(x, b), g.base = m.slice(x, A)), g.ext = m.slice(b, A)), x > 0 ? g.dir = m.slice(0, x - 1) : k && (g.dir = "/"), g;
          }, sep: "/", delimiter: ":", win32: null, posix: null };
          d.posix = d, i.exports = d;
        }, 920: function(i) {
          i.exports = { nop: function(u) {
            return u;
          }, clone: function(u) {
            return JSON.parse(JSON.stringify(u));
          }, shallowClone: function(u) {
            let c = {};
            for (let d in u) u.hasOwnProperty(d) && (c[d] = u[d]);
            return c;
          }, deepClone: function u(c) {
            let d = Array.isArray(c) ? [] : {};
            for (let m in c) (c.hasOwnProperty(m) || Array.isArray(c)) && (d[m] = typeof c[m] == "object" ? u(c[m]) : c[m]);
            return d;
          }, fastClone: function(u) {
            return Object.assign({}, u);
          }, circularClone: function u(c, d) {
            if (d || (d = /* @__PURE__ */ new WeakMap()), Object(c) !== c || c instanceof Function) return c;
            if (d.has(c)) return d.get(c);
            try {
              var m = new c.constructor();
            } catch {
              m = Object.create(Object.getPrototypeOf(c));
            }
            return d.set(c, m), Object.assign(m, ...Object.keys(c).map((g) => ({ [g]: u(c[g], d) })));
          } };
        }, 737: function(i, u, c) {
          const d = c(880).recurse, m = c(920).shallowClone, g = c(33).jptr, v = c(264).isRef;
          i.exports = { dereference: function S(k, b, x) {
            x || (x = {}), x.cache || (x.cache = {}), x.state || (x.state = {}), x.state.identityDetection = !0, x.depth = x.depth ? x.depth + 1 : 1;
            let A = x.depth > 1 ? k : m(k), _ = { data: A }, O = x.depth > 1 ? b : m(b);
            x.master || (x.master = A);
            let R = function(T) {
              return T && T.verbose ? { warn: function() {
                var j = Array.prototype.slice.call(arguments);
                console.warn.apply(console, j);
              } } : { warn: function() {
              } };
            }(x), C = 1;
            for (; C > 0; ) C = 0, d(_, x.state, function(T, j, D) {
              if (v(T, j)) {
                let V = T[j];
                if (C++, x.cache[V]) {
                  let U = x.cache[V];
                  if (U.resolved) R.warn("Patching %s for %s", V, U.path), D.parent[D.pkey] = U.data, x.$ref && typeof D.parent[D.pkey] == "object" && D.parent[D.pkey] !== null && (D.parent[D.pkey][x.$ref] = V);
                  else {
                    if (V === U.path) throw new Error(`Tight circle at ${U.path}`);
                    R.warn("Unresolved ref"), D.parent[D.pkey] = g(U.source, U.path), D.parent[D.pkey] === !1 && (D.parent[D.pkey] = g(U.source, U.key)), x.$ref && typeof D.parent[D.pkey] == "object" && D.parent[D.pkey] !== null && (D.parent[x.$ref] = V);
                  }
                } else {
                  let U = {};
                  U.path = D.path.split("/$ref")[0], U.key = V, R.warn("Dereffing %s at %s", V, U.path), U.source = O, U.data = g(U.source, U.key), U.data === !1 && (U.data = g(x.master, U.key), U.source = x.master), U.data === !1 && R.warn("Missing $ref target", U.key), x.cache[V] = U, U.data = D.parent[D.pkey] = S(g(U.source, U.key), U.source, x), x.$ref && typeof D.parent[D.pkey] == "object" && D.parent[D.pkey] !== null && (D.parent[D.pkey][x.$ref] = V), U.resolved = !0;
                }
              }
            });
            return _.data;
          } };
        }, 264: function(i) {
          i.exports = { isRef: function(u, c) {
            return c === "$ref" && !!u && typeof u[c] == "string";
          } };
        }, 33: function(i) {
          function u(c) {
            return c.replace(/\~1/g, "/").replace(/~0/g, "~");
          }
          i.exports = { jptr: function(c, d, m) {
            if (c === void 0) return !1;
            if (!d || typeof d != "string" || d === "#") return m !== void 0 ? m : c;
            if (d.indexOf("#") >= 0) {
              let v = d.split("#");
              if (v[0]) return !1;
              d = v[1], d = decodeURIComponent(d.slice(1).split("+").join(" "));
            }
            d.startsWith("/") && (d = d.slice(1));
            let g = d.split("/");
            for (let v = 0; v < g.length; v++) {
              g[v] = u(g[v]);
              let S = m !== void 0 && v == g.length - 1, k = parseInt(g[v], 10);
              if (!Array.isArray(c) || isNaN(k) || k.toString() !== g[v] ? k = Array.isArray(c) && g[v] === "-" ? -2 : -1 : g[v] = v > 0 ? g[v - 1] : "", k != -1 || c && c.hasOwnProperty(g[v])) if (k >= 0) S && (c[k] = m), c = c[k];
              else {
                if (k === -2) return S ? (Array.isArray(c) && c.push(m), m) : void 0;
                S && (c[g[v]] = m), c = c[g[v]];
              }
              else {
                if (m === void 0 || typeof c != "object" || Array.isArray(c)) return !1;
                c[g[v]] = S ? m : g[v + 1] === "0" || g[v + 1] === "-" ? [] : {}, c = c[g[v]];
              }
            }
            return c;
          }, jpescape: function(c) {
            return c.replace(/\~/g, "~0").replace(/\//g, "~1");
          }, jpunescape: u };
        }, 880: function(i, u, c) {
          const d = c(33).jpescape;
          i.exports = { recurse: function m(g, v, S) {
            if (v || (v = { depth: 0 }), v.depth || (v = Object.assign({}, { path: "#", depth: 0, pkey: "", parent: {}, payload: {}, seen: /* @__PURE__ */ new WeakMap(), identity: !1, identityDetection: !1 }, v)), typeof g != "object") return;
            let k = v.path;
            for (let b in g) {
              if (v.key = b, v.path = v.path + "/" + encodeURIComponent(d(b)), v.identityPath = v.seen.get(g[b]), v.identity = v.identityPath !== void 0, g.hasOwnProperty(b) && S(g, b, v), typeof g[b] == "object" && !v.identity) {
                v.identityDetection && !Array.isArray(g[b]) && g[b] !== null && v.seen.set(g[b], v.path);
                let x = {};
                x.parent = g, x.path = v.path, x.depth = v.depth ? v.depth + 1 : 1, x.pkey = b, x.payload = v.payload, x.seen = v.seen, x.identity = !1, x.identityDetection = v.identityDetection, m(g[b], x, S);
              }
              v.path = k;
            }
          } };
        }, 494: function(i, u, c) {
          c.r(u);
          var d = c(72), m = c.n(d), g = c(825), v = c.n(g), S = c(659), k = c.n(S), b = c(56), x = c.n(b), A = c(540), _ = c.n(A), O = c(113), R = c.n(O), C = c(997), T = {};
          T.styleTagTransform = R(), T.setAttributes = x(), T.insert = k().bind(null, "head"), T.domAPI = v(), T.insertStyleElement = _(), m()(C.A, T), u.default = C.A && C.A.locals ? C.A.locals : void 0;
        }, 72: function(i) {
          var u = [];
          function c(g) {
            for (var v = -1, S = 0; S < u.length; S++) if (u[S].identifier === g) {
              v = S;
              break;
            }
            return v;
          }
          function d(g, v) {
            for (var S = {}, k = [], b = 0; b < g.length; b++) {
              var x = g[b], A = v.base ? x[0] + v.base : x[0], _ = S[A] || 0, O = "".concat(A, " ").concat(_);
              S[A] = _ + 1;
              var R = c(O), C = { css: x[1], media: x[2], sourceMap: x[3], supports: x[4], layer: x[5] };
              if (R !== -1) u[R].references++, u[R].updater(C);
              else {
                var T = m(C, v);
                v.byIndex = b, u.splice(b, 0, { identifier: O, updater: T, references: 1 });
              }
              k.push(O);
            }
            return k;
          }
          function m(g, v) {
            var S = v.domAPI(v);
            return S.update(g), function(k) {
              if (k) {
                if (k.css === g.css && k.media === g.media && k.sourceMap === g.sourceMap && k.supports === g.supports && k.layer === g.layer) return;
                S.update(g = k);
              } else S.remove();
            };
          }
          i.exports = function(g, v) {
            var S = d(g = g || [], v = v || {});
            return function(k) {
              k = k || [];
              for (var b = 0; b < S.length; b++) {
                var x = c(S[b]);
                u[x].references--;
              }
              for (var A = d(k, v), _ = 0; _ < S.length; _++) {
                var O = c(S[_]);
                u[O].references === 0 && (u[O].updater(), u.splice(O, 1));
              }
              S = A;
            };
          };
        }, 659: function(i) {
          var u = {};
          i.exports = function(c, d) {
            var m = function(g) {
              if (u[g] === void 0) {
                var v = document.querySelector(g);
                if (window.HTMLIFrameElement && v instanceof window.HTMLIFrameElement) try {
                  v = v.contentDocument.head;
                } catch {
                  v = null;
                }
                u[g] = v;
              }
              return u[g];
            }(c);
            if (!m) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
            m.appendChild(d);
          };
        }, 540: function(i) {
          i.exports = function(u) {
            var c = document.createElement("style");
            return u.setAttributes(c, u.attributes), u.insert(c, u.options), c;
          };
        }, 56: function(i, u, c) {
          i.exports = function(d) {
            var m = c.nc;
            m && d.setAttribute("nonce", m);
          };
        }, 825: function(i) {
          i.exports = function(u) {
            var c = u.insertStyleElement(u);
            return { update: function(d) {
              (function(m, g, v) {
                var S = "";
                v.supports && (S += "@supports (".concat(v.supports, ") {")), v.media && (S += "@media ".concat(v.media, " {"));
                var k = v.layer !== void 0;
                k && (S += "@layer".concat(v.layer.length > 0 ? " ".concat(v.layer) : "", " {")), S += v.css, k && (S += "}"), v.media && (S += "}"), v.supports && (S += "}");
                var b = v.sourceMap;
                b && typeof btoa < "u" && (S += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(b)))), " */")), g.styleTagTransform(S, m, g.options);
              })(c, u, d);
            }, remove: function() {
              (function(d) {
                if (d.parentNode === null) return !1;
                d.parentNode.removeChild(d);
              })(c);
            } };
          };
        }, 113: function(i) {
          i.exports = function(u, c) {
            if (c.styleSheet) c.styleSheet.cssText = u;
            else {
              for (; c.firstChild; ) c.removeChild(c.firstChild);
              c.appendChild(document.createTextNode(u));
            }
          };
        }, 65: function(i, u, c) {
          const d = c(364), m = c(725), g = (c(975), c(884)), v = c(725), S = c(115), k = c(33), b = k.jptr, x = c(264).isRef, A = c(920).clone, _ = c(920).circularClone, O = c(880).recurse, R = c(751), C = c(319), T = c(435), j = c(665).statusCodes, D = c(430).rE, V = "3.0.0";
          let U;
          class ne extends Error {
            constructor(B) {
              super(B), this.name = "S2OError";
            }
          }
          function H(N, B) {
            let oe = new ne(N);
            if (oe.options = B, !B.promise) throw oe;
            B.promise.reject(oe);
          }
          function ae(N, B, oe) {
            oe.warnOnly ? B[oe.warnProperty || "x-s2o-warning"] = N : H(N, oe);
          }
          function ge(N, B) {
            C.walkSchema(N, {}, {}, function(oe, ie, he) {
              (function(Z) {
                if (Z["x-required"] && Array.isArray(Z["x-required"]) && (Z.required || (Z.required = []), Z.required = Z.required.concat(Z["x-required"]), delete Z["x-required"]), Z["x-anyOf"] && (Z.anyOf = Z["x-anyOf"], delete Z["x-anyOf"]), Z["x-oneOf"] && (Z.oneOf = Z["x-oneOf"], delete Z["x-oneOf"]), Z["x-not"] && (Z.not = Z["x-not"], delete Z["x-not"]), typeof Z["x-nullable"] == "boolean" && (Z.nullable = Z["x-nullable"], delete Z["x-nullable"]), typeof Z["x-discriminator"] == "object" && typeof Z["x-discriminator"].propertyName == "string") {
                  Z.discriminator = Z["x-discriminator"], delete Z["x-discriminator"];
                  for (let re in Z.discriminator.mapping) {
                    let Pe = Z.discriminator.mapping[re];
                    Pe.startsWith("#/definitions/") && (Z.discriminator.mapping[re] = Pe.replace("#/definitions/", "#/components/schemas/"));
                  }
                }
              })(oe), function(Z, re, Pe) {
                if (Z.nullable && Pe.patches++, Z.discriminator && typeof Z.discriminator == "string" && (Z.discriminator = { propertyName: Z.discriminator }), Z.items && Array.isArray(Z.items) && (Z.items.length === 0 ? Z.items = {} : Z.items.length === 1 ? Z.items = Z.items[0] : Z.items = { anyOf: Z.items }), Z.type && Array.isArray(Z.type)) if (Pe.patch) {
                  if (Pe.patches++, Z.type.length === 0) delete Z.type;
                  else {
                    Z.oneOf || (Z.oneOf = []);
                    for (let Oe of Z.type) {
                      let qe = {};
                      if (Oe === "null") Z.nullable = !0;
                      else {
                        qe.type = Oe;
                        for (let je of T.arrayProperties) Z.prop !== void 0 && (qe[je] = Z[je], delete Z[je]);
                      }
                      qe.type && Z.oneOf.push(qe);
                    }
                    delete Z.type, Z.oneOf.length === 0 ? delete Z.oneOf : Z.oneOf.length < 2 && (Z.type = Z.oneOf[0].type, Object.keys(Z.oneOf[0]).length > 1 && ae("Lost properties from oneOf", Z, Pe), delete Z.oneOf);
                  }
                  Z.type && Array.isArray(Z.type) && Z.type.length === 1 && (Z.type = Z.type[0]);
                } else H("(Patchable) schema type must not be an array", Pe);
                Z.type && Z.type === "null" && (delete Z.type, Z.nullable = !0), Z.type !== "array" || Z.items || (Z.items = {}), Z.type === "file" && (Z.type = "string", Z.format = "binary"), typeof Z.required == "boolean" && (Z.required && Z.name && (re.required === void 0 && (re.required = []), Array.isArray(re.required) && re.required.push(Z.name)), delete Z.required), Z.xml && typeof Z.xml.namespace == "string" && (Z.xml.namespace || delete Z.xml.namespace), Z.allowEmptyValue !== void 0 && (Pe.patches++, delete Z.allowEmptyValue);
              }(oe, ie, B);
            });
          }
          function fe(N, B, oe) {
            let ie = oe.payload.options;
            if (x(N, B)) {
              if (!N[B].startsWith("#/components/")) {
                if (N[B] === "#/consumes") delete N[B], oe.parent[oe.pkey] = A(ie.openapi.consumes);
                else if (N[B] === "#/produces") delete N[B], oe.parent[oe.pkey] = A(ie.openapi.produces);
                else if (N[B].startsWith("#/definitions/")) {
                  let Z = N[B].replace("#/definitions/", "").split("/");
                  const re = k.jpunescape(Z[0]);
                  let Pe = U.schemas[decodeURIComponent(re)];
                  Pe ? Z[0] = Pe : ae("Could not resolve reference " + N[B], N, ie), N[B] = "#/components/schemas/" + Z.join("/");
                } else if (N[B].startsWith("#/parameters/")) N[B] = "#/components/parameters/" + T.sanitise(N[B].replace("#/parameters/", ""));
                else if (N[B].startsWith("#/responses/")) N[B] = "#/components/responses/" + T.sanitise(N[B].replace("#/responses/", ""));
                else if (N[B].startsWith("#")) {
                  let Z = A(k.jptr(ie.openapi, N[B]));
                  if (Z === !1) ae("direct $ref not found " + N[B], N, ie);
                  else if (ie.refmap[N[B]]) N[B] = ie.refmap[N[B]];
                  else {
                    let re = N[B];
                    re = re.replace("/properties/headers/", ""), re = re.replace("/properties/responses/", ""), re = re.replace("/properties/parameters/", ""), re = re.replace("/properties/schemas/", "");
                    let Pe = "schemas", Oe = re.lastIndexOf("/schema");
                    if (Pe = re.indexOf("/headers/") > Oe ? "headers" : re.indexOf("/responses/") > Oe ? "responses" : re.indexOf("/example") > Oe ? "examples" : re.indexOf("/x-") > Oe ? "extensions" : re.indexOf("/parameters/") > Oe ? "parameters" : "schemas", Pe === "schemas" && ge(Z, ie), Pe !== "responses" && Pe !== "extensions") {
                      let qe = Pe.substr(0, Pe.length - 1);
                      qe === "parameter" && Z.name && Z.name === T.sanitise(Z.name) && (qe = encodeURIComponent(Z.name));
                      let je = 1;
                      for (N["x-miro"] && (he = (he = N["x-miro"]).indexOf("#") >= 0 ? he.split("#")[1].split("/").pop() : he.split("/").pop().split(".")[0], qe = encodeURIComponent(T.sanitise(he)), je = ""); k.jptr(ie.openapi, "#/components/" + Pe + "/" + qe + je); ) je = je === "" ? 2 : ++je;
                      let $ = "#/components/" + Pe + "/" + qe + je, K = "";
                      Pe === "examples" && (Z = { value: Z }, K = "/value"), k.jptr(ie.openapi, $, Z), ie.refmap[N[B]] = $ + K, N[B] = $ + K;
                    }
                  }
                }
              }
              if (delete N["x-miro"], Object.keys(N).length > 1) {
                const Z = N[B], re = oe.path.indexOf("/schema") >= 0;
                ie.refSiblings === "preserve" || (re && ie.refSiblings === "allOf" ? (delete N.$ref, oe.parent[oe.pkey] = { allOf: [{ $ref: Z }, N] }) : oe.parent[oe.pkey] = { $ref: Z });
              }
            }
            var he;
            if (B === "x-ms-odata" && typeof N[B] == "string" && N[B].startsWith("#/")) {
              let Z = N[B].replace("#/definitions/", "").replace("#/components/schemas/", "").split("/"), re = U.schemas[decodeURIComponent(Z[0])];
              re ? Z[0] = re : ae("Could not resolve reference " + N[B], N, ie), N[B] = "#/components/schemas/" + Z.join("/");
            }
          }
          function ve(N) {
            for (let B in N) for (let oe in N[B]) {
              let ie = T.sanitise(oe);
              oe !== ie && (N[B][ie] = N[B][oe], delete N[B][oe]);
            }
          }
          function $e(N, B) {
            if (N.type === "basic" && (N.type = "http", N.scheme = "basic"), N.type === "oauth2") {
              let oe = {}, ie = N.flow;
              N.flow === "application" && (ie = "clientCredentials"), N.flow === "accessCode" && (ie = "authorizationCode"), N.authorizationUrl !== void 0 && (oe.authorizationUrl = N.authorizationUrl.split("?")[0].trim() || "/"), typeof N.tokenUrl == "string" && (oe.tokenUrl = N.tokenUrl.split("?")[0].trim() || "/"), oe.scopes = N.scopes || {}, N.flows = {}, N.flows[ie] = oe, delete N.flow, delete N.authorizationUrl, delete N.tokenUrl, delete N.scopes, N.name !== void 0 && (B.patch ? (B.patches++, delete N.name) : H("(Patchable) oauth2 securitySchemes should not have name property", B));
            }
          }
          function ce(N) {
            return N && !N["x-s2o-delete"];
          }
          function se(N, B) {
            if (N.$ref) N.$ref = N.$ref.replace("#/responses/", "#/components/responses/");
            else {
              N.type && !N.schema && (N.schema = {}), N.type && (N.schema.type = N.type), N.items && N.items.type !== "array" && (N.items.collectionFormat !== N.collectionFormat && ae("Nested collectionFormats are not supported", N, B), delete N.items.collectionFormat), N.type === "array" ? (N.collectionFormat === "ssv" ? ae("collectionFormat:ssv is no longer supported for headers", N, B) : N.collectionFormat === "pipes" ? ae("collectionFormat:pipes is no longer supported for headers", N, B) : N.collectionFormat === "multi" ? N.explode = !0 : N.collectionFormat === "tsv" ? (ae("collectionFormat:tsv is no longer supported", N, B), N["x-collectionFormat"] = "tsv") : N.style = "simple", delete N.collectionFormat) : N.collectionFormat && (B.patch ? (B.patches++, delete N.collectionFormat) : H("(Patchable) collectionFormat is only applicable to header.type array", B)), delete N.type;
              for (let oe of T.parameterTypeProperties) N[oe] !== void 0 && (N.schema[oe] = N[oe], delete N[oe]);
              for (let oe of T.arrayProperties) N[oe] !== void 0 && (N.schema[oe] = N[oe], delete N[oe]);
            }
          }
          function te(N, B) {
            if (N.$ref.indexOf("#/parameters/") >= 0) {
              let oe = N.$ref.split("#/parameters/");
              N.$ref = oe[0] + "#/components/parameters/" + T.sanitise(oe[1]);
            }
            N.$ref.indexOf("#/definitions/") >= 0 && ae("Definition used as parameter", N, B);
          }
          function F(N, B, oe, ie, he, Z, re) {
            let Pe, Oe = {}, qe = !0;
            if (B && B.consumes && typeof B.consumes == "string") {
              if (!re.patch) return H("(Patchable) operation.consumes must be an array", re);
              re.patches++, B.consumes = [B.consumes];
            }
            Array.isArray(Z.consumes) || delete Z.consumes;
            let je = ((B ? B.consumes : null) || Z.consumes || []).filter(T.uniqueOnly);
            if (N && N.$ref && typeof N.$ref == "string") {
              te(N, re);
              let $ = decodeURIComponent(N.$ref.replace("#/components/parameters/", "")), K = !1, me = Z.components.parameters[$];
              if (me && !me["x-s2o-delete"] || !N.$ref.startsWith("#/") || (N["x-s2o-delete"] = !0, K = !0), K) {
                let Te = N.$ref, ke = b(Z, N.$ref);
                !ke && Te.startsWith("#/") ? ae("Could not resolve reference " + Te, N, re) : ke && (N = ke);
              }
            }
            if (N && (N.name || N.in)) {
              typeof N["x-deprecated"] == "boolean" && (N.deprecated = N["x-deprecated"], delete N["x-deprecated"]), N["x-example"] !== void 0 && (N.example = N["x-example"], delete N["x-example"]), N.in === "body" || N.type || (re.patch ? (re.patches++, N.type = "string") : H("(Patchable) parameter.type is mandatory for non-body parameters", re)), N.type && typeof N.type == "object" && N.type.$ref && (N.type = b(Z, N.type.$ref)), N.type === "file" && (N["x-s2o-originalType"] = N.type, Pe = N.type), N.description && typeof N.description == "object" && N.description.$ref && (N.description = b(Z, N.description.$ref)), N.description === null && delete N.description;
              let $ = N.collectionFormat;
              if (N.type !== "array" || $ || ($ = "csv"), $ && (N.type !== "array" && (re.patch ? (re.patches++, delete N.collectionFormat) : H("(Patchable) collectionFormat is only applicable to param.type array", re)), $ !== "csv" || N.in !== "query" && N.in !== "cookie" || (N.style = "form", N.explode = !1), $ !== "csv" || N.in !== "path" && N.in !== "header" || (N.style = "simple"), $ === "ssv" && (N.in === "query" ? N.style = "spaceDelimited" : ae("collectionFormat:ssv is no longer supported except for in:query parameters", N, re)), $ === "pipes" && (N.in === "query" ? N.style = "pipeDelimited" : ae("collectionFormat:pipes is no longer supported except for in:query parameters", N, re)), $ === "multi" && (N.explode = !0), $ === "tsv" && (ae("collectionFormat:tsv is no longer supported", N, re), N["x-collectionFormat"] = "tsv"), delete N.collectionFormat), N.type && N.type !== "body" && N.in !== "formData") if (N.items && N.schema) ae("parameter has array,items and schema", N, re);
              else {
                N.schema && re.patches++, N.schema && typeof N.schema == "object" || (N.schema = {}), N.schema.type = N.type, N.items && (N.schema.items = N.items, delete N.items, O(N.schema.items, null, function(K, me, Te) {
                  me === "collectionFormat" && typeof K[me] == "string" && ($ && K[me] !== $ && ae("Nested collectionFormats are not supported", N, re), delete K[me]);
                }));
                for (let K of T.parameterTypeProperties) N[K] !== void 0 && (N.schema[K] = N[K]), delete N[K];
              }
              N.schema && ge(N.schema, re), N["x-ms-skip-url-encoding"] && N.in === "query" && (N.allowReserved = !0, delete N["x-ms-skip-url-encoding"]);
            }
            if (N && N.in === "formData") {
              qe = !1, Oe.content = {};
              let $ = "application/x-www-form-urlencoded";
              if (je.length && je.indexOf("multipart/form-data") >= 0 && ($ = "multipart/form-data"), Oe.content[$] = {}, N.schema) Oe.content[$].schema = N.schema, N.schema.$ref && (Oe["x-s2o-name"] = decodeURIComponent(N.schema.$ref.replace("#/components/schemas/", "")));
              else {
                Oe.content[$].schema = {}, Oe.content[$].schema.type = "object", Oe.content[$].schema.properties = {}, Oe.content[$].schema.properties[N.name] = {};
                let K = Oe.content[$].schema, me = Oe.content[$].schema.properties[N.name];
                N.description && (me.description = N.description), N.example && (me.example = N.example), N.type && (me.type = N.type);
                for (let Te of T.parameterTypeProperties) N[Te] !== void 0 && (me[Te] = N[Te]);
                N.required === !0 && (K.required || (K.required = []), K.required.push(N.name), Oe.required = !0), N.default !== void 0 && (me.default = N.default), me.properties && (me.properties = N.properties), N.allOf && (me.allOf = N.allOf), N.type === "array" && N.items && (me.items = N.items, me.items.collectionFormat && delete me.items.collectionFormat), Pe !== "file" && N["x-s2o-originalType"] !== "file" || (me.type = "string", me.format = "binary"), J(N, me);
              }
            } else N && N.type === "file" && (N.required && (Oe.required = N.required), Oe.content = {}, Oe.content["application/octet-stream"] = {}, Oe.content["application/octet-stream"].schema = {}, Oe.content["application/octet-stream"].schema.type = "string", Oe.content["application/octet-stream"].schema.format = "binary", J(N, Oe));
            if (N && N.in === "body") {
              Oe.content = {}, N.name && (Oe["x-s2o-name"] = (B && B.operationId ? T.sanitiseAll(B.operationId) : "") + ("_" + N.name).toCamelCase()), N.description && (Oe.description = N.description), N.required && (Oe.required = N.required), B && re.rbname && N.name && (B[re.rbname] = N.name), N.schema && N.schema.$ref ? Oe["x-s2o-name"] = decodeURIComponent(N.schema.$ref.replace("#/components/schemas/", "")) : N.schema && N.schema.type === "array" && N.schema.items && N.schema.items.$ref && (Oe["x-s2o-name"] = decodeURIComponent(N.schema.items.$ref.replace("#/components/schemas/", "")) + "Array"), je.length || je.push("application/json");
              for (let $ of je) Oe.content[$] = {}, Oe.content[$].schema = A(N.schema || {}), ge(Oe.content[$].schema, re);
              J(N, Oe);
            }
            if (Object.keys(Oe).length > 0 && (N["x-s2o-delete"] = !0, B) && (B.requestBody && qe ? (B.requestBody["x-s2o-overloaded"] = !0, ae("Operation " + (B.operationId || he) + " has multiple requestBodies", B, re)) : (B.requestBody || (B = oe[ie] = function($, K) {
              let me = {};
              for (let Te of Object.keys($)) me[Te] = $[Te], Te === "parameters" && (me.requestBody = {}, K.rbname && (me[K.rbname] = ""));
              return me.requestBody = {}, me;
            }(B, re)), B.requestBody.content && B.requestBody.content["multipart/form-data"] && B.requestBody.content["multipart/form-data"].schema && B.requestBody.content["multipart/form-data"].schema.properties && Oe.content["multipart/form-data"] && Oe.content["multipart/form-data"].schema && Oe.content["multipart/form-data"].schema.properties ? (B.requestBody.content["multipart/form-data"].schema.properties = Object.assign(B.requestBody.content["multipart/form-data"].schema.properties, Oe.content["multipart/form-data"].schema.properties), B.requestBody.content["multipart/form-data"].schema.required = (B.requestBody.content["multipart/form-data"].schema.required || []).concat(Oe.content["multipart/form-data"].schema.required || []), B.requestBody.content["multipart/form-data"].schema.required.length || delete B.requestBody.content["multipart/form-data"].schema.required) : B.requestBody.content && B.requestBody.content["application/x-www-form-urlencoded"] && B.requestBody.content["application/x-www-form-urlencoded"].schema && B.requestBody.content["application/x-www-form-urlencoded"].schema.properties && Oe.content["application/x-www-form-urlencoded"] && Oe.content["application/x-www-form-urlencoded"].schema && Oe.content["application/x-www-form-urlencoded"].schema.properties ? (B.requestBody.content["application/x-www-form-urlencoded"].schema.properties = Object.assign(B.requestBody.content["application/x-www-form-urlencoded"].schema.properties, Oe.content["application/x-www-form-urlencoded"].schema.properties), B.requestBody.content["application/x-www-form-urlencoded"].schema.required = (B.requestBody.content["application/x-www-form-urlencoded"].schema.required || []).concat(Oe.content["application/x-www-form-urlencoded"].schema.required || []), B.requestBody.content["application/x-www-form-urlencoded"].schema.required.length || delete B.requestBody.content["application/x-www-form-urlencoded"].schema.required) : (B.requestBody = Object.assign(B.requestBody, Oe), B.requestBody["x-s2o-name"] || (B.requestBody.schema && B.requestBody.schema.$ref ? B.requestBody["x-s2o-name"] = decodeURIComponent(B.requestBody.schema.$ref.replace("#/components/schemas/", "")).split("/").join("") : B.operationId && (B.requestBody["x-s2o-name"] = T.sanitiseAll(B.operationId)))))), N && !N["x-s2o-delete"]) {
              delete N.type;
              for (let $ of T.parameterTypeProperties) delete N[$];
              N.in !== "path" || N.required !== void 0 && N.required === !0 || (re.patch ? (re.patches++, N.required = !0) : H("(Patchable) path parameters must be required:true [" + N.name + " in " + he + "]", re));
            }
            return B;
          }
          function J(N, B) {
            for (let oe in N) oe.startsWith("x-") && !oe.startsWith("x-s2o") && (B[oe] = N[oe]);
          }
          function W(N, B, oe, ie, he) {
            if (!N) return !1;
            if (N.$ref && typeof N.$ref == "string") N.$ref.indexOf("#/definitions/") >= 0 ? ae("definition used as response: " + N.$ref, N, he) : N.$ref.startsWith("#/responses/") && (N.$ref = "#/components/responses/" + T.sanitise(decodeURIComponent(N.$ref.replace("#/responses/", ""))));
            else {
              if ((N.description === void 0 || N.description === null || N.description === "" && he.patch) && (he.patch ? typeof N != "object" || Array.isArray(N) || (he.patches++, N.description = j[N] || "") : H("(Patchable) response.description is mandatory", he)), N.schema !== void 0) {
                if (ge(N.schema, he), N.schema.$ref && typeof N.schema.$ref == "string" && N.schema.$ref.startsWith("#/responses/") && (N.schema.$ref = "#/components/responses/" + T.sanitise(decodeURIComponent(N.schema.$ref.replace("#/responses/", "")))), oe && oe.produces && typeof oe.produces == "string") {
                  if (!he.patch) return H("(Patchable) operation.produces must be an array", he);
                  he.patches++, oe.produces = [oe.produces];
                }
                ie.produces && !Array.isArray(ie.produces) && delete ie.produces;
                let Z = ((oe ? oe.produces : null) || ie.produces || []).filter(T.uniqueOnly);
                Z.length || Z.push("*/*"), N.content = {};
                for (let re of Z) {
                  if (N.content[re] = {}, N.content[re].schema = A(N.schema), N.examples && N.examples[re]) {
                    let Pe = {};
                    Pe.value = N.examples[re], N.content[re].examples = {}, N.content[re].examples.response = Pe, delete N.examples[re];
                  }
                  N.content[re].schema.type === "file" && (N.content[re].schema = { type: "string", format: "binary" });
                }
                delete N.schema;
              }
              for (let Z in N.examples) N.content || (N.content = {}), N.content[Z] || (N.content[Z] = {}), N.content[Z].examples = {}, N.content[Z].examples.response = {}, N.content[Z].examples.response.value = N.examples[Z];
              if (delete N.examples, N.headers) for (let Z in N.headers) Z.toLowerCase() === "status code" ? he.patch ? (he.patches++, delete N.headers[Z]) : H('(Patchable) "Status Code" is not a valid header', he) : se(N.headers[Z], he);
            }
          }
          function q(N, B, oe, ie, he) {
            for (let Z in N) {
              let re = N[Z];
              re && re["x-trace"] && typeof re["x-trace"] == "object" && (re.trace = re["x-trace"], delete re["x-trace"]), re && re["x-summary"] && typeof re["x-summary"] == "string" && (re.summary = re["x-summary"], delete re["x-summary"]), re && re["x-description"] && typeof re["x-description"] == "string" && (re.description = re["x-description"], delete re["x-description"]), re && re["x-servers"] && Array.isArray(re["x-servers"]) && (re.servers = re["x-servers"], delete re["x-servers"]);
              for (let Pe in re) if (T.httpMethods.indexOf(Pe) >= 0 || Pe === "x-amazon-apigateway-any-method") {
                let Oe = re[Pe];
                if (Oe && Oe.parameters && Array.isArray(Oe.parameters)) {
                  if (re.parameters) for (let qe of re.parameters) typeof qe.$ref == "string" && (te(qe, oe), qe = b(he, qe.$ref)), Oe.parameters.find(function(je, $, K) {
                    return je.name === qe.name && je.in === qe.in;
                  }) || qe.in !== "formData" && qe.in !== "body" && qe.type !== "file" || (Oe = F(qe, Oe, re, Pe, Z, he, oe), oe.rbname && Oe[oe.rbname] === "" && delete Oe[oe.rbname]);
                  for (let qe of Oe.parameters) Oe = F(qe, Oe, re, Pe, Pe + ":" + Z, he, oe);
                  oe.rbname && Oe[oe.rbname] === "" && delete Oe[oe.rbname], oe.debug || Oe.parameters && (Oe.parameters = Oe.parameters.filter(ce));
                }
                if (Oe && Oe.security && ve(Oe.security), typeof Oe == "object") {
                  if (!Oe.responses) {
                    let qe = { description: "Default response" };
                    Oe.responses = { default: qe };
                  }
                  for (let qe in Oe.responses) W(Oe.responses[qe], 0, Oe, he, oe);
                }
                if (Oe && Oe["x-servers"] && Array.isArray(Oe["x-servers"])) Oe.servers = Oe["x-servers"], delete Oe["x-servers"];
                else if (Oe && Oe.schemes && Oe.schemes.length) {
                  for (let qe of Oe.schemes) if ((!he.schemes || he.schemes.indexOf(qe) < 0) && (Oe.servers || (Oe.servers = []), Array.isArray(he.servers))) for (let je of he.servers) {
                    let $ = A(je), K = m.parse($.url);
                    K.protocol = qe, $.url = K.format(), Oe.servers.push($);
                  }
                }
                if (oe.debug && (Oe["x-s2o-consumes"] = Oe.consumes || [], Oe["x-s2o-produces"] = Oe.produces || []), Oe) {
                  if (delete Oe.consumes, delete Oe.produces, delete Oe.schemes, Oe["x-ms-examples"]) {
                    for (let qe in Oe["x-ms-examples"]) {
                      let je = Oe["x-ms-examples"][qe], $ = T.sanitiseAll(qe);
                      if (je.parameters) for (let K in je.parameters) {
                        let me = je.parameters[K];
                        for (let Te of (Oe.parameters || []).concat(re.parameters || [])) Te.$ref && (Te = k.jptr(he, Te.$ref)), Te.name !== K || Te.example || (Te.examples || (Te.examples = {}), Te.examples[qe] = { value: me });
                      }
                      if (je.responses) for (let K in je.responses) {
                        if (je.responses[K].headers) for (let me in je.responses[K].headers) {
                          let Te = je.responses[K].headers[me];
                          for (let ke in Oe.responses[K].headers) ke === me && (Oe.responses[K].headers[ke].example = Te);
                        }
                        if (je.responses[K].body && (he.components.examples[$] = { value: A(je.responses[K].body) }, Oe.responses[K] && Oe.responses[K].content)) for (let me in Oe.responses[K].content) {
                          let Te = Oe.responses[K].content[me];
                          Te.examples || (Te.examples = {}), Te.examples[qe] = { $ref: "#/components/examples/" + $ };
                        }
                      }
                    }
                    delete Oe["x-ms-examples"];
                  }
                  if (Oe.parameters && Oe.parameters.length === 0 && delete Oe.parameters, Oe.requestBody) {
                    let qe = Oe.operationId ? T.sanitiseAll(Oe.operationId) : T.sanitiseAll(Pe + Z).toCamelCase(), je = T.sanitise(Oe.requestBody["x-s2o-name"] || qe || "");
                    delete Oe.requestBody["x-s2o-name"];
                    let $ = JSON.stringify(Oe.requestBody), K = T.hash($);
                    if (!ie[K]) {
                      let Te = {};
                      Te.name = je, Te.body = Oe.requestBody, Te.refs = [], ie[K] = Te;
                    }
                    let me = "#/" + B + "/" + encodeURIComponent(k.jpescape(Z)) + "/" + Pe + "/requestBody";
                    ie[K].refs.push(me);
                  }
                }
              }
              if (re && re.parameters) {
                for (let Pe in re.parameters) F(re.parameters[Pe], null, re, null, Z, he, oe);
                !oe.debug && Array.isArray(re.parameters) && (re.parameters = re.parameters.filter(ce));
              }
            }
          }
          function X(N) {
            return N && N.url && typeof N.url == "string" && (N.url = N.url.split("{{").join("{"), N.url = N.url.split("}}").join("}"), N.url.replace(/\{(.+?)\}/g, function(B, oe) {
              N.variables || (N.variables = {}), N.variables[oe] = { default: "unknown" };
            })), N;
          }
          function Q(N, B, oe) {
            if (N.info === void 0 || N.info === null) {
              if (!B.patch) return oe(new ne("(Patchable) info object is mandatory"));
              B.patches++, N.info = { version: "", title: "" };
            }
            if (typeof N.info != "object" || Array.isArray(N.info)) return oe(new ne("info must be an object"));
            if (N.info.title === void 0 || N.info.title === null) {
              if (!B.patch) return oe(new ne("(Patchable) info.title cannot be null"));
              B.patches++, N.info.title = "";
            }
            if (N.info.version === void 0 || N.info.version === null) {
              if (!B.patch) return oe(new ne("(Patchable) info.version cannot be null"));
              B.patches++, N.info.version = "";
            }
            if (typeof N.info.version != "string") {
              if (!B.patch) return oe(new ne("(Patchable) info.version must be a string"));
              B.patches++, N.info.version = N.info.version.toString();
            }
            if (N.info.logo !== void 0) {
              if (!B.patch) return oe(new ne("(Patchable) info should not have logo property"));
              B.patches++, N.info["x-logo"] = N.info.logo, delete N.info.logo;
            }
            if (N.info.termsOfService !== void 0) {
              if (N.info.termsOfService === null) {
                if (!B.patch) return oe(new ne("(Patchable) info.termsOfService cannot be null"));
                B.patches++, N.info.termsOfService = "";
              }
              try {
                new URL(N.info.termsOfService);
              } catch {
                if (!B.patch) return oe(new ne("(Patchable) info.termsOfService must be a URL"));
                B.patches++, delete N.info.termsOfService;
              }
            }
          }
          function ye(N, B, oe) {
            if (N.paths === void 0) {
              if (!B.patch) return oe(new ne("(Patchable) paths object is mandatory"));
              B.patches++, N.paths = {};
            }
          }
          function Se(N, B, oe) {
            return g(oe, new Promise(function(ie, he) {
              if (N || (N = {}), B.original = N, B.text || (B.text = S.stringify(N)), B.externals = [], B.externalRefs = {}, B.rewriteRefs = !0, B.preserveMiro = !0, B.promise = {}, B.promise.resolve = ie, B.promise.reject = he, B.patches = 0, B.cache || (B.cache = {}), B.source && (B.cache[B.source] = B.original), function(re, Pe) {
                const Oe = /* @__PURE__ */ new WeakSet();
                O(re, { identityDetection: !0 }, function(qe, je, $) {
                  typeof qe[je] == "object" && qe[je] !== null && (Oe.has(qe[je]) ? Pe.anchors ? qe[je] = A(qe[je]) : H("YAML anchor or merge key at " + $.path, Pe) : Oe.add(qe[je]));
                });
              }(N, B), N.openapi && typeof N.openapi == "string" && N.openapi.startsWith("3.")) return B.openapi = _(N), Q(B.openapi, B, he), ye(B.openapi, B, he), void R.optionalResolve(B).then(function() {
                return B.direct ? ie(B.openapi) : ie(B);
              }).catch(function(re) {
                console.warn(re), he(re);
              });
              if (!N.swagger || N.swagger != "2.0") return he(new ne("Unsupported swagger/OpenAPI version: " + (N.openapi ? N.openapi : N.swagger)));
              let Z = B.openapi = {};
              if (Z.openapi = typeof B.targetVersion == "string" && B.targetVersion.startsWith("3.") ? B.targetVersion : V, B.origin) {
                Z["x-origin"] || (Z["x-origin"] = []);
                let re = {};
                re.url = B.source || B.origin, re.format = "swagger", re.version = N.swagger, re.converter = {}, re.converter.url = "https://github.com/mermade/oas-kit", re.converter.version = D, Z["x-origin"].push(re);
              }
              if (Z = Object.assign(Z, _(N)), delete Z.swagger, O(Z, {}, function(re, Pe, Oe) {
                re[Pe] === null && !Pe.startsWith("x-") && Pe !== "default" && Oe.path.indexOf("/example") < 0 && delete re[Pe];
              }), N.host) for (let re of Array.isArray(N.schemes) ? N.schemes : [""]) {
                let Pe = {}, Oe = (N.basePath || "").replace(/\/$/, "");
                Pe.url = (re ? re + ":" : "") + "//" + N.host + Oe, X(Pe), Z.servers || (Z.servers = []), Z.servers.push(Pe);
              }
              else if (N.basePath) {
                let re = {};
                re.url = N.basePath, X(re), Z.servers || (Z.servers = []), Z.servers.push(re);
              }
              if (delete Z.host, delete Z.basePath, Z["x-servers"] && Array.isArray(Z["x-servers"]) && (Z.servers = Z["x-servers"], delete Z["x-servers"]), N["x-ms-parameterized-host"]) {
                let re = N["x-ms-parameterized-host"], Pe = {};
                Pe.url = re.hostTemplate + (N.basePath ? N.basePath : ""), Pe.variables = {};
                const Oe = Pe.url.match(/\{\w+\}/g);
                for (let qe in re.parameters) {
                  let je = re.parameters[qe];
                  je.$ref && (je = A(b(Z, je.$ref))), qe.startsWith("x-") || (delete je.required, delete je.type, delete je.in, je.default === void 0 && (je.enum ? je.default = je.enum[0] : je.default = "none"), je.name || (je.name = Oe[qe].replace("{", "").replace("}", "")), Pe.variables[je.name] = je, delete je.name);
                }
                Z.servers || (Z.servers = []), re.useSchemePrefix === !1 ? Z.servers.push(Pe) : N.schemes.forEach((qe) => {
                  Z.servers.push(Object.assign({}, Pe, { url: qe + "://" + Pe.url }));
                }), delete Z["x-ms-parameterized-host"];
              }
              Q(Z, B, he), ye(Z, B, he), typeof Z.consumes == "string" && (Z.consumes = [Z.consumes]), typeof Z.produces == "string" && (Z.produces = [Z.produces]), Z.components = {}, Z["x-callbacks"] && (Z.components.callbacks = Z["x-callbacks"], delete Z["x-callbacks"]), Z.components.examples = {}, Z.components.headers = {}, Z["x-links"] && (Z.components.links = Z["x-links"], delete Z["x-links"]), Z.components.parameters = Z.parameters || {}, Z.components.responses = Z.responses || {}, Z.components.requestBodies = {}, Z.components.securitySchemes = Z.securityDefinitions || {}, Z.components.schemas = Z.definitions || {}, delete Z.definitions, delete Z.responses, delete Z.parameters, delete Z.securityDefinitions, R.optionalResolve(B).then(function() {
                (function(re, Pe) {
                  let Oe = {};
                  U = { schemas: {} }, re.security && ve(re.security);
                  for (let je in re.components.securitySchemes) {
                    let $ = T.sanitise(je);
                    je !== $ && (re.components.securitySchemes[$] && H("Duplicate sanitised securityScheme name " + $, Pe), re.components.securitySchemes[$] = re.components.securitySchemes[je], delete re.components.securitySchemes[je]), $e(re.components.securitySchemes[$], Pe);
                  }
                  for (let je in re.components.schemas) {
                    let $ = T.sanitiseAll(je), K = "";
                    if (je !== $) {
                      for (; re.components.schemas[$ + K]; ) K = K ? ++K : 2;
                      re.components.schemas[$ + K] = re.components.schemas[je], delete re.components.schemas[je];
                    }
                    U.schemas[je] = $ + K, ge(re.components.schemas[$ + K], Pe);
                  }
                  Pe.refmap = {}, O(re, { payload: { options: Pe } }, fe), function(je, $) {
                    for (let K in $.refmap) k.jptr(je, K, { $ref: $.refmap[K] });
                  }(re, Pe);
                  for (let je in re.components.parameters) {
                    let $ = T.sanitise(je);
                    je !== $ && (re.components.parameters[$] && H("Duplicate sanitised parameter name " + $, Pe), re.components.parameters[$] = re.components.parameters[je], delete re.components.parameters[je]), F(re.components.parameters[$], null, null, null, $, re, Pe);
                  }
                  for (let je in re.components.responses) {
                    let $ = T.sanitise(je);
                    je !== $ && (re.components.responses[$] && H("Duplicate sanitised response name " + $, Pe), re.components.responses[$] = re.components.responses[je], delete re.components.responses[je]);
                    let K = re.components.responses[$];
                    if (W(K, 0, null, re, Pe), K.headers) for (let me in K.headers) me.toLowerCase() === "status code" ? Pe.patch ? (Pe.patches++, delete K.headers[me]) : H('(Patchable) "Status Code" is not a valid header', Pe) : se(K.headers[me], Pe);
                  }
                  for (let je in re.components.requestBodies) {
                    let $ = re.components.requestBodies[je], K = JSON.stringify($), me = T.hash(K), Te = {};
                    Te.name = je, Te.body = $, Te.refs = [], Oe[me] = Te;
                  }
                  if (q(re.paths, "paths", Pe, Oe, re), re["x-ms-paths"] && q(re["x-ms-paths"], "x-ms-paths", Pe, Oe, re), !Pe.debug) for (let je in re.components.parameters) re.components.parameters[je]["x-s2o-delete"] && delete re.components.parameters[je];
                  Pe.debug && (re["x-s2o-consumes"] = re.consumes || [], re["x-s2o-produces"] = re.produces || []), delete re.consumes, delete re.produces, delete re.schemes;
                  let qe = [];
                  if (re.components.requestBodies = {}, !Pe.resolveInternal) {
                    let je = 1;
                    for (let $ in Oe) {
                      let K = Oe[$];
                      if (K.refs.length > 1) {
                        let me = "";
                        for (K.name || (K.name = "requestBody", me = je++); qe.indexOf(K.name + me) >= 0; ) me = me ? ++me : 2;
                        K.name = K.name + me, qe.push(K.name), re.components.requestBodies[K.name] = A(K.body);
                        for (let Te in K.refs) {
                          let ke = {};
                          ke.$ref = "#/components/requestBodies/" + K.name, k.jptr(re, K.refs[Te], ke);
                        }
                      }
                    }
                  }
                  re.components.responses && Object.keys(re.components.responses).length === 0 && delete re.components.responses, re.components.parameters && Object.keys(re.components.parameters).length === 0 && delete re.components.parameters, re.components.examples && Object.keys(re.components.examples).length === 0 && delete re.components.examples, re.components.requestBodies && Object.keys(re.components.requestBodies).length === 0 && delete re.components.requestBodies, re.components.securitySchemes && Object.keys(re.components.securitySchemes).length === 0 && delete re.components.securitySchemes, re.components.headers && Object.keys(re.components.headers).length === 0 && delete re.components.headers, re.components.schemas && Object.keys(re.components.schemas).length === 0 && delete re.components.schemas, re.components && Object.keys(re.components).length === 0 && delete re.components;
                })(B.openapi, B), B.direct ? ie(B.openapi) : ie(B);
              }).catch(function(re) {
                console.warn(re), he(re);
              });
            }));
          }
          function Ne(N, B, oe) {
            return g(oe, new Promise(function(ie, he) {
              let Z = null, re = null;
              try {
                Z = JSON.parse(N), B.text = JSON.stringify(Z, null, 2);
              } catch (Pe) {
                re = Pe;
                try {
                  Z = S.parse(N, { schema: "core", prettyErrors: !0 }), B.sourceYaml = !0, B.text = N;
                } catch (Oe) {
                  re = Oe;
                }
              }
              Z ? Se(Z, B).then((Pe) => ie(Pe)).catch((Pe) => he(Pe)) : he(new ne(re ? re.message : "Could not parse string"));
            }));
          }
          i.exports = { S2OError: ne, targetVersion: V, convert: Se, convertObj: Se, convertUrl: function(N, B, oe) {
            return g(oe, new Promise(function(ie, he) {
              B.origin = !0, B.source || (B.source = N), B.verbose && console.warn("GET " + N), B.fetch || (B.fetch = v);
              const Z = Object.assign({}, B.fetchOptions, { agent: B.agent });
              B.fetch(N, Z).then(function(re) {
                if (re.status !== 200) throw new ne(`Received status code ${re.status}: ${N}`);
                return re.text();
              }).then(function(re) {
                Ne(re, B).then((Pe) => ie(Pe)).catch((Pe) => he(Pe));
              }).catch(function(re) {
                he(re);
              });
            }));
          }, convertStr: Ne, convertFile: function(N, B, oe) {
            return g(oe, new Promise(function(ie, he) {
              d.readFile(N, B.encoding || "utf8", function(Z, re) {
                Z ? he(Z) : (B.sourceFile = N, Ne(re, B).then((Pe) => ie(Pe)).catch((Pe) => he(Pe)));
              });
            }));
          }, convertStream: function(N, B, oe) {
            return g(oe, new Promise(function(ie, he) {
              let Z = "";
              N.on("data", function(re) {
                Z += re;
              }).on("end", function() {
                Ne(Z, B).then((re) => ie(re)).catch((re) => he(re));
              });
            }));
          } };
        }, 665: function(i, u, c) {
          const d = c(375);
          i.exports = { statusCodes: Object.assign({}, { default: "Default response", "1XX": "Informational", 103: "Early hints", "2XX": "Successful", "3XX": "Redirection", "4XX": "Client Error", "5XX": "Server Error", "7XX": "Developer Error" }, d.STATUS_CODES) };
        }, 988: function(i, u, c) {
          var d = c(7), m = ["add", "done", "toJS", "fromExternalJS", "load", "dispose", "search", "Worker"];
          i.exports = function() {
            var g = new Worker(URL.createObjectURL(new Blob([`/*! For license information please see cfb294d7f6536ffa8d42.worker.js.LICENSE.txt */
!function(){var e={291:function(e,t,r){var n,i;!function(){var s,o,a,u,l,c,h,d,f,p,y,m,g,x,v,w,Q,k,S,E,L,P,b,T,O,I,R,F,C,N,j=function(e){var t=new j.Builder;return t.pipeline.add(j.trimmer,j.stopWordFilter,j.stemmer),t.searchPipeline.add(j.stemmer),e.call(t,t),t.build()};j.version="2.3.9",j.utils={},j.utils.warn=(s=this,function(e){s.console&&console.warn&&console.warn(e)}),j.utils.asString=function(e){return null==e?"":e.toString()},j.utils.clone=function(e){if(null==e)return e;for(var t=Object.create(null),r=Object.keys(e),n=0;n<r.length;n++){var i=r[n],s=e[i];if(Array.isArray(s))t[i]=s.slice();else{if("string"!=typeof s&&"number"!=typeof s&&"boolean"!=typeof s)throw new TypeError("clone is not deep and does not support nested objects");t[i]=s}}return t},j.FieldRef=function(e,t,r){this.docRef=e,this.fieldName=t,this._stringValue=r},j.FieldRef.joiner="/",j.FieldRef.fromString=function(e){var t=e.indexOf(j.FieldRef.joiner);if(-1===t)throw"malformed field ref string";var r=e.slice(0,t),n=e.slice(t+1);return new j.FieldRef(n,r,e)},j.FieldRef.prototype.toString=function(){return null==this._stringValue&&(this._stringValue=this.fieldName+j.FieldRef.joiner+this.docRef),this._stringValue},j.Set=function(e){if(this.elements=Object.create(null),e){this.length=e.length;for(var t=0;t<this.length;t++)this.elements[e[t]]=!0}else this.length=0},j.Set.complete={intersect:function(e){return e},union:function(){return this},contains:function(){return!0}},j.Set.empty={intersect:function(){return this},union:function(e){return e},contains:function(){return!1}},j.Set.prototype.contains=function(e){return!!this.elements[e]},j.Set.prototype.intersect=function(e){var t,r,n,i=[];if(e===j.Set.complete)return this;if(e===j.Set.empty)return e;this.length<e.length?(t=this,r=e):(t=e,r=this),n=Object.keys(t.elements);for(var s=0;s<n.length;s++){var o=n[s];o in r.elements&&i.push(o)}return new j.Set(i)},j.Set.prototype.union=function(e){return e===j.Set.complete?j.Set.complete:e===j.Set.empty?this:new j.Set(Object.keys(this.elements).concat(Object.keys(e.elements)))},j.idf=function(e,t){var r=0;for(var n in e)"_index"!=n&&(r+=Object.keys(e[n]).length);var i=(t-r+.5)/(r+.5);return Math.log(1+Math.abs(i))},j.Token=function(e,t){this.str=e||"",this.metadata=t||{}},j.Token.prototype.toString=function(){return this.str},j.Token.prototype.update=function(e){return this.str=e(this.str,this.metadata),this},j.Token.prototype.clone=function(e){return e=e||function(e){return e},new j.Token(e(this.str,this.metadata),this.metadata)},j.tokenizer=function(e,t){if(null==e||null==e)return[];if(Array.isArray(e))return e.map((function(e){return new j.Token(j.utils.asString(e).toLowerCase(),j.utils.clone(t))}));for(var r=e.toString().toLowerCase(),n=r.length,i=[],s=0,o=0;s<=n;s++){var a=s-o;if(r.charAt(s).match(j.tokenizer.separator)||s==n){if(a>0){var u=j.utils.clone(t)||{};u.position=[o,a],u.index=i.length,i.push(new j.Token(r.slice(o,s),u))}o=s+1}}return i},j.tokenizer.separator=/[\\s\\-]+/,j.Pipeline=function(){this._stack=[]},j.Pipeline.registeredFunctions=Object.create(null),j.Pipeline.registerFunction=function(e,t){t in this.registeredFunctions&&j.utils.warn("Overwriting existing registered function: "+t),e.label=t,j.Pipeline.registeredFunctions[e.label]=e},j.Pipeline.warnIfFunctionNotRegistered=function(e){e.label&&e.label in this.registeredFunctions||j.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\\n",e)},j.Pipeline.load=function(e){var t=new j.Pipeline;return e.forEach((function(e){var r=j.Pipeline.registeredFunctions[e];if(!r)throw new Error("Cannot load unregistered function: "+e);t.add(r)})),t},j.Pipeline.prototype.add=function(){Array.prototype.slice.call(arguments).forEach((function(e){j.Pipeline.warnIfFunctionNotRegistered(e),this._stack.push(e)}),this)},j.Pipeline.prototype.after=function(e,t){j.Pipeline.warnIfFunctionNotRegistered(t);var r=this._stack.indexOf(e);if(-1==r)throw new Error("Cannot find existingFn");r+=1,this._stack.splice(r,0,t)},j.Pipeline.prototype.before=function(e,t){j.Pipeline.warnIfFunctionNotRegistered(t);var r=this._stack.indexOf(e);if(-1==r)throw new Error("Cannot find existingFn");this._stack.splice(r,0,t)},j.Pipeline.prototype.remove=function(e){var t=this._stack.indexOf(e);-1!=t&&this._stack.splice(t,1)},j.Pipeline.prototype.run=function(e){for(var t=this._stack.length,r=0;r<t;r++){for(var n=this._stack[r],i=[],s=0;s<e.length;s++){var o=n(e[s],s,e);if(null!=o&&""!==o)if(Array.isArray(o))for(var a=0;a<o.length;a++)i.push(o[a]);else i.push(o)}e=i}return e},j.Pipeline.prototype.runString=function(e,t){var r=new j.Token(e,t);return this.run([r]).map((function(e){return e.toString()}))},j.Pipeline.prototype.reset=function(){this._stack=[]},j.Pipeline.prototype.toJSON=function(){return this._stack.map((function(e){return j.Pipeline.warnIfFunctionNotRegistered(e),e.label}))},j.Vector=function(e){this._magnitude=0,this.elements=e||[]},j.Vector.prototype.positionForIndex=function(e){if(0==this.elements.length)return 0;for(var t=0,r=this.elements.length/2,n=r-t,i=Math.floor(n/2),s=this.elements[2*i];n>1&&(s<e&&(t=i),s>e&&(r=i),s!=e);)n=r-t,i=t+Math.floor(n/2),s=this.elements[2*i];return s==e||s>e?2*i:s<e?2*(i+1):void 0},j.Vector.prototype.insert=function(e,t){this.upsert(e,t,(function(){throw"duplicate index"}))},j.Vector.prototype.upsert=function(e,t,r){this._magnitude=0;var n=this.positionForIndex(e);this.elements[n]==e?this.elements[n+1]=r(this.elements[n+1],t):this.elements.splice(n,0,e,t)},j.Vector.prototype.magnitude=function(){if(this._magnitude)return this._magnitude;for(var e=0,t=this.elements.length,r=1;r<t;r+=2){var n=this.elements[r];e+=n*n}return this._magnitude=Math.sqrt(e)},j.Vector.prototype.dot=function(e){for(var t=0,r=this.elements,n=e.elements,i=r.length,s=n.length,o=0,a=0,u=0,l=0;u<i&&l<s;)(o=r[u])<(a=n[l])?u+=2:o>a?l+=2:o==a&&(t+=r[u+1]*n[l+1],u+=2,l+=2);return t},j.Vector.prototype.similarity=function(e){return this.dot(e)/this.magnitude()||0},j.Vector.prototype.toArray=function(){for(var e=new Array(this.elements.length/2),t=1,r=0;t<this.elements.length;t+=2,r++)e[r]=this.elements[t];return e},j.Vector.prototype.toJSON=function(){return this.elements},j.stemmer=(o={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},a={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},h="^("+(l="[^aeiou][^aeiouy]*")+")?"+(c=(u="[aeiouy]")+"[aeiou]*")+l+"("+c+")?$",d="^("+l+")?"+c+l+c+l,f="^("+l+")?"+u,p=new RegExp("^("+l+")?"+c+l),y=new RegExp(d),m=new RegExp(h),g=new RegExp(f),x=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,w=/^(.+?)eed$/,Q=/^(.+?)(ed|ing)$/,k=/.$/,S=/(at|bl|iz)$/,E=new RegExp("([^aeiouylsz])\\\\1$"),L=new RegExp("^"+l+u+"[^aeiouwxy]$"),P=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,T=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,O=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,I=/^(.+?)(s|t)(ion)$/,R=/^(.+?)e$/,F=/ll$/,C=new RegExp("^"+l+u+"[^aeiouwxy]$"),N=function(e){var t,r,n,i,s,u,l;if(e.length<3)return e;if("y"==(n=e.substr(0,1))&&(e=n.toUpperCase()+e.substr(1)),s=v,(i=x).test(e)?e=e.replace(i,"$1$2"):s.test(e)&&(e=e.replace(s,"$1$2")),s=Q,(i=w).test(e)){var c=i.exec(e);(i=p).test(c[1])&&(i=k,e=e.replace(i,""))}else s.test(e)&&(t=(c=s.exec(e))[1],(s=g).test(t)&&(u=E,l=L,(s=S).test(e=t)?e+="e":u.test(e)?(i=k,e=e.replace(i,"")):l.test(e)&&(e+="e")));return(i=P).test(e)&&(e=(t=(c=i.exec(e))[1])+"i"),(i=b).test(e)&&(t=(c=i.exec(e))[1],r=c[2],(i=p).test(t)&&(e=t+o[r])),(i=T).test(e)&&(t=(c=i.exec(e))[1],r=c[2],(i=p).test(t)&&(e=t+a[r])),s=I,(i=O).test(e)?(t=(c=i.exec(e))[1],(i=y).test(t)&&(e=t)):s.test(e)&&(t=(c=s.exec(e))[1]+c[2],(s=y).test(t)&&(e=t)),(i=R).test(e)&&(t=(c=i.exec(e))[1],s=m,u=C,((i=y).test(t)||s.test(t)&&!u.test(t))&&(e=t)),s=y,(i=F).test(e)&&s.test(e)&&(i=k,e=e.replace(i,"")),"y"==n&&(e=n.toLowerCase()+e.substr(1)),e},function(e){return e.update(N)}),j.Pipeline.registerFunction(j.stemmer,"stemmer"),j.generateStopWordFilter=function(e){var t=e.reduce((function(e,t){return e[t]=t,e}),{});return function(e){if(e&&t[e.toString()]!==e.toString())return e}},j.stopWordFilter=j.generateStopWordFilter(["a","able","about","across","after","all","almost","also","am","among","an","and","any","are","as","at","be","because","been","but","by","can","cannot","could","dear","did","do","does","either","else","ever","every","for","from","get","got","had","has","have","he","her","hers","him","his","how","however","i","if","in","into","is","it","its","just","least","let","like","likely","may","me","might","most","must","my","neither","no","nor","not","of","off","often","on","only","or","other","our","own","rather","said","say","says","she","should","since","so","some","than","that","the","their","them","then","there","these","they","this","tis","to","too","twas","us","wants","was","we","were","what","when","where","which","while","who","whom","why","will","with","would","yet","you","your"]),j.Pipeline.registerFunction(j.stopWordFilter,"stopWordFilter"),j.trimmer=function(e){return e.update((function(e){return e.replace(/^\\W+/,"").replace(/\\W+$/,"")}))},j.Pipeline.registerFunction(j.trimmer,"trimmer"),j.TokenSet=function(){this.final=!1,this.edges={},this.id=j.TokenSet._nextId,j.TokenSet._nextId+=1},j.TokenSet._nextId=1,j.TokenSet.fromArray=function(e){for(var t=new j.TokenSet.Builder,r=0,n=e.length;r<n;r++)t.insert(e[r]);return t.finish(),t.root},j.TokenSet.fromClause=function(e){return"editDistance"in e?j.TokenSet.fromFuzzyString(e.term,e.editDistance):j.TokenSet.fromString(e.term)},j.TokenSet.fromFuzzyString=function(e,t){for(var r=new j.TokenSet,n=[{node:r,editsRemaining:t,str:e}];n.length;){var i=n.pop();if(i.str.length>0){var s,o=i.str.charAt(0);o in i.node.edges?s=i.node.edges[o]:(s=new j.TokenSet,i.node.edges[o]=s),1==i.str.length&&(s.final=!0),n.push({node:s,editsRemaining:i.editsRemaining,str:i.str.slice(1)})}if(0!=i.editsRemaining){if("*"in i.node.edges)var a=i.node.edges["*"];else a=new j.TokenSet,i.node.edges["*"]=a;if(0==i.str.length&&(a.final=!0),n.push({node:a,editsRemaining:i.editsRemaining-1,str:i.str}),i.str.length>1&&n.push({node:i.node,editsRemaining:i.editsRemaining-1,str:i.str.slice(1)}),1==i.str.length&&(i.node.final=!0),i.str.length>=1){if("*"in i.node.edges)var u=i.node.edges["*"];else u=new j.TokenSet,i.node.edges["*"]=u;1==i.str.length&&(u.final=!0),n.push({node:u,editsRemaining:i.editsRemaining-1,str:i.str.slice(1)})}if(i.str.length>1){var l,c=i.str.charAt(0),h=i.str.charAt(1);h in i.node.edges?l=i.node.edges[h]:(l=new j.TokenSet,i.node.edges[h]=l),1==i.str.length&&(l.final=!0),n.push({node:l,editsRemaining:i.editsRemaining-1,str:c+i.str.slice(2)})}}}return r},j.TokenSet.fromString=function(e){for(var t=new j.TokenSet,r=t,n=0,i=e.length;n<i;n++){var s=e[n],o=n==i-1;if("*"==s)t.edges[s]=t,t.final=o;else{var a=new j.TokenSet;a.final=o,t.edges[s]=a,t=a}}return r},j.TokenSet.prototype.toArray=function(){for(var e=[],t=[{prefix:"",node:this}];t.length;){var r=t.pop(),n=Object.keys(r.node.edges),i=n.length;r.node.final&&(r.prefix.charAt(0),e.push(r.prefix));for(var s=0;s<i;s++){var o=n[s];t.push({prefix:r.prefix.concat(o),node:r.node.edges[o]})}}return e},j.TokenSet.prototype.toString=function(){if(this._str)return this._str;for(var e=this.final?"1":"0",t=Object.keys(this.edges).sort(),r=t.length,n=0;n<r;n++){var i=t[n];e=e+i+this.edges[i].id}return e},j.TokenSet.prototype.intersect=function(e){for(var t=new j.TokenSet,r=void 0,n=[{qNode:e,output:t,node:this}];n.length;){r=n.pop();for(var i=Object.keys(r.qNode.edges),s=i.length,o=Object.keys(r.node.edges),a=o.length,u=0;u<s;u++)for(var l=i[u],c=0;c<a;c++){var h=o[c];if(h==l||"*"==l){var d=r.node.edges[h],f=r.qNode.edges[l],p=d.final&&f.final,y=void 0;h in r.output.edges?(y=r.output.edges[h]).final=y.final||p:((y=new j.TokenSet).final=p,r.output.edges[h]=y),n.push({qNode:f,output:y,node:d})}}}return t},j.TokenSet.Builder=function(){this.previousWord="",this.root=new j.TokenSet,this.uncheckedNodes=[],this.minimizedNodes={}},j.TokenSet.Builder.prototype.insert=function(e){var t,r=0;if(e<this.previousWord)throw new Error("Out of order word insertion");for(var n=0;n<e.length&&n<this.previousWord.length&&e[n]==this.previousWord[n];n++)r++;for(this.minimize(r),t=0==this.uncheckedNodes.length?this.root:this.uncheckedNodes[this.uncheckedNodes.length-1].child,n=r;n<e.length;n++){var i=new j.TokenSet,s=e[n];t.edges[s]=i,this.uncheckedNodes.push({parent:t,char:s,child:i}),t=i}t.final=!0,this.previousWord=e},j.TokenSet.Builder.prototype.finish=function(){this.minimize(0)},j.TokenSet.Builder.prototype.minimize=function(e){for(var t=this.uncheckedNodes.length-1;t>=e;t--){var r=this.uncheckedNodes[t],n=r.child.toString();n in this.minimizedNodes?r.parent.edges[r.char]=this.minimizedNodes[n]:(r.child._str=n,this.minimizedNodes[n]=r.child),this.uncheckedNodes.pop()}},j.Index=function(e){this.invertedIndex=e.invertedIndex,this.fieldVectors=e.fieldVectors,this.tokenSet=e.tokenSet,this.fields=e.fields,this.pipeline=e.pipeline},j.Index.prototype.search=function(e){return this.query((function(t){new j.QueryParser(e,t).parse()}))},j.Index.prototype.query=function(e){for(var t=new j.Query(this.fields),r=Object.create(null),n=Object.create(null),i=Object.create(null),s=Object.create(null),o=Object.create(null),a=0;a<this.fields.length;a++)n[this.fields[a]]=new j.Vector;for(e.call(t,t),a=0;a<t.clauses.length;a++){var u,l=t.clauses[a],c=j.Set.empty;u=l.usePipeline?this.pipeline.runString(l.term,{fields:l.fields}):[l.term];for(var h=0;h<u.length;h++){var d=u[h];l.term=d;var f=j.TokenSet.fromClause(l),p=this.tokenSet.intersect(f).toArray();if(0===p.length&&l.presence===j.Query.presence.REQUIRED){for(var y=0;y<l.fields.length;y++)s[R=l.fields[y]]=j.Set.empty;break}for(var m=0;m<p.length;m++){var g=p[m],x=this.invertedIndex[g],v=x._index;for(y=0;y<l.fields.length;y++){var w=x[R=l.fields[y]],Q=Object.keys(w),k=g+"/"+R,S=new j.Set(Q);if(l.presence==j.Query.presence.REQUIRED&&(c=c.union(S),void 0===s[R]&&(s[R]=j.Set.complete)),l.presence!=j.Query.presence.PROHIBITED){if(n[R].upsert(v,l.boost,(function(e,t){return e+t})),!i[k]){for(var E=0;E<Q.length;E++){var L,P=Q[E],b=new j.FieldRef(P,R),T=w[P];void 0===(L=r[b])?r[b]=new j.MatchData(g,R,T):L.add(g,R,T)}i[k]=!0}}else void 0===o[R]&&(o[R]=j.Set.empty),o[R]=o[R].union(S)}}}if(l.presence===j.Query.presence.REQUIRED)for(y=0;y<l.fields.length;y++)s[R=l.fields[y]]=s[R].intersect(c)}var O=j.Set.complete,I=j.Set.empty;for(a=0;a<this.fields.length;a++){var R;s[R=this.fields[a]]&&(O=O.intersect(s[R])),o[R]&&(I=I.union(o[R]))}var F=Object.keys(r),C=[],N=Object.create(null);if(t.isNegated())for(F=Object.keys(this.fieldVectors),a=0;a<F.length;a++){b=F[a];var _=j.FieldRef.fromString(b);r[b]=new j.MatchData}for(a=0;a<F.length;a++){var D=(_=j.FieldRef.fromString(F[a])).docRef;if(O.contains(D)&&!I.contains(D)){var A,B=this.fieldVectors[_],z=n[_.fieldName].similarity(B);if(void 0!==(A=N[D]))A.score+=z,A.matchData.combine(r[_]);else{var V={ref:D,score:z,matchData:r[_]};N[D]=V,C.push(V)}}}return C.sort((function(e,t){return t.score-e.score}))},j.Index.prototype.toJSON=function(){var e=Object.keys(this.invertedIndex).sort().map((function(e){return[e,this.invertedIndex[e]]}),this),t=Object.keys(this.fieldVectors).map((function(e){return[e,this.fieldVectors[e].toJSON()]}),this);return{version:j.version,fields:this.fields,fieldVectors:t,invertedIndex:e,pipeline:this.pipeline.toJSON()}},j.Index.load=function(e){var t={},r={},n=e.fieldVectors,i=Object.create(null),s=e.invertedIndex,o=new j.TokenSet.Builder,a=j.Pipeline.load(e.pipeline);e.version!=j.version&&j.utils.warn("Version mismatch when loading serialised index. Current version of lunr '"+j.version+"' does not match serialized index '"+e.version+"'");for(var u=0;u<n.length;u++){var l=(h=n[u])[0],c=h[1];r[l]=new j.Vector(c)}for(u=0;u<s.length;u++){var h,d=(h=s[u])[0],f=h[1];o.insert(d),i[d]=f}return o.finish(),t.fields=e.fields,t.fieldVectors=r,t.invertedIndex=i,t.tokenSet=o.root,t.pipeline=a,new j.Index(t)},j.Builder=function(){this._ref="id",this._fields=Object.create(null),this._documents=Object.create(null),this.invertedIndex=Object.create(null),this.fieldTermFrequencies={},this.fieldLengths={},this.tokenizer=j.tokenizer,this.pipeline=new j.Pipeline,this.searchPipeline=new j.Pipeline,this.documentCount=0,this._b=.75,this._k1=1.2,this.termIndex=0,this.metadataWhitelist=[]},j.Builder.prototype.ref=function(e){this._ref=e},j.Builder.prototype.field=function(e,t){if(/\\//.test(e))throw new RangeError("Field '"+e+"' contains illegal character '/'");this._fields[e]=t||{}},j.Builder.prototype.b=function(e){this._b=e<0?0:e>1?1:e},j.Builder.prototype.k1=function(e){this._k1=e},j.Builder.prototype.add=function(e,t){var r=e[this._ref],n=Object.keys(this._fields);this._documents[r]=t||{},this.documentCount+=1;for(var i=0;i<n.length;i++){var s=n[i],o=this._fields[s].extractor,a=o?o(e):e[s],u=this.tokenizer(a,{fields:[s]}),l=this.pipeline.run(u),c=new j.FieldRef(r,s),h=Object.create(null);this.fieldTermFrequencies[c]=h,this.fieldLengths[c]=0,this.fieldLengths[c]+=l.length;for(var d=0;d<l.length;d++){var f=l[d];if(null==h[f]&&(h[f]=0),h[f]+=1,null==this.invertedIndex[f]){var p=Object.create(null);p._index=this.termIndex,this.termIndex+=1;for(var y=0;y<n.length;y++)p[n[y]]=Object.create(null);this.invertedIndex[f]=p}null==this.invertedIndex[f][s][r]&&(this.invertedIndex[f][s][r]=Object.create(null));for(var m=0;m<this.metadataWhitelist.length;m++){var g=this.metadataWhitelist[m],x=f.metadata[g];null==this.invertedIndex[f][s][r][g]&&(this.invertedIndex[f][s][r][g]=[]),this.invertedIndex[f][s][r][g].push(x)}}}},j.Builder.prototype.calculateAverageFieldLengths=function(){for(var e=Object.keys(this.fieldLengths),t=e.length,r={},n={},i=0;i<t;i++){var s=j.FieldRef.fromString(e[i]),o=s.fieldName;n[o]||(n[o]=0),n[o]+=1,r[o]||(r[o]=0),r[o]+=this.fieldLengths[s]}var a=Object.keys(this._fields);for(i=0;i<a.length;i++){var u=a[i];r[u]=r[u]/n[u]}this.averageFieldLength=r},j.Builder.prototype.createFieldVectors=function(){for(var e={},t=Object.keys(this.fieldTermFrequencies),r=t.length,n=Object.create(null),i=0;i<r;i++){for(var s=j.FieldRef.fromString(t[i]),o=s.fieldName,a=this.fieldLengths[s],u=new j.Vector,l=this.fieldTermFrequencies[s],c=Object.keys(l),h=c.length,d=this._fields[o].boost||1,f=this._documents[s.docRef].boost||1,p=0;p<h;p++){var y,m,g,x=c[p],v=l[x],w=this.invertedIndex[x]._index;void 0===n[x]?(y=j.idf(this.invertedIndex[x],this.documentCount),n[x]=y):y=n[x],m=y*((this._k1+1)*v)/(this._k1*(1-this._b+this._b*(a/this.averageFieldLength[o]))+v),m*=d,m*=f,g=Math.round(1e3*m)/1e3,u.insert(w,g)}e[s]=u}this.fieldVectors=e},j.Builder.prototype.createTokenSet=function(){this.tokenSet=j.TokenSet.fromArray(Object.keys(this.invertedIndex).sort())},j.Builder.prototype.build=function(){return this.calculateAverageFieldLengths(),this.createFieldVectors(),this.createTokenSet(),new j.Index({invertedIndex:this.invertedIndex,fieldVectors:this.fieldVectors,tokenSet:this.tokenSet,fields:Object.keys(this._fields),pipeline:this.searchPipeline})},j.Builder.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},j.MatchData=function(e,t,r){for(var n=Object.create(null),i=Object.keys(r||{}),s=0;s<i.length;s++){var o=i[s];n[o]=r[o].slice()}this.metadata=Object.create(null),void 0!==e&&(this.metadata[e]=Object.create(null),this.metadata[e][t]=n)},j.MatchData.prototype.combine=function(e){for(var t=Object.keys(e.metadata),r=0;r<t.length;r++){var n=t[r],i=Object.keys(e.metadata[n]);null==this.metadata[n]&&(this.metadata[n]=Object.create(null));for(var s=0;s<i.length;s++){var o=i[s],a=Object.keys(e.metadata[n][o]);null==this.metadata[n][o]&&(this.metadata[n][o]=Object.create(null));for(var u=0;u<a.length;u++){var l=a[u];null==this.metadata[n][o][l]?this.metadata[n][o][l]=e.metadata[n][o][l]:this.metadata[n][o][l]=this.metadata[n][o][l].concat(e.metadata[n][o][l])}}}},j.MatchData.prototype.add=function(e,t,r){if(!(e in this.metadata))return this.metadata[e]=Object.create(null),void(this.metadata[e][t]=r);if(t in this.metadata[e])for(var n=Object.keys(r),i=0;i<n.length;i++){var s=n[i];s in this.metadata[e][t]?this.metadata[e][t][s]=this.metadata[e][t][s].concat(r[s]):this.metadata[e][t][s]=r[s]}else this.metadata[e][t]=r},j.Query=function(e){this.clauses=[],this.allFields=e},j.Query.wildcard=new String("*"),j.Query.wildcard.NONE=0,j.Query.wildcard.LEADING=1,j.Query.wildcard.TRAILING=2,j.Query.presence={OPTIONAL:1,REQUIRED:2,PROHIBITED:3},j.Query.prototype.clause=function(e){return"fields"in e||(e.fields=this.allFields),"boost"in e||(e.boost=1),"usePipeline"in e||(e.usePipeline=!0),"wildcard"in e||(e.wildcard=j.Query.wildcard.NONE),e.wildcard&j.Query.wildcard.LEADING&&e.term.charAt(0)!=j.Query.wildcard&&(e.term="*"+e.term),e.wildcard&j.Query.wildcard.TRAILING&&e.term.slice(-1)!=j.Query.wildcard&&(e.term=e.term+"*"),"presence"in e||(e.presence=j.Query.presence.OPTIONAL),this.clauses.push(e),this},j.Query.prototype.isNegated=function(){for(var e=0;e<this.clauses.length;e++)if(this.clauses[e].presence!=j.Query.presence.PROHIBITED)return!1;return!0},j.Query.prototype.term=function(e,t){if(Array.isArray(e))return e.forEach((function(e){this.term(e,j.utils.clone(t))}),this),this;var r=t||{};return r.term=e.toString(),this.clause(r),this},j.QueryParseError=function(e,t,r){this.name="QueryParseError",this.message=e,this.start=t,this.end=r},j.QueryParseError.prototype=new Error,j.QueryLexer=function(e){this.lexemes=[],this.str=e,this.length=e.length,this.pos=0,this.start=0,this.escapeCharPositions=[]},j.QueryLexer.prototype.run=function(){for(var e=j.QueryLexer.lexText;e;)e=e(this)},j.QueryLexer.prototype.sliceString=function(){for(var e=[],t=this.start,r=this.pos,n=0;n<this.escapeCharPositions.length;n++)r=this.escapeCharPositions[n],e.push(this.str.slice(t,r)),t=r+1;return e.push(this.str.slice(t,this.pos)),this.escapeCharPositions.length=0,e.join("")},j.QueryLexer.prototype.emit=function(e){this.lexemes.push({type:e,str:this.sliceString(),start:this.start,end:this.pos}),this.start=this.pos},j.QueryLexer.prototype.escapeCharacter=function(){this.escapeCharPositions.push(this.pos-1),this.pos+=1},j.QueryLexer.prototype.next=function(){if(this.pos>=this.length)return j.QueryLexer.EOS;var e=this.str.charAt(this.pos);return this.pos+=1,e},j.QueryLexer.prototype.width=function(){return this.pos-this.start},j.QueryLexer.prototype.ignore=function(){this.start==this.pos&&(this.pos+=1),this.start=this.pos},j.QueryLexer.prototype.backup=function(){this.pos-=1},j.QueryLexer.prototype.acceptDigitRun=function(){var e,t;do{t=(e=this.next()).charCodeAt(0)}while(t>47&&t<58);e!=j.QueryLexer.EOS&&this.backup()},j.QueryLexer.prototype.more=function(){return this.pos<this.length},j.QueryLexer.EOS="EOS",j.QueryLexer.FIELD="FIELD",j.QueryLexer.TERM="TERM",j.QueryLexer.EDIT_DISTANCE="EDIT_DISTANCE",j.QueryLexer.BOOST="BOOST",j.QueryLexer.PRESENCE="PRESENCE",j.QueryLexer.lexField=function(e){return e.backup(),e.emit(j.QueryLexer.FIELD),e.ignore(),j.QueryLexer.lexText},j.QueryLexer.lexTerm=function(e){if(e.width()>1&&(e.backup(),e.emit(j.QueryLexer.TERM)),e.ignore(),e.more())return j.QueryLexer.lexText},j.QueryLexer.lexEditDistance=function(e){return e.ignore(),e.acceptDigitRun(),e.emit(j.QueryLexer.EDIT_DISTANCE),j.QueryLexer.lexText},j.QueryLexer.lexBoost=function(e){return e.ignore(),e.acceptDigitRun(),e.emit(j.QueryLexer.BOOST),j.QueryLexer.lexText},j.QueryLexer.lexEOS=function(e){e.width()>0&&e.emit(j.QueryLexer.TERM)},j.QueryLexer.termSeparator=j.tokenizer.separator,j.QueryLexer.lexText=function(e){for(;;){var t=e.next();if(t==j.QueryLexer.EOS)return j.QueryLexer.lexEOS;if(92!=t.charCodeAt(0)){if(":"==t)return j.QueryLexer.lexField;if("~"==t)return e.backup(),e.width()>0&&e.emit(j.QueryLexer.TERM),j.QueryLexer.lexEditDistance;if("^"==t)return e.backup(),e.width()>0&&e.emit(j.QueryLexer.TERM),j.QueryLexer.lexBoost;if("+"==t&&1===e.width())return e.emit(j.QueryLexer.PRESENCE),j.QueryLexer.lexText;if("-"==t&&1===e.width())return e.emit(j.QueryLexer.PRESENCE),j.QueryLexer.lexText;if(t.match(j.QueryLexer.termSeparator))return j.QueryLexer.lexTerm}else e.escapeCharacter()}},j.QueryParser=function(e,t){this.lexer=new j.QueryLexer(e),this.query=t,this.currentClause={},this.lexemeIdx=0},j.QueryParser.prototype.parse=function(){this.lexer.run(),this.lexemes=this.lexer.lexemes;for(var e=j.QueryParser.parseClause;e;)e=e(this);return this.query},j.QueryParser.prototype.peekLexeme=function(){return this.lexemes[this.lexemeIdx]},j.QueryParser.prototype.consumeLexeme=function(){var e=this.peekLexeme();return this.lexemeIdx+=1,e},j.QueryParser.prototype.nextClause=function(){var e=this.currentClause;this.query.clause(e),this.currentClause={}},j.QueryParser.parseClause=function(e){var t=e.peekLexeme();if(null!=t)switch(t.type){case j.QueryLexer.PRESENCE:return j.QueryParser.parsePresence;case j.QueryLexer.FIELD:return j.QueryParser.parseField;case j.QueryLexer.TERM:return j.QueryParser.parseTerm;default:var r="expected either a field or a term, found "+t.type;throw t.str.length>=1&&(r+=" with value '"+t.str+"'"),new j.QueryParseError(r,t.start,t.end)}},j.QueryParser.parsePresence=function(e){var t=e.consumeLexeme();if(null!=t){switch(t.str){case"-":e.currentClause.presence=j.Query.presence.PROHIBITED;break;case"+":e.currentClause.presence=j.Query.presence.REQUIRED;break;default:var r="unrecognised presence operator'"+t.str+"'";throw new j.QueryParseError(r,t.start,t.end)}var n=e.peekLexeme();if(null==n)throw r="expecting term or field, found nothing",new j.QueryParseError(r,t.start,t.end);switch(n.type){case j.QueryLexer.FIELD:return j.QueryParser.parseField;case j.QueryLexer.TERM:return j.QueryParser.parseTerm;default:throw r="expecting term or field, found '"+n.type+"'",new j.QueryParseError(r,n.start,n.end)}}},j.QueryParser.parseField=function(e){var t=e.consumeLexeme();if(null!=t){if(-1==e.query.allFields.indexOf(t.str)){var r=e.query.allFields.map((function(e){return"'"+e+"'"})).join(", "),n="unrecognised field '"+t.str+"', possible fields: "+r;throw new j.QueryParseError(n,t.start,t.end)}e.currentClause.fields=[t.str];var i=e.peekLexeme();if(null==i)throw n="expecting term, found nothing",new j.QueryParseError(n,t.start,t.end);if(i.type===j.QueryLexer.TERM)return j.QueryParser.parseTerm;throw n="expecting term, found '"+i.type+"'",new j.QueryParseError(n,i.start,i.end)}},j.QueryParser.parseTerm=function(e){var t=e.consumeLexeme();if(null!=t){e.currentClause.term=t.str.toLowerCase(),-1!=t.str.indexOf("*")&&(e.currentClause.usePipeline=!1);var r=e.peekLexeme();if(null!=r)switch(r.type){case j.QueryLexer.TERM:return e.nextClause(),j.QueryParser.parseTerm;case j.QueryLexer.FIELD:return e.nextClause(),j.QueryParser.parseField;case j.QueryLexer.EDIT_DISTANCE:return j.QueryParser.parseEditDistance;case j.QueryLexer.BOOST:return j.QueryParser.parseBoost;case j.QueryLexer.PRESENCE:return e.nextClause(),j.QueryParser.parsePresence;default:var n="Unexpected lexeme type '"+r.type+"'";throw new j.QueryParseError(n,r.start,r.end)}else e.nextClause()}},j.QueryParser.parseEditDistance=function(e){var t=e.consumeLexeme();if(null!=t){var r=parseInt(t.str,10);if(isNaN(r)){var n="edit distance must be numeric";throw new j.QueryParseError(n,t.start,t.end)}e.currentClause.editDistance=r;var i=e.peekLexeme();if(null!=i)switch(i.type){case j.QueryLexer.TERM:return e.nextClause(),j.QueryParser.parseTerm;case j.QueryLexer.FIELD:return e.nextClause(),j.QueryParser.parseField;case j.QueryLexer.EDIT_DISTANCE:return j.QueryParser.parseEditDistance;case j.QueryLexer.BOOST:return j.QueryParser.parseBoost;case j.QueryLexer.PRESENCE:return e.nextClause(),j.QueryParser.parsePresence;default:throw n="Unexpected lexeme type '"+i.type+"'",new j.QueryParseError(n,i.start,i.end)}else e.nextClause()}},j.QueryParser.parseBoost=function(e){var t=e.consumeLexeme();if(null!=t){var r=parseInt(t.str,10);if(isNaN(r)){var n="boost must be numeric";throw new j.QueryParseError(n,t.start,t.end)}e.currentClause.boost=r;var i=e.peekLexeme();if(null!=i)switch(i.type){case j.QueryLexer.TERM:return e.nextClause(),j.QueryParser.parseTerm;case j.QueryLexer.FIELD:return e.nextClause(),j.QueryParser.parseField;case j.QueryLexer.EDIT_DISTANCE:return j.QueryParser.parseEditDistance;case j.QueryLexer.BOOST:return j.QueryParser.parseBoost;case j.QueryLexer.PRESENCE:return e.nextClause(),j.QueryParser.parsePresence;default:throw n="Unexpected lexeme type '"+i.type+"'",new j.QueryParseError(n,i.start,i.end)}else e.nextClause()}},void 0===(i="function"==typeof(n=function(){return j})?n.call(t,r,t,e):n)||(e.exports=i)}()}},t={};function r(n){var i=t[n];if(void 0!==i)return i.exports;var s=t[n]={exports:{}};return e[n](s,s.exports,r),s.exports}r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,{a:t}),t},r.d=function(e,t){for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)};var n={};!function(){"use strict";r.d(n,{add:function(){return c},dispose:function(){return y},done:function(){return h},fromExternalJS:function(){return f},load:function(){return p},search:function(){return m},toJS:function(){return d}});var e=r(291),t=(e,t,r)=>new Promise(((n,i)=>{var s=e=>{try{a(r.next(e))}catch(e){i(e)}},o=e=>{try{a(r.throw(e))}catch(e){i(e)}},a=e=>e.done?n(e.value):Promise.resolve(e.value).then(s,o);a((r=r.apply(e,t)).next())}));let i,s,o,a=[];function u(){i=new e.Builder,i.field("title"),i.field("description"),i.ref("ref"),i.pipeline.add(e.trimmer,e.stopWordFilter,e.stemmer),o=new Promise((e=>{s=e}))}e.tokenizer.separator=/\\s+/,u();const l=t=>{const r=e.trimmer(new e.Token(t,{}));return"*"+e.stemmer(r)+"*"};function c(e,t,r){const n=a.push(r)-1,s={title:e.toLowerCase(),description:t.toLowerCase(),ref:n};i.add(s)}function h(){return t(this,null,(function*(){s(i.build())}))}function d(){return t(this,null,(function*(){return{store:a,index:(yield o).toJSON()}}))}function f(e,r){return t(this,null,(function*(){try{if(importScripts(e),!self[r])throw new Error("Broken index file format");p(self[r])}catch(e){console.error("Failed to load search index: "+e.message)}}))}function p(r){return t(this,null,(function*(){a=r.store,s(e.Index.load(r.index))}))}function y(){return t(this,null,(function*(){a=[],u()}))}function m(e,r=0){return t(this,null,(function*(){if(0===e.trim().length)return[];let t=(yield o).query((t=>{e.trim().toLowerCase().split(/\\s+/).forEach((e=>{if(1===e.length)return;const r=l(e);t.term(r,{})}))}));return r>0&&(t=t.slice(0,r)),t.map((e=>({meta:a[e.ref],score:e.score})))}))}addEventListener("message",(function(e){var t,r=e.data,i=r.type,s=r.method,o=r.id,a=r.params;"RPC"===i&&s&&((t=n[s])?Promise.resolve().then((function(){return t.apply(n,a)})):Promise.reject("No such method")).then((function(e){postMessage({type:"RPC",id:o,result:e})})).catch((function(e){var t={message:e};e.stack&&(t.message=e.message,t.stack=e.stack,t.name=e.name),postMessage({type:"RPC",id:o,error:t})}))})),postMessage({type:"RPC",method:"ready"})}()}();
//# sourceMappingURL=cfb294d7f6536ffa8d42.worker.js.map`])), { name: "[fullhash].worker.js" });
            return d(g, m), g;
          };
        }, 7: function(i) {
          i.exports = function(u, c) {
            var d = 0, m = {};
            u.addEventListener("message", function(g) {
              var v = g.data;
              if (v.type === "RPC") if (v.id) {
                var S = m[v.id];
                S && (delete m[v.id], v.error ? S[1](Object.assign(Error(v.error.message), v.error)) : S[0](v.result));
              } else {
                var k = document.createEvent("Event");
                k.initEvent(v.method, !1, !1), k.data = v.params, u.dispatchEvent(k);
              }
            }), c.forEach(function(g) {
              u[g] = function() {
                var v = arguments;
                return new Promise(function(S, k) {
                  var b = ++d;
                  m[b] = [S, k], u.postMessage({ type: "RPC", id: b, method: g, params: [].slice.call(v) });
                });
              };
            });
          };
        }, 884: function(i) {
          i.exports = WR();
        }, 648: function(i) {
          i.exports = KR();
        }, 230: function(i) {
          i.exports = QR();
        }, 115: function(i) {
          i.exports = rN;
        }, 725: function(i) {
          i.exports = void 0;
        }, 375: function() {
        }, 430: function(i) {
          i.exports = { rE: "7.0.8" };
        } }, n = {};
        function o(i) {
          var u = n[i];
          if (u !== void 0) return u.exports;
          var c = n[i] = { id: i, exports: {} };
          return r[i](c, c.exports, o), c.exports;
        }
        o.n = function(i) {
          var u = i && i.__esModule ? function() {
            return i.default;
          } : function() {
            return i;
          };
          return o.d(u, { a: u }), u;
        }, o.d = function(i, u) {
          for (var c in u) o.o(u, c) && !o.o(i, c) && Object.defineProperty(i, c, { enumerable: !0, get: u[c] });
        }, o.g = function() {
          if (typeof globalThis == "object") return globalThis;
          try {
            return this || new Function("return this")();
          } catch {
            if (typeof window == "object") return window;
          }
        }(), o.o = function(i, u) {
          return Object.prototype.hasOwnProperty.call(i, u);
        }, o.r = function(i) {
          typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(i, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(i, "__esModule", { value: !0 });
        }, o.nc = void 0;
        var a = {};
        return function() {
          o.r(a), o.d(a, { AUTH_TYPES: function() {
            return Xa;
          }, ApiContentWrap: function() {
            return Gx;
          }, ApiInfo: function() {
            return mn;
          }, ApiInfoModel: function() {
            return rf;
          }, ApiLogo: function() {
            return Ja;
          }, AppStore: function() {
            return ms;
          }, ArraySchema: function() {
            return Qo;
          }, BackgroundStub: function() {
            return Xx;
          }, BodyContent: function() {
            return du;
          }, COMPONENT_REGEXP: function() {
            return ef;
          }, CallbackModel: function() {
            return $l;
          }, ClipboardService: function() {
            return Li;
          }, ContentItem: function() {
            return rg;
          }, ContentItems: function() {
            return yd;
          }, DiscriminatorDropdown: function() {
            return eu;
          }, Dropdown: function() {
            return za;
          }, DropdownLabel: function() {
            return Cc;
          }, DropdownOrLabel: function() {
            return to;
          }, DropdownWrapper: function() {
            return $c;
          }, ErrorBoundary: function() {
            return ke;
          }, Example: function() {
            return Pc;
          }, ExampleModel: function() {
            return Io;
          }, ExternalExample: function() {
            return wm;
          }, FieldModel: function() {
            return Zr;
          }, GROUP_DEPTH: function() {
            return Do;
          }, GroupModel: function() {
            return Hr;
          }, HistoryService: function() {
            return ki;
          }, IS_BROWSER: function() {
            return m;
          }, InvertedSimpleDropdown: function() {
            return Gl;
          }, JsonPointer: function() {
            return kt;
          }, JsonViewer: function() {
            return Mf;
          }, LEGACY_REGEXP: function() {
            return Fh;
          }, Loading: function() {
            return ct;
          }, MDX_COMPONENT_REGEXP: function() {
            return qh;
          }, Markdown: function() {
            return xr;
          }, MarkdownRenderer: function() {
            return Pi;
          }, MarkerService: function() {
            return ft;
          }, MediaContentModel: function() {
            return No;
          }, MediaTypeModel: function() {
            return ff;
          }, MediaTypesSwitch: function() {
            return ys;
          }, MenuBuilder: function() {
            return ui;
          }, MenuItem: function() {
            return vd;
          }, MenuItemLabel: function() {
            return fu;
          }, MenuItemLi: function() {
            return Bm;
          }, MenuItemTitle: function() {
            return Wc;
          }, MenuItemUl: function() {
            return pu;
          }, MenuItems: function() {
            return bd;
          }, MenuStore: function() {
            return zn;
          }, MiddlePanel: function() {
            return Sn;
          }, MimeLabel: function() {
            return Tc;
          }, NoSampleLabel: function() {
            return qf;
          }, OLD_SECURITY_DEFINITIONS_JSX_NAME: function() {
            return El;
          }, ObjectSchema: function() {
            return Wa;
          }, OneOfButton: function() {
            return nu;
          }, OneOfSchema: function() {
            return Qa;
          }, OpenAPIParser: function() {
            return lf;
          }, Operation: function() {
            return qx;
          }, OperationBadge: function() {
            return Jo;
          }, OperationItem: function() {
            return ig;
          }, OperationMenuItemContent: function() {
            return Hx;
          }, OperationModel: function() {
            return Dr;
          }, OptionsConsumer: function() {
            return Vt;
          }, OptionsContext: function() {
            return st;
          }, OptionsProvider: function() {
            return at;
          }, Parameters: function() {
            return Gc;
          }, PayloadSamples: function() {
            return ot;
          }, Redoc: function() {
            return Qb;
          }, RedocAttribution: function() {
            return lo;
          }, RedocNormalizedOptions: function() {
            return ie;
          }, RedocStandalone: function() {
            return IR;
          }, RedocWrap: function() {
            return Yx;
          }, RequestBodyModel: function() {
            return Qt;
          }, ResponseDetails: function() {
            return gu;
          }, ResponseHeaders: function() {
            return gd;
          }, ResponseModel: function() {
            return uc;
          }, ResponseSamples: function() {
            return eg;
          }, ResponseTitle: function() {
            return dd;
          }, ResponseView: function() {
            return s;
          }, ResponsesList: function() {
            return y;
          }, RightPanel: function() {
            return Fl;
          }, Row: function() {
            return Tr;
          }, SCHEMA_DEFINITION_JSX_NAME: function() {
            return ko;
          }, SECTION_ATTR: function() {
            return tn;
          }, SECURITY_DEFINITIONS_JSX_NAME: function() {
            return ss;
          }, SECURITY_SCHEMES_SECTION_PREFIX: function() {
            return Ln;
          }, Schema: function() {
            return qi;
          }, SchemaDefinition: function() {
            return Nt;
          }, SchemaModel: function() {
            return Ra;
          }, ScrollService: function() {
            return Ci;
          }, SearchBox: function() {
            return og;
          }, SearchStore: function() {
            return qo;
          }, Section: function() {
            return Xs;
          }, SectionItem: function() {
            return ng;
          }, SecurityDefs: function() {
            return zi;
          }, SecuritySchemeModel: function() {
            return Lo;
          }, SecuritySchemesModel: function() {
            return li;
          }, SideMenu: function() {
            return wd;
          }, SideNavStyleEnum: function() {
            return J;
          }, SimpleDropdown: function() {
            return Ho;
          }, SourceCode: function() {
            return Df;
          }, SourceCodeWithCopy: function() {
            return Yl;
          }, SpecStore: function() {
            return Na;
          }, StickyResponsiveSidebar: function() {
            return Sd;
          }, StoreBuilder: function() {
            return bf;
          }, StoreConsumer: function() {
            return Bn;
          }, StoreContext: function() {
            return Kr;
          }, StoreProvider: function() {
            return Zt;
          }, StyledMarkdownBlock: function() {
            return nr;
          }, ThemeProvider: function() {
            return je;
          }, Throttle: function() {
            return kl;
          }, alphabeticallyByProp: function() {
            return To;
          }, appendToMdHeading: function() {
            return C;
          }, argValueToBoolean: function() {
            return B;
          }, buildComponentComment: function() {
            return tf;
          }, concatRefStacks: function() {
            return Nl;
          }, convertSwagger2OpenAPI: function() {
            return rt;
          }, createGlobalStyle: function() {
            return Oe;
          }, createStore: function() {
            return so;
          }, css: function() {
            return Pe;
          }, debugTime: function() {
            return mr;
          }, debugTimeEnd: function() {
            return Ei;
          }, detectType: function() {
            return Ls;
          }, escapeHTMLAttrChars: function() {
            return ve;
          }, expandDefaultServerVariables: function() {
            return qs;
          }, extensionsHook: function() {
            return me;
          }, extractExtensions: function() {
            return os;
          }, flattenByProp: function() {
            return _;
          }, getBasePath: function() {
            return H;
          }, getContentWithLegacyExamples: function() {
            return Lt;
          }, getDefinitionName: function() {
            return rs;
          }, getOperationSummary: function() {
            return va;
          }, getSerializedValue: function() {
            return bi;
          }, getStatusCodeType: function() {
            return cr;
          }, highlight: function() {
            return Sa;
          }, history: function() {
            return oi;
          }, html2Str: function() {
            return v;
          }, humanizeConstraints: function() {
            return Mr;
          }, humanizeNumberRange: function() {
            return Ku;
          }, isAbsoluteUrl: function() {
            return U;
          }, isArray: function() {
            return ce;
          }, isBoolean: function() {
            return se;
          }, isFormUrlEncoded: function() {
            return Eo;
          }, isJsonLike: function() {
            return es;
          }, isNamedDefinition: function() {
            return ts;
          }, isNumeric: function() {
            return R;
          }, isObject: function() {
            return j;
          }, isOperationName: function() {
            return Ht;
          }, isPayloadSample: function() {
            return Ia;
          }, isPrimitiveType: function() {
            return Ms;
          }, isRedocExtension: function() {
            return xi;
          }, isStatusCode: function() {
            return xl;
          }, keyframes: function() {
            return qe;
          }, langFromMime: function() {
            return jn;
          }, loadAndBundleSpec: function() {
            return He;
          }, mapLang: function() {
            return _i;
          }, mapValues: function() {
            return A;
          }, mapWithLast: function() {
            return x;
          }, media: function() {
            return $;
          }, memoize: function() {
            return Oi;
          }, menuItemDepth: function() {
            return Um;
          }, mergeObjects: function() {
            return T;
          }, mergeParams: function() {
            return is;
          }, mergeSimilarMediaTypes: function() {
            return Fs;
          }, normalizeServers: function() {
            return Si;
          }, pluralizeType: function() {
            return wa;
          }, pushRef: function() {
            return Il;
          }, querySelector: function() {
            return g;
          }, removeQueryStringAndHash: function() {
            return ge;
          }, resolveUrl: function() {
            return ne;
          }, safeSlugify: function() {
            return V;
          }, scrollIntoViewIfNeeded: function() {
            return S;
          }, serializeParameterValue: function() {
            return Ds;
          }, serializeParameterValueWithMime: function() {
            return ri;
          }, setSecuritySchemePrefix: function() {
            return Mn;
          }, shortenHTTPVerb: function() {
            return Dn;
          }, sortByField: function() {
            return wi;
          }, sortByRequired: function() {
            return ns;
          }, stripTrailingSlash: function() {
            return O;
          }, styled: function() {
            return K;
          }, titleize: function() {
            return ae;
          }, unescapeHTMLChars: function() {
            return $e;
          }, urlFormEncodePayload: function() {
            return Kt;
          }, useStore: function() {
            return wf;
          } });
          var i = ch(), u = BL;
          const c = { spacing: { unit: 5, sectionHorizontal: ({ spacing: p }) => 8 * p.unit, sectionVertical: ({ spacing: p }) => 8 * p.unit }, breakpoints: { small: "50rem", medium: "75rem", large: "105rem" }, colors: { tonalOffset: 0.2, primary: { main: "#32329f", light: ({ colors: p }) => (0, u.lighten)(p.tonalOffset, p.primary.main), dark: ({ colors: p }) => (0, u.darken)(p.tonalOffset, p.primary.main), contrastText: ({ colors: p }) => (0, u.readableColor)(p.primary.main) }, success: { main: "#1d8127", light: ({ colors: p }) => (0, u.lighten)(2 * p.tonalOffset, p.success.main), dark: ({ colors: p }) => (0, u.darken)(p.tonalOffset, p.success.main), contrastText: ({ colors: p }) => (0, u.readableColor)(p.success.main) }, warning: { main: "#ffa500", light: ({ colors: p }) => (0, u.lighten)(p.tonalOffset, p.warning.main), dark: ({ colors: p }) => (0, u.darken)(p.tonalOffset, p.warning.main), contrastText: "#ffffff" }, error: { main: "#d41f1c", light: ({ colors: p }) => (0, u.lighten)(p.tonalOffset, p.error.main), dark: ({ colors: p }) => (0, u.darken)(p.tonalOffset, p.error.main), contrastText: ({ colors: p }) => (0, u.readableColor)(p.error.main) }, gray: { 50: "#FAFAFA", 100: "#F5F5F5" }, text: { primary: "#333333", secondary: ({ colors: p }) => (0, u.lighten)(p.tonalOffset, p.text.primary) }, border: { dark: "rgba(0,0,0, 0.1)", light: "#ffffff" }, responses: { success: { color: ({ colors: p }) => p.success.main, backgroundColor: ({ colors: p }) => (0, u.transparentize)(0.93, p.success.main), tabTextColor: ({ colors: p }) => p.responses.success.color }, error: { color: ({ colors: p }) => p.error.main, backgroundColor: ({ colors: p }) => (0, u.transparentize)(0.93, p.error.main), tabTextColor: ({ colors: p }) => p.responses.error.color }, redirect: { color: ({ colors: p }) => p.warning.main, backgroundColor: ({ colors: p }) => (0, u.transparentize)(0.9, p.responses.redirect.color), tabTextColor: ({ colors: p }) => p.responses.redirect.color }, info: { color: "#87ceeb", backgroundColor: ({ colors: p }) => (0, u.transparentize)(0.9, p.responses.info.color), tabTextColor: ({ colors: p }) => p.responses.info.color } }, http: { get: "#2F8132", post: "#186FAF", put: "#95507c", options: "#947014", patch: "#bf581d", delete: "#cc3333", basic: "#707070", link: "#07818F", head: "#A23DAD" } }, schema: { linesColor: (p) => (0, u.lighten)(p.colors.tonalOffset, (0, u.desaturate)(p.colors.tonalOffset, p.colors.primary.main)), defaultDetailsWidth: "75%", typeNameColor: (p) => p.colors.text.secondary, typeTitleColor: (p) => p.schema.typeNameColor, requireLabelColor: (p) => p.colors.error.main, labelsTextSize: "0.9em", nestingSpacing: "1em", nestedBackground: "#fafafa", arrow: { size: "1.1em", color: (p) => p.colors.text.secondary } }, typography: { fontSize: "14px", lineHeight: "1.5em", fontWeightRegular: "400", fontWeightBold: "600", fontWeightLight: "300", fontFamily: "Roboto, sans-serif", smoothing: "antialiased", optimizeSpeed: !0, headings: { fontFamily: "Montserrat, sans-serif", fontWeight: "400", lineHeight: "1.6em" }, code: { fontSize: "13px", fontFamily: "Courier, monospace", lineHeight: ({ typography: p }) => p.lineHeight, fontWeight: ({ typography: p }) => p.fontWeightRegular, color: "#e53935", backgroundColor: "rgba(38, 50, 56, 0.05)", wrap: !1 }, links: { color: ({ colors: p }) => p.primary.main, visited: ({ typography: p }) => p.links.color, hover: ({ typography: p }) => (0, u.lighten)(0.2, p.links.color), textDecoration: "auto", hoverTextDecoration: "auto" } }, sidebar: { width: "260px", backgroundColor: "#fafafa", textColor: "#333333", activeTextColor: (p) => p.sidebar.textColor !== c.sidebar.textColor ? p.sidebar.textColor : p.colors.primary.main, groupItems: { activeBackgroundColor: (p) => (0, u.darken)(0.1, p.sidebar.backgroundColor), activeTextColor: (p) => p.sidebar.activeTextColor, textTransform: "uppercase" }, level1Items: { activeBackgroundColor: (p) => (0, u.darken)(0.05, p.sidebar.backgroundColor), activeTextColor: (p) => p.sidebar.activeTextColor, textTransform: "none" }, arrow: { size: "1.5em", color: (p) => p.sidebar.textColor } }, logo: { maxHeight: ({ sidebar: p }) => p.width, maxWidth: ({ sidebar: p }) => p.width, gutter: "2px" }, rightPanel: { backgroundColor: "#263238", width: "40%", textColor: "#ffffff", servers: { overlay: { backgroundColor: "#fafafa", textColor: "#263238" }, url: { backgroundColor: "#fff" } } }, codeBlock: { backgroundColor: ({ rightPanel: p }) => (0, u.darken)(0.1, p.backgroundColor) }, fab: { backgroundColor: "#f2f2f2", color: "#0065FB" } };
          var d = c;
          const m = typeof window < "u" && "HTMLElement" in window;
          function g(p) {
            return typeof document < "u" ? document.querySelector(p) : null;
          }
          function v(p) {
            return p.split(/<[^>]+>/).map((f) => f.trim()).filter((f) => f.length > 0).join(" ");
          }
          function S(p, f = !0) {
            const h = p.parentNode;
            if (!h) return;
            const w = window.getComputedStyle(h, void 0), P = parseInt(w.getPropertyValue("border-top-width"), 10), L = parseInt(w.getPropertyValue("border-left-width"), 10), z = p.offsetTop - h.offsetTop < h.scrollTop, ee = p.offsetTop - h.offsetTop + p.clientHeight - P > h.scrollTop + h.clientHeight, ue = p.offsetLeft - h.offsetLeft < h.scrollLeft, pe = p.offsetLeft - h.offsetLeft + p.clientWidth - L > h.scrollLeft + h.clientWidth, xe = z && !ee;
            (z || ee) && f && (h.scrollTop = p.offsetTop - h.offsetTop - h.clientHeight / 2 - P + p.clientHeight / 2), (ue || pe) && f && (h.scrollLeft = p.offsetLeft - h.offsetLeft - h.clientWidth / 2 - L + p.clientWidth / 2), (z || ee || ue || pe) && !f && p.scrollIntoView(xe);
          }
          var k = VL(), b = o.n(k);
          function x(p, f) {
            const h = [];
            for (let w = 0; w < p.length - 1; w++) h.push(f(p[w], !1));
            return p.length !== 0 && h.push(f(p[p.length - 1], !0)), h;
          }
          function A(p, f) {
            const h = {};
            for (const w in p) p.hasOwnProperty(w) && (h[w] = f(p[w], w, p));
            return h;
          }
          function _(p, f) {
            const h = [], w = (P) => {
              for (const L of P) h.push(L), L[f] && w(L[f]);
            };
            return w(p), h;
          }
          function O(p) {
            return p.endsWith("/") ? p.substring(0, p.length - 1) : p;
          }
          function R(p) {
            return !isNaN(parseFloat(p)) && isFinite(p);
          }
          function C(p, f, h) {
            const w = new RegExp(`(^|\\n)#\\s?${f}\\s*\\n`, "i"), P = new RegExp(`((\\n|^)#\\s*${f}\\s*(\\n|$)(?:.|\\n)*?)(\\n#|$)`, "i");
            if (w.test(p)) return p.replace(P, `$1

${h}
$4`);
            {
              const L = p === "" || p.endsWith(`

`) ? "" : p.endsWith(`
`) ? `
` : `

`;
              return `${p}${L}# ${f}

${h}`;
            }
          }
          const T = (p, ...f) => {
            if (!f.length) return p;
            const h = f.shift();
            return h === void 0 ? p : (D(p) && D(h) && Object.keys(h).forEach((w) => {
              Object.prototype.hasOwnProperty.call(h, w) && w !== "__proto__" && (D(h[w]) ? (p[w] || (p[w] = {}), T(p[w], h[w])) : p[w] = h[w]);
            }), T(p, ...f));
          }, j = (p) => p !== null && typeof p == "object", D = (p) => j(p) && !ce(p);
          function V(p) {
            return b()(p) || p.toString().toLowerCase().replace(/\s+/g, "-").replace(/&/g, "-and-").replace(/\--+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
          }
          function U(p) {
            return /(?:^[a-z][a-z0-9+.-]*:|\/\/)/i.test(p);
          }
          function ne(p, f) {
            let h;
            if (f.startsWith("//")) try {
              h = `${new URL(p).protocol || "https:"}${f}`;
            } catch {
              h = `https:${f}`;
            }
            else if (U(f)) h = f;
            else if (f.startsWith("/")) try {
              const w = new URL(p);
              w.pathname = f, h = w.href;
            } catch {
              h = f;
            }
            else h = O(p) + "/" + f;
            return O(h);
          }
          function H(p) {
            try {
              return fe(p).pathname;
            } catch {
              return p;
            }
          }
          function ae(p) {
            return p.charAt(0).toUpperCase() + p.slice(1);
          }
          function ge(p) {
            try {
              const f = fe(p);
              return f.search = "", f.hash = "", f.toString();
            } catch {
              return p;
            }
          }
          function fe(p) {
            return typeof URL > "u" ? new (o(725)).URL(p) : new URL(p);
          }
          function ve(p) {
            return p.replace(/["\\]/g, "\\$&");
          }
          function $e(p) {
            return p.replace(/&#(\d+);/g, (f, h) => String.fromCharCode(parseInt(h, 10))).replace(/&amp;/g, "&").replace(/&quot;/g, '"');
          }
          function ce(p) {
            return Array.isArray(p);
          }
          function se(p) {
            return typeof p == "boolean";
          }
          const te = { enum: "Enum", enumSingleValue: "Value", enumArray: "Items", default: "Default", deprecated: "Deprecated", example: "Example", examples: "Examples", recursive: "Recursive", arrayOf: "Array of ", webhook: "Event", const: "Value", noResultsFound: "No results found", download: "Download", downloadSpecification: "Download OpenAPI specification", responses: "Responses", callbackResponses: "Callback responses", requestSamples: "Request samples", responseSamples: "Response samples" };
          function F(p, f) {
            const h = te[p];
            return f !== void 0 ? h[f] : h;
          }
          var J = ((p) => (p.SummaryOnly = "summary-only", p.PathOnly = "path-only", p.IdOnly = "id-only", p))(J || {}), W = Object.defineProperty, q = Object.defineProperties, X = Object.getOwnPropertyDescriptors, Q = Object.getOwnPropertySymbols, ye = Object.prototype.hasOwnProperty, Se = Object.prototype.propertyIsEnumerable, Ne = (p, f, h) => f in p ? W(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h, N = (p, f) => {
            for (var h in f || (f = {})) ye.call(f, h) && Ne(p, h, f[h]);
            if (Q) for (var h of Q(f)) Se.call(f, h) && Ne(p, h, f[h]);
            return p;
          };
          function B(p, f) {
            return p === void 0 ? f || !1 : typeof p == "string" ? p !== "false" : p;
          }
          function oe(p) {
            return typeof p == "string" ? parseInt(p, 10) : typeof p == "number" ? p : void 0;
          }
          class ie {
            static normalizeExpandResponses(f) {
              if (f === "all") return "all";
              if (typeof f == "string") {
                const h = {};
                return f.split(",").forEach((w) => {
                  h[w.trim()] = !0;
                }), h;
              }
              return f !== void 0 && console.warn(`expandResponses must be a string but received value "${f}" of type ${typeof f}`), {};
            }
            static normalizeHideHostname(f) {
              return !!f;
            }
            static normalizeScrollYOffset(f) {
              if (typeof f == "string" && !R(f)) {
                const h = g(f);
                h || console.warn("scrollYOffset value is a selector to non-existing element. Using offset 0 by default");
                const w = h && h.getBoundingClientRect().bottom || 0;
                return () => w;
              }
              return typeof f == "number" || R(f) ? () => typeof f == "number" ? f : parseFloat(f) : typeof f == "function" ? () => {
                const h = f();
                return typeof h != "number" && console.warn(`scrollYOffset should return number but returned value "${h}" of type ${typeof h}`), h;
              } : (f !== void 0 && console.warn("Wrong value for scrollYOffset ReDoc option: should be string, number or function"), () => 0);
            }
            static normalizeShowExtensions(f) {
              if (f === void 0) return !1;
              if (f === "") return !0;
              if (typeof f != "string") return f;
              switch (f) {
                case "true":
                  return !0;
                case "false":
                  return !1;
                default:
                  return f.split(",").map((h) => h.trim());
              }
            }
            static normalizeSideNavStyle(f) {
              const h = J.SummaryOnly;
              if (typeof f != "string") return h;
              switch (f) {
                case h:
                  return f;
                case J.PathOnly:
                  return J.PathOnly;
                case J.IdOnly:
                  return J.IdOnly;
                default:
                  return h;
              }
            }
            static normalizePayloadSampleIdx(f) {
              return typeof f == "number" ? Math.max(0, f) : typeof f == "string" && isFinite(f) ? parseInt(f, 10) : 0;
            }
            static normalizeJsonSampleExpandLevel(f) {
              return f === "all" ? 1 / 0 : isNaN(Number(f)) ? 2 : Math.ceil(Number(f));
            }
            static normalizeGeneratedPayloadSamplesMaxDepth(f) {
              return isNaN(Number(f)) ? 10 : Math.max(0, Number(f));
            }
            constructor(f, h = {}) {
              var w, P, L, z, ee;
              const ue = (f = N(N({}, h), f)).theme && f.theme.extensionsHook;
              var pe, xe;
              (w = f.theme) != null && w.menu && !((P = f.theme) != null && P.sidebar) && (console.warn('Theme setting "menu" is deprecated. Rename to "sidebar"'), f.theme.sidebar = f.theme.menu), (L = f.theme) != null && L.codeSample && !((z = f.theme) != null && z.codeBlock) && (console.warn('Theme setting "codeSample" is deprecated. Rename to "codeBlock"'), f.theme.codeBlock = f.theme.codeSample), this.theme = function(we) {
                const Ve = {};
                let it = 0;
                const _t = (Et, gt) => {
                  Object.keys(Et).forEach((pi) => {
                    const Qn = (gt ? gt + "." : "") + pi, Pr = Et[pi];
                    typeof Pr == "function" ? Object.defineProperty(Et, pi, { get() {
                      if (!Ve[Qn]) {
                        if (it++, it > 1e3) throw new Error(`Theme probably contains circular dependency at ${Qn}: ${Pr.toString()}`);
                        Ve[Qn] = Pr(we);
                      }
                      return Ve[Qn];
                    }, enumerable: !0 }) : typeof Pr == "object" && _t(Pr, Qn);
                  });
                };
                return _t(we, ""), JSON.parse(JSON.stringify(we));
              }(T({}, d, (pe = N({}, f.theme), q(pe, X({ extensionsHook: void 0 }))))), this.theme.extensionsHook = ue, xe = f.labels, Object.assign(te, xe), this.scrollYOffset = ie.normalizeScrollYOffset(f.scrollYOffset), this.hideHostname = ie.normalizeHideHostname(f.hideHostname), this.expandResponses = ie.normalizeExpandResponses(f.expandResponses), this.sortRequiredPropsFirst = B(f.sortRequiredPropsFirst || f.requiredPropsFirst), this.sortPropsAlphabetically = B(f.sortPropsAlphabetically), this.sortEnumValuesAlphabetically = B(f.sortEnumValuesAlphabetically), this.sortOperationsAlphabetically = B(f.sortOperationsAlphabetically), this.sortTagsAlphabetically = B(f.sortTagsAlphabetically), this.nativeScrollbars = B(f.nativeScrollbars), this.pathInMiddlePanel = B(f.pathInMiddlePanel), this.sanitize = B(f.sanitize || f.untrustedSpec), this.hideDownloadButtons = B(f.hideDownloadButtons || f.hideDownloadButton), this.downloadFileName = f.downloadFileName, this.downloadDefinitionUrl = f.downloadDefinitionUrl, this.downloadUrls = f.downloadUrls, this.disableSearch = B(f.disableSearch), this.onlyRequiredInSamples = B(f.onlyRequiredInSamples), this.showExtensions = ie.normalizeShowExtensions(f.showExtensions), this.sideNavStyle = ie.normalizeSideNavStyle(f.sideNavStyle), this.hideSingleRequestSampleTab = B(f.hideSingleRequestSampleTab), this.hideRequestPayloadSample = B(f.hideRequestPayloadSample), this.menuToggle = B(f.menuToggle, !0), this.jsonSamplesExpandLevel = ie.normalizeJsonSampleExpandLevel(f.jsonSamplesExpandLevel || f.jsonSampleExpandLevel), this.enumSkipQuotes = B(f.enumSkipQuotes), this.hideSchemaTitles = B(f.hideSchemaTitles), this.simpleOneOfTypeLabel = B(f.simpleOneOfTypeLabel), this.payloadSampleIdx = ie.normalizePayloadSampleIdx(f.payloadSampleIdx), this.expandSingleSchemaField = B(f.expandSingleSchemaField), this.schemasExpansionLevel = function(we, Ve = 0) {
                return we === "all" ? 1 / 0 : oe(we) || Ve;
              }(f.schemasExpansionLevel || f.schemaExpansionLevel), this.schemaDefinitionsTagName = f.schemaDefinitionsTagName, this.showObjectSchemaExamples = B(f.showObjectSchemaExamples), this.showSecuritySchemeType = B(f.showSecuritySchemeType), this.hideSecuritySection = B(f.hideSecuritySection), this.unstable_ignoreMimeParameters = B(f.unstable_ignoreMimeParameters), this.allowedMdComponents = f.allowedMdComponents || {}, this.expandDefaultServerVariables = B(f.expandDefaultServerVariables), this.maxDisplayedEnumValues = oe(f.maxDisplayedEnumValues);
              const le = ce(f.ignoreNamedSchemas) ? f.ignoreNamedSchemas : (ee = f.ignoreNamedSchemas) == null ? void 0 : ee.split(",").map((we) => we.trim());
              this.ignoreNamedSchemas = new Set(le), this.hideSchemaPattern = B(f.hideSchemaPattern), this.generatedSamplesMaxDepth = ie.normalizeGeneratedPayloadSamplesMaxDepth(f.generatedSamplesMaxDepth || f.generatedPayloadSamplesMaxDepth), this.nonce = f.nonce, this.hideFab = B(f.hideFab), this.minCharacterLengthToInitSearch = oe(f.minCharacterLengthToInitSearch) || 3, this.showWebhookVerb = B(f.showWebhookVerb), this.hidePropertiesPrefix = B(f.hidePropertiesPrefix, !0);
            }
          }
          var he = eM, Z = o.n(he);
          const { default: re, css: Pe, createGlobalStyle: Oe, keyframes: qe, ThemeProvider: je } = he, $ = { lessThan(p, f, h) {
            return (...w) => Pe`
      @media ${f ? "print, " : ""} screen and (max-width: ${(P) => P.theme.breakpoints[p]}) ${h || ""} {
        ${Pe(...w)};
      }
    `;
          }, greaterThan(p) {
            return (...f) => Pe`
      @media (min-width: ${(h) => h.theme.breakpoints[p]}) {
        ${Pe(...f)};
      }
    `;
          }, between(p, f) {
            return (...h) => Pe`
      @media (min-width: ${(w) => w.theme.breakpoints[p]}) and (max-width: ${(w) => w.theme.breakpoints[f]}) {
        ${Pe(...h)};
      }
    `;
          } };
          var K = re;
          function me(p) {
            return (f) => {
              if (f.theme.extensionsHook) return f.theme.extensionsHook(p, f);
            };
          }
          const Te = K.div`
  padding: 20px;
  color: red;
`;
          class ke extends i.Component {
            constructor(f) {
              super(f), this.state = { error: void 0 };
            }
            componentDidCatch(f) {
              return this.setState({ error: f }), !1;
            }
            render() {
              return this.state.error ? i.createElement(Te, null, i.createElement("h1", null, "Something went wrong..."), i.createElement("small", null, " ", this.state.error.message, " "), i.createElement("p", null, i.createElement("details", null, i.createElement("summary", null, "Stack trace"), i.createElement("pre", null, this.state.error.stack))), i.createElement("small", null, " ReDoc Version: ", "2.5.0"), " ", i.createElement("br", null), i.createElement("small", null, " Commit: ", "00bc6ed")) : i.createElement(i.Fragment, null, i.Children.only(this.props.children));
            }
          }
          const De = qe`
  0% {
    transform: rotate(0deg); }
  100% {
    transform: rotate(360deg);
  }
`, Fe = K((p) => i.createElement("svg", { className: p.className, version: "1.1", width: "512", height: "512", viewBox: "0 0 512 512" }, i.createElement("path", { d: "M275.682 147.999c0 10.864-8.837 19.661-19.682 19.661v0c-10.875 0-19.681-8.796-19.681-19.661v-96.635c0-10.885 8.806-19.661 19.681-19.661v0c10.844 0 19.682 8.776 19.682 19.661v96.635z" }), i.createElement("path", { d: "M275.682 460.615c0 10.865-8.837 19.682-19.682 19.682v0c-10.875 0-19.681-8.817-19.681-19.682v-96.604c0-10.885 8.806-19.681 19.681-19.681v0c10.844 0 19.682 8.796 19.682 19.682v96.604z" }), i.createElement("path", { d: "M147.978 236.339c10.885 0 19.681 8.755 19.681 19.641v0c0 10.885-8.796 19.702-19.681 19.702h-96.624c-10.864 0-19.661-8.817-19.661-19.702v0c0-10.885 8.796-19.641 19.661-19.641h96.624z" }), i.createElement("path", { d: "M460.615 236.339c10.865 0 19.682 8.755 19.682 19.641v0c0 10.885-8.817 19.702-19.682 19.702h-96.584c-10.885 0-19.722-8.817-19.722-19.702v0c0-10.885 8.837-19.641 19.722-19.641h96.584z" }), i.createElement("path", { d: "M193.546 165.703c7.69 7.66 7.68 20.142 0 27.822v0c-7.701 7.701-20.162 7.701-27.853 0.020l-68.311-68.322c-7.68-7.701-7.68-20.142 0-27.863v0c7.68-7.68 20.121-7.68 27.822 0l68.342 68.342z" }), i.createElement("path", { d: "M414.597 386.775c7.7 7.68 7.7 20.163 0.021 27.863v0c-7.7 7.659-20.142 7.659-27.843-0.062l-68.311-68.26c-7.68-7.7-7.68-20.204 0-27.863v0c7.68-7.7 20.163-7.7 27.842 0l68.291 68.322z" }), i.createElement("path", { d: "M165.694 318.464c7.69-7.7 20.153-7.7 27.853 0v0c7.68 7.659 7.69 20.163 0 27.863l-68.342 68.322c-7.67 7.659-20.142 7.659-27.822-0.062v0c-7.68-7.68-7.68-20.122 0-27.801l68.311-68.322z" }), i.createElement("path", { d: "M386.775 97.362c7.7-7.68 20.142-7.68 27.822 0v0c7.7 7.68 7.7 20.183 0.021 27.863l-68.322 68.311c-7.68 7.68-20.163 7.68-27.843-0.020v0c-7.68-7.68-7.68-20.162 0-27.822l68.322-68.332z" })))`
  animation: 2s ${De} linear infinite;
  width: 50px;
  height: 50px;
  content: '';
  display: inline-block;
  margin-left: -25px;

  path {
    fill: ${(p) => p.color};
  }
`, Xe = K.div`
  font-family: helvetica, sans;
  width: 100%;
  text-align: center;
  font-size: 25px;
  margin: 30px 0 20px 0;
  color: ${(p) => p.color};
`;
          class ct extends i.PureComponent {
            render() {
              return i.createElement("div", { style: { textAlign: "center" } }, i.createElement(Xe, { color: this.props.color }, "Loading ..."), i.createElement(Fe, { color: this.props.color }));
            }
          }
          var mt = /* @__PURE__ */ gT();
          const st = i.createContext(new ie({})), at = st.Provider, Vt = st.Consumer;
          var Y = xF, Ie = tU(), Le = g$(), Me = o(65), ze = (p, f, h) => new Promise((w, P) => {
            var L = (ue) => {
              try {
                ee(h.next(ue));
              } catch (pe) {
                P(pe);
              }
            }, z = (ue) => {
              try {
                ee(h.throw(ue));
              } catch (pe) {
                P(pe);
              }
            }, ee = (ue) => ue.done ? w(ue.value) : Promise.resolve(ue.value).then(L, z);
            ee((h = h.apply(p, f)).next());
          });
          function He(p) {
            return ze(this, null, function* () {
              const f = new Le.Config({}), h = { config: f, base: m ? window.location.href : process.cwd() };
              m && (f.resolve.http.customFetch = o.g.fetch), typeof p == "object" && p !== null ? h.doc = { source: { absoluteRef: "" }, parsed: p } : h.ref = p;
              const { bundle: { parsed: w } } = yield (0, Ie.bundle)(h);
              return w.swagger !== void 0 ? rt(w) : w;
            });
          }
          function rt(p) {
            return console.warn("[ReDoc Compatibility mode]: Converting OpenAPI 2.0 to OpenAPI 3.0"), new Promise((f, h) => (0, Me.convertObj)(p, { patch: !0, warnOnly: !0, text: "{}", anchors: !0 }, (w, P) => {
              if (w) return h(w);
              f(P && P.openapi);
            }));
          }
          var Ye = nU(), Ze = iU(), Ge = y$();
          const bt = Ge.parse;
          class kt {
            static baseName(f, h = 1) {
              const w = kt.parse(f);
              return w[w.length - h];
            }
            static dirName(f, h = 1) {
              const w = kt.parse(f);
              return Ge.compile(w.slice(0, w.length - h));
            }
            static relative(f, h) {
              const w = kt.parse(f);
              return kt.parse(h).slice(w.length);
            }
            static parse(f) {
              let h = f;
              return h.charAt(0) === "#" && (h = h.substring(1)), bt(h);
            }
            static join(f, h) {
              const w = kt.parse(f).concat(h);
              return Ge.compile(w);
            }
            static get(f, h) {
              return Ge.get(f, h);
            }
            static compile(f) {
              return Ge.compile(f);
            }
            static escape(f) {
              return Ge.escape(f);
            }
          }
          Ge.parse = kt.parse, Object.assign(kt, Ge);
          var Tt = o(975), It = aU(), Xr = Object.defineProperty, er = Object.defineProperties, Xi = Object.getOwnPropertyDescriptors, Ns = Object.getOwnPropertySymbols, Ji = Object.prototype.hasOwnProperty, Kp = Object.prototype.propertyIsEnumerable, js = (p, f, h) => f in p ? Xr(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h, In = (p, f) => {
            for (var h in f || (f = {})) Ji.call(f, h) && js(p, h, f[h]);
            if (Ns) for (var h of Ns(f)) Kp.call(f, h) && js(p, h, f[h]);
            return p;
          }, Zi = (p, f) => er(p, Xi(f));
          function ya(p) {
            return typeof p == "string" && /\dxx/i.test(p);
          }
          function xl(p) {
            return p === "default" || R(p) || ya(p);
          }
          function cr(p, f = !1) {
            if (p === "default") return f ? "error" : "success";
            let h = typeof p == "string" ? parseInt(p, 10) : p;
            if (ya(p) && (h *= 100), h < 100 || h > 599) throw new Error("invalid HTTP code");
            let w = "success";
            return h >= 300 && h < 400 ? w = "redirect" : h >= 400 ? w = "error" : h < 200 && (w = "info"), w;
          }
          const Wu = { get: !0, post: !0, put: !0, head: !0, patch: !0, delete: !0, options: !0, $ref: !0 };
          function Ht(p) {
            return p in Wu;
          }
          function va(p) {
            return p.summary || p.operationId || p.description && p.description.substring(0, 50) || p.pathName || "<no summary>";
          }
          const Xt = { multipleOf: "number", maximum: "number", exclusiveMaximum: "number", minimum: "number", exclusiveMinimum: "number", maxLength: "string", minLength: "string", pattern: "string", contentEncoding: "string", contentMediaType: "string", items: "array", maxItems: "array", minItems: "array", uniqueItems: "array", maxProperties: "object", minProperties: "object", required: "object", additionalProperties: "object", unevaluatedProperties: "object", properties: "object", patternProperties: "object" };
          function Ls(p) {
            if (p.type !== void 0 && !ce(p.type)) return p.type;
            const f = Object.keys(Xt);
            for (const h of f) {
              const w = Xt[h];
              if (p[h] !== void 0) return w;
            }
            return "any";
          }
          function Ms(p, f = p.type) {
            if (p["x-circular-ref"]) return !0;
            if (p.oneOf !== void 0 || p.anyOf !== void 0 || p.if && p.then || p.if && p.else) return !1;
            let h = !0;
            const w = ce(f);
            return (f === "object" || w && (f != null && f.includes("object"))) && (h = p.properties !== void 0 ? Object.keys(p.properties).length === 0 : p.additionalProperties === void 0 && p.unevaluatedProperties === void 0 && p.patternProperties === void 0), !ce(p.items) && !ce(p.prefixItems) && (p.items !== void 0 && !se(p.items) && (f === "array" || w && (f != null && f.includes("array"))) && (h = Ms(p.items, p.items.type)), h);
          }
          function es(p) {
            return p.search(/json/i) !== -1;
          }
          function Eo(p) {
            return p === "application/x-www-form-urlencoded";
          }
          function ba(p, f, h) {
            return ce(p) ? p.map((w) => w.toString()).join(h) : typeof p == "object" ? Object.keys(p).map((w) => `${w}${h}${p[w]}`).join(h) : f + "=" + p.toString();
          }
          function _l(p, f) {
            return ce(p) ? (console.warn("deepObject style cannot be used with array value:" + p.toString()), "") : typeof p == "object" ? Object.keys(p).map((h) => `${f}[${h}]=${p[h]}`).join("&") : (console.warn("deepObject style cannot be used with non-object value:" + p.toString()), "");
          }
          function Nn(p, f, h) {
            const w = "__redoc_param_name__", P = f ? "*" : "";
            return It.parse(`{?${w}${P}}`).expand({ [w]: h }).substring(1).replace(/__redoc_param_name__/g, p);
          }
          function Kt(p, f = {}) {
            if (ce(p)) throw new Error("Payload must have fields: " + p.toString());
            return Object.keys(p).map((h) => {
              const w = p[h], { style: P = "form", explode: L = !0 } = f[h] || {};
              switch (P) {
                case "form":
                  return Nn(h, L, w);
                case "spaceDelimited":
                  return ba(w, h, "%20");
                case "pipeDelimited":
                  return ba(w, h, "|");
                case "deepObject":
                  return _l(w, h);
                default:
                  return console.warn("Incorrect or unsupported encoding style: " + P), "";
              }
            }).join("&");
          }
          function ri(p, f) {
            return es(f) ? JSON.stringify(p) : (console.warn(`Parameter serialization as ${f} is not supported`), "");
          }
          function Ds(p, f) {
            const { name: h, style: w, explode: P = !1, serializationMime: L } = p;
            if (L) switch (p.in) {
              case "path":
              case "header":
                return ri(f, L);
              case "cookie":
              case "query":
                return `${h}=${ri(f, L)}`;
              default:
                return console.warn("Unexpected parameter location: " + p.in), "";
            }
            if (!w) return console.warn(`Missing style attribute or content for parameter ${h}`), "";
            switch (p.in) {
              case "path":
                return function(z, ee, ue, pe) {
                  const xe = ue ? "*" : "";
                  let le = "";
                  ee === "label" ? le = "." : ee === "matrix" && (le = ";");
                  const we = "__redoc_param_name__";
                  return It.parse(`{${le}${we}${xe}}`).expand({ [we]: pe }).replace(/__redoc_param_name__/g, z);
                }(h, w, P, f);
              case "query":
                return function(z, ee, ue, pe) {
                  switch (ee) {
                    case "form":
                      return Nn(z, ue, pe);
                    case "spaceDelimited":
                      return ce(pe) ? ue ? Nn(z, ue, pe) : `${z}=${pe.join("%20")}` : (console.warn("The style spaceDelimited is only applicable to arrays"), "");
                    case "pipeDelimited":
                      return ce(pe) ? ue ? Nn(z, ue, pe) : `${z}=${pe.join("|")}` : (console.warn("The style pipeDelimited is only applicable to arrays"), "");
                    case "deepObject":
                      return !ue || ce(pe) || typeof pe != "object" ? (console.warn("The style deepObject is only applicable for objects with explode=true"), "") : _l(pe, z);
                    default:
                      return console.warn("Unexpected style for query: " + ee), "";
                  }
                }(h, w, P, f);
              case "header":
                return function(z, ee, ue) {
                  if (z === "simple") {
                    const pe = ee ? "*" : "", xe = "__redoc_param_name__", le = It.parse(`{${xe}${pe}}`);
                    return decodeURIComponent(le.expand({ [xe]: ue }));
                  }
                  return console.warn("Unexpected style for header: " + z), "";
                }(w, P, f);
              case "cookie":
                return function(z, ee, ue, pe) {
                  return ee === "form" ? Nn(z, ue, pe) : (console.warn("Unexpected style for cookie: " + ee), "");
                }(h, w, P, f);
              default:
                return console.warn("Unexpected parameter location: " + p.in), "";
            }
          }
          function bi(p, f) {
            return p.in ? decodeURIComponent(Ds(p, f)) : typeof f == "object" ? f : String(f);
          }
          function jn(p) {
            return p.search(/xml/i) !== -1 ? "xml" : p.search(/csv/i) !== -1 ? "csv" : p.search(/plain/i) !== -1 ? "tex" : "clike";
          }
          const Oo = /^#\/components\/(schemas|pathItems)\/([^/]+)$/;
          function ts(p) {
            return Oo.test(p || "");
          }
          function rs(p) {
            var f;
            const [h] = ((f = p == null ? void 0 : p.match(Oo)) == null ? void 0 : f.reverse()) || [];
            return h;
          }
          function Jr(p, f, h) {
            let w;
            return f !== void 0 && h !== void 0 ? w = f === h ? `= ${f} ${p}` : `[ ${f} .. ${h} ] ${p}` : h !== void 0 ? w = `<= ${h} ${p}` : f !== void 0 && (w = f === 1 ? "non-empty" : `>= ${f} ${p}`), w;
          }
          function Ku(p) {
            var f, h;
            const w = typeof p.exclusiveMinimum == "number" ? Math.min(p.exclusiveMinimum, (f = p.minimum) != null ? f : 1 / 0) : p.minimum, P = typeof p.exclusiveMaximum == "number" ? Math.max(p.exclusiveMaximum, (h = p.maximum) != null ? h : -1 / 0) : p.maximum, L = typeof p.exclusiveMinimum == "number" || p.exclusiveMinimum, z = typeof p.exclusiveMaximum == "number" || p.exclusiveMaximum;
            return w !== void 0 && P !== void 0 ? `${L ? "( " : "[ "}${w} .. ${P}${z ? " )" : " ]"}` : P !== void 0 ? `${z ? "< " : "<= "}${P}` : w !== void 0 ? `${L ? "> " : ">= "}${w}` : void 0;
          }
          function Mr(p) {
            const f = [], h = Jr("characters", p.minLength, p.maxLength);
            h !== void 0 && f.push(h);
            const w = Jr("items", p.minItems, p.maxItems);
            w !== void 0 && f.push(w);
            const P = Jr("properties", p.minProperties, p.maxProperties);
            P !== void 0 && f.push(P);
            const L = function(ee) {
              if (ee === void 0) return;
              const ue = ee.toString(10);
              return /^0\.0*1$/.test(ue) ? `decimal places <= ${ue.split(".")[1].length}` : `multiple of ${ue}`;
            }(p.multipleOf);
            L !== void 0 && f.push(L);
            const z = Ku(p);
            return z !== void 0 && f.push(z), p.uniqueItems && f.push("unique"), f;
          }
          function ns(p, f = []) {
            const h = [], w = [], P = [];
            return p.forEach((L) => {
              L.required ? f.includes(L.name) ? w.push(L) : P.push(L) : h.push(L);
            }), w.sort((L, z) => f.indexOf(L.name) - f.indexOf(z.name)), [...w, ...P, ...h];
          }
          function wi(p, f) {
            return [...p].sort((h, w) => h[f].localeCompare(w[f]));
          }
          function is(p, f = [], h = []) {
            const w = {};
            return h.forEach((P) => {
              ({ resolved: P } = p.deref(P)), w[P.name + "_" + P.in] = !0;
            }), (f = f.filter((P) => ({ resolved: P } = p.deref(P), !w[P.name + "_" + P.in]))).concat(h);
          }
          function Fs(p) {
            const f = {};
            return Object.keys(p).forEach((h) => {
              const w = p[h], P = h.split(";")[0].trim();
              f[P] ? f[P] = In(In({}, f[P]), w) : f[P] = w;
            }), f;
          }
          function qs(p, f = {}) {
            return p.replace(/(?:{)([\w-.]+)(?:})/g, (h, w) => f[w] && f[w].default || h);
          }
          function Si(p, f) {
            const h = p === void 0 ? ge((() => {
              if (!m) return "";
              const w = window.location.href;
              return w.endsWith(".html") ? (0, Tt.dirname)(w) : w;
            })()) : (0, Tt.dirname)(p);
            return f.length === 0 && (f = [{ url: "/" }]), f.map((w) => {
              return Zi(In({}, w), { url: (P = w.url, ne(h, P)), description: w.description || "" });
              var P;
            });
          }
          const ss = "SecurityDefinitions", El = "security-definitions", ko = "SchemaDefinition";
          let Ln = "section/Authentication/";
          function Mn(p) {
            Ln = p;
          }
          const Dn = (p) => ({ delete: "del", options: "opts" })[p] || p;
          function xi(p) {
            return p in { "x-circular-ref": !0, "x-parentRefs": !0, "x-refsStack": !0, "x-code-samples": !0, "x-codeSamples": !0, "x-displayName": !0, "x-examples": !0, "x-enumDescriptions": !0, "x-logo": !0, "x-nullable": !0, "x-servers": !0, "x-tagGroups": !0, "x-traitTag": !0, "x-badges": !0, "x-additionalPropertiesName": !0, "x-explicitMappingOnly": !0 };
          }
          function os(p, f) {
            return Object.keys(p).filter((h) => f === !0 ? h.startsWith("x-") && !xi(h) : h.startsWith("x-") && f.indexOf(h) > -1).reduce((h, w) => (h[w] = p[w], h), {});
          }
          function wa(p) {
            return p.split(" or ").map((f) => f.replace(/^(string|object|number|integer|array|boolean)s?( ?.*)/, "$1s$2")).join(" or ");
          }
          function Lt(p) {
            let f = p.content;
            const h = p["x-examples"], w = p["x-example"];
            if (h) {
              f = In({}, f);
              for (const P of Object.keys(h)) {
                const L = h[P];
                f[P] = Zi(In({}, f[P]), { examples: L });
              }
            } else if (w) {
              f = In({}, f);
              for (const P of Object.keys(w)) {
                const L = w[P];
                f[P] = Zi(In({}, f[P]), { example: L });
              }
            }
            return f;
          }
          var ni = lU();
          uU(), cU(), pU(), fU(), dU(), hU(), mU(), gU(), yU(), vU(), bU(), wU(), SU(), xU(), _U(), EU(), OU(), kU(), AU(), PU(), TU(), CU(), $U();
          const Ol = "clike";
          function _i(p) {
            return { json: "js", "c++": "cpp", "c#": "csharp", "objective-c": "objectivec", shell: "bash", viml: "vim" }[p] || Ol;
          }
          function Sa(p, f = Ol) {
            f = f.toLowerCase();
            let h = ni.languages[f];
            return h || (h = ni.languages[_i(f)]), ni.highlight(p.toString(), h, f);
          }
          function kl(p) {
            return (f, h, w) => {
              w.value = /* @__PURE__ */ function(P, L) {
                let z, ee, ue, pe = null, xe = 0;
                const le = () => {
                  xe = (/* @__PURE__ */ new Date()).getTime(), pe = null, ue = P.apply(z, ee), pe || (z = ee = null);
                };
                return function() {
                  const we = (/* @__PURE__ */ new Date()).getTime(), Ve = L - (we - xe);
                  return z = this, ee = arguments, Ve <= 0 || Ve > L ? (pe && (clearTimeout(pe), pe = null), xe = we, ue = P.apply(z, ee), pe || (z = ee = null)) : pe || (pe = setTimeout(le, Ve)), ue;
                };
              }(w.value, p);
            };
          }
          function mr(p) {
          }
          function Ei(p) {
          }
          ni.languages.insertBefore("javascript", "string", { "property string": { pattern: /([{,]\s*)"(?:\\.|[^\\"\r\n])*"(?=\s*:)/i, lookbehind: !0 } }, void 0), ni.languages.insertBefore("javascript", "punctuation", { property: { pattern: /([{,]\s*)[a-z]\w*(?=\s*:)/i, lookbehind: !0 } }, void 0);
          var xa = Object.defineProperty, ii = Object.defineProperties, Fn = Object.getOwnPropertyDescriptors, qn = Object.getOwnPropertySymbols, zs = Object.prototype.hasOwnProperty, Ao = Object.prototype.propertyIsEnumerable, br = (p, f, h) => f in p ? xa(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h, Po = (p, f) => {
            for (var h in f || (f = {})) zs.call(f, h) && br(p, h, f[h]);
            if (qn) for (var h of qn(f)) Ao.call(f, h) && br(p, h, f[h]);
            return p;
          }, _a = (p, f) => ii(p, Fn(f));
          const si = {};
          function Oi(p, f, h) {
            if (typeof h.value == "function") return function(w, P, L) {
              if (!L.value || L.value.length > 0) throw new Error("@memoize decorator can only be applied to methods of zero arguments");
              const z = `_memoized_${P}`, ee = L.value;
              return w[z] = si, _a(Po({}, L), { value() {
                return this[z] === si && (this[z] = ee.call(this)), this[z];
              } });
            }(p, f, h);
            if (typeof h.get == "function") return function(w, P, L) {
              const z = `_memoized_${P}`, ee = L.get;
              return w[z] = si, _a(Po({}, L), { get() {
                return this[z] === si && (this[z] = ee.call(this)), this[z];
              } });
            }(p, f, h);
            throw new Error("@memoize decorator can be applied to methods or getters, got " + String(h.value) + " instead");
          }
          function To(p) {
            let f = 1;
            return p[0] === "-" && (f = -1, p = p.substr(1)), (h, w) => f == -1 ? w[p].localeCompare(h[p]) : h[p].localeCompare(w[p]);
          }
          var ln = Object.defineProperty, Al = Object.getOwnPropertyDescriptor;
          const Ea = "hashchange";
          class ki {
            constructor() {
              this.emit = () => {
                this._emiter.emit(Ea, this.currentId);
              }, this._emiter = new Ze.EventEmitter(), this.bind();
            }
            get currentId() {
              return m ? decodeURIComponent(window.location.hash.substring(1)) : "";
            }
            linkForId(f) {
              return f ? "#" + f : "";
            }
            subscribe(f) {
              const h = this._emiter.addListener(Ea, f);
              return () => h.removeListener(Ea, f);
            }
            bind() {
              m && window.addEventListener("hashchange", this.emit, !1);
            }
            dispose() {
              m && window.removeEventListener("hashchange", this.emit);
            }
            replace(f, h = !1) {
              m && f != null && f !== this.currentId && (h ? window.history.replaceState(null, "", window.location.href.split("#")[0] + this.linkForId(f)) : (window.history.pushState(null, "", window.location.href.split("#")[0] + this.linkForId(f)), this.emit()));
            }
          }
          ((p, f, h) => {
            for (var w, P = Al(f, h), L = p.length - 1; L >= 0; L--) (w = p[L]) && (P = w(f, h, P) || P);
            P && ln(f, h, P);
          })([Ye.bind, Ye.debounce], ki.prototype, "replace");
          const oi = new ki();
          var as = IU();
          class ft {
            constructor() {
              this.map = /* @__PURE__ */ new Map(), this.prevTerm = "";
            }
            add(f) {
              this.map.set(f, new as(f));
            }
            delete(f) {
              this.map.delete(f);
            }
            addOnly(f) {
              this.map.forEach((h, w) => {
                f.indexOf(w) === -1 && (h.unmark(), this.map.delete(w));
              });
              for (const h of f) this.map.has(h) || this.map.set(h, new as(h));
            }
            clearAll() {
              this.unmark(), this.map.clear();
            }
            mark(f) {
              (f || this.prevTerm) && (this.map.forEach((h) => {
                h.unmark(), h.mark(f || this.prevTerm);
              }), this.prevTerm = f || this.prevTerm);
            }
            unmark() {
              this.map.forEach((f) => f.unmark()), this.prevTerm = "";
            }
          }
          let _e = { async: !1, baseUrl: null, breaks: !1, extensions: null, gfm: !0, headerIds: !0, headerPrefix: "", highlight: null, hooks: null, langPrefix: "language-", mangle: !0, pedantic: !1, renderer: null, sanitize: !1, sanitizer: null, silent: !1, smartypants: !1, tokenizer: null, walkTokens: null, xhtml: !1 };
          const Ke = /[&<>"']/, lt = new RegExp(Ke.source, "g"), qt = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, wr = new RegExp(qt.source, "g"), Sr = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, tr = (p) => Sr[p];
          function Ut(p, f) {
            if (f) {
              if (Ke.test(p)) return p.replace(lt, tr);
            } else if (qt.test(p)) return p.replace(wr, tr);
            return p;
          }
          const Ai = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi;
          function Or(p) {
            return p.replace(Ai, (f, h) => (h = h.toLowerCase()) === "colon" ? ":" : h.charAt(0) === "#" ? h.charAt(1) === "x" ? String.fromCharCode(parseInt(h.substring(2), 16)) : String.fromCharCode(+h.substring(1)) : "");
          }
          const Co = /(^|[^\[])\^/g;
          function Dt(p, f) {
            p = typeof p == "string" ? p : p.source, f = f || "";
            const h = { replace: (w, P) => (P = (P = P.source || P).replace(Co, "$1"), p = p.replace(w, P), h), getRegex: () => new RegExp(p, f) };
            return h;
          }
          const Ch = /[^\w:]/g, wn = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
          function $o(p, f, h) {
            if (p) {
              let w;
              try {
                w = decodeURIComponent(Or(h)).replace(Ch, "").toLowerCase();
              } catch {
                return null;
              }
              if (w.indexOf("javascript:") === 0 || w.indexOf("vbscript:") === 0 || w.indexOf("data:") === 0) return null;
            }
            f && !wn.test(h) && (h = function(w, P) {
              Oa[" " + w] || (Pl.test(w) ? Oa[" " + w] = w + "/" : Oa[" " + w] = Ro(w, "/", !0));
              const L = (w = Oa[" " + w]).indexOf(":") === -1;
              return P.substring(0, 2) === "//" ? L ? P : w.replace(db, "$1") + P : P.charAt(0) === "/" ? L ? P : w.replace(Qp, "$1") + P : w + P;
            }(f, h));
            try {
              h = encodeURI(h).replace(/%25/g, "%");
            } catch {
              return null;
            }
            return h;
          }
          const Oa = {}, Pl = /^[^:]+:\/*[^/]*$/, db = /^([^:]+:)[\s\S]*$/, Qp = /^([^:]+:\/*[^/]*)[\s\S]*$/, ka = { exec: function() {
          } };
          function Aa(p, f) {
            const h = p.replace(/\|/g, (P, L, z) => {
              let ee = !1, ue = L;
              for (; --ue >= 0 && z[ue] === "\\"; ) ee = !ee;
              return ee ? "|" : " |";
            }).split(/ \|/);
            let w = 0;
            if (h[0].trim() || h.shift(), h.length > 0 && !h[h.length - 1].trim() && h.pop(), h.length > f) h.splice(f);
            else for (; h.length < f; ) h.push("");
            for (; w < h.length; w++) h[w] = h[w].trim().replace(/\\\|/g, "|");
            return h;
          }
          function Ro(p, f, h) {
            const w = p.length;
            if (w === 0) return "";
            let P = 0;
            for (; P < w; ) {
              const L = p.charAt(w - P - 1);
              if (L !== f || h) {
                if (L === f || !h) break;
                P++;
              } else P++;
            }
            return p.slice(0, w - P);
          }
          function Yp(p, f) {
            if (f < 1) return "";
            let h = "";
            for (; f > 1; ) 1 & f && (h += p), f >>= 1, p += p;
            return h + p;
          }
          function $h(p, f, h, w) {
            const P = f.href, L = f.title ? Ut(f.title) : null, z = p[1].replace(/\\([\[\]])/g, "$1");
            if (p[0].charAt(0) !== "!") {
              w.state.inLink = !0;
              const ee = { type: "link", raw: h, href: P, title: L, text: z, tokens: w.inlineTokens(z) };
              return w.state.inLink = !1, ee;
            }
            return { type: "image", raw: h, href: P, title: L, text: Ut(z) };
          }
          class Gp {
            constructor(f) {
              this.options = f || _e;
            }
            space(f) {
              const h = this.rules.block.newline.exec(f);
              if (h && h[0].length > 0) return { type: "space", raw: h[0] };
            }
            code(f) {
              const h = this.rules.block.code.exec(f);
              if (h) {
                const w = h[0].replace(/^ {1,4}/gm, "");
                return { type: "code", raw: h[0], codeBlockStyle: "indented", text: this.options.pedantic ? w : Ro(w, `
`) };
              }
            }
            fences(f) {
              const h = this.rules.block.fences.exec(f);
              if (h) {
                const w = h[0], P = function(L, z) {
                  const ee = L.match(/^(\s+)(?:```)/);
                  if (ee === null) return z;
                  const ue = ee[1];
                  return z.split(`
`).map((pe) => {
                    const xe = pe.match(/^\s+/);
                    if (xe === null) return pe;
                    const [le] = xe;
                    return le.length >= ue.length ? pe.slice(ue.length) : pe;
                  }).join(`
`);
                }(w, h[3] || "");
                return { type: "code", raw: w, lang: h[2] ? h[2].trim().replace(this.rules.inline._escapes, "$1") : h[2], text: P };
              }
            }
            heading(f) {
              const h = this.rules.block.heading.exec(f);
              if (h) {
                let w = h[2].trim();
                if (/#$/.test(w)) {
                  const P = Ro(w, "#");
                  this.options.pedantic ? w = P.trim() : P && !/ $/.test(P) || (w = P.trim());
                }
                return { type: "heading", raw: h[0], depth: h[1].length, text: w, tokens: this.lexer.inline(w) };
              }
            }
            hr(f) {
              const h = this.rules.block.hr.exec(f);
              if (h) return { type: "hr", raw: h[0] };
            }
            blockquote(f) {
              const h = this.rules.block.blockquote.exec(f);
              if (h) {
                const w = h[0].replace(/^ *>[ \t]?/gm, ""), P = this.lexer.state.top;
                this.lexer.state.top = !0;
                const L = this.lexer.blockTokens(w);
                return this.lexer.state.top = P, { type: "blockquote", raw: h[0], tokens: L, text: w };
              }
            }
            list(f) {
              let h = this.rules.block.list.exec(f);
              if (h) {
                let w, P, L, z, ee, ue, pe, xe, le, we, Ve, it, _t = h[1].trim();
                const Et = _t.length > 1, gt = { type: "list", raw: "", ordered: Et, start: Et ? +_t.slice(0, -1) : "", loose: !1, items: [] };
                _t = Et ? `\\d{1,9}\\${_t.slice(-1)}` : `\\${_t}`, this.options.pedantic && (_t = Et ? _t : "[*+-]");
                const pi = new RegExp(`^( {0,3}${_t})((?:[	 ][^\\n]*)?(?:\\n|$))`);
                for (; f && (it = !1, h = pi.exec(f)) && !this.rules.block.hr.test(f); ) {
                  if (w = h[0], f = f.substring(w.length), xe = h[2].split(`
`, 1)[0].replace(/^\t+/, (Pr) => " ".repeat(3 * Pr.length)), le = f.split(`
`, 1)[0], this.options.pedantic ? (z = 2, Ve = xe.trimLeft()) : (z = h[2].search(/[^ ]/), z = z > 4 ? 1 : z, Ve = xe.slice(z), z += h[1].length), ue = !1, !xe && /^ *$/.test(le) && (w += le + `
`, f = f.substring(le.length + 1), it = !0), !it) {
                    const Pr = new RegExp(`^ {0,${Math.min(3, z - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), Bi = new RegExp(`^ {0,${Math.min(3, z - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), Ir = new RegExp(`^ {0,${Math.min(3, z - 1)}}(?:\`\`\`|~~~)`), yn = new RegExp(`^ {0,${Math.min(3, z - 1)}}#`);
                    for (; f && (we = f.split(`
`, 1)[0], le = we, this.options.pedantic && (le = le.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), !Ir.test(le)) && !yn.test(le) && !Pr.test(le) && !Bi.test(f); ) {
                      if (le.search(/[^ ]/) >= z || !le.trim()) Ve += `
` + le.slice(z);
                      else {
                        if (ue || xe.search(/[^ ]/) >= 4 || Ir.test(xe) || yn.test(xe) || Bi.test(xe)) break;
                        Ve += `
` + le;
                      }
                      ue || le.trim() || (ue = !0), w += we + `
`, f = f.substring(we.length + 1), xe = le.slice(z);
                    }
                  }
                  gt.loose || (pe ? gt.loose = !0 : /\n *\n *$/.test(w) && (pe = !0)), this.options.gfm && (P = /^\[[ xX]\] /.exec(Ve), P && (L = P[0] !== "[ ] ", Ve = Ve.replace(/^\[[ xX]\] +/, ""))), gt.items.push({ type: "list_item", raw: w, task: !!P, checked: L, loose: !1, text: Ve }), gt.raw += w;
                }
                gt.items[gt.items.length - 1].raw = w.trimRight(), gt.items[gt.items.length - 1].text = Ve.trimRight(), gt.raw = gt.raw.trimRight();
                const Qn = gt.items.length;
                for (ee = 0; ee < Qn; ee++) if (this.lexer.state.top = !1, gt.items[ee].tokens = this.lexer.blockTokens(gt.items[ee].text, []), !gt.loose) {
                  const Pr = gt.items[ee].tokens.filter((Ir) => Ir.type === "space"), Bi = Pr.length > 0 && Pr.some((Ir) => /\n.*\n/.test(Ir.raw));
                  gt.loose = Bi;
                }
                if (gt.loose) for (ee = 0; ee < Qn; ee++) gt.items[ee].loose = !0;
                return gt;
              }
            }
            html(f) {
              const h = this.rules.block.html.exec(f);
              if (h) {
                const w = { type: "html", raw: h[0], pre: !this.options.sanitizer && (h[1] === "pre" || h[1] === "script" || h[1] === "style"), text: h[0] };
                if (this.options.sanitize) {
                  const P = this.options.sanitizer ? this.options.sanitizer(h[0]) : Ut(h[0]);
                  w.type = "paragraph", w.text = P, w.tokens = this.lexer.inline(P);
                }
                return w;
              }
            }
            def(f) {
              const h = this.rules.block.def.exec(f);
              if (h) {
                const w = h[1].toLowerCase().replace(/\s+/g, " "), P = h[2] ? h[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "", L = h[3] ? h[3].substring(1, h[3].length - 1).replace(this.rules.inline._escapes, "$1") : h[3];
                return { type: "def", tag: w, raw: h[0], href: P, title: L };
              }
            }
            table(f) {
              const h = this.rules.block.table.exec(f);
              if (h) {
                const w = { type: "table", header: Aa(h[1]).map((P) => ({ text: P })), align: h[2].replace(/^ *|\| *$/g, "").split(/ *\| */), rows: h[3] && h[3].trim() ? h[3].replace(/\n[ \t]*$/, "").split(`
`) : [] };
                if (w.header.length === w.align.length) {
                  w.raw = h[0];
                  let P, L, z, ee, ue = w.align.length;
                  for (P = 0; P < ue; P++) /^ *-+: *$/.test(w.align[P]) ? w.align[P] = "right" : /^ *:-+: *$/.test(w.align[P]) ? w.align[P] = "center" : /^ *:-+ *$/.test(w.align[P]) ? w.align[P] = "left" : w.align[P] = null;
                  for (ue = w.rows.length, P = 0; P < ue; P++) w.rows[P] = Aa(w.rows[P], w.header.length).map((pe) => ({ text: pe }));
                  for (ue = w.header.length, L = 0; L < ue; L++) w.header[L].tokens = this.lexer.inline(w.header[L].text);
                  for (ue = w.rows.length, L = 0; L < ue; L++) for (ee = w.rows[L], z = 0; z < ee.length; z++) ee[z].tokens = this.lexer.inline(ee[z].text);
                  return w;
                }
              }
            }
            lheading(f) {
              const h = this.rules.block.lheading.exec(f);
              if (h) return { type: "heading", raw: h[0], depth: h[2].charAt(0) === "=" ? 1 : 2, text: h[1], tokens: this.lexer.inline(h[1]) };
            }
            paragraph(f) {
              const h = this.rules.block.paragraph.exec(f);
              if (h) {
                const w = h[1].charAt(h[1].length - 1) === `
` ? h[1].slice(0, -1) : h[1];
                return { type: "paragraph", raw: h[0], text: w, tokens: this.lexer.inline(w) };
              }
            }
            text(f) {
              const h = this.rules.block.text.exec(f);
              if (h) return { type: "text", raw: h[0], text: h[0], tokens: this.lexer.inline(h[0]) };
            }
            escape(f) {
              const h = this.rules.inline.escape.exec(f);
              if (h) return { type: "escape", raw: h[0], text: Ut(h[1]) };
            }
            tag(f) {
              const h = this.rules.inline.tag.exec(f);
              if (h) return !this.lexer.state.inLink && /^<a /i.test(h[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(h[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(h[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(h[0]) && (this.lexer.state.inRawBlock = !1), { type: this.options.sanitize ? "text" : "html", raw: h[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(h[0]) : Ut(h[0]) : h[0] };
            }
            link(f) {
              const h = this.rules.inline.link.exec(f);
              if (h) {
                const w = h[2].trim();
                if (!this.options.pedantic && /^</.test(w)) {
                  if (!/>$/.test(w)) return;
                  const z = Ro(w.slice(0, -1), "\\");
                  if ((w.length - z.length) % 2 == 0) return;
                } else {
                  const z = function(ee, ue) {
                    if (ee.indexOf(ue[1]) === -1) return -1;
                    const pe = ee.length;
                    let xe = 0, le = 0;
                    for (; le < pe; le++) if (ee[le] === "\\") le++;
                    else if (ee[le] === ue[0]) xe++;
                    else if (ee[le] === ue[1] && (xe--, xe < 0)) return le;
                    return -1;
                  }(h[2], "()");
                  if (z > -1) {
                    const ee = (h[0].indexOf("!") === 0 ? 5 : 4) + h[1].length + z;
                    h[2] = h[2].substring(0, z), h[0] = h[0].substring(0, ee).trim(), h[3] = "";
                  }
                }
                let P = h[2], L = "";
                if (this.options.pedantic) {
                  const z = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(P);
                  z && (P = z[1], L = z[3]);
                } else L = h[3] ? h[3].slice(1, -1) : "";
                return P = P.trim(), /^</.test(P) && (P = this.options.pedantic && !/>$/.test(w) ? P.slice(1) : P.slice(1, -1)), $h(h, { href: P && P.replace(this.rules.inline._escapes, "$1"), title: L && L.replace(this.rules.inline._escapes, "$1") }, h[0], this.lexer);
              }
            }
            reflink(f, h) {
              let w;
              if ((w = this.rules.inline.reflink.exec(f)) || (w = this.rules.inline.nolink.exec(f))) {
                let P = (w[2] || w[1]).replace(/\s+/g, " ");
                if (P = h[P.toLowerCase()], !P) {
                  const L = w[0].charAt(0);
                  return { type: "text", raw: L, text: L };
                }
                return $h(w, P, w[0], this.lexer);
              }
            }
            emStrong(f, h, w = "") {
              let P = this.rules.inline.emStrong.lDelim.exec(f);
              if (!P || P[3] && w.match(/[\p{L}\p{N}]/u)) return;
              const L = P[1] || P[2] || "";
              if (!L || L && (w === "" || this.rules.inline.punctuation.exec(w))) {
                const z = P[0].length - 1;
                let ee, ue, pe = z, xe = 0;
                const le = P[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
                for (le.lastIndex = 0, h = h.slice(-1 * f.length + z); (P = le.exec(h)) != null; ) {
                  if (ee = P[1] || P[2] || P[3] || P[4] || P[5] || P[6], !ee) continue;
                  if (ue = ee.length, P[3] || P[4]) {
                    pe += ue;
                    continue;
                  }
                  if ((P[5] || P[6]) && z % 3 && !((z + ue) % 3)) {
                    xe += ue;
                    continue;
                  }
                  if (pe -= ue, pe > 0) continue;
                  ue = Math.min(ue, ue + pe + xe);
                  const we = f.slice(0, z + P.index + (P[0].length - ee.length) + ue);
                  if (Math.min(z, ue) % 2) {
                    const it = we.slice(1, -1);
                    return { type: "em", raw: we, text: it, tokens: this.lexer.inlineTokens(it) };
                  }
                  const Ve = we.slice(2, -2);
                  return { type: "strong", raw: we, text: Ve, tokens: this.lexer.inlineTokens(Ve) };
                }
              }
            }
            codespan(f) {
              const h = this.rules.inline.code.exec(f);
              if (h) {
                let w = h[2].replace(/\n/g, " ");
                const P = /[^ ]/.test(w), L = /^ /.test(w) && / $/.test(w);
                return P && L && (w = w.substring(1, w.length - 1)), w = Ut(w, !0), { type: "codespan", raw: h[0], text: w };
              }
            }
            br(f) {
              const h = this.rules.inline.br.exec(f);
              if (h) return { type: "br", raw: h[0] };
            }
            del(f) {
              const h = this.rules.inline.del.exec(f);
              if (h) return { type: "del", raw: h[0], text: h[2], tokens: this.lexer.inlineTokens(h[2]) };
            }
            autolink(f, h) {
              const w = this.rules.inline.autolink.exec(f);
              if (w) {
                let P, L;
                return w[2] === "@" ? (P = Ut(this.options.mangle ? h(w[1]) : w[1]), L = "mailto:" + P) : (P = Ut(w[1]), L = P), { type: "link", raw: w[0], text: P, href: L, tokens: [{ type: "text", raw: P, text: P }] };
              }
            }
            url(f, h) {
              let w;
              if (w = this.rules.inline.url.exec(f)) {
                let P, L;
                if (w[2] === "@") P = Ut(this.options.mangle ? h(w[0]) : w[0]), L = "mailto:" + P;
                else {
                  let z;
                  do
                    z = w[0], w[0] = this.rules.inline._backpedal.exec(w[0])[0];
                  while (z !== w[0]);
                  P = Ut(w[0]), L = w[1] === "www." ? "http://" + w[0] : w[0];
                }
                return { type: "link", raw: w[0], text: P, href: L, tokens: [{ type: "text", raw: P, text: P }] };
              }
            }
            inlineText(f, h) {
              const w = this.rules.inline.text.exec(f);
              if (w) {
                let P;
                return P = this.lexer.state.inRawBlock ? this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(w[0]) : Ut(w[0]) : w[0] : Ut(this.options.smartypants ? h(w[0]) : w[0]), { type: "text", raw: w[0], text: P };
              }
            }
          }
          const wt = { newline: /^(?: *(?:\n|$))+/, code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/, fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/, list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/, html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/, table: ka, lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, text: /^[^\n]+/, _label: /(?!\s*\])(?:\\.|[^\[\]\\])+/, _title: /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/ };
          wt.def = Dt(wt.def).replace("label", wt._label).replace("title", wt._title).getRegex(), wt.bullet = /(?:[*+-]|\d{1,9}[.)])/, wt.listItemStart = Dt(/^( *)(bull) */).replace("bull", wt.bullet).getRegex(), wt.list = Dt(wt.list).replace(/bull/g, wt.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + wt.def.source + ")").getRegex(), wt._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", wt._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/, wt.html = Dt(wt.html, "i").replace("comment", wt._comment).replace("tag", wt._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), wt.paragraph = Dt(wt._paragraph).replace("hr", wt.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", wt._tag).getRegex(), wt.blockquote = Dt(wt.blockquote).replace("paragraph", wt.paragraph).getRegex(), wt.normal = { ...wt }, wt.gfm = { ...wt.normal, table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)" }, wt.gfm.table = Dt(wt.gfm.table).replace("hr", wt.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", wt._tag).getRegex(), wt.gfm.paragraph = Dt(wt._paragraph).replace("hr", wt.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", wt.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", wt._tag).getRegex(), wt.pedantic = { ...wt.normal, html: Dt(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", wt._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: ka, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: Dt(wt.normal._paragraph).replace("hr", wt.hr).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", wt.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex() };
          const tt = { escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/, url: ka, tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/, reflink: /^!?\[(label)\]\[(ref)\]/, nolink: /^!?\[(ref)\](?:\[\])?/, reflinkSearch: "reflink|nolink(?!\\()", emStrong: { lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/, rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/, rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/ }, code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, br: /^( {2,}|\\)\n(?!\s*$)/, del: ka, text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, punctuation: /^([\spunctuation])/ };
          function hb(p) {
            return p.replace(/---/g, "—").replace(/--/g, "–").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1‘").replace(/'/g, "’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1“").replace(/"/g, "”").replace(/\.{3}/g, "…");
          }
          function Rh(p) {
            let f, h, w = "";
            const P = p.length;
            for (f = 0; f < P; f++) h = p.charCodeAt(f), Math.random() > 0.5 && (h = "x" + h.toString(16)), w += "&#" + h + ";";
            return w;
          }
          tt._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~", tt.punctuation = Dt(tt.punctuation).replace(/punctuation/g, tt._punctuation).getRegex(), tt.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g, tt.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g, tt._comment = Dt(wt._comment).replace("(?:-->|$)", "-->").getRegex(), tt.emStrong.lDelim = Dt(tt.emStrong.lDelim).replace(/punct/g, tt._punctuation).getRegex(), tt.emStrong.rDelimAst = Dt(tt.emStrong.rDelimAst, "g").replace(/punct/g, tt._punctuation).getRegex(), tt.emStrong.rDelimUnd = Dt(tt.emStrong.rDelimUnd, "g").replace(/punct/g, tt._punctuation).getRegex(), tt._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g, tt._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/, tt._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/, tt.autolink = Dt(tt.autolink).replace("scheme", tt._scheme).replace("email", tt._email).getRegex(), tt._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/, tt.tag = Dt(tt.tag).replace("comment", tt._comment).replace("attribute", tt._attribute).getRegex(), tt._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, tt._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/, tt._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/, tt.link = Dt(tt.link).replace("label", tt._label).replace("href", tt._href).replace("title", tt._title).getRegex(), tt.reflink = Dt(tt.reflink).replace("label", tt._label).replace("ref", wt._label).getRegex(), tt.nolink = Dt(tt.nolink).replace("ref", wt._label).getRegex(), tt.reflinkSearch = Dt(tt.reflinkSearch, "g").replace("reflink", tt.reflink).replace("nolink", tt.nolink).getRegex(), tt.normal = { ...tt }, tt.pedantic = { ...tt.normal, strong: { start: /^__|\*\*/, middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/, endAst: /\*\*(?!\*)/g, endUnd: /__(?!_)/g }, em: { start: /^_|\*/, middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/, endAst: /\*(?!\*)/g, endUnd: /_(?!_)/g }, link: Dt(/^!?\[(label)\]\((.*?)\)/).replace("label", tt._label).getRegex(), reflink: Dt(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", tt._label).getRegex() }, tt.gfm = { ...tt.normal, escape: Dt(tt.escape).replace("])", "~|])").getRegex(), _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/, url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/, text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/ }, tt.gfm.url = Dt(tt.gfm.url, "i").replace("email", tt.gfm._extended_email).getRegex(), tt.breaks = { ...tt.gfm, br: Dt(tt.br).replace("{2,}", "*").getRegex(), text: Dt(tt.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() };
          class Bs {
            constructor(f) {
              this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = f || _e, this.options.tokenizer = this.options.tokenizer || new Gp(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: !1, inRawBlock: !1, top: !0 };
              const h = { block: wt.normal, inline: tt.normal };
              this.options.pedantic ? (h.block = wt.pedantic, h.inline = tt.pedantic) : this.options.gfm && (h.block = wt.gfm, this.options.breaks ? h.inline = tt.breaks : h.inline = tt.gfm), this.tokenizer.rules = h;
            }
            static get rules() {
              return { block: wt, inline: tt };
            }
            static lex(f, h) {
              return new Bs(h).lex(f);
            }
            static lexInline(f, h) {
              return new Bs(h).inlineTokens(f);
            }
            lex(f) {
              let h;
              for (f = f.replace(/\r\n|\r/g, `
`), this.blockTokens(f, this.tokens); h = this.inlineQueue.shift(); ) this.inlineTokens(h.src, h.tokens);
              return this.tokens;
            }
            blockTokens(f, h = []) {
              let w, P, L, z;
              for (f = this.options.pedantic ? f.replace(/\t/g, "    ").replace(/^ +$/gm, "") : f.replace(/^( *)(\t+)/gm, (ee, ue, pe) => ue + "    ".repeat(pe.length)); f; ) if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((ee) => !!(w = ee.call({ lexer: this }, f, h)) && (f = f.substring(w.raw.length), h.push(w), !0)))) if (w = this.tokenizer.space(f)) f = f.substring(w.raw.length), w.raw.length === 1 && h.length > 0 ? h[h.length - 1].raw += `
` : h.push(w);
              else if (w = this.tokenizer.code(f)) f = f.substring(w.raw.length), P = h[h.length - 1], !P || P.type !== "paragraph" && P.type !== "text" ? h.push(w) : (P.raw += `
` + w.raw, P.text += `
` + w.text, this.inlineQueue[this.inlineQueue.length - 1].src = P.text);
              else if (w = this.tokenizer.fences(f)) f = f.substring(w.raw.length), h.push(w);
              else if (w = this.tokenizer.heading(f)) f = f.substring(w.raw.length), h.push(w);
              else if (w = this.tokenizer.hr(f)) f = f.substring(w.raw.length), h.push(w);
              else if (w = this.tokenizer.blockquote(f)) f = f.substring(w.raw.length), h.push(w);
              else if (w = this.tokenizer.list(f)) f = f.substring(w.raw.length), h.push(w);
              else if (w = this.tokenizer.html(f)) f = f.substring(w.raw.length), h.push(w);
              else if (w = this.tokenizer.def(f)) f = f.substring(w.raw.length), P = h[h.length - 1], !P || P.type !== "paragraph" && P.type !== "text" ? this.tokens.links[w.tag] || (this.tokens.links[w.tag] = { href: w.href, title: w.title }) : (P.raw += `
` + w.raw, P.text += `
` + w.raw, this.inlineQueue[this.inlineQueue.length - 1].src = P.text);
              else if (w = this.tokenizer.table(f)) f = f.substring(w.raw.length), h.push(w);
              else if (w = this.tokenizer.lheading(f)) f = f.substring(w.raw.length), h.push(w);
              else {
                if (L = f, this.options.extensions && this.options.extensions.startBlock) {
                  let ee = 1 / 0;
                  const ue = f.slice(1);
                  let pe;
                  this.options.extensions.startBlock.forEach(function(xe) {
                    pe = xe.call({ lexer: this }, ue), typeof pe == "number" && pe >= 0 && (ee = Math.min(ee, pe));
                  }), ee < 1 / 0 && ee >= 0 && (L = f.substring(0, ee + 1));
                }
                if (this.state.top && (w = this.tokenizer.paragraph(L))) P = h[h.length - 1], z && P.type === "paragraph" ? (P.raw += `
` + w.raw, P.text += `
` + w.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = P.text) : h.push(w), z = L.length !== f.length, f = f.substring(w.raw.length);
                else if (w = this.tokenizer.text(f)) f = f.substring(w.raw.length), P = h[h.length - 1], P && P.type === "text" ? (P.raw += `
` + w.raw, P.text += `
` + w.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = P.text) : h.push(w);
                else if (f) {
                  const ee = "Infinite loop on byte: " + f.charCodeAt(0);
                  if (this.options.silent) {
                    console.error(ee);
                    break;
                  }
                  throw new Error(ee);
                }
              }
              return this.state.top = !0, h;
            }
            inline(f, h = []) {
              return this.inlineQueue.push({ src: f, tokens: h }), h;
            }
            inlineTokens(f, h = []) {
              let w, P, L, z, ee, ue, pe = f;
              if (this.tokens.links) {
                const xe = Object.keys(this.tokens.links);
                if (xe.length > 0) for (; (z = this.tokenizer.rules.inline.reflinkSearch.exec(pe)) != null; ) xe.includes(z[0].slice(z[0].lastIndexOf("[") + 1, -1)) && (pe = pe.slice(0, z.index) + "[" + Yp("a", z[0].length - 2) + "]" + pe.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
              }
              for (; (z = this.tokenizer.rules.inline.blockSkip.exec(pe)) != null; ) pe = pe.slice(0, z.index) + "[" + Yp("a", z[0].length - 2) + "]" + pe.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
              for (; (z = this.tokenizer.rules.inline.escapedEmSt.exec(pe)) != null; ) pe = pe.slice(0, z.index + z[0].length - 2) + "++" + pe.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex), this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
              for (; f; ) if (ee || (ue = ""), ee = !1, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((xe) => !!(w = xe.call({ lexer: this }, f, h)) && (f = f.substring(w.raw.length), h.push(w), !0)))) if (w = this.tokenizer.escape(f)) f = f.substring(w.raw.length), h.push(w);
              else if (w = this.tokenizer.tag(f)) f = f.substring(w.raw.length), P = h[h.length - 1], P && w.type === "text" && P.type === "text" ? (P.raw += w.raw, P.text += w.text) : h.push(w);
              else if (w = this.tokenizer.link(f)) f = f.substring(w.raw.length), h.push(w);
              else if (w = this.tokenizer.reflink(f, this.tokens.links)) f = f.substring(w.raw.length), P = h[h.length - 1], P && w.type === "text" && P.type === "text" ? (P.raw += w.raw, P.text += w.text) : h.push(w);
              else if (w = this.tokenizer.emStrong(f, pe, ue)) f = f.substring(w.raw.length), h.push(w);
              else if (w = this.tokenizer.codespan(f)) f = f.substring(w.raw.length), h.push(w);
              else if (w = this.tokenizer.br(f)) f = f.substring(w.raw.length), h.push(w);
              else if (w = this.tokenizer.del(f)) f = f.substring(w.raw.length), h.push(w);
              else if (w = this.tokenizer.autolink(f, Rh)) f = f.substring(w.raw.length), h.push(w);
              else if (this.state.inLink || !(w = this.tokenizer.url(f, Rh))) {
                if (L = f, this.options.extensions && this.options.extensions.startInline) {
                  let xe = 1 / 0;
                  const le = f.slice(1);
                  let we;
                  this.options.extensions.startInline.forEach(function(Ve) {
                    we = Ve.call({ lexer: this }, le), typeof we == "number" && we >= 0 && (xe = Math.min(xe, we));
                  }), xe < 1 / 0 && xe >= 0 && (L = f.substring(0, xe + 1));
                }
                if (w = this.tokenizer.inlineText(L, hb)) f = f.substring(w.raw.length), w.raw.slice(-1) !== "_" && (ue = w.raw.slice(-1)), ee = !0, P = h[h.length - 1], P && P.type === "text" ? (P.raw += w.raw, P.text += w.text) : h.push(w);
                else if (f) {
                  const xe = "Infinite loop on byte: " + f.charCodeAt(0);
                  if (this.options.silent) {
                    console.error(xe);
                    break;
                  }
                  throw new Error(xe);
                }
              } else f = f.substring(w.raw.length), h.push(w);
              return h;
            }
          }
          class Xp {
            constructor(f) {
              this.options = f || _e;
            }
            code(f, h, w) {
              const P = (h || "").match(/\S*/)[0];
              if (this.options.highlight) {
                const L = this.options.highlight(f, P);
                L != null && L !== f && (w = !0, f = L);
              }
              return f = f.replace(/\n$/, "") + `
`, P ? '<pre><code class="' + this.options.langPrefix + Ut(P) + '">' + (w ? f : Ut(f, !0)) + `</code></pre>
` : "<pre><code>" + (w ? f : Ut(f, !0)) + `</code></pre>
`;
            }
            blockquote(f) {
              return `<blockquote>
${f}</blockquote>
`;
            }
            html(f) {
              return f;
            }
            heading(f, h, w, P) {
              return this.options.headerIds ? `<h${h} id="${this.options.headerPrefix + P.slug(w)}">${f}</h${h}>
` : `<h${h}>${f}</h${h}>
`;
            }
            hr() {
              return this.options.xhtml ? `<hr/>
` : `<hr>
`;
            }
            list(f, h, w) {
              const P = h ? "ol" : "ul";
              return "<" + P + (h && w !== 1 ? ' start="' + w + '"' : "") + `>
` + f + "</" + P + `>
`;
            }
            listitem(f) {
              return `<li>${f}</li>
`;
            }
            checkbox(f) {
              return "<input " + (f ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
            }
            paragraph(f) {
              return `<p>${f}</p>
`;
            }
            table(f, h) {
              return h && (h = `<tbody>${h}</tbody>`), `<table>
<thead>
` + f + `</thead>
` + h + `</table>
`;
            }
            tablerow(f) {
              return `<tr>
${f}</tr>
`;
            }
            tablecell(f, h) {
              const w = h.header ? "th" : "td";
              return (h.align ? `<${w} align="${h.align}">` : `<${w}>`) + f + `</${w}>
`;
            }
            strong(f) {
              return `<strong>${f}</strong>`;
            }
            em(f) {
              return `<em>${f}</em>`;
            }
            codespan(f) {
              return `<code>${f}</code>`;
            }
            br() {
              return this.options.xhtml ? "<br/>" : "<br>";
            }
            del(f) {
              return `<del>${f}</del>`;
            }
            link(f, h, w) {
              if ((f = $o(this.options.sanitize, this.options.baseUrl, f)) === null) return w;
              let P = '<a href="' + f + '"';
              return h && (P += ' title="' + h + '"'), P += ">" + w + "</a>", P;
            }
            image(f, h, w) {
              if ((f = $o(this.options.sanitize, this.options.baseUrl, f)) === null) return w;
              let P = `<img src="${f}" alt="${w}"`;
              return h && (P += ` title="${h}"`), P += this.options.xhtml ? "/>" : ">", P;
            }
            text(f) {
              return f;
            }
          }
          class Ih {
            strong(f) {
              return f;
            }
            em(f) {
              return f;
            }
            codespan(f) {
              return f;
            }
            del(f) {
              return f;
            }
            html(f) {
              return f;
            }
            text(f) {
              return f;
            }
            link(f, h, w) {
              return "" + w;
            }
            image(f, h, w) {
              return "" + w;
            }
            br() {
              return "";
            }
          }
          class Jp {
            constructor() {
              this.seen = {};
            }
            serialize(f) {
              return f.toLowerCase().trim().replace(/<[!\/a-z].*?>/gi, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
            }
            getNextSafeSlug(f, h) {
              let w = f, P = 0;
              if (this.seen.hasOwnProperty(w)) {
                P = this.seen[f];
                do
                  P++, w = f + "-" + P;
                while (this.seen.hasOwnProperty(w));
              }
              return h || (this.seen[f] = P, this.seen[w] = 0), w;
            }
            slug(f, h = {}) {
              const w = this.serialize(f);
              return this.getNextSafeSlug(w, h.dryrun);
            }
          }
          class Us {
            constructor(f) {
              this.options = f || _e, this.options.renderer = this.options.renderer || new Xp(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.textRenderer = new Ih(), this.slugger = new Jp();
            }
            static parse(f, h) {
              return new Us(h).parse(f);
            }
            static parseInline(f, h) {
              return new Us(h).parseInline(f);
            }
            parse(f, h = !0) {
              let w, P, L, z, ee, ue, pe, xe, le, we, Ve, it, _t, Et, gt, pi, Qn, Pr, Bi, Ir = "";
              const yn = f.length;
              for (w = 0; w < yn; w++) if (we = f[w], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[we.type] && (Bi = this.options.extensions.renderers[we.type].call({ parser: this }, we), Bi !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(we.type))) Ir += Bi || "";
              else switch (we.type) {
                case "space":
                  continue;
                case "hr":
                  Ir += this.renderer.hr();
                  continue;
                case "heading":
                  Ir += this.renderer.heading(this.parseInline(we.tokens), we.depth, Or(this.parseInline(we.tokens, this.textRenderer)), this.slugger);
                  continue;
                case "code":
                  Ir += this.renderer.code(we.text, we.lang, we.escaped);
                  continue;
                case "table":
                  for (xe = "", pe = "", z = we.header.length, P = 0; P < z; P++) pe += this.renderer.tablecell(this.parseInline(we.header[P].tokens), { header: !0, align: we.align[P] });
                  for (xe += this.renderer.tablerow(pe), le = "", z = we.rows.length, P = 0; P < z; P++) {
                    for (ue = we.rows[P], pe = "", ee = ue.length, L = 0; L < ee; L++) pe += this.renderer.tablecell(this.parseInline(ue[L].tokens), { header: !1, align: we.align[L] });
                    le += this.renderer.tablerow(pe);
                  }
                  Ir += this.renderer.table(xe, le);
                  continue;
                case "blockquote":
                  le = this.parse(we.tokens), Ir += this.renderer.blockquote(le);
                  continue;
                case "list":
                  for (Ve = we.ordered, it = we.start, _t = we.loose, z = we.items.length, le = "", P = 0; P < z; P++) gt = we.items[P], pi = gt.checked, Qn = gt.task, Et = "", gt.task && (Pr = this.renderer.checkbox(pi), _t ? gt.tokens.length > 0 && gt.tokens[0].type === "paragraph" ? (gt.tokens[0].text = Pr + " " + gt.tokens[0].text, gt.tokens[0].tokens && gt.tokens[0].tokens.length > 0 && gt.tokens[0].tokens[0].type === "text" && (gt.tokens[0].tokens[0].text = Pr + " " + gt.tokens[0].tokens[0].text)) : gt.tokens.unshift({ type: "text", text: Pr }) : Et += Pr), Et += this.parse(gt.tokens, _t), le += this.renderer.listitem(Et, Qn, pi);
                  Ir += this.renderer.list(le, Ve, it);
                  continue;
                case "html":
                  Ir += this.renderer.html(we.text);
                  continue;
                case "paragraph":
                  Ir += this.renderer.paragraph(this.parseInline(we.tokens));
                  continue;
                case "text":
                  for (le = we.tokens ? this.parseInline(we.tokens) : we.text; w + 1 < yn && f[w + 1].type === "text"; ) we = f[++w], le += `
` + (we.tokens ? this.parseInline(we.tokens) : we.text);
                  Ir += h ? this.renderer.paragraph(le) : le;
                  continue;
                default: {
                  const ta = 'Token with "' + we.type + '" type was not found.';
                  if (this.options.silent) return void console.error(ta);
                  throw new Error(ta);
                }
              }
              return Ir;
            }
            parseInline(f, h) {
              h = h || this.renderer;
              let w, P, L, z = "";
              const ee = f.length;
              for (w = 0; w < ee; w++) if (P = f[w], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[P.type] && (L = this.options.extensions.renderers[P.type].call({ parser: this }, P), L !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(P.type))) z += L || "";
              else switch (P.type) {
                case "escape":
                case "text":
                  z += h.text(P.text);
                  break;
                case "html":
                  z += h.html(P.text);
                  break;
                case "link":
                  z += h.link(P.href, P.title, this.parseInline(P.tokens, h));
                  break;
                case "image":
                  z += h.image(P.href, P.title, P.text);
                  break;
                case "strong":
                  z += h.strong(this.parseInline(P.tokens, h));
                  break;
                case "em":
                  z += h.em(this.parseInline(P.tokens, h));
                  break;
                case "codespan":
                  z += h.codespan(P.text);
                  break;
                case "br":
                  z += h.br();
                  break;
                case "del":
                  z += h.del(this.parseInline(P.tokens, h));
                  break;
                default: {
                  const ue = 'Token with "' + P.type + '" type was not found.';
                  if (this.options.silent) return void console.error(ue);
                  throw new Error(ue);
                }
              }
              return z;
            }
          }
          class Qu {
            constructor(f) {
              this.options = f || _e;
            }
            preprocess(f) {
              return f;
            }
            postprocess(f) {
              return f;
            }
          }
          t1(Qu, "passThroughHooks", /* @__PURE__ */ new Set(["preprocess", "postprocess"]));
          function Nh(p, f) {
            return (h, w, P) => {
              typeof w == "function" && (P = w, w = null);
              const L = { ...w }, z = /* @__PURE__ */ function(ee, ue, pe) {
                return (xe) => {
                  if (xe.message += `
Please report this to https://github.com/markedjs/marked.`, ee) {
                    const le = "<p>An error occurred:</p><pre>" + Ut(xe.message + "", !0) + "</pre>";
                    return ue ? Promise.resolve(le) : pe ? void pe(null, le) : le;
                  }
                  if (ue) return Promise.reject(xe);
                  if (!pe) throw xe;
                  pe(xe);
                };
              }((w = { ...ht.defaults, ...L }).silent, w.async, P);
              if (h == null) return z(new Error("marked(): input parameter is undefined or null"));
              if (typeof h != "string") return z(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(h) + ", string expected"));
              if (function(ee) {
                ee && ee.sanitize && !ee.silent && console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
              }(w), w.hooks && (w.hooks.options = w), P) {
                const ee = w.highlight;
                let ue;
                try {
                  w.hooks && (h = w.hooks.preprocess(h)), ue = p(h, w);
                } catch (le) {
                  return z(le);
                }
                const pe = function(le) {
                  let we;
                  if (!le) try {
                    w.walkTokens && ht.walkTokens(ue, w.walkTokens), we = f(ue, w), w.hooks && (we = w.hooks.postprocess(we));
                  } catch (Ve) {
                    le = Ve;
                  }
                  return w.highlight = ee, le ? z(le) : P(null, we);
                };
                if (!ee || ee.length < 3 || (delete w.highlight, !ue.length)) return pe();
                let xe = 0;
                return ht.walkTokens(ue, function(le) {
                  le.type === "code" && (xe++, setTimeout(() => {
                    ee(le.text, le.lang, function(we, Ve) {
                      if (we) return pe(we);
                      Ve != null && Ve !== le.text && (le.text = Ve, le.escaped = !0), xe--, xe === 0 && pe();
                    });
                  }, 0));
                }), void (xe === 0 && pe());
              }
              if (w.async) return Promise.resolve(w.hooks ? w.hooks.preprocess(h) : h).then((ee) => p(ee, w)).then((ee) => w.walkTokens ? Promise.all(ht.walkTokens(ee, w.walkTokens)).then(() => ee) : ee).then((ee) => f(ee, w)).then((ee) => w.hooks ? w.hooks.postprocess(ee) : ee).catch(z);
              try {
                w.hooks && (h = w.hooks.preprocess(h));
                const ee = p(h, w);
                w.walkTokens && ht.walkTokens(ee, w.walkTokens);
                let ue = f(ee, w);
                return w.hooks && (ue = w.hooks.postprocess(ue)), ue;
              } catch (ee) {
                return z(ee);
              }
            };
          }
          function ht(p, f, h) {
            return Nh(Bs.lex, Us.parse)(p, f, h);
          }
          ht.options = ht.setOptions = function(p) {
            var f;
            return ht.defaults = { ...ht.defaults, ...p }, f = ht.defaults, _e = f, ht;
          }, ht.getDefaults = function() {
            return { async: !1, baseUrl: null, breaks: !1, extensions: null, gfm: !0, headerIds: !0, headerPrefix: "", highlight: null, hooks: null, langPrefix: "language-", mangle: !0, pedantic: !1, renderer: null, sanitize: !1, sanitizer: null, silent: !1, smartypants: !1, tokenizer: null, walkTokens: null, xhtml: !1 };
          }, ht.defaults = _e, ht.use = function(...p) {
            const f = ht.defaults.extensions || { renderers: {}, childTokens: {} };
            p.forEach((h) => {
              const w = { ...h };
              if (w.async = ht.defaults.async || w.async || !1, h.extensions && (h.extensions.forEach((P) => {
                if (!P.name) throw new Error("extension name required");
                if (P.renderer) {
                  const L = f.renderers[P.name];
                  f.renderers[P.name] = L ? function(...z) {
                    let ee = P.renderer.apply(this, z);
                    return ee === !1 && (ee = L.apply(this, z)), ee;
                  } : P.renderer;
                }
                if (P.tokenizer) {
                  if (!P.level || P.level !== "block" && P.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
                  f[P.level] ? f[P.level].unshift(P.tokenizer) : f[P.level] = [P.tokenizer], P.start && (P.level === "block" ? f.startBlock ? f.startBlock.push(P.start) : f.startBlock = [P.start] : P.level === "inline" && (f.startInline ? f.startInline.push(P.start) : f.startInline = [P.start]));
                }
                P.childTokens && (f.childTokens[P.name] = P.childTokens);
              }), w.extensions = f), h.renderer) {
                const P = ht.defaults.renderer || new Xp();
                for (const L in h.renderer) {
                  const z = P[L];
                  P[L] = (...ee) => {
                    let ue = h.renderer[L].apply(P, ee);
                    return ue === !1 && (ue = z.apply(P, ee)), ue;
                  };
                }
                w.renderer = P;
              }
              if (h.tokenizer) {
                const P = ht.defaults.tokenizer || new Gp();
                for (const L in h.tokenizer) {
                  const z = P[L];
                  P[L] = (...ee) => {
                    let ue = h.tokenizer[L].apply(P, ee);
                    return ue === !1 && (ue = z.apply(P, ee)), ue;
                  };
                }
                w.tokenizer = P;
              }
              if (h.hooks) {
                const P = ht.defaults.hooks || new Qu();
                for (const L in h.hooks) {
                  const z = P[L];
                  Qu.passThroughHooks.has(L) ? P[L] = (ee) => {
                    if (ht.defaults.async) return Promise.resolve(h.hooks[L].call(P, ee)).then((pe) => z.call(P, pe));
                    const ue = h.hooks[L].call(P, ee);
                    return z.call(P, ue);
                  } : P[L] = (...ee) => {
                    let ue = h.hooks[L].apply(P, ee);
                    return ue === !1 && (ue = z.apply(P, ee)), ue;
                  };
                }
                w.hooks = P;
              }
              if (h.walkTokens) {
                const P = ht.defaults.walkTokens;
                w.walkTokens = function(L) {
                  let z = [];
                  return z.push(h.walkTokens.call(this, L)), P && (z = z.concat(P.call(this, L))), z;
                };
              }
              ht.setOptions(w);
            });
          }, ht.walkTokens = function(p, f) {
            let h = [];
            for (const w of p) switch (h = h.concat(f.call(ht, w)), w.type) {
              case "table":
                for (const P of w.header) h = h.concat(ht.walkTokens(P.tokens, f));
                for (const P of w.rows) for (const L of P) h = h.concat(ht.walkTokens(L.tokens, f));
                break;
              case "list":
                h = h.concat(ht.walkTokens(w.items, f));
                break;
              default:
                ht.defaults.extensions && ht.defaults.extensions.childTokens && ht.defaults.extensions.childTokens[w.type] ? ht.defaults.extensions.childTokens[w.type].forEach(function(P) {
                  h = h.concat(ht.walkTokens(w[P], f));
                }) : w.tokens && (h = h.concat(ht.walkTokens(w.tokens, f)));
            }
            return h;
          }, ht.parseInline = Nh(Bs.lexInline, Us.parseInline), ht.Parser = Us, ht.parser = Us.parse, ht.Renderer = Xp, ht.TextRenderer = Ih, ht.Lexer = Bs, ht.lexer = Bs.lex, ht.Tokenizer = Gp, ht.Slugger = Jp, ht.Hooks = Qu, ht.parse = ht, ht.options, ht.setOptions, ht.use, ht.walkTokens, ht.parseInline, Us.parse, Bs.lex;
          var Zp = Object.defineProperty, mb = Object.defineProperties, gb = Object.getOwnPropertyDescriptors, jh = Object.getOwnPropertySymbols, Lh = Object.prototype.hasOwnProperty, yb = Object.prototype.propertyIsEnumerable, Mh = (p, f, h) => f in p ? Zp(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h, Dh = (p, f) => {
            for (var h in f || (f = {})) Lh.call(f, h) && Mh(p, h, f[h]);
            if (jh) for (var h of jh(f)) yb.call(f, h) && Mh(p, h, f[h]);
            return p;
          };
          const vb = new ht.Renderer();
          ht.setOptions({ renderer: vb, highlight: (p, f) => Sa(p, f) });
          const Fh = "^ {0,3}<!-- ReDoc-Inject:\\s+?<({component}).*?/?>\\s+?-->\\s*$", qh = "(?:^ {0,3}<({component})([\\s\\S]*?)>([\\s\\S]*?)</\\2>|^ {0,3}<({component})([\\s\\S]*?)(?:/>|\\n{2,}))", ef = "(?:" + Fh + "|" + qh + ")";
          function tf(p) {
            return `<!-- ReDoc-Inject: <${p}> -->`;
          }
          class Pi {
            constructor(f, h) {
              this.options = f, this.parentId = h, this.headings = [], this.headingRule = (w, P, L, z) => (P === 1 ? this.currentTopHeading = this.saveHeading(w, P) : P === 2 && this.saveHeading(w, P, this.currentTopHeading && this.currentTopHeading.items, this.currentTopHeading && this.currentTopHeading.id), this.originalHeadingRule(w, P, L, z)), this.parentId = h, this.parser = new ht.Parser(), this.headingEnhanceRenderer = new ht.Renderer(), this.originalHeadingRule = this.headingEnhanceRenderer.heading.bind(this.headingEnhanceRenderer), this.headingEnhanceRenderer.heading = this.headingRule;
            }
            static containsComponent(f, h) {
              return new RegExp(ef.replace(/{component}/g, h), "gmi").test(f);
            }
            static getTextBeforeHading(f, h) {
              const w = f.search(new RegExp(`^##?\\s+${h}`, "m"));
              return w > -1 ? f.substring(0, w) : f;
            }
            saveHeading(f, h, w = this.headings, P) {
              f = $e(f);
              const L = { id: P ? `${P}/${V(f)}` : `${this.parentId || "section"}/${V(f)}`, name: f, level: h, items: [] };
              return w.push(L), L;
            }
            flattenHeadings(f) {
              if (f === void 0) return [];
              const h = [];
              for (const w of f) h.push(w), h.push(...this.flattenHeadings(w.items));
              return h;
            }
            attachHeadingsDescriptions(f) {
              const h = (ee) => new RegExp(`##?\\s+${ee.name.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")}s*(
|\r
|$|s*)`), w = this.flattenHeadings(this.headings);
              if (w.length < 1) return;
              let P = w[0], L = h(P), z = f.search(L);
              for (let ee = 1; ee < w.length; ee++) {
                const ue = w[ee], pe = h(ue), xe = f.substr(z + 1).search(pe) + z + 1;
                P.description = f.substring(z, xe).replace(L, "").trim(), P = ue, L = pe, z = xe;
              }
              P.description = f.substring(z).replace(L, "").trim();
            }
            renderMd(f, h = !1) {
              const w = h ? { renderer: this.headingEnhanceRenderer } : void 0;
              return ht(f.toString(), w);
            }
            extractHeadings(f) {
              this.renderMd(f, !0), this.attachHeadingsDescriptions(f);
              const h = this.headings;
              return this.headings = [], h;
            }
            renderMdWithComponents(f) {
              const h = this.options && this.options.allowedMdComponents;
              if (!h || Object.keys(h).length === 0) return [this.renderMd(f)];
              const w = Object.keys(h).join("|"), P = new RegExp(ef.replace(/{component}/g, w), "mig"), L = [], z = [];
              let ee = P.exec(f), ue = 0;
              for (; ee; ) {
                L.push(f.substring(ue, ee.index)), ue = P.lastIndex;
                const we = h[ee[1] || ee[2] || ee[5]], Ve = ee[3] || ee[6], it = ee[4];
                we && z.push({ component: we.component, propsSelector: we.propsSelector, props: (pe = Dh(Dh({}, bb(Ve)), we.props), xe = { children: it }, mb(pe, gb(xe))) }), ee = P.exec(f);
              }
              var pe, xe;
              L.push(f.substring(ue));
              const le = [];
              for (let we = 0; we < L.length; we++) {
                const Ve = L[we];
                Ve && le.push(this.renderMd(Ve)), z[we] && le.push(z[we]);
              }
              return le;
            }
          }
          function bb(p) {
            if (!p) return {};
            const f = /([\w-]+)\s*=\s*(?:{([^}]+?)}|"([^"]+?)")/gim, h = {};
            let w;
            for (; (w = f.exec(p)) !== null; ) if (w[3]) h[w[1]] = w[3];
            else if (w[2]) {
              let P;
              try {
                P = JSON.parse(w[2]);
              } catch {
              }
              h[w[1]] = P;
            }
            return h;
          }
          class rf {
            constructor(f, h = new ie({})) {
              this.parser = f, this.options = h, Object.assign(this, f.spec.info), this.description = f.spec.info.description || "", this.summary = f.spec.info.summary || "";
              const w = this.description.search(/^\s*##?\s+/m);
              w > -1 && (this.description = this.description.substring(0, w)), this.downloadUrls = this.getDownloadUrls(), this.downloadFileName = this.getDownloadFileName();
            }
            getDownloadUrls() {
              return (this.options.downloadUrls ? this.options.downloadUrls.map(({ title: f, url: h }) => ({ title: f || F("download"), url: this.getDownloadLink(h) })) : [{ title: F("download"), url: this.getDownloadLink(this.options.downloadDefinitionUrl) }]).filter(({ title: f, url: h }) => f && h);
            }
            getDownloadLink(f) {
              if (f) return f;
              if (this.parser.specUrl) return this.parser.specUrl;
              if (m && window.Blob && window.URL && window.URL.createObjectURL) {
                const h = new Blob([JSON.stringify(this.parser.spec, null, 2)], { type: "application/json" });
                return window.URL.createObjectURL(h);
              }
            }
            getDownloadFileName() {
              return this.parser.specUrl || this.options.downloadDefinitionUrl ? this.options.downloadFileName : this.options.downloadFileName || "openapi.json";
            }
          }
          var zh = Object.defineProperty, Bh = Object.defineProperties, Uh = Object.getOwnPropertyDescriptors, nf = Object.getOwnPropertySymbols, Pa = Object.prototype.hasOwnProperty, wb = Object.prototype.propertyIsEnumerable, Vh = (p, f, h) => f in p ? zh(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h;
          class Hh {
            constructor(f, h) {
              const w = h.spec.components && h.spec.components.securitySchemes || {};
              this.schemes = Object.keys(f || {}).map((P) => {
                const { resolved: L } = h.deref(w[P]), z = f[P] || [];
                if (!L) return void console.warn(`Non existing security scheme referenced: ${P}. Skipping`);
                const ee = L["x-displayName"] || P;
                return ue = ((pe, xe) => {
                  for (var le in xe || (xe = {})) Pa.call(xe, le) && Vh(pe, le, xe[le]);
                  if (nf) for (var le of nf(xe)) wb.call(xe, le) && Vh(pe, le, xe[le]);
                  return pe;
                })({}, L), Bh(ue, Uh({ id: P, sectionId: P, displayName: ee, scopes: z }));
                var ue;
              }).filter((P) => P !== void 0);
            }
          }
          var sf = Object.defineProperty, Wh = Object.defineProperties, Tl = Object.getOwnPropertyDescriptor, Cl = Object.getOwnPropertyDescriptors, Kh = Object.getOwnPropertySymbols, Yu = Object.prototype.hasOwnProperty, Sb = Object.prototype.propertyIsEnumerable, of = (p, f, h) => f in p ? sf(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h, af = (p, f) => {
            for (var h in f || (f = {})) Yu.call(f, h) && of(p, h, f[h]);
            if (Kh) for (var h of Kh(f)) Sb.call(f, h) && of(p, h, f[h]);
            return p;
          }, Gu = (p, f, h, w) => {
            for (var P, L = w > 1 ? void 0 : w ? Tl(f, h) : f, z = p.length - 1; z >= 0; z--) (P = p[z]) && (L = (w ? P(f, h, L) : P(L)) || L);
            return w && L && sf(f, h, L), L;
          };
          class $l {
            constructor(f, h, w, P, L) {
              this.expanded = !1, this.operations = [], (0, Y.makeObservable)(this), this.name = h;
              const { resolved: z } = f.deref(w);
              for (const pe of Object.keys(z)) {
                const xe = z[pe], le = Object.keys(xe).filter(Ht);
                for (const we of le) {
                  const Ve = xe[we], it = new Dr(f, (ee = af({}, Ve), ue = { pathName: pe, pointer: kt.compile([P, h, pe, we]), httpVerb: we, pathParameters: xe.parameters || [], pathServers: xe.servers }, Wh(ee, Cl(ue))), void 0, L, !0);
                  this.operations.push(it);
                }
              }
              var ee, ue;
            }
            toggle() {
              this.expanded = !this.expanded;
            }
          }
          Gu([Y.observable], $l.prototype, "expanded", 2), Gu([Y.action], $l.prototype, "toggle", 1);
          var Qh = Object.defineProperty, Yh = Object.defineProperties, xb = Object.getOwnPropertyDescriptors, Xu = Object.getOwnPropertySymbols, Gh = Object.prototype.hasOwnProperty, Xh = Object.prototype.propertyIsEnumerable, Jh = (p, f, h) => f in p ? Qh(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h, kr = (p, f) => {
            for (var h in f || (f = {})) Gh.call(f, h) && Jh(p, h, f[h]);
            if (Xu) for (var h of Xu(f)) Xh.call(f, h) && Jh(p, h, f[h]);
            return p;
          }, Vs = (p, f) => Yh(p, xb(f)), Rl = (p, f) => {
            var h = {};
            for (var w in p) Gh.call(p, w) && f.indexOf(w) < 0 && (h[w] = p[w]);
            if (p != null && Xu) for (var w of Xu(p)) f.indexOf(w) < 0 && Xh.call(p, w) && (h[w] = p[w]);
            return h;
          };
          function Il(p, f) {
            return f && p[p.length - 1] !== f ? [...p, f] : p;
          }
          function Nl(p, f) {
            return f ? p.concat(f) : p;
          }
          class lf {
            constructor(f, h, w = new ie({})) {
              this.options = w, this.allowMergeRefs = !1, this.byRef = (L) => {
                let z;
                if (this.spec) {
                  L.charAt(0) !== "#" && (L = "#" + L), L = decodeURIComponent(L);
                  try {
                    z = kt.get(this.spec, L);
                  } catch {
                  }
                  return z || {};
                }
              }, this.validate(f), this.spec = f, this.allowMergeRefs = f.openapi.startsWith("3.1");
              const P = m ? window.location.href : "";
              typeof h == "string" && (this.specUrl = P ? new URL(h, P).href : h);
            }
            validate(f) {
              if (f.openapi === void 0) throw new Error("Document must be valid OpenAPI 3.0.0 definition");
            }
            isRef(f) {
              return !!f && f.$ref !== void 0 && f.$ref !== null;
            }
            deref(f, h = [], w = !1) {
              const P = f == null ? void 0 : f["x-refsStack"];
              if (h = Nl(h, P), this.isRef(f)) {
                const L = rs(f.$ref);
                if (L && this.options.ignoreNamedSchemas.has(L)) return { resolved: { type: "object", title: L }, refsStack: h };
                let z = this.byRef(f.$ref);
                if (!z) throw new Error(`Failed to resolve $ref "${f.$ref}"`);
                let ee = h;
                if (h.includes(f.$ref) || h.length > 999) z = Object.assign({}, z, { "x-circular-ref": !0 });
                else if (this.isRef(z)) {
                  const ue = this.deref(z, h, w);
                  ee = ue.refsStack, z = ue.resolved;
                }
                return ee = Il(h, f.$ref), z = this.allowMergeRefs ? this.mergeRefs(f, z, w) : z, { resolved: z, refsStack: ee };
              }
              return { resolved: f, refsStack: Nl(h, P) };
            }
            mergeRefs(f, h, w) {
              const P = f, { $ref: L } = P, z = Rl(P, ["$ref"]), ee = Object.keys(z);
              if (ee.length === 0) return h;
              if (w && ee.some((ue) => !["description", "title", "externalDocs", "x-refsStack", "x-parentRefs", "readOnly", "writeOnly"].includes(ue))) {
                const ue = z, { description: pe, title: xe, readOnly: le, writeOnly: we } = ue;
                return { allOf: [{ description: pe, title: xe, readOnly: le, writeOnly: we }, h, Rl(ue, ["description", "title", "readOnly", "writeOnly"])] };
              }
              return kr(kr({}, h), z);
            }
            mergeAllOf(f, h, w) {
              var P;
              if (f["x-circular-ref"] || (f = this.hoistOneOfs(f, w)).allOf === void 0) return f;
              let L = Vs(kr({}, f), { "x-parentRefs": [], allOf: void 0, title: f.title || rs(h) });
              L.properties !== void 0 && typeof L.properties == "object" && (L.properties = kr({}, L.properties)), L.items !== void 0 && typeof L.items == "object" && (L.items = kr({}, L.items));
              const z = function(ee) {
                const ue = /* @__PURE__ */ new Set();
                return ee.filter((pe) => {
                  const xe = pe.$ref;
                  return !xe || xe && !ue.has(xe) && ue.add(xe);
                });
              }(f.allOf.map((ee) => {
                var ue;
                const { resolved: pe, refsStack: xe } = this.deref(ee, w, !0), le = ee.$ref || void 0, we = this.mergeAllOf(pe, le, xe);
                if (!we["x-circular-ref"] || !we.allOf) return le && ((ue = L["x-parentRefs"]) == null || ue.push(...we["x-parentRefs"] || [], le)), { $ref: le, refsStack: Il(xe, le), schema: we };
              }).filter((ee) => ee !== void 0));
              for (const { schema: ee, refsStack: ue } of z) {
                const pe = ee, { type: xe, enum: le, properties: we, items: Ve, required: it, title: _t, description: Et, readOnly: gt, writeOnly: pi, oneOf: Qn, anyOf: Pr, "x-circular-ref": Bi } = pe, Ir = Rl(pe, ["type", "enum", "properties", "items", "required", "title", "description", "readOnly", "writeOnly", "oneOf", "anyOf", "x-circular-ref"]);
                if (L.type !== xe && L.type !== void 0 && xe !== void 0 && console.warn(`Incompatible types in allOf at "${h}": "${L.type}" and "${xe}"`), xe !== void 0 && (Array.isArray(xe) && Array.isArray(L.type) ? L.type = [...xe, ...L.type] : L.type = xe), le !== void 0 && (Array.isArray(le) && Array.isArray(L.enum) ? L.enum = Array.from(/* @__PURE__ */ new Set([...le, ...L.enum])) : L.enum = le), we !== void 0 && typeof we == "object") {
                  L.properties = L.properties || {};
                  for (const yn in we) {
                    const ta = Nl(ue, (P = we[yn]) == null ? void 0 : P["x-refsStack"]);
                    if (L.properties[yn]) {
                      if (!Bi) {
                        const NR = this.mergeAllOf({ allOf: [L.properties[yn], Vs(kr({}, we[yn]), { "x-refsStack": ta })], "x-refsStack": ta }, h + "/properties/" + yn, ta);
                        L.properties[yn] = NR;
                      }
                    } else L.properties[yn] = Vs(kr({}, we[yn]), { "x-refsStack": ta });
                  }
                }
                if (Ve !== void 0 && !Bi) {
                  const yn = typeof L.items == "boolean" ? {} : Object.assign({}, L.items), ta = typeof ee.items == "boolean" ? {} : Object.assign({}, ee.items);
                  L.items = this.mergeAllOf({ allOf: [yn, ta] }, h + "/items", ue);
                }
                Qn !== void 0 && (L.oneOf = Qn), Pr !== void 0 && (L.anyOf = Pr), it !== void 0 && (L.required = [...L.required || [], ...it]), L = kr(Vs(kr({}, L), { title: L.title || _t, description: L.description || Et, readOnly: L.readOnly !== void 0 ? L.readOnly : gt, writeOnly: L.writeOnly !== void 0 ? L.writeOnly : pi, "x-circular-ref": L["x-circular-ref"] || Bi }), Ir);
              }
              return L;
            }
            findDerived(f) {
              const h = {}, w = this.spec.components && this.spec.components.schemas || {};
              for (const P in w) {
                const { resolved: L } = this.deref(w[P]);
                L.allOf !== void 0 && L.allOf.find((z) => z.$ref !== void 0 && f.indexOf(z.$ref) > -1) && (h["#/components/schemas/" + P] = [L["x-discriminator-value"] || P]);
              }
              return h;
            }
            hoistOneOfs(f, h) {
              if (f.allOf === void 0) return f;
              const w = f.allOf;
              for (let P = 0; P < w.length; P++) {
                const L = w[P], { oneOf: z } = L, ee = Rl(L, ["oneOf"]);
                if (z && Array.isArray(z)) {
                  const ue = w.slice(0, P), pe = w.slice(P + 1), xe = Object.keys(ee).length > 0 ? [ee] : [];
                  return { oneOf: z.map((le) => ({ allOf: [...ue, ...xe, le, ...pe], "x-refsStack": h })) };
                }
              }
              return f;
            }
          }
          var Ju = Object.defineProperty, _b = Object.defineProperties, Eb = Object.getOwnPropertyDescriptor, Ta = Object.getOwnPropertyDescriptors, Ca = Object.getOwnPropertySymbols, $a = Object.prototype.hasOwnProperty, Zu = Object.prototype.propertyIsEnumerable, uf = (p, f, h) => f in p ? Ju(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h, ls = (p, f) => {
            for (var h in f || (f = {})) $a.call(f, h) && uf(p, h, f[h]);
            if (Ca) for (var h of Ca(f)) Zu.call(f, h) && uf(p, h, f[h]);
            return p;
          }, Hs = (p, f) => _b(p, Ta(f)), ec = (p, f, h, w) => {
            for (var P, L = w > 1 ? void 0 : w ? Eb(f, h) : f, z = p.length - 1; z >= 0; z--) (P = p[z]) && (L = (w ? P(f, h, L) : P(L)) || L);
            return w && L && Ju(f, h, L), L;
          };
          const tc = class Vd {
            constructor(f, h, w, P, L = !1, z = []) {
              this.options = P, this.refsStack = z, this.typePrefix = "", this.isCircular = !1, this.activeOneOf = 0, (0, Y.makeObservable)(this), this.pointer = h.$ref || w || "";
              const { resolved: ee, refsStack: ue } = f.deref(h, z, !0);
              this.refsStack = Il(ue, this.pointer), this.rawSchema = ee, this.schema = f.mergeAllOf(this.rawSchema, this.pointer, this.refsStack), this.init(f, L), P.showExtensions && (this.extensions = os(this.schema, P.showExtensions));
            }
            activateOneOf(f) {
              this.activeOneOf = f;
            }
            hasType(f) {
              return this.type === f || ce(this.type) && this.type.includes(f);
            }
            init(f, h) {
              var w, P, L, z, ee, ue, pe, xe;
              const le = this.schema;
              if (this.isCircular = !!le["x-circular-ref"], this.title = le.title || ts(this.pointer) && kt.baseName(this.pointer) || "", this.description = le.description || "", this.type = le.type || Ls(le), this.format = le.format, this.enum = le.enum || [], this["x-enumDescriptions"] = le["x-enumDescriptions"], this.example = le.example, this.examples = le.examples, this.deprecated = !!le.deprecated, this.pattern = le.pattern, this.externalDocs = le.externalDocs, this.constraints = Mr(le), this.displayFormat = this.format, this.isPrimitive = Ms(le, this.type), this.default = le.default, this.readOnly = !!le.readOnly, this.writeOnly = !!le.writeOnly, this.const = le.const || "", this.contentEncoding = le.contentEncoding, this.contentMediaType = le.contentMediaType, this.minItems = le.minItems, this.maxItems = le.maxItems, (le.nullable || le["x-nullable"]) && (ce(this.type) && !this.type.some((we) => we === null || we === "null") ? this.type = [...this.type, "null"] : ce(this.type) || this.type === null && this.type === "null" || (this.type = [this.type, "null"])), this.displayType = ce(this.type) ? this.type.map((we) => we === null ? "null" : we).join(" or ") : this.type, !this.isCircular) if (le.if && le.then || le.if && le.else) this.initConditionalOperators(le, f);
              else if (h || pf(le) === void 0) {
                if (h && ce(le.oneOf) && le.oneOf.find((we) => we.$ref === this.pointer) && delete le.oneOf, le.oneOf !== void 0) return this.initOneOf(le.oneOf, f), this.oneOfType = "One of", void (le.anyOf !== void 0 && console.warn(`oneOf and anyOf are not supported on the same level. Skipping anyOf at ${this.pointer}`));
                if (le.anyOf !== void 0) return this.initOneOf(le.anyOf, f), void (this.oneOfType = "Any of");
                if (this.hasType("object")) this.fields = cf(f, le, this.pointer, this.options, this.refsStack);
                else if (this.hasType("array") && (ce(le.items) || ce(le.prefixItems) ? this.fields = cf(f, le, this.pointer, this.options, this.refsStack) : le.items && (this.items = new Vd(f, le.items, this.pointer + "/items", this.options, !1, this.refsStack)), this.displayType = le.prefixItems || ce(le.items) ? "items" : wa(((w = this.items) == null ? void 0 : w.displayType) || this.displayType), this.displayFormat = ((P = this.items) == null ? void 0 : P.format) || "", this.typePrefix = ((L = this.items) == null ? void 0 : L.typePrefix) || "" + F("arrayOf"), this.title = this.title || ((z = this.items) == null ? void 0 : z.title) || "", this.isPrimitive = ((ee = this.items) == null ? void 0 : ee.isPrimitive) !== void 0 ? (ue = this.items) == null ? void 0 : ue.isPrimitive : this.isPrimitive, this.example === void 0 && ((pe = this.items) == null ? void 0 : pe.example) !== void 0 && (this.example = [this.items.example]), (xe = this.items) != null && xe.isPrimitive && (this.enum = this.items.enum, this["x-enumDescriptions"] = this.items["x-enumDescriptions"]), ce(this.type))) {
                  const we = this.type.filter((Ve) => Ve !== "array");
                  we.length && (this.displayType += ` or ${we.join(" or ")}`);
                }
                this.enum.length && this.options.sortEnumValuesAlphabetically && this.enum.sort();
              } else this.initDiscriminator(le, f);
            }
            initOneOf(f, h) {
              if (this.oneOf = f.map((w, P) => {
                const { resolved: L, refsStack: z } = h.deref(w, this.refsStack, !0), ee = h.mergeAllOf(L, this.pointer + "/oneOf/" + P, z), ue = ts(w.$ref) && !ee.title ? kt.baseName(w.$ref) : `${ee.title || ""}${ee.const !== void 0 && JSON.stringify(ee.const) || ""}`;
                return new Vd(h, Hs(ls({}, ee), { title: ue, allOf: [Hs(ls({}, this.schema), { oneOf: void 0, anyOf: void 0 })], discriminator: L.allOf ? void 0 : ee.discriminator }), w.$ref || this.pointer + "/oneOf/" + P, this.options, !1, z);
              }), this.options.simpleOneOfTypeLabel) {
                const w = function(P) {
                  const L = /* @__PURE__ */ new Set();
                  return function z(ee) {
                    for (const ue of ee.oneOf || []) ue.oneOf ? z(ue) : ue.type && L.add(ue.type);
                  }(P), Array.from(L.values());
                }(this);
                this.displayType = w.join(" or ");
              } else this.displayType = this.oneOf.map((w) => {
                let P = w.typePrefix + (w.title ? `${w.title} (${w.displayType})` : w.displayType);
                return P.indexOf(" or ") > -1 && (P = `(${P})`), P;
              }).join(" or ");
            }
            initDiscriminator(f, h) {
              const w = pf(f);
              this.discriminatorProp = w.propertyName;
              const P = h.findDerived([...this.schema["x-parentRefs"] || [], this.pointer]);
              if (f.oneOf) for (const le of f.oneOf) {
                if (le.$ref === void 0) continue;
                const we = kt.baseName(le.$ref);
                P[le.$ref] = we;
              }
              const L = w.mapping || {};
              let z = w["x-explicitMappingOnly"] || !1;
              Object.keys(L).length === 0 && (z = !1);
              const ee = {};
              for (const le in L) {
                const we = L[le];
                ce(ee[we]) ? ee[we].push(le) : ee[we] = [le];
              }
              const ue = ls(z ? {} : ls({}, P), ee);
              let pe = [];
              for (const le of Object.keys(ue)) {
                const we = ue[le];
                if (ce(we)) for (const Ve of we) pe.push({ $ref: le, name: Ve });
                else pe.push({ $ref: le, name: we });
              }
              const xe = Object.keys(L);
              xe.length !== 0 && (pe = pe.sort((le, we) => {
                const Ve = xe.indexOf(le.name), it = xe.indexOf(we.name);
                return Ve < 0 && it < 0 ? le.name.localeCompare(we.name) : Ve < 0 ? 1 : it < 0 ? -1 : Ve - it;
              })), this.oneOf = pe.map(({ $ref: le, name: we }) => {
                const Ve = new Vd(h, { $ref: le }, le, this.options, !0, this.refsStack.slice(0, -1));
                return Ve.title = we, Ve;
              });
            }
            initConditionalOperators(f, h) {
              const w = f, { if: P, else: L = {}, then: z = {} } = w, ee = ((pe, xe) => {
                var le = {};
                for (var we in pe) $a.call(pe, we) && xe.indexOf(we) < 0 && (le[we] = pe[we]);
                if (pe != null && Ca) for (var we of Ca(pe)) xe.indexOf(we) < 0 && Zu.call(pe, we) && (le[we] = pe[we]);
                return le;
              })(w, ["if", "else", "then"]), ue = [{ allOf: [ee, z, P], title: P && P["x-displayName"] || (P == null ? void 0 : P.title) || "case 1" }, { allOf: [ee, L], title: L && L["x-displayName"] || (L == null ? void 0 : L.title) || "case 2" }];
              this.oneOf = ue.map((pe, xe) => new Vd(h, ls({}, pe), this.pointer + "/oneOf/" + xe, this.options, !1, this.refsStack)), this.oneOfType = "One of";
            }
          };
          ec([Y.observable], tc.prototype, "activeOneOf", 2), ec([Y.action], tc.prototype, "activateOneOf", 1);
          let Ra = tc;
          function cf(p, f, h, w, P) {
            const L = f.properties || f.prefixItems || f.items || {}, z = f.patternProperties || {}, ee = f.additionalProperties || f.unevaluatedProperties, ue = f.prefixItems ? f.items : f.additionalItems, pe = f.default;
            let xe = Object.keys(L || []).map((le) => {
              let we = L[le];
              we || (console.warn(`Field "${le}" is invalid, skipping.
 Field must be an object but got ${typeof we} at "${h}"`), we = {});
              const Ve = f.required !== void 0 && f.required.indexOf(le) > -1;
              return new Zr(p, { name: f.properties ? le : `[${le}]`, required: Ve, schema: Hs(ls({}, we), { default: we.default === void 0 && pe ? pe[le] : we.default }) }, h + "/properties/" + le, w, P);
            });
            return w.sortPropsAlphabetically && (xe = wi(xe, "name")), w.sortRequiredPropsFirst && (xe = ns(xe, w.sortPropsAlphabetically ? void 0 : f.required)), xe.push(...Object.keys(z).map((le) => {
              let we = z[le];
              return we || (console.warn(`Field "${le}" is invalid, skipping.
 Field must be an object but got ${typeof we} at "${h}"`), we = {}), new Zr(p, { name: le, required: !1, schema: we, kind: "patternProperties" }, `${h}/patternProperties/${le}`, w, P);
            })), typeof ee != "object" && ee !== !0 || xe.push(new Zr(p, { name: (typeof ee == "object" && ee["x-additionalPropertiesName"] || "property name").concat("*"), required: !1, schema: ee === !0 ? {} : ee, kind: "additionalProperties" }, h + "/additionalProperties", w, P)), xe.push(...function({ parser: le, schema: we = !1, fieldsCount: Ve, $ref: it, options: _t, refsStack: Et }) {
              return se(we) ? we ? [new Zr(le, { name: `[${Ve}...]`, schema: {} }, `${it}/additionalItems`, _t, Et)] : [] : ce(we) ? [...we.map((gt, pi) => new Zr(le, { name: `[${Ve + pi}]`, schema: gt }, `${it}/additionalItems`, _t, Et))] : j(we) ? [new Zr(le, { name: `[${Ve}...]`, schema: we }, `${it}/additionalItems`, _t, Et)] : [];
            }({ parser: p, schema: ue, fieldsCount: xe.length, $ref: h, options: w, refsStack: P })), xe;
          }
          function pf(p) {
            return p.discriminator || p["x-discriminator"];
          }
          const rc = {};
          class Io {
            constructor(f, h, w, P) {
              this.mime = w;
              const { resolved: L } = f.deref(h);
              this.value = L.value, this.summary = L.summary, this.description = L.description, L.externalValue && (this.externalValueUrl = new URL(L.externalValue, f.specUrl).href), Eo(w) && this.value && typeof this.value == "object" && (this.value = Kt(this.value, P));
            }
            getExternalValue(f) {
              return this.externalValueUrl ? (this.externalValueUrl in rc || (rc[this.externalValueUrl] = fetch(this.externalValueUrl).then((h) => h.text().then((w) => {
                if (!h.ok) return Promise.reject(new Error(w));
                if (!es(f)) return w;
                try {
                  return JSON.parse(w);
                } catch {
                  return w;
                }
              }))), rc[this.externalValueUrl]) : Promise.resolve(void 0);
            }
          }
          var Zh = Object.defineProperty, em = Object.getOwnPropertyDescriptor, ai = (p, f, h, w) => {
            for (var P, L = w > 1 ? void 0 : w ? em(f, h) : f, z = p.length - 1; z >= 0; z--) (P = p[z]) && (L = (w ? P(f, h, L) : P(L)) || L);
            return w && L && Zh(f, h, L), L;
          };
          const nc = { path: { style: "simple", explode: !1 }, query: { style: "form", explode: !0 }, header: { style: "simple", explode: !1 }, cookie: { style: "form", explode: !0 } };
          class Zr {
            constructor(f, h, w, P, L) {
              var z, ee, ue, pe, xe;
              this.expanded = void 0, (0, Y.makeObservable)(this);
              const { resolved: le } = f.deref(h);
              this.kind = h.kind || "field", this.name = h.name || le.name, this.in = le.in, this.required = !!le.required;
              let we = le.schema, Ve = "";
              if (!we && le.in && le.content && (Ve = Object.keys(le.content)[0], we = le.content[Ve] && le.content[Ve].schema), this.schema = new Ra(f, we || {}, w, P, !1, L), this.description = le.description === void 0 ? this.schema.description || "" : le.description, this.example = le.example || this.schema.example, le.examples !== void 0 || this.schema.examples !== void 0) {
                const it = le.examples || this.schema.examples;
                this.examples = ce(it) ? it : A(it, (_t, Et) => new Io(f, _t, Et, le.encoding));
              }
              Ve ? this.serializationMime = Ve : le.style ? this.style = le.style : this.in && (this.style = (ee = (z = nc[this.in]) == null ? void 0 : z.style) != null ? ee : "form"), le.explode === void 0 && this.in ? this.explode = (pe = (ue = nc[this.in]) == null ? void 0 : ue.explode) == null || pe : this.explode = !!le.explode, this.deprecated = le.deprecated === void 0 ? !!this.schema.deprecated : le.deprecated, P.showExtensions && (this.extensions = os(le, P.showExtensions)), this.const = ((xe = this.schema) == null ? void 0 : xe.const) || (le == null ? void 0 : le.const) || "";
            }
            toggle() {
              this.expanded = !this.expanded;
            }
            collapse() {
              this.expanded = !1;
            }
            expand() {
              this.expanded = !0;
            }
          }
          ai([Y.observable], Zr.prototype, "expanded", 2), ai([Y.action], Zr.prototype, "toggle", 1), ai([Y.action], Zr.prototype, "collapse", 1), ai([Y.action], Zr.prototype, "expand", 1);
          var tm = C5;
          class ff {
            constructor(f, h, w, P, L) {
              this.name = h, this.isRequestType = w, this.schema = P.schema && new Ra(f, P.schema, "", L), this.onlyRequiredInSamples = L.onlyRequiredInSamples, this.generatedSamplesMaxDepth = L.generatedSamplesMaxDepth, P.examples !== void 0 ? this.examples = A(P.examples, (z) => new Io(f, z, h, P.encoding)) : P.example !== void 0 ? this.examples = { default: new Io(f, { value: f.deref(P.example).resolved }, h, P.encoding) } : es(h) && this.generateExample(f, P);
            }
            generateExample(f, h) {
              const w = { skipReadOnly: this.isRequestType, skipWriteOnly: !this.isRequestType, skipNonRequired: this.isRequestType && this.onlyRequiredInSamples, maxSampleDepth: this.generatedSamplesMaxDepth };
              if (this.schema && this.schema.oneOf) {
                this.examples = {};
                for (const P of this.schema.oneOf) {
                  const L = tm.sample(P.rawSchema, w, f.spec);
                  this.schema.discriminatorProp && typeof L == "object" && L && (L[this.schema.discriminatorProp] = P.title), this.examples[P.title] = new Io(f, { value: L }, this.name, h.encoding);
                }
              } else this.schema && (this.examples = { default: new Io(f, { value: tm.sample(h.schema, w, f.spec) }, this.name, h.encoding) });
            }
          }
          var jl = Object.defineProperty, Ob = Object.getOwnPropertyDescriptor, ic = (p, f, h, w) => {
            for (var P, L = w > 1 ? void 0 : w ? Ob(f, h) : f, z = p.length - 1; z >= 0; z--) (P = p[z]) && (L = (w ? P(f, h, L) : P(L)) || L);
            return w && L && jl(f, h, L), L;
          };
          class No {
            constructor(f, h, w, P) {
              this.isRequestType = w, this.activeMimeIdx = 0, (0, Y.makeObservable)(this), P.unstable_ignoreMimeParameters && (h = Fs(h)), this.mediaTypes = Object.keys(h).map((L) => {
                const z = h[L];
                return new ff(f, L, w, z, P);
              });
            }
            activate(f) {
              this.activeMimeIdx = f;
            }
            get active() {
              return this.mediaTypes[this.activeMimeIdx];
            }
            get hasSample() {
              return this.mediaTypes.filter((f) => !!f.examples).length > 0;
            }
          }
          ic([Y.observable], No.prototype, "activeMimeIdx", 2), ic([Y.action], No.prototype, "activate", 1), ic([Y.computed], No.prototype, "active", 1);
          class Qt {
            constructor({ parser: f, infoOrRef: h, options: w, isEvent: P }) {
              const L = !P, { resolved: z } = f.deref(h);
              this.description = z.description || "", this.required = z.required;
              const ee = Lt(z);
              ee !== void 0 && (this.content = new No(f, ee, L, w));
            }
          }
          var sc = Object.defineProperty, oc = Object.defineProperties, Ll = Object.getOwnPropertyDescriptor, rm = Object.getOwnPropertyDescriptors, ac = Object.getOwnPropertySymbols, Ml = Object.prototype.hasOwnProperty, lc = Object.prototype.propertyIsEnumerable, jo = (p, f, h) => f in p ? sc(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h, df = (p, f, h, w) => {
            for (var P, L = w > 1 ? void 0 : w ? Ll(f, h) : f, z = p.length - 1; z >= 0; z--) (P = p[z]) && (L = (w ? P(f, h, L) : P(L)) || L);
            return w && L && sc(f, h, L), L;
          };
          class uc {
            constructor({ parser: f, code: h, defaultAsError: w, infoOrRef: P, options: L, isEvent: z }) {
              this.expanded = !1, this.headers = [], (0, Y.makeObservable)(this), this.expanded = L.expandResponses === "all" || L.expandResponses[h];
              const { resolved: ee } = f.deref(P);
              this.code = h, ee.content !== void 0 && (this.content = new No(f, ee.content, z, L)), ee["x-summary"] !== void 0 ? (this.summary = ee["x-summary"], this.description = ee.description || "") : (this.summary = ee.description || "", this.description = ""), this.type = cr(h, w);
              const ue = ee.headers;
              ue !== void 0 && (this.headers = Object.keys(ue).map((pe) => {
                const xe = ue[pe];
                return new Zr(f, (le = ((we, Ve) => {
                  for (var it in Ve || (Ve = {})) Ml.call(Ve, it) && jo(we, it, Ve[it]);
                  if (ac) for (var it of ac(Ve)) lc.call(Ve, it) && jo(we, it, Ve[it]);
                  return we;
                })({}, xe), oc(le, rm({ name: pe }))), "", L);
                var le;
              })), L.showExtensions && (this.extensions = os(ee, L.showExtensions));
            }
            toggle() {
              this.expanded = !this.expanded;
            }
          }
          df([Y.observable], uc.prototype, "expanded", 2), df([Y.action], uc.prototype, "toggle", 1);
          var kb = Object.defineProperty, nm = Object.getOwnPropertyDescriptor, un = (p, f, h, w) => {
            for (var P, L = w > 1 ? void 0 : w ? nm(f, h) : f, z = p.length - 1; z >= 0; z--) (P = p[z]) && (L = (w ? P(f, h, L) : P(L)) || L);
            return w && L && kb(f, h, L), L;
          };
          function Ia(p) {
            return p.lang === "payload" && p.requestBodyContent;
          }
          let cc = !1;
          class Dr {
            constructor(f, h, w, P, L = !1) {
              var z;
              this.parser = f, this.operationSpec = h, this.options = P, this.type = "operation", this.items = [], this.ready = !0, this.active = !1, this.expanded = !1, (0, Y.makeObservable)(this), this.pointer = h.pointer, this.description = h.description, this.parent = w, this.externalDocs = h.externalDocs, this.deprecated = !!h.deprecated, this.httpVerb = h.httpVerb, this.deprecated = !!h.deprecated, this.operationId = h.operationId, this.path = h.pathName, this.isCallback = L, this.isWebhook = h.isWebhook, this.isEvent = this.isCallback || this.isWebhook, this.name = va(h), this.sidebarLabel = P.sideNavStyle === J.IdOnly ? this.operationId || this.path : P.sideNavStyle === J.PathOnly ? this.path : this.name, this.badges = ((z = h["x-badges"]) == null ? void 0 : z.map(({ name: ee, color: ue, position: pe }) => ({ name: ee, color: ue, position: pe || "after" }))) || [], this.isCallback ? (this.security = (h.security || []).map((ee) => new Hh(ee, f)), this.servers = Si("", h.servers || h.pathServers || [])) : (this.operationHash = h.operationId && "operation/" + h.operationId, this.id = h.operationId !== void 0 ? (w ? w.id + "/" : "") + this.operationHash : w !== void 0 ? w.id + this.pointer : this.pointer, this.security = (h.security || f.spec.security || []).map((ee) => new Hh(ee, f)), this.servers = Si(f.specUrl, h.servers || h.pathServers || f.spec.servers || [])), P.showExtensions && (this.extensions = os(h, P.showExtensions));
            }
            activate() {
              this.active = !0;
            }
            deactivate() {
              this.active = !1;
            }
            toggle() {
              this.expanded = !this.expanded;
            }
            expand() {
              this.parent && this.parent.expand();
            }
            collapse() {
            }
            get requestBody() {
              return this.operationSpec.requestBody && new Qt({ parser: this.parser, infoOrRef: this.operationSpec.requestBody, options: this.options, isEvent: this.isEvent });
            }
            get codeSamples() {
              const { payloadSampleIdx: f, hideRequestPayloadSample: h } = this.options;
              let w = this.operationSpec["x-codeSamples"] || this.operationSpec["x-code-samples"] || [];
              this.operationSpec["x-code-samples"] && !cc && (cc = !0, console.warn('"x-code-samples" is deprecated. Use "x-codeSamples" instead'));
              const P = this.requestBody && this.requestBody.content;
              if (P && P.hasSample && !h) {
                const L = Math.min(w.length, f);
                w = [...w.slice(0, L), { lang: "payload", label: "Payload", source: "", requestBodyContent: P }, ...w.slice(L)];
              }
              return w;
            }
            get parameters() {
              const f = is(this.parser, this.operationSpec.pathParameters, this.operationSpec.parameters).map((h) => new Zr(this.parser, h, this.pointer, this.options));
              return this.options.sortPropsAlphabetically ? wi(f, "name") : this.options.sortRequiredPropsFirst ? ns(f) : f;
            }
            get responses() {
              let f = !1;
              return Object.keys(this.operationSpec.responses || []).filter((h) => h === "default" || (cr(h) === "success" && (f = !0), xl(h))).map((h) => new uc({ parser: this.parser, code: h, defaultAsError: f, infoOrRef: this.operationSpec.responses[h], options: this.options, isEvent: this.isEvent }));
            }
            get callbacks() {
              return Object.keys(this.operationSpec.callbacks || []).map((f) => new $l(this.parser, f, this.operationSpec.callbacks[f], this.pointer, this.options));
            }
          }
          un([Y.observable], Dr.prototype, "ready", 2), un([Y.observable], Dr.prototype, "active", 2), un([Y.observable], Dr.prototype, "expanded", 2), un([Y.action], Dr.prototype, "activate", 1), un([Y.action], Dr.prototype, "deactivate", 1), un([Y.action], Dr.prototype, "toggle", 1), un([Oi], Dr.prototype, "requestBody", 1), un([Oi], Dr.prototype, "codeSamples", 1), un([Oi], Dr.prototype, "parameters", 1), un([Oi], Dr.prototype, "responses", 1), un([Oi], Dr.prototype, "callbacks", 1);
          var hf = Object.defineProperty, mf = Object.defineProperties, Ab = Object.getOwnPropertyDescriptors, gf = Object.getOwnPropertySymbols, Pb = Object.prototype.hasOwnProperty, Tb = Object.prototype.propertyIsEnumerable, pc = (p, f, h) => f in p ? hf(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h, Ws = (p, f) => {
            for (var h in f || (f = {})) Pb.call(f, h) && pc(p, h, f[h]);
            if (gf) for (var h of gf(f)) Tb.call(f, h) && pc(p, h, f[h]);
            return p;
          };
          class im {
            constructor(f, h, w) {
              this.operations = [];
              const { resolved: P } = f.deref(w || {});
              this.initWebhooks(f, P, h);
            }
            initWebhooks(f, h, w) {
              for (const L of Object.keys(h)) {
                const z = h[L], ee = Object.keys(z).filter(Ht);
                for (const ue of ee) {
                  const pe = z[ue];
                  if (z.$ref) {
                    const le = f.deref(z || {});
                    this.initWebhooks(f, { [ue]: le }, w);
                  }
                  if (!pe) continue;
                  const xe = new Dr(f, (P = Ws({}, pe), mf(P, Ab({ httpVerb: ue }))), void 0, w, !1);
                  this.operations.push(xe);
                }
              }
              var P;
            }
          }
          class Lo {
            constructor(f, h, w) {
              const { resolved: P } = f.deref(w);
              this.id = h, this.sectionId = Ln + h, this.type = P.type, this.displayName = P["x-displayName"] || h, this.description = P.description || "", P.type === "apiKey" && (this.apiKey = { name: P.name, in: P.in }), P.type === "http" && (this.http = { scheme: P.scheme, bearerFormat: P.bearerFormat }), P.type === "openIdConnect" && (this.openId = { connectUrl: P.openIdConnectUrl }), P.type === "oauth2" && P.flows && (this.flows = P.flows);
            }
          }
          class li {
            constructor(f) {
              const h = f.spec.components && f.spec.components.securitySchemes || {};
              this.schemes = Object.keys(h).map((w) => new Lo(f, w, h[w]));
            }
          }
          var Dl = Object.defineProperty, Ti = Object.getOwnPropertySymbols, yf = Object.prototype.hasOwnProperty, Cb = Object.prototype.propertyIsEnumerable, sm = (p, f, h) => f in p ? Dl(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h, Ks = (p, f) => {
            for (var h in f || (f = {})) yf.call(f, h) && sm(p, h, f[h]);
            if (Ti) for (var h of Ti(f)) Cb.call(f, h) && sm(p, h, f[h]);
            return p;
          };
          class Na {
            constructor(f, h, w) {
              var P, L, z;
              this.options = w, this.parser = new lf(f, h, w), this.info = new rf(this.parser, this.options), this.externalDocs = this.parser.spec.externalDocs, this.contentItems = ui.buildStructure(this.parser, this.options), this.securitySchemes = new li(this.parser);
              const ee = Ks(Ks({}, (L = (P = this.parser) == null ? void 0 : P.spec) == null ? void 0 : L["x-webhooks"]), (z = this.parser) == null ? void 0 : z.spec.webhooks);
              this.webhooks = new im(this.parser, w, ee);
            }
          }
          var ja = Object.defineProperty, fc = Object.getOwnPropertyDescriptor, Qs = (p, f, h, w) => {
            for (var P, L = w > 1 ? void 0 : w ? fc(f, h) : f, z = p.length - 1; z >= 0; z--) (P = p[z]) && (L = (w ? P(f, h, L) : P(L)) || L);
            return w && L && ja(f, h, L), L;
          };
          class Hr {
            constructor(f, h, w) {
              this.items = [], this.active = !1, this.expanded = !1, (0, Y.makeObservable)(this), this.id = h.id || f + "/" + V(h.name), this.type = f, this.name = h["x-displayName"] || h.name, this.level = h.level || 1, this.sidebarLabel = this.name, this.description = h.description || "";
              const P = h.items;
              P && P.length && (this.description = Pi.getTextBeforeHading(this.description, P[0].name)), this.parent = w, this.externalDocs = h.externalDocs, this.type === "group" && (this.expanded = !0);
            }
            activate() {
              this.active = !0;
            }
            expand() {
              this.parent && this.parent.expand(), this.expanded = !0;
            }
            collapse() {
              this.type !== "group" && (this.expanded = !1);
            }
            deactivate() {
              this.active = !1;
            }
          }
          Qs([Y.observable], Hr.prototype, "active", 2), Qs([Y.observable], Hr.prototype, "expanded", 2), Qs([Y.action], Hr.prototype, "activate", 1), Qs([Y.action], Hr.prototype, "expand", 1), Qs([Y.action], Hr.prototype, "collapse", 1), Qs([Y.action], Hr.prototype, "deactivate", 1);
          var Ys = Object.defineProperty, Jt = Object.defineProperties, Yt = Object.getOwnPropertyDescriptors, us = Object.getOwnPropertySymbols, Wr = Object.prototype.hasOwnProperty, cn = Object.prototype.propertyIsEnumerable, Gs = (p, f, h) => f in p ? Ys(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h, Mo = (p, f) => {
            for (var h in f || (f = {})) Wr.call(f, h) && Gs(p, h, f[h]);
            if (us) for (var h of us(f)) cn.call(f, h) && Gs(p, h, f[h]);
            return p;
          }, en = (p, f) => Jt(p, Yt(f));
          const Do = 0;
          class ui {
            static buildStructure(f, h) {
              const w = f.spec, { schemaDefinitionsTagName: P } = h, L = [], z = [...w.tags || []];
              !z.find((ue) => (ue == null ? void 0 : ue.name) === P) && P && z.push({ name: P });
              const ee = ui.getTagsWithOperations(f, z);
              return L.push(...ui.addMarkdownItems(w.info.description || "", void 0, 1, h)), w["x-tagGroups"] && w["x-tagGroups"].length > 0 ? L.push(...ui.getTagGroupsItems(f, void 0, w["x-tagGroups"], ee, h)) : L.push(...ui.getTagsItems(f, ee, void 0, void 0, h)), L;
            }
            static addMarkdownItems(f, h, w, P) {
              const L = new Pi(P, h == null ? void 0 : h.id).extractHeadings(f || "");
              L.length && h && h.description && (h.description = Pi.getTextBeforeHading(h.description, L[0].name));
              const z = (ee, ue, pe = 1) => ue.map((xe) => {
                const le = new Hr("section", xe, ee);
                return le.depth = pe, xe.items && (le.items = z(le, xe.items, pe + 1)), le;
              });
              return z(h, L, w);
            }
            static getTagGroupsItems(f, h, w, P, L) {
              const z = [];
              for (const ee of w) {
                const ue = new Hr("group", ee, h);
                ue.depth = Do, ue.items = ui.getTagsItems(f, P, ue, ee, L), z.push(ue);
              }
              return z;
            }
            static getTagsItems(f, h, w, P, L) {
              let z;
              z = P === void 0 ? Object.keys(h) : P.tags;
              const ee = z.map((pe) => h[pe] ? (h[pe].used = !0, h[pe]) : (console.warn(`Non-existing tag "${pe}" is added to the group "${P.name}"`), null)), ue = [];
              for (const pe of ee) {
                if (!pe) continue;
                const xe = new Hr("tag", pe, w);
                if (xe.depth = Do + 1, pe.name === "") {
                  const we = [...ui.addMarkdownItems(pe.description || "", xe, xe.depth + 1, L), ...this.getOperationsItems(f, void 0, pe, xe.depth + 1, L)];
                  ue.push(...we);
                  continue;
                }
                const le = this.getTagRelatedSchema({ parser: f, tag: pe, parent: xe, schemaDefinitionsTagName: L.schemaDefinitionsTagName });
                xe.items = [...le, ...ui.addMarkdownItems(pe.description || "", xe, xe.depth + 1, L), ...this.getOperationsItems(f, xe, pe, xe.depth + 1, L)], ue.push(xe);
              }
              return L.sortTagsAlphabetically && ue.sort(To("name")), ue;
            }
            static getOperationsItems(f, h, w, P, L) {
              if (w.operations.length === 0) return [];
              const z = [];
              for (const ee of w.operations) {
                const ue = new Dr(f, ee, h, L);
                ue.depth = P, z.push(ue);
              }
              return L.sortOperationsAlphabetically && z.sort(To("name")), z;
            }
            static getTagsWithOperations(f, h) {
              const { spec: w } = f, P = {}, L = w["x-webhooks"] || w.webhooks;
              for (const ee of h || []) P[ee.name] = en(Mo({}, ee), { operations: [] });
              function z(ee, ue, pe) {
                for (const xe of Object.keys(ue)) {
                  const le = ue[xe], we = Object.keys(le).filter(Ht);
                  for (const Ve of we) {
                    const it = le[Ve];
                    if (le.$ref) {
                      const { resolved: Et } = ee.deref(le);
                      z(ee, { [xe]: Et }, pe);
                      continue;
                    }
                    let _t = it == null ? void 0 : it.tags;
                    _t && _t.length || (_t = [""]);
                    for (const Et of _t) {
                      let gt = P[Et];
                      gt === void 0 && (gt = { name: Et, operations: [] }, P[Et] = gt), gt["x-traitTag"] || gt.operations.push(en(Mo({}, it), { pathName: xe, pointer: kt.compile(["paths", xe, Ve]), httpVerb: Ve, pathParameters: le.parameters || [], pathServers: le.servers, isWebhook: !!pe }));
                    }
                  }
                }
              }
              return L && z(f, L, !0), w.paths && z(f, w.paths), P;
            }
            static getTagRelatedSchema({ parser: f, tag: h, parent: w, schemaDefinitionsTagName: P }) {
              var L;
              const z = P ? [P] : [];
              return Object.entries(((L = f.spec.components) == null ? void 0 : L.schemas) || {}).map(([ee, ue]) => {
                const pe = ue["x-tags"] || z;
                if (!(pe != null && pe.includes(h.name))) return null;
                const xe = new Hr("schema", { name: ee, "x-displayName": `${ue.title || ee}`, description: `<SchemaDefinition showWriteOnly={true} schemaRef="#/components/schemas/${ee}" />` }, w);
                return xe.depth = w.depth + 1, xe;
              }).filter(Boolean);
            }
          }
          var om = Object.defineProperty, dc = Object.getOwnPropertyDescriptor, Fo = (p, f, h, w) => {
            for (var P, L = w > 1 ? void 0 : w ? dc(f, h) : f, z = p.length - 1; z >= 0; z--) (P = p[z]) && (L = (w ? P(f, h, L) : P(L)) || L);
            return w && L && om(f, h, L), L;
          };
          const tn = "data-section-id";
          class zn {
            constructor(f, h, w) {
              this.scroll = h, this.history = w, this.activeItemIdx = -1, this.sideBarOpened = !1, this.updateOnScroll = (P) => {
                const L = P ? 1 : -1;
                let z = this.activeItemIdx;
                for (; (z !== -1 || P) && !(z >= this.flatItems.length - 1 && P); ) {
                  if (P) {
                    const ee = this.getElementAtOrFirstChild(z + 1);
                    if (this.scroll.isElementBellow(ee)) break;
                  } else {
                    const ee = this.getElementAt(z);
                    if (this.scroll.isElementAbove(ee)) break;
                  }
                  z += L;
                }
                this.activate(this.flatItems[z], !0, !0);
              }, this.updateOnHistory = (P = this.history.currentId) => {
                if (!P) return;
                let L;
                L = this.flatItems.find((z) => z.id === P), L ? this.activateAndScroll(L, !1) : (P.startsWith(Ln) && (L = this.flatItems.find((z) => Ln.startsWith(z.id)), this.activateAndScroll(L, !1)), this.scroll.scrollIntoViewBySelector(`[${tn}="${ve(P)}"]`));
              }, this.getItemById = (P) => this.flatItems.find((L) => L.id === P), (0, Y.makeObservable)(this), this.items = f.contentItems, this.flatItems = _(this.items || [], "items"), this.flatItems.forEach((P, L) => P.absoluteIdx = L), this.subscribe();
            }
            static updateOnHistory(f = oi.currentId, h) {
              f && h.scrollIntoViewBySelector(`[${tn}="${ve(f)}"]`);
            }
            subscribe() {
              this._unsubscribe = this.scroll.subscribe(this.updateOnScroll), this._hashUnsubscribe = this.history.subscribe(this.updateOnHistory);
            }
            toggleSidebar() {
              this.sideBarOpened = !this.sideBarOpened;
            }
            closeSidebar() {
              this.sideBarOpened = !1;
            }
            getElementAt(f) {
              const h = this.flatItems[f];
              return h && g(`[${tn}="${ve(h.id)}"]`) || null;
            }
            getElementAtOrFirstChild(f) {
              let h = this.flatItems[f];
              return h && h.type === "group" && (h = h.items[0]), h && g(`[${tn}="${ve(h.id)}"]`) || null;
            }
            get activeItem() {
              return this.flatItems[this.activeItemIdx] || void 0;
            }
            activate(f, h = !0, w = !1) {
              if ((this.activeItem && this.activeItem.id) !== (f && f.id) && (!f || f.type !== "group")) {
                if (this.deactivate(this.activeItem), !f) return this.activeItemIdx = -1, void this.history.replace("", w);
                f.depth <= Do || (this.activeItemIdx = f.absoluteIdx, h && this.history.replace(encodeURI(f.id), w), f.activate(), f.expand());
              }
            }
            deactivate(f) {
              if (f !== void 0) for (f.deactivate(); f !== void 0; ) f.collapse(), f = f.parent;
            }
            activateAndScroll(f, h, w) {
              const P = f && this.getItemById(f.id) || f;
              this.activate(P, h, w), this.scrollToActive(), P && P.items.length || this.closeSidebar();
            }
            scrollToActive() {
              this.scroll.scrollIntoView(this.getElementAt(this.activeItemIdx));
            }
            dispose() {
              this._unsubscribe(), this._hashUnsubscribe();
            }
          }
          Fo([Y.observable], zn.prototype, "activeItemIdx", 2), Fo([Y.observable], zn.prototype, "sideBarOpened", 2), Fo([Y.action], zn.prototype, "toggleSidebar", 1), Fo([Y.action], zn.prototype, "closeSidebar", 1), Fo([Y.action], zn.prototype, "activate", 1), Fo([Y.action.bound], zn.prototype, "activateAndScroll", 1);
          var vf = Object.defineProperty, am = Object.getOwnPropertyDescriptor;
          const hc = "scroll";
          class Ci {
            constructor(f) {
              this.options = f, this._prevOffsetY = 0, this._scrollParent = m ? window : void 0, this._emiter = new Ze.EventEmitter(), this.bind();
            }
            bind() {
              this._prevOffsetY = this.scrollY(), this._scrollParent && this._scrollParent.addEventListener("scroll", this.handleScroll);
            }
            dispose() {
              this._scrollParent && this._scrollParent.removeEventListener("scroll", this.handleScroll), this._emiter.removeAllListeners(hc);
            }
            scrollY() {
              return typeof HTMLElement < "u" && this._scrollParent instanceof HTMLElement ? this._scrollParent.scrollTop : this._scrollParent !== void 0 ? this._scrollParent.pageYOffset : 0;
            }
            isElementBellow(f) {
              if (f !== null) return f.getBoundingClientRect().top > this.options.scrollYOffset();
            }
            isElementAbove(f) {
              if (f === null) return;
              const h = f.getBoundingClientRect().top;
              return (h > 0 ? Math.floor(h) : Math.ceil(h)) <= this.options.scrollYOffset();
            }
            subscribe(f) {
              const h = this._emiter.addListener(hc, f);
              return () => h.removeListener(hc, f);
            }
            scrollIntoView(f) {
              f !== null && (f.scrollIntoView(), this._scrollParent && this._scrollParent.scrollBy && this._scrollParent.scrollBy(0, 1 - this.options.scrollYOffset()));
            }
            scrollIntoViewBySelector(f) {
              const h = g(f);
              this.scrollIntoView(h);
            }
            handleScroll() {
              const f = this.scrollY() - this._prevOffsetY > 0;
              this._prevOffsetY = this.scrollY(), this._emiter.emit(hc, f);
            }
          }
          ((p, f, h) => {
            for (var w, P = am(f, h), L = p.length - 1; L >= 0; L--) (w = p[L]) && (P = w(f, h, P) || P);
            P && vf(f, h, P);
          })([Ye.bind, kl(100)], Ci.prototype, "handleScroll");
          class qo {
            constructor() {
              this.searchWorker = function() {
                let f;
                if (m) try {
                  f = o(988);
                } catch {
                  f = o(353).Ay;
                }
                else f = o(353).Ay;
                return new f();
              }();
            }
            indexItems(f) {
              const h = (w) => {
                w.forEach((P) => {
                  P.type !== "group" && this.add(P.name, (P.description || "").concat(" ", P.path || ""), P.id), h(P.items);
                });
              };
              h(f), this.searchWorker.done();
            }
            add(f, h, w) {
              this.searchWorker.add(f, h, w);
            }
            dispose() {
              this.searchWorker.terminate(), this.searchWorker.dispose();
            }
            search(f) {
              return this.searchWorker.search(f);
            }
            toJS() {
              return f = this, h = function* () {
                return this.searchWorker.toJS();
              }, new Promise((w, P) => {
                var L = (ue) => {
                  try {
                    ee(h.next(ue));
                  } catch (pe) {
                    P(pe);
                  }
                }, z = (ue) => {
                  try {
                    ee(h.throw(ue));
                  } catch (pe) {
                    P(pe);
                  }
                }, ee = (ue) => ue.done ? w(ue.value) : Promise.resolve(ue.value).then(L, z);
                ee((h = h.apply(f, null)).next());
              });
              var f, h;
            }
            load(f) {
              this.searchWorker.load(f);
            }
            fromExternalJS(f, h) {
              f && h && this.searchWorker.fromExternalJS(f, h);
            }
          }
          const Sn = K.div`
  width: calc(100% - ${(p) => p.theme.rightPanel.width});
  padding: 0 ${(p) => p.theme.spacing.sectionHorizontal}px;

  ${({ $compact: p, theme: f }) => $.lessThan("medium", !0)`
    width: 100%;
    padding: ${`${p ? 0 : f.spacing.sectionVertical}px ${f.spacing.sectionHorizontal}px`};
  `};
`, Xs = K.div.attrs((p) => ({ [tn]: p.id }))`
  padding: ${(p) => p.theme.spacing.sectionVertical}px 0;

  &:last-child {
    min-height: calc(100vh + 1px);
  }

  & > &:last-child {
    min-height: initial;
  }

  ${$.lessThan("medium", !0)`
    padding: 0;
  `}
  ${({ $underlined: p }) => p ? `
    position: relative;

    &:not(:last-of-type):after {
      position: absolute;
      bottom: 0;
      width: 100%;
      display: block;
      content: '';
      border-bottom: 1px solid rgba(0, 0, 0, 0.2);
    }
  ` : ""}
`, Fl = K.div`
  width: ${(p) => p.theme.rightPanel.width};
  color: ${({ theme: p }) => p.rightPanel.textColor};
  background-color: ${(p) => p.theme.rightPanel.backgroundColor};
  padding: 0 ${(p) => p.theme.spacing.sectionHorizontal}px;

  ${$.lessThan("medium", !0)`
    width: 100%;
    padding: ${(p) => `${p.theme.spacing.sectionVertical}px ${p.theme.spacing.sectionHorizontal}px`};
  `};
`, xn = K(Fl)`
  background-color: ${(p) => p.theme.rightPanel.backgroundColor};
`, Tr = K.div`
  display: flex;
  width: 100%;
  padding: 0;

  ${$.lessThan("medium", !0)`
    flex-direction: column;
  `};
`, zo = { 1: "1.85714em", 2: "1.57143em", 3: "1.27em" }, _n = (p) => Pe`
  font-family: ${({ theme: f }) => f.typography.headings.fontFamily};
  font-weight: ${({ theme: f }) => f.typography.headings.fontWeight};
  font-size: ${zo[p]};
  line-height: ${({ theme: f }) => f.typography.headings.lineHeight};
`, cs = K.h1`
  ${_n(1)};
  color: ${({ theme: p }) => p.colors.text.primary};

  ${me("H1")};
`, ps = K.h2`
  ${_n(2)};
  color: ${({ theme: p }) => p.colors.text.primary};
  margin: 0 0 20px;

  ${me("H2")};
`, lm = K.h2`
  ${_n(3)};
  color: ${({ theme: p }) => p.colors.text.primary};

  ${me("H3")};
`, ql = K.h3`
  color: ${({ theme: p }) => p.rightPanel.textColor};

  ${me("RightPanelHeader")};
`, Bo = K.h5`
  border-bottom: 1px solid rgba(38, 50, 56, 0.3);
  margin: 1em 0 1em 0;
  color: rgba(38, 50, 56, 0.5);
  font-weight: normal;
  text-transform: uppercase;
  font-size: 0.929em;
  line-height: 20px;

  ${me("UnderlinedHeader")};
`;
          var En = (p, f, h) => new Promise((w, P) => {
            var L = (ue) => {
              try {
                ee(h.next(ue));
              } catch (pe) {
                P(pe);
              }
            }, z = (ue) => {
              try {
                ee(h.throw(ue));
              } catch (pe) {
                P(pe);
              }
            }, ee = (ue) => ue.done ? w(ue.value) : Promise.resolve(ue.value).then(L, z);
            ee((h = h.apply(p, f)).next());
          });
          const Kr = (0, i.createContext)(void 0), { Provider: Zt, Consumer: Bn } = Kr;
          function bf(p) {
            const { spec: f, specUrl: h, options: w, onLoaded: P, children: L } = p, [z, ee] = i.useState(null), [ue, pe] = i.useState(null);
            if (ue) throw ue;
            i.useEffect(() => {
              (function() {
                En(this, null, function* () {
                  if (f || h) {
                    ee(null);
                    try {
                      const le = yield He(f || h);
                      ee(le);
                    } catch (le) {
                      throw P && P(le), pe(le), le;
                    }
                  }
                });
              })();
            }, [f, h]);
            const xe = i.useMemo(() => {
              if (!z) return null;
              try {
                return new ms(z, h, w);
              } catch (le) {
                throw P && P(le), le;
              }
            }, [z, h, w]);
            return i.useEffect(() => {
              xe && P && P();
            }, [xe, P]), L({ loading: !xe, store: xe });
          }
          function wf() {
            return (0, i.useContext)(Kr);
          }
          const mc = (p) => Pe`
  ${p} {
    cursor: pointer;
    margin-left: -20px;
    padding: 0;
    line-height: 1;
    width: 20px;
    display: inline-block;
    outline: 0;
  }
  ${p}:before {
    content: '';
    width: 15px;
    height: 15px;
    background-size: contain;
    background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgeD0iMCIgeT0iMCIgd2lkdGg9IjUxMiIgaGVpZ2h0PSI1MTIiIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMCA1MTIgNTEyIiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSIjMDEwMTAxIiBkPSJNNDU5LjcgMjMzLjRsLTkwLjUgOTAuNWMtNTAgNTAtMTMxIDUwLTE4MSAwIC03LjktNy44LTE0LTE2LjctMTkuNC0yNS44bDQyLjEtNDIuMWMyLTIgNC41LTMuMiA2LjgtNC41IDIuOSA5LjkgOCAxOS4zIDE1LjggMjcuMiAyNSAyNSA2NS42IDI0LjkgOTAuNSAwbDkwLjUtOTAuNWMyNS0yNSAyNS02NS42IDAtOTAuNSAtMjQuOS0yNS02NS41LTI1LTkwLjUgMGwtMzIuMiAzMi4yYy0yNi4xLTEwLjItNTQuMi0xMi45LTgxLjYtOC45bDY4LjYtNjguNmM1MC01MCAxMzEtNTAgMTgxIDBDNTA5LjYgMTAyLjMgNTA5LjYgMTgzLjQgNDU5LjcgMjMzLjR6TTIyMC4zIDM4Mi4ybC0zMi4yIDMyLjJjLTI1IDI0LjktNjUuNiAyNC45LTkwLjUgMCAtMjUtMjUtMjUtNjUuNiAwLTkwLjVsOTAuNS05MC41YzI1LTI1IDY1LjUtMjUgOTAuNSAwIDcuOCA3LjggMTIuOSAxNy4yIDE1LjggMjcuMSAyLjQtMS40IDQuOC0yLjUgNi44LTQuNWw0Mi4xLTQyYy01LjQtOS4yLTExLjYtMTgtMTkuNC0yNS44IC01MC01MC0xMzEtNTAtMTgxIDBsLTkwLjUgOTAuNWMtNTAgNTAtNTAgMTMxIDAgMTgxIDUwIDUwIDEzMSA1MCAxODEgMGw2OC42LTY4LjZDMjc0LjYgMzk1LjEgMjQ2LjQgMzkyLjMgMjIwLjMgMzgyLjJ6Ii8+PC9zdmc+Cg==');
    opacity: 0.5;
    visibility: hidden;
    display: inline-block;
    vertical-align: middle;
  }

  h1:hover > ${p}::before, h2:hover > ${p}::before, ${p}:hover::before {
    visibility: visible;
  }
`, Sf = K(function(p) {
            const f = i.useContext(Kr), h = i.useCallback((w) => {
              f && function(P, L, z) {
                L.defaultPrevented || L.button !== 0 || ((ee) => !!(ee.metaKey || ee.altKey || ee.ctrlKey || ee.shiftKey))(L) || (L.preventDefault(), P.replace(encodeURI(z)));
              }(f.menu.history, w, p.to);
            }, [f, p.to]);
            return f ? i.createElement("a", { className: p.className, href: f.menu.history.linkForId(p.to), onClick: h, "aria-label": p.to }, p.children) : null;
          })`
  ${mc("&")};
`;
          function gc(p) {
            return i.createElement(Sf, { to: p.to });
          }
          const yc = { left: "90deg", right: "-90deg", up: "-180deg", down: "0" }, $i = K((p) => i.createElement("svg", { className: p.className, style: p.style, version: "1.1", viewBox: "0 0 24 24", x: "0", xmlns: "http://www.w3.org/2000/svg", y: "0", "aria-hidden": "true" }, i.createElement("polygon", { points: "17.3 8.3 12 13.6 6.7 8.3 5.3 9.7 12 16.4 18.7 9.7 " })))`
  height: ${(p) => p.size || "18px"};
  width: ${(p) => p.size || "18px"};
  min-width: ${(p) => p.size || "18px"};
  vertical-align: middle;
  float: ${(p) => p.float || ""};
  transition: transform 0.2s ease-out;
  transform: rotateZ(${(p) => yc[p.direction || "down"]});

  polygon {
    fill: ${({ color: p, theme: f }) => p && f.colors.responses[p] && f.colors.responses[p].color || p};
  }
`, Un = K.span`
  display: inline-block;
  padding: 2px 8px;
  margin: 0;
  background-color: ${(p) => p.color || p.theme.colors[p.type].main};
  color: ${(p) => p.theme.colors[p.type].contrastText};
  font-size: ${(p) => p.theme.typography.code.fontSize};
  vertical-align: middle;
  line-height: 1.6;
  border-radius: 4px;
  font-weight: ${({ theme: p }) => p.typography.fontWeightBold};
  font-size: 12px;
  + span[type] {
    margin-left: 4px;
  }
`, La = Pe`
  text-decoration: line-through;
  color: #707070;
`, $b = K.caption`
  text-align: right;
  font-size: 0.9em;
  font-weight: normal;
  color: ${(p) => p.theme.colors.text.secondary};
`, Ma = K.td`
  border-left: 1px solid ${(p) => p.theme.schema.linesColor};
  box-sizing: border-box;
  position: relative;
  padding: 10px 10px 10px 0;

  ${$.lessThan("small")`
    display: block;
    overflow: hidden;
  `}

  tr:first-of-type > &,
  tr.last > & {
    border-left-width: 0;
    background-position: top left;
    background-repeat: no-repeat;
    background-size: 1px 100%;
  }

  tr:first-of-type > & {
    background-image: linear-gradient(
      to bottom,
      transparent 0%,
      transparent 22px,
      ${(p) => p.theme.schema.linesColor} 22px,
      ${(p) => p.theme.schema.linesColor} 100%
    );
  }

  tr.last > & {
    background-image: linear-gradient(
      to bottom,
      ${(p) => p.theme.schema.linesColor} 0%,
      ${(p) => p.theme.schema.linesColor} 22px,
      transparent 22px,
      transparent 100%
    );
  }

  tr.last + tr > & {
    border-left-color: transparent;
  }

  tr.last:first-child > & {
    background: none;
    border-left-color: transparent;
  }
`, vc = K(Ma)`
  padding: 0;
`, xf = K(Ma)`
  vertical-align: top;
  line-height: 20px;
  white-space: nowrap;
  font-size: 13px;
  font-family: ${(p) => p.theme.typography.code.fontFamily};

  &.deprecated {
    ${La};
  }

  ${({ kind: p }) => p === "patternProperties" && Pe`
      > span.property-name {
        display: inline-table;
        white-space: break-spaces;
        margin-right: 20px;

        ::before,
        ::after {
          content: '/';
          filter: opacity(0.2);
        }
      }
    `}

  ${({ kind: p = "" }) => ["field", "additionalProperties", "patternProperties"].includes(p) ? "" : "font-style: italic"};

  ${me("PropertyNameCell")};
`, um = K.td`
  border-bottom: 1px solid #9fb4be;
  padding: 10px 0;
  width: ${(p) => p.theme.schema.defaultDetailsWidth};
  box-sizing: border-box;

  tr.expanded & {
    border-bottom: none;
  }

  ${$.lessThan("small")`
    padding: 0 20px;
    border-bottom: none;
    border-left: 1px solid ${(p) => p.theme.schema.linesColor};

    tr.last > & {
      border-left: none;
    }
  `}

  ${me("PropertyDetailsCell")};
`, Uo = K.span`
  color: ${(p) => p.theme.schema.linesColor};
  font-family: ${(p) => p.theme.typography.code.fontFamily};
  margin-right: 10px;

  &::before {
    content: '';
    display: inline-block;
    vertical-align: middle;
    width: 10px;
    height: 1px;
    background: ${(p) => p.theme.schema.linesColor};
  }

  &::after {
    content: '';
    display: inline-block;
    vertical-align: middle;
    width: 1px;
    background: ${(p) => p.theme.schema.linesColor};
    height: 7px;
  }
`, or = K.div`
  padding: ${({ theme: p }) => p.schema.nestingSpacing};
`, Da = K.table`
  border-collapse: separate;
  border-radius: 3px;
  font-size: ${(p) => p.theme.typography.fontSize};

  border-spacing: 0;
  width: 100%;

  > tr {
    vertical-align: middle;
  }

  ${$.lessThan("small")`
    display: block;
    > tr, > tbody > tr {
      display: block;
    }
  `}

  ${$.lessThan("small", !1, " and (-ms-high-contrast:none)")`
    td {
      float: left;
      width: 100%;
    }
  `}

  &
    ${or},
    &
    ${or}
    ${or}
    ${or},
    &
    ${or}
    ${or}
    ${or}
    ${or}
    ${or} {
    margin: ${({ theme: p }) => p.schema.nestingSpacing};
    margin-right: 0;
    background: ${({ theme: p }) => p.schema.nestedBackground};
  }

  &
    ${or}
    ${or},
    &
    ${or}
    ${or}
    ${or}
    ${or},
    &
    ${or}
    ${or}
    ${or}
    ${or}
    ${or}
    ${or} {
    background: #ffffff;
  }
`, bc = K.div`
  margin: 0 0 3px 0;
  display: inline-block;
`, Fa = K.span`
  font-size: 0.9em;
  margin-right: 10px;
  color: ${(p) => p.theme.colors.primary.main};
  font-family: ${(p) => p.theme.typography.headings.fontFamily};
}
`, _f = K.button`
  display: inline-block;
  margin-right: 10px;
  margin-bottom: 5px;
  font-size: 0.8em;
  cursor: pointer;
  border: 1px solid ${(p) => p.theme.colors.primary.main};
  padding: 2px 10px;
  line-height: 1.5em;
  outline: none;
  &:focus {
    box-shadow: 0 0 0 1px ${(p) => p.theme.colors.primary.main};
  }

  ${({ $deprecated: p }) => p && La || ""};

  ${(p) => p.$active ? `
      color: white;
      background-color: ${p.theme.colors.primary.main};
      &:focus {
        box-shadow: none;
        background-color: ${(0, u.darken)(0.15, p.theme.colors.primary.main)};
      }
      ` : `
        color: ${p.theme.colors.primary.main};
        background-color: white;
      `}
`, Ef = K.div`
  font-size: 0.9em;
  font-family: ${(p) => p.theme.typography.code.fontFamily};
  &::after {
    content: ' [';
  }
`, Of = K.div`
  font-size: 0.9em;
  font-family: ${(p) => p.theme.typography.code.fontFamily};
  &::after {
    content: ']';
  }
`;
          var fs = r4;
          const Js = K(fs.Tabs)`
  > ul {
    list-style: none;
    padding: 0;
    margin: 0;
    margin: 0 -5px;

    > li {
      padding: 5px 10px;
      display: inline-block;

      background-color: ${({ theme: p }) => p.codeBlock.backgroundColor};
      border-bottom: 1px solid rgba(0, 0, 0, 0.5);
      cursor: pointer;
      text-align: center;
      outline: none;
      color: ${({ theme: p }) => (0, u.darken)(p.colors.tonalOffset, p.rightPanel.textColor)};
      margin: 0
        ${({ theme: p }) => `${p.spacing.unit}px ${p.spacing.unit}px ${p.spacing.unit}px`};
      border: 1px solid ${({ theme: p }) => (0, u.darken)(0.05, p.codeBlock.backgroundColor)};
      border-radius: 5px;
      min-width: 60px;
      font-size: 0.9em;
      font-weight: bold;

      &.react-tabs__tab--selected {
        color: ${(p) => p.theme.colors.text.primary};
        background: ${({ theme: p }) => p.rightPanel.textColor};
        &:focus {
          outline: auto;
        }
      }

      &:only-child {
        flex: none;
        min-width: 100px;
      }

      &.tab-success {
        color: ${(p) => p.theme.colors.responses.success.tabTextColor};
      }

      &.tab-redirect {
        color: ${(p) => p.theme.colors.responses.redirect.tabTextColor};
      }

      &.tab-info {
        color: ${(p) => p.theme.colors.responses.info.tabTextColor};
      }

      &.tab-error {
        color: ${(p) => p.theme.colors.responses.error.tabTextColor};
      }
    }
  }
  > .react-tabs__tab-panel {
    background: ${({ theme: p }) => p.codeBlock.backgroundColor};
    & > div,
    & > pre {
      padding: ${(p) => 4 * p.theme.spacing.unit}px;
      margin: 0;
    }

    & > div > pre {
      padding: 0;
    }
  }
`, pn = (K(Js)`
  > ul {
    display: block;
    > li {
      padding: 2px 5px;
      min-width: auto;
      margin: 0 15px 0 0;
      font-size: 13px;
      font-weight: normal;
      border-bottom: 1px dashed;
      color: ${({ theme: p }) => (0, u.darken)(p.colors.tonalOffset, p.rightPanel.textColor)};
      border-radius: 0;
      background: none;

      &:last-child {
        margin-right: 0;
      }

      &.react-tabs__tab--selected {
        color: ${({ theme: p }) => p.rightPanel.textColor};
        background: none;
      }
    }
  }
  > .react-tabs__tab-panel {
    & > div,
    & > pre {
      padding: ${(p) => 2 * p.theme.spacing.unit}px 0;
    }
  }
`, K.div`
  /**
  * Based on prism-dark.css
  */

  code[class*='language-'],
  pre[class*='language-'] {
    /* color: white;
    background: none; */
    text-shadow: 0 -0.1em 0.2em black;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;

    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;

    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
  }

  @media print {
    code[class*='language-'],
    pre[class*='language-'] {
      text-shadow: none;
    }
  }

  /* Code blocks */
  pre[class*='language-'] {
    padding: 1em;
    margin: 0.5em 0;
    overflow: auto;
  }

  .token.comment,
  .token.prolog,
  .token.doctype,
  .token.cdata {
    color: hsl(30, 20%, 50%);
  }

  .token.punctuation {
    opacity: 0.7;
  }

  .namespace {
    opacity: 0.7;
  }

  .token.property,
  .token.tag,
  .token.number,
  .token.constant,
  .token.symbol {
    color: #4a8bb3;
  }

  .token.boolean {
    color: #e64441;
  }

  .token.selector,
  .token.attr-name,
  .token.string,
  .token.char,
  .token.builtin,
  .token.inserted {
    color: #a0fbaa;
    & + a,
    & + a:visited {
      color: #4ed2ba;
      text-decoration: underline;
    }
  }

  .token.property.string {
    color: white;
  }

  .token.operator,
  .token.entity,
  .token.url,
  .token.variable {
    color: hsl(40, 90%, 60%);
  }

  .token.atrule,
  .token.attr-value,
  .token.keyword {
    color: hsl(350, 40%, 70%);
  }

  .token.regex,
  .token.important {
    color: #e90;
  }

  .token.important,
  .token.bold {
    font-weight: bold;
  }
  .token.italic {
    font-style: italic;
  }

  .token.entity {
    cursor: help;
  }

  .token.deleted {
    color: red;
  }

  ${me("Prism")};
`), Ri = K.div`
  opacity: 0.7;
  transition: opacity 0.3s ease;
  text-align: right;
  &:focus-within {
    opacity: 1;
  }
  > button {
    background-color: transparent;
    border: 0;
    color: inherit;
    padding: 2px 10px;
    font-family: ${({ theme: p }) => p.typography.fontFamily};
    font-size: ${({ theme: p }) => p.typography.fontSize};
    line-height: ${({ theme: p }) => p.typography.lineHeight};
    cursor: pointer;
    outline: 0;

    :hover,
    :focus {
      background: rgba(255, 255, 255, 0.1);
    }
  }
`, kf = K.div`
  &:hover ${Ri} {
    opacity: 1;
  }
`, Af = K(pn).attrs({ as: "pre" })`
  font-family: ${(p) => p.theme.typography.code.fontFamily};
  font-size: ${(p) => p.theme.typography.code.fontSize};
  overflow-x: auto;
  margin: 0;

  white-space: ${({ theme: p }) => p.typography.code.wrap ? "pre-wrap" : "pre"};
`;
          var Ii = g4, Zs = o.n(Ii), Pf = Object.defineProperty, Tf = Object.getOwnPropertySymbols, ds = Object.prototype.hasOwnProperty, eo = Object.prototype.propertyIsEnumerable, zl = (p, f, h) => f in p ? Pf(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h;
          const cm = Zs() || Ii;
          let Vn = "";
          m && (Vn = o(494), Vn = typeof Vn.toString == "function" && Vn.toString() || "", Vn = Vn === "[object Object]" ? "" : Vn);
          const pm = Oe`${Vn}`, Bl = K.div`
  position: relative;
`;
          class Ni extends i.Component {
            constructor() {
              super(...arguments), this.handleRef = (f) => {
                this._container = f;
              };
            }
            componentDidMount() {
              const f = this._container.parentElement && this._container.parentElement.scrollTop || 0;
              this.inst = new cm(this._container, this.props.options || {}), this._container.scrollTo && this._container.scrollTo(0, f);
            }
            componentDidUpdate() {
              this.inst.update();
            }
            componentWillUnmount() {
              this.inst.destroy();
            }
            render() {
              const { children: f, className: h, updateFn: w } = this.props;
              return w && w(this.componentDidUpdate.bind(this)), i.createElement(i.Fragment, null, Vn && i.createElement(pm, null), i.createElement(Bl, { className: `scrollbar-container ${h}`, ref: this.handleRef }, f));
            }
          }
          function qa(p) {
            return i.createElement(st.Consumer, null, (f) => f.nativeScrollbars ? i.createElement("div", { style: { overflow: "auto", overscrollBehavior: "contain", msOverflowStyle: "-ms-autohiding-scrollbar" } }, p.children) : i.createElement(Ni, ((h, w) => {
              for (var P in w || (w = {})) ds.call(w, P) && zl(h, P, w[P]);
              if (Tf) for (var P of Tf(w)) eo.call(w, P) && zl(h, P, w[P]);
              return h;
            })({}, p), p.children));
          }
          const Ul = K(({ className: p, style: f }) => i.createElement("svg", { className: p, style: f, xmlns: "http://www.w3.org/2000/svg", width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, i.createElement("polyline", { points: "6 9 12 15 18 9" })))`
  position: absolute;
  pointer-events: none;
  z-index: 1;
  top: 50%;
  -webkit-transform: translateY(-50%);
  -ms-transform: translateY(-50%);
  transform: translateY(-50%);
  right: 8px;
  margin: auto;
  text-align: center;
  polyline {
    color: ${(p) => p.variant === "dark" && "white"};
  }
`, Vo = i.memo((p) => {
            const { options: f, onChange: h, placeholder: w, value: P = "", variant: L, className: z } = p;
            return i.createElement("div", { className: z }, i.createElement(Ul, { variant: L }), i.createElement("select", { onChange: (ee) => {
              const { selectedIndex: ue } = ee.target;
              h(f[w ? ue - 1 : ue]);
            }, value: P, className: "dropdown-select" }, w && i.createElement("option", { disabled: !0, hidden: !0, value: w }, w), f.map(({ idx: ee, value: ue, title: pe }, xe) => i.createElement("option", { key: ee || ue + xe, value: ue }, pe || ue))), i.createElement("label", null, P));
          }), za = Z()(Vo)`
  label {
    box-sizing: border-box;
    min-width: 100px;
    outline: none;
    display: inline-block;
    font-family: ${(p) => p.theme.typography.headings.fontFamily};
    color: ${({ theme: p }) => p.colors.text.primary};
    vertical-align: bottom;
    width: ${({ fullWidth: p }) => p ? "100%" : "auto"};
    text-transform: none;
    padding: 0 22px 0 4px;

    font-size: 0.929em;
    line-height: 1.5em;
    font-family: inherit;
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
  }
  .dropdown-select {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
    border: none;
    appearance: none;
    cursor: pointer;

    color: ${({ theme: p }) => p.colors.text.primary};
    line-height: inherit;
    font-family: inherit;
  }
  box-sizing: border-box;
  min-width: 100px;
  outline: none;
  display: inline-block;
  border-radius: 2px;
  border: 1px solid rgba(38, 50, 56, 0.5);
  vertical-align: bottom;
  padding: 2px 0px 2px 6px;
  position: relative;
  width: auto;
  background: white;
  color: #263238;
  font-family: ${(p) => p.theme.typography.headings.fontFamily};
  font-size: 0.929em;
  line-height: 1.5em;
  cursor: pointer;
  transition: border 0.25s ease, color 0.25s ease, box-shadow 0.25s ease;

  &:hover,
  &:focus-within {
    border: 1px solid ${(p) => p.theme.colors.primary.main};
    color: ${(p) => p.theme.colors.primary.main};
    box-shadow: 0px 0px 0px 1px ${(p) => p.theme.colors.primary.main};
  }
`, Ho = Z()(za)`
  margin-left: 10px;
  text-transform: none;
  font-size: 0.969em;

  font-size: 1em;
  border: none;
  padding: 0 1.2em 0 0;
  background: transparent;

  &:hover,
  &:focus-within {
    border: none;
    box-shadow: none;
    label {
      color: ${(p) => p.theme.colors.primary.main};
      text-shadow: 0px 0px 0px ${(p) => p.theme.colors.primary.main};
    }
  }
`, Cf = Z().span`
  margin-left: 10px;
  text-transform: none;
  font-size: 0.929em;
  color: black;
`;
          var $f = Object.defineProperty, rr = Object.getOwnPropertySymbols, wc = Object.prototype.hasOwnProperty, Rf = Object.prototype.propertyIsEnumerable, Sc = (p, f, h) => f in p ? $f(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h, xc = (p, f) => {
            for (var h in f || (f = {})) wc.call(f, h) && Sc(p, h, f[h]);
            if (rr) for (var h of rr(f)) Rf.call(f, h) && Sc(p, h, f[h]);
            return p;
          };
          function to(p) {
            const { Label: f = Cf, Dropdown: h = Ho } = p;
            return p.options.length === 1 ? i.createElement(f, null, p.options[0].value) : i.createElement(h, xc({}, p));
          }
          var Wo = y4(), ar = o.n(Wo);
          const pr = Pe`
  a {
    text-decoration: ${(p) => p.theme.typography.links.textDecoration};
    color: ${(p) => p.theme.typography.links.color};

    &:visited {
      color: ${(p) => p.theme.typography.links.visited};
    }

    &:hover {
      color: ${(p) => p.theme.typography.links.hover};
      text-decoration: ${(p) => p.theme.typography.links.hoverTextDecoration};
    }
  }
`, nr = K(pn)`
  font-family: ${(p) => p.theme.typography.fontFamily};
  font-weight: ${(p) => p.theme.typography.fontWeightRegular};
  line-height: ${(p) => p.theme.typography.lineHeight};

  p {
    &:last-child {
      margin-bottom: 0;
    }
  }

  ${({ $compact: p }) => p && `
    p:first-child {
      margin-top: 0;
    }
    p:last-child {
      margin-bottom: 0;
    }
  `}

  ${({ $inline: p }) => p && ` p {
    display: inline-block;
  }`}

  h1 {
    ${_n(1)};
    color: ${(p) => p.theme.colors.primary.main};
    margin-top: 0;
  }

  h2 {
    ${_n(2)};
    color: ${(p) => p.theme.colors.text.primary};
  }

  code {
    color: ${({ theme: p }) => p.typography.code.color};
    background-color: ${({ theme: p }) => p.typography.code.backgroundColor};

    font-family: ${(p) => p.theme.typography.code.fontFamily};
    border-radius: 2px;
    border: 1px solid rgba(38, 50, 56, 0.1);
    padding: 0 ${({ theme: p }) => p.spacing.unit}px;
    font-size: ${(p) => p.theme.typography.code.fontSize};
    font-weight: ${({ theme: p }) => p.typography.code.fontWeight};

    word-break: break-word;
  }

  pre {
    font-family: ${(p) => p.theme.typography.code.fontFamily};
    white-space: ${({ theme: p }) => p.typography.code.wrap ? "pre-wrap" : "pre"};
    background-color: ${({ theme: p }) => p.codeBlock.backgroundColor};
    color: white;
    padding: ${(p) => 4 * p.theme.spacing.unit}px;
    overflow-x: auto;
    line-height: normal;
    border-radius: 0;
    border: 1px solid rgba(38, 50, 56, 0.1);

    code {
      background-color: transparent;
      color: white;
      padding: 0;

      &:before,
      &:after {
        content: none;
      }
    }
  }

  blockquote {
    margin: 0;
    margin-bottom: 1em;
    padding: 0 15px;
    color: #777;
    border-left: 4px solid #ddd;
  }

  img {
    max-width: 100%;
    box-sizing: content-box;
  }

  ul,
  ol {
    padding-left: 2em;
    margin: 0;
    margin-bottom: 1em;

    ul,
    ol {
      margin-bottom: 0;
      margin-top: 0;
    }
  }

  table {
    display: block;
    width: 100%;
    overflow: auto;
    word-break: normal;
    word-break: keep-all;
    border-collapse: collapse;
    border-spacing: 0;
    margin-top: 1.5em;
    margin-bottom: 1.5em;
  }

  table tr {
    background-color: #fff;
    border-top: 1px solid #ccc;

    &:nth-child(2n) {
      background-color: ${({ theme: p }) => p.schema.nestedBackground};
    }
  }

  table th,
  table td {
    padding: 6px 13px;
    border: 1px solid #ddd;
  }

  table th {
    text-align: left;
    font-weight: bold;
  }

  ${mc(".share-link")};

  ${pr}

  ${me("Markdown")};
`;
          var _c = Object.defineProperty, Vl = Object.defineProperties, Hl = Object.getOwnPropertyDescriptors, Ec = Object.getOwnPropertySymbols, Fr = Object.prototype.hasOwnProperty, Oc = Object.prototype.propertyIsEnumerable, kc = (p, f, h) => f in p ? _c(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h;
          const If = ar(), ji = Z()(nr)`
  display: inline;
`;
          function On(p) {
            var f = p, { inline: h, compact: w } = f, P = ((z, ee) => {
              var ue = {};
              for (var pe in z) Fr.call(z, pe) && ee.indexOf(pe) < 0 && (ue[pe] = z[pe]);
              if (z != null && Ec) for (var pe of Ec(z)) ee.indexOf(pe) < 0 && Oc.call(z, pe) && (ue[pe] = z[pe]);
              return ue;
            })(f, ["inline", "compact"]);
            const L = h ? ji : nr;
            return i.createElement(Vt, null, (z) => {
              return i.createElement(L, (ee = ((xe, le) => {
                for (var we in le || (le = {})) Fr.call(le, we) && kc(xe, we, le[we]);
                if (Ec) for (var we of Ec(le)) Oc.call(le, we) && kc(xe, we, le[we]);
                return xe;
              })({ className: "redoc-markdown " + (P.className || ""), dangerouslySetInnerHTML: { __html: (ue = z.sanitize, pe = P.html, ue ? If.sanitize(pe) : pe) }, "data-role": P["data-role"] }, P), Vl(ee, Hl({ $inline: h, $compact: w }))));
              var ee, ue, pe;
            });
          }
          class xr extends i.Component {
            render() {
              const { source: f, inline: h, compact: w, className: P, "data-role": L } = this.props, z = new Pi();
              return i.createElement(On, { html: z.renderMd(f), inline: h, compact: w, className: P, "data-role": L });
            }
          }
          const Nf = K.div`
  position: relative;
`, jf = K.div`
  position: absolute;
  min-width: 80px;
  max-width: 500px;
  background: #fff;
  bottom: 100%;
  left: 50%;
  margin-bottom: 10px;
  transform: translateX(-50%);

  border-radius: 4px;
  padding: 0.3em 0.6em;
  text-align: center;
  box-shadow: 0px 0px 5px 0px rgba(204, 204, 204, 1);
`, fm = K.div`
  background: #fff;
  color: #000;
  display: inline;
  font-size: 0.85em;
  white-space: nowrap;
`, dm = K.div`
  position: absolute;
  width: 0;
  height: 0;
  bottom: -5px;
  left: 50%;
  margin-left: -5px;
  border-left: solid transparent 5px;
  border-right: solid transparent 5px;
  border-top: solid #fff 5px;
`, hm = K.div`
  position: absolute;
  width: 100%;
  height: 20px;
  bottom: -20px;
`;
          class mm extends i.Component {
            render() {
              const { open: f, title: h, children: w } = this.props;
              return i.createElement(Nf, null, w, f && i.createElement(jf, null, i.createElement(fm, null, h), i.createElement(dm, null), i.createElement(hm, null)));
            }
          }
          const gm = typeof document < "u" && document.queryCommandSupported && document.queryCommandSupported("copy");
          class Li {
            static isSupported() {
              return gm;
            }
            static selectElement(f) {
              let h, w;
              document.body.createTextRange ? (h = document.body.createTextRange(), h.moveToElementText(f), h.select()) : document.createRange && window.getSelection && (w = window.getSelection(), h = document.createRange(), h.selectNodeContents(f), w.removeAllRanges(), w.addRange(h));
            }
            static deselect() {
              if (document.selection) document.selection.empty();
              else if (window.getSelection) {
                const f = window.getSelection();
                f && f.removeAllRanges();
              }
            }
            static copySelected() {
              let f;
              try {
                f = document.execCommand("copy");
              } catch {
                f = !1;
              }
              return f;
            }
            static copyElement(f) {
              Li.selectElement(f);
              const h = Li.copySelected();
              return h && Li.deselect(), h;
            }
            static copyCustom(f) {
              const h = document.createElement("textarea");
              h.style.position = "fixed", h.style.top = "0", h.style.left = "0", h.style.width = "2em", h.style.height = "2em", h.style.padding = "0", h.style.border = "none", h.style.outline = "none", h.style.boxShadow = "none", h.style.background = "transparent", h.value = f, document.body.appendChild(h), h.select();
              const w = Li.copySelected();
              return document.body.removeChild(h), w;
            }
          }
          const Lf = (p) => {
            const [f, h] = i.useState(!1), w = () => {
              const L = typeof p.data == "string" ? p.data : JSON.stringify(p.data, null, 2);
              Li.copyCustom(L), P();
            }, P = () => {
              h(!0), setTimeout(() => {
                h(!1);
              }, 1500);
            };
            return p.children({ renderCopyButton: () => i.createElement("button", { onClick: w }, i.createElement(mm, { title: Li.isSupported() ? "Copied" : "Not supported in your browser", open: f }, "Copy")) });
          };
          let Mi = 1;
          function Wl(p, f) {
            Mi = 1;
            let h = "";
            return h += '<div class="redoc-json">', h += "<code>", h += Ql(p, f), h += "</code>", h += "</div>", h;
          }
          function Ac(p) {
            return p !== void 0 ? p.toString().replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;") : "";
          }
          function Kl(p) {
            return JSON.stringify(p).slice(1, -1);
          }
          function Di(p, f) {
            return '<span class="' + f + '">' + Ac(p) + "</span>";
          }
          function ro(p) {
            return '<span class="token punctuation">' + p + "</span>";
          }
          function Ql(p, f) {
            const h = typeof p;
            let w = "";
            return p == null ? w += Di("null", "token keyword") : p && p.constructor === Array ? (Mi++, w += function(P, L) {
              const z = Mi > L ? "collapsed" : "";
              let ee = `<button class="collapser" aria-label="${Mi > L + 1 ? "expand" : "collapse"}"></button>${ro("[")}<span class="ellipsis"></span><ul class="array collapsible">`, ue = !1;
              const pe = P.length;
              for (let xe = 0; xe < pe; xe++) ue = !0, ee += '<li><div class="hoverable ' + z + '">', ee += Ql(P[xe], L), xe < pe - 1 && (ee += ","), ee += "</div></li>";
              return ee += `</ul>${ro("]")}`, ue || (ee = ro("[ ]")), ee;
            }(p, f), Mi--) : p && p.constructor === Date ? w += Di('"' + p.toISOString() + '"', "token string") : h === "object" ? (Mi++, w += function(P, L) {
              const z = Mi > L ? "collapsed" : "", ee = Object.keys(P), ue = ee.length;
              let pe = `<button class="collapser" aria-label="${Mi > L + 1 ? "expand" : "collapse"}"></button>${ro("{")}<span class="ellipsis"></span><ul class="obj collapsible">`, xe = !1;
              for (let le = 0; le < ue; le++) {
                const we = ee[le];
                xe = !0, pe += '<li><div class="hoverable ' + z + '">', pe += '<span class="property token string">"' + Ac(we) + '"</span>: ', pe += Ql(P[we], L), le < ue - 1 && (pe += ro(",")), pe += "</div></li>";
              }
              return pe += `</ul>${ro("}")}`, xe || (pe = ro("{ }")), pe;
            }(p, f), Mi--) : h === "number" ? w += Di(p, "token number") : h === "string" ? /^(http|https):\/\/[^\s]+$/.test(p) ? w += Di('"', "token string") + '<a href="' + encodeURI(p) + '">' + Ac(Kl(p)) + "</a>" + Di('"', "token string") : w += Di('"' + Kl(p) + '"', "token string") : h === "boolean" && (w += Di(p, "token boolean")), w;
          }
          const ym = Pe`
  .redoc-json code > .collapser {
    display: none;
    pointer-events: none;
  }

  font-family: ${(p) => p.theme.typography.code.fontFamily};
  font-size: ${(p) => p.theme.typography.code.fontSize};

  white-space: ${({ theme: p }) => p.typography.code.wrap ? "pre-wrap" : "pre"};
  contain: content;
  overflow-x: auto;

  .callback-function {
    color: gray;
  }

  .collapser:after {
    content: '-';
    cursor: pointer;
  }

  .collapsed > .collapser:after {
    content: '+';
    cursor: pointer;
  }

  .ellipsis:after {
    content: ' … ';
  }

  .collapsible {
    margin-left: 2em;
  }

  .hoverable {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 2px;
    padding-right: 2px;
    border-radius: 2px;
  }

  .hovered {
    background-color: rgba(235, 238, 249, 1);
  }

  .collapser {
    background-color: transparent;
    border: 0;
    color: #fff;
    font-family: ${(p) => p.theme.typography.code.fontFamily};
    font-size: ${(p) => p.theme.typography.code.fontSize};
    padding-right: 6px;
    padding-left: 6px;
    padding-top: 0;
    padding-bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 15px;
    height: 15px;
    position: absolute;
    top: 4px;
    left: -1.5em;
    cursor: default;
    user-select: none;
    -webkit-user-select: none;
    padding: 2px;
    &:focus {
      outline-color: #fff;
      outline-style: dotted;
      outline-width: 1px;
    }
  }

  ul {
    list-style-type: none;
    padding: 0px;
    margin: 0px 0px 0px 26px;
  }

  li {
    position: relative;
    display: block;
  }

  .hoverable {
    display: inline-block;
  }

  .selected {
    outline-style: solid;
    outline-width: 1px;
    outline-style: dotted;
  }

  .collapsed > .collapsible {
    display: none;
  }

  .ellipsis {
    display: none;
  }

  .collapsed > .ellipsis {
    display: inherit;
  }
`, vm = K.div`
  &:hover > ${Ri} {
    opacity: 1;
  }
`, Mf = K((p) => {
            const [f, h] = i.useState(), w = ({ renderCopyButton: pe }) => {
              const xe = p.data && Object.values(p.data).some((le) => typeof le == "object" && le !== null);
              return i.createElement(vm, null, i.createElement(Ri, null, pe(), xe && i.createElement(i.Fragment, null, i.createElement("button", { onClick: P }, " Expand all "), i.createElement("button", { onClick: L }, " Collapse all "))), i.createElement(st.Consumer, null, (le) => i.createElement(pn, { tabIndex: 0, className: p.className, ref: (we) => h(we), dangerouslySetInnerHTML: { __html: Wl(p.data, le.jsonSamplesExpandLevel) } })));
            }, P = () => {
              const pe = f == null ? void 0 : f.getElementsByClassName("collapsible");
              for (const xe of Array.prototype.slice.call(pe)) {
                const le = xe.parentNode;
                le.classList.remove("collapsed"), le.querySelector(".collapser").setAttribute("aria-label", "collapse");
              }
            }, L = () => {
              const pe = f == null ? void 0 : f.getElementsByClassName("collapsible"), xe = Array.prototype.slice.call(pe, 1);
              for (const le of xe) {
                const we = le.parentNode;
                we.classList.add("collapsed"), we.querySelector(".collapser").setAttribute("aria-label", "expand");
              }
            }, z = (pe) => {
              let xe;
              pe.className === "collapser" && (xe = pe.parentElement.getElementsByClassName("collapsible")[0], xe.parentElement.classList.contains("collapsed") ? (xe.parentElement.classList.remove("collapsed"), pe.setAttribute("aria-label", "collapse")) : (xe.parentElement.classList.add("collapsed"), pe.setAttribute("aria-label", "expand")));
            }, ee = i.useCallback((pe) => {
              z(pe.target);
            }, []), ue = i.useCallback((pe) => {
              pe.key === "Enter" && z(pe.target);
            }, []);
            return i.useEffect(() => (f == null || f.addEventListener("click", ee), f == null || f.addEventListener("focus", ue), () => {
              f == null || f.removeEventListener("click", ee), f == null || f.removeEventListener("focus", ue);
            }), [ee, ue, f]), i.createElement(Lf, { data: p.data }, w);
          })`
  ${ym};
`, Df = (p) => {
            const { source: f, lang: h } = p;
            return i.createElement(Af, { dangerouslySetInnerHTML: { __html: Sa(f, h) } });
          }, Yl = (p) => {
            const { source: f, lang: h } = p;
            return i.createElement(Lf, { data: f }, ({ renderCopyButton: w }) => i.createElement(kf, null, i.createElement(Ri, null, w()), i.createElement(Df, { lang: h, source: f })));
          };
          function Ff({ value: p, mimeType: f }) {
            return es(f) ? i.createElement(Mf, { data: p }) : (typeof p == "object" && (p = JSON.stringify(p, null, 2)), i.createElement(Yl, { lang: jn(f), source: p }));
          }
          var bm = (p, f, h) => new Promise((w, P) => {
            var L = (ue) => {
              try {
                ee(h.next(ue));
              } catch (pe) {
                P(pe);
              }
            }, z = (ue) => {
              try {
                ee(h.throw(ue));
              } catch (pe) {
                P(pe);
              }
            }, ee = (ue) => ue.done ? w(ue.value) : Promise.resolve(ue.value).then(L, z);
            ee((h = h.apply(p, f)).next());
          });
          function Pc({ example: p, mimeType: f }) {
            return p.value === void 0 && p.externalValueUrl ? i.createElement(wm, { example: p, mimeType: f }) : i.createElement(Ff, { value: p.value, mimeType: f });
          }
          function wm({ example: p, mimeType: f }) {
            const h = function(w, P) {
              const [, L] = (0, i.useState)(!0), z = (0, i.useRef)(void 0), ee = (0, i.useRef)(void 0);
              return ee.current !== w && (z.current = void 0), ee.current = w, (0, i.useEffect)(() => {
                bm(this, null, function* () {
                  L(!0);
                  try {
                    z.current = yield w.getExternalValue(P);
                  } catch (ue) {
                    z.current = ue;
                  }
                  L(!1);
                });
              }, [w, P]), z.current;
            }(p, f);
            return h === void 0 ? i.createElement("span", null, "Loading...") : h instanceof Error ? i.createElement(Af, null, "Error loading external example: ", i.createElement("br", null), i.createElement("a", { className: "token string", href: p.externalValueUrl, target: "_blank", rel: "noopener noreferrer" }, p.externalValueUrl)) : i.createElement(Ff, { value: h, mimeType: f });
          }
          const Tc = K.div`
  padding: 0.9em;
  background-color: ${({ theme: p }) => (0, u.transparentize)(0.6, p.rightPanel.backgroundColor)};
  margin: 0 0 10px 0;
  display: block;
  font-family: ${({ theme: p }) => p.typography.headings.fontFamily};
  font-size: 0.929em;
  line-height: 1.5em;
`, Cc = K.span`
  font-family: ${({ theme: p }) => p.typography.headings.fontFamily};
  font-size: 12px;
  position: absolute;
  z-index: 1;
  top: -11px;
  left: 12px;
  font-weight: ${({ theme: p }) => p.typography.fontWeightBold};
  color: ${({ theme: p }) => (0, u.transparentize)(0.3, p.rightPanel.textColor)};
`, $c = K.div`
  position: relative;
`, Gl = K(za)`
  label {
    color: ${({ theme: p }) => p.rightPanel.textColor};
    text-overflow: ellipsis;
    white-space: nowrap;
    overflow: hidden;
    font-size: 1em;
    text-transform: none;
    border: none;
  }
  margin: 0 0 10px 0;
  display: block;
  background-color: ${({ theme: p }) => (0, u.transparentize)(0.6, p.rightPanel.backgroundColor)};
  border: none;
  padding: 0.9em 1.6em 0.9em 0.9em;
  box-shadow: none;
  &:hover,
  &:focus-within {
    border: none;
    box-shadow: none;
    background-color: ${({ theme: p }) => (0, u.transparentize)(0.3, p.rightPanel.backgroundColor)};
  }
`, qf = K.div`
  font-family: ${(p) => p.theme.typography.code.fontFamily};
  font-size: 12px;
  color: #ee807f;
`;
          class zf extends i.Component {
            constructor() {
              super(...arguments), this.state = { activeIdx: 0 }, this.switchMedia = ({ idx: f }) => {
                f !== void 0 && this.setState({ activeIdx: f });
              };
            }
            render() {
              const { activeIdx: f } = this.state, h = this.props.mediaType.examples || {}, w = this.props.mediaType.name, P = i.createElement(qf, null, "No sample"), L = Object.keys(h);
              if (L.length === 0) return P;
              if (L.length > 1) {
                const z = L.map((pe, xe) => ({ value: h[pe].summary || pe, idx: xe })), ee = h[L[f]], ue = ee.description;
                return i.createElement(Xl, null, i.createElement($c, null, i.createElement(Cc, null, "Example"), this.props.renderDropdown({ value: z[f].value, options: z, onChange: this.switchMedia, ariaLabel: "Example" })), i.createElement("div", null, ue && i.createElement(xr, { source: ue }), i.createElement(Pc, { example: ee, mimeType: w })));
              }
              {
                const z = h[L[0]];
                return i.createElement(Xl, null, z.description && i.createElement(xr, { source: z.description }), i.createElement(Pc, { example: z, mimeType: w }));
              }
            }
          }
          const Xl = K.div`
  margin-top: 15px;
`;
          var zt = oV;
          const Rb = K(xf)`
  &.deprecated {
    span.property-name {
      ${La}
    }
  }

  button {
    background-color: transparent;
    border: 0;
    outline: 0;
    font-size: 13px;
    font-family: ${(p) => p.theme.typography.code.fontFamily};
    cursor: pointer;
    padding: 0;
    color: ${(p) => p.theme.colors.text.primary};
    &:focus {
      font-weight: ${({ theme: p }) => p.typography.fontWeightBold};
    }
    ${({ kind: p }) => p === "patternProperties" && Pe`
        display: inline-flex;
        margin-right: 20px;

        > span.property-name {
          white-space: break-spaces;
          text-align: left;

          ::before,
          ::after {
            content: '/';
            filter: opacity(0.2);
          }
        }

        > svg {
          align-self: center;
        }
      `}
  }
  ${$i} {
    height: ${({ theme: p }) => p.schema.arrow.size};
    width: ${({ theme: p }) => p.schema.arrow.size};
    polygon {
      fill: ${({ theme: p }) => p.schema.arrow.color};
    }
  }
`, kn = K.span`
  vertical-align: middle;
  font-size: ${({ theme: p }) => p.typography.code.fontSize};
  line-height: 20px;
`, Hn = K(kn)`
  color: ${(p) => (0, u.transparentize)(0.1, p.theme.schema.typeNameColor)};
`, Ba = K(kn)`
  color: ${(p) => p.theme.schema.typeNameColor};
`, Jl = K(kn)`
  color: ${(p) => p.theme.schema.typeTitleColor};
  word-break: break-word;
`, Zl = Ba, Rc = K(kn).attrs({ as: "div" })`
  color: ${(p) => p.theme.schema.requireLabelColor};
  font-size: ${(p) => p.theme.schema.labelsTextSize};
  font-weight: normal;
  margin-left: 20px;
  line-height: 1;
`, Bf = K(Rc)`
  color: ${(p) => p.theme.colors.primary.light};
`, Ic = K(kn)`
  color: ${({ theme: p }) => p.colors.warning.main};
  font-size: 13px;
`, Ua = K(kn)`
  color: #0e7c86;
  font-family: ${(p) => p.theme.typography.code.fontFamily};
  font-size: 12px;
  &::before,
  &::after {
    content: ' ';
  }
`, Ko = K(kn)`
  border-radius: 2px;
  word-break: break-word;
  ${({ theme: p }) => `
    background-color: ${(0, u.transparentize)(0.95, p.colors.text.primary)};
    color: ${(0, u.transparentize)(0.1, p.colors.text.primary)};

    padding: 0 ${p.spacing.unit}px;
    border: 1px solid ${(0, u.transparentize)(0.9, p.colors.text.primary)};
    font-family: ${p.typography.code.fontFamily};
}`};
  & + & {
    margin-left: 0;
  }
  ${me("ExampleValue")};
`, Uf = K(Ko)``, Ib = K(kn)`
  border-radius: 2px;
  ${({ theme: p }) => `
    background-color: ${(0, u.transparentize)(0.95, p.colors.primary.light)};
    color: ${(0, u.transparentize)(0.1, p.colors.primary.main)};

    margin: 0 ${p.spacing.unit}px;
    padding: 0 ${p.spacing.unit}px;
    border: 1px solid ${(0, u.transparentize)(0.9, p.colors.primary.main)};
}`};
  & + & {
    margin-left: 0;
  }
  ${me("ConstraintItem")};
`, Sm = K.button`
  background-color: transparent;
  border: 0;
  color: ${({ theme: p }) => p.colors.text.secondary};
  margin-left: ${({ theme: p }) => p.spacing.unit}px;
  border-radius: 2px;
  cursor: pointer;
  outline-color: ${({ theme: p }) => p.colors.text.secondary};
  font-size: 12px;
`, xm = K.div`
  ${pr};
  ${({ $compact: p }) => p ? "" : "margin: 1em 0"}
`;
          let no = class extends i.Component {
            render() {
              const { externalDocs: p } = this.props;
              return p && p.url ? i.createElement(xm, { $compact: this.props.compact }, i.createElement("a", { href: p.url }, p.description || p.url)) : null;
            }
          };
          no = ((p, f) => {
            for (var h, w = f, P = p.length - 1; P >= 0; P--) (h = p[P]) && (w = h(w) || w);
            return w;
          })([zt.observer], no);
          const _m = K(nr)`
  table {
    margin-bottom: 0.2em;
  }
`;
          class Vf extends i.PureComponent {
            constructor(f) {
              super(f), this.state = { collapsed: !0 }, this.toggle = this.toggle.bind(this);
            }
            toggle() {
              this.setState({ collapsed: !this.state.collapsed });
            }
            render() {
              const { values: f, type: h } = this.props, { collapsed: w } = this.state, P = !Array.isArray(f), L = Array.isArray(f) && f || Object.entries(f || {}).map(([le, we]) => ({ value: le, description: we })), { enumSkipQuotes: z, maxDisplayedEnumValues: ee } = this.context;
              if (!L.length) return null;
              const ue = this.state.collapsed && ee ? L.slice(0, ee) : L, pe = !!ee && L.length > ee, xe = ee ? w ? `… ${L.length - ee} more` : "Hide" : "";
              return i.createElement("div", null, P ? i.createElement(i.Fragment, null, i.createElement(_m, null, i.createElement("table", null, i.createElement("thead", null, i.createElement("tr", null, i.createElement("th", null, i.createElement(kn, null, h === "array" ? F("enumArray") : "", " ", L.length === 1 ? F("enumSingleValue") : F("enum")), " "), i.createElement("th", null, i.createElement("strong", null, "Description")))), i.createElement("tbody", null, ue.map(({ description: le, value: we }) => i.createElement("tr", { key: we }, i.createElement("td", null, we), i.createElement("td", null, i.createElement(xr, { source: le, compact: !0, inline: !0 }))))))), pe ? i.createElement(Em, { onClick: this.toggle }, xe) : null) : i.createElement(i.Fragment, null, i.createElement(kn, null, h === "array" ? F("enumArray") : "", " ", f.length === 1 ? F("enumSingleValue") : F("enum"), ":"), " ", ue.map((le, we) => {
                const Ve = z ? String(le) : JSON.stringify(le);
                return i.createElement(i.Fragment, { key: we }, i.createElement(Ko, null, Ve), " ");
              }), pe ? i.createElement(Em, { onClick: this.toggle }, xe) : null));
            }
          }
          Vf.contextType = st;
          const Em = K.span`
  color: ${(p) => p.theme.colors.primary.main};
  vertical-align: middle;
  font-size: 13px;
  line-height: 20px;
  padding: 0 5px;
  cursor: pointer;
`, fn = K(nr)`
  margin: 2px 0;
`;
          class Cr extends i.PureComponent {
            render() {
              const f = this.props.extensions;
              return i.createElement(st.Consumer, null, (h) => i.createElement(i.Fragment, null, h.showExtensions && Object.keys(f).map((w) => i.createElement(fn, { key: w }, i.createElement(kn, null, " ", w.substring(2), ": "), " ", i.createElement(Uf, null, typeof f[w] == "string" ? f[w] : JSON.stringify(f[w]))))));
            }
          }
          function Om({ field: p }) {
            return p.examples ? i.createElement(i.Fragment, null, i.createElement(kn, null, " ", F("examples"), ": "), ce(p.examples) ? p.examples.map((f, h) => {
              const w = bi(p, f), P = p.in ? String(w) : JSON.stringify(w);
              return i.createElement(i.Fragment, { key: h }, i.createElement(Ko, null, P), " ");
            }) : i.createElement(km, null, Object.values(p.examples).map((f, h) => i.createElement("li", { key: h + f.value }, i.createElement(Ko, null, bi(p, f.value)), " -", " ", f.summary || f.description)))) : null;
          }
          const km = K.ul`
  margin-top: 1em;
  list-style-position: outside;
`;
          class Va extends i.PureComponent {
            render() {
              return this.props.constraints.length === 0 ? null : i.createElement("span", null, " ", this.props.constraints.map((f) => i.createElement(Ib, { key: f }, " ", f, " ")));
            }
          }
          const Nc = i.memo(function({ value: p, label: f, raw: h }) {
            if (p === void 0) return null;
            const w = h ? String(p) : JSON.stringify(p);
            return i.createElement("div", null, i.createElement(kn, null, " ", f, " "), " ", i.createElement(Ko, null, w));
          }), jc = 45;
          function Lc(p) {
            const f = p.schema.pattern, { hideSchemaPattern: h } = i.useContext(st), [w, P] = i.useState(!1), L = i.useCallback(() => P(!w), [w]);
            return !f || h ? null : i.createElement(i.Fragment, null, i.createElement(Ua, null, w || f.length < jc ? f : `${f.substr(0, jc)}...`), f.length > jc && i.createElement(Sm, { onClick: L }, w ? "Hide pattern" : "Show pattern"));
          }
          function Hf({ schema: p }) {
            var f;
            const { hideSchemaPattern: h } = i.useContext(st);
            return p && (p != null && p.pattern && !h || p.items || p.displayFormat || (f = p.constraints) != null && f.length) ? i.createElement(Wf, null, "[ items", p.displayFormat && i.createElement(Zl, null, " <", p.displayFormat, " >"), i.createElement(Va, { constraints: p.constraints }), i.createElement(Lc, { schema: p }), p.items && i.createElement(Hf, { schema: p.items }), " ]") : null;
          }
          const Wf = K(Hn)`
  margin: 0 5px;
  vertical-align: text-top;
`;
          var Am = Object.defineProperty, Kf = Object.getOwnPropertySymbols, Qf = Object.prototype.hasOwnProperty, Yf = Object.prototype.propertyIsEnumerable, Gf = (p, f, h) => f in p ? Am(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h, Mc = (p, f) => {
            for (var h in f || (f = {})) Qf.call(f, h) && Gf(p, h, f[h]);
            if (Kf) for (var h of Kf(f)) Yf.call(f, h) && Gf(p, h, f[h]);
            return p;
          };
          const Dc = (0, zt.observer)((p) => {
            const { enumSkipQuotes: f, hideSchemaTitles: h } = i.useContext(st), { showExamples: w, field: P, renderDiscriminatorSwitch: L } = p, { schema: z, description: ee, deprecated: ue, extensions: pe, in: xe, const: le } = P, we = z.type === "array" || ce(z.type) && z.type.includes("array"), Ve = f || xe === "header", it = i.useMemo(() => !w || P.example === void 0 && P.examples === void 0 ? null : P.examples !== void 0 ? i.createElement(Om, { field: P }) : i.createElement(Nc, { label: F("example") + ":", value: bi(P, P.example), raw: !!P.in }), [P, w]), _t = j(z.default) && P.in ? bi(P, z.default).replace(`${P.name}=`, "") : z.default;
            return i.createElement("div", null, i.createElement("div", null, i.createElement(Hn, null, z.typePrefix), i.createElement(Ba, null, z.displayType), z.displayFormat && i.createElement(Zl, null, " ", "<", z.displayFormat, ">", " "), z.contentEncoding && i.createElement(Zl, null, " ", "<", z.contentEncoding, ">", " "), z.contentMediaType && i.createElement(Zl, null, " ", "<", z.contentMediaType, ">", " "), z.title && !h && i.createElement(Jl, null, " (", z.title, ") "), i.createElement(Va, { constraints: z.constraints }), i.createElement(Lc, { schema: z }), z.isCircular && i.createElement(Ic, null, " ", F("recursive"), " "), we && z.items && i.createElement(Hf, { schema: z.items })), ue && i.createElement("div", null, i.createElement(Un, { type: "warning" }, " ", F("deprecated"), " ")), i.createElement(Nc, { raw: Ve, label: F("default") + ":", value: _t }), !L && i.createElement(Vf, { type: z.type, values: z["x-enumDescriptions"] || z.enum }), " ", it, i.createElement(Cr, { extensions: Mc(Mc({}, pe), z.extensions) }), i.createElement("div", null, i.createElement(xr, { compact: !0, source: ee })), z.externalDocs && i.createElement(no, { externalDocs: z.externalDocs, compact: !0 }), L && L(p) || null, le && i.createElement(Nc, { label: F("const") + ":", value: le }) || null);
          }), Pm = i.memo(Dc);
          var Tm = Object.defineProperty, Fc = Object.getOwnPropertySymbols, Cm = Object.prototype.hasOwnProperty, qc = Object.prototype.propertyIsEnumerable, Fi = (p, f, h) => f in p ? Tm(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h;
          let Ha = class extends i.Component {
            constructor() {
              super(...arguments), this.toggle = () => {
                this.props.field.expanded === void 0 && this.props.expandByDefault ? this.props.field.collapse() : this.props.field.toggle();
              }, this.handleKeyPress = (p) => {
                p.key === "Enter" && (p.preventDefault(), this.toggle());
              };
            }
            render() {
              const { hidePropertiesPrefix: p } = this.context, { className: f = "", field: h, isLast: w, expandByDefault: P, fieldParentsName: L = [] } = this.props, { name: z, deprecated: ee, required: ue, kind: pe } = h, xe = !h.schema.isPrimitive && !h.schema.isCircular, le = h.expanded === void 0 ? P : h.expanded, we = i.createElement(i.Fragment, null, pe === "additionalProperties" && i.createElement(Bf, null, "additional property"), pe === "patternProperties" && i.createElement(Bf, null, "pattern property"), ue && i.createElement(Rc, null, "required")), Ve = xe ? i.createElement(Rb, { className: ee ? "deprecated" : "", kind: pe, title: z }, i.createElement(Uo, null), i.createElement("button", { onClick: this.toggle, onKeyPress: this.handleKeyPress, "aria-label": `expand ${z}` }, !p && L.map((it) => it + ".​"), i.createElement("span", { className: "property-name" }, z), i.createElement($i, { direction: le ? "down" : "right" })), we) : i.createElement(xf, { className: ee ? "deprecated" : void 0, kind: pe, title: z }, i.createElement(Uo, null), !p && L.map((it) => it + ".​"), i.createElement("span", { className: "property-name" }, z), we);
              return i.createElement(i.Fragment, null, i.createElement("tr", { className: w ? "last " + f : f }, Ve, i.createElement(um, null, i.createElement(Pm, ((it, _t) => {
                for (var Et in _t || (_t = {})) Cm.call(_t, Et) && Fi(it, Et, _t[Et]);
                if (Fc) for (var Et of Fc(_t)) qc.call(_t, Et) && Fi(it, Et, _t[Et]);
                return it;
              })({}, this.props)))), le && xe && i.createElement("tr", { key: h.name + "inner" }, i.createElement(vc, { colSpan: 2 }, i.createElement(or, null, i.createElement(qi, { schema: h.schema, fieldParentsName: [...L || [], h.name], skipReadOnly: this.props.skipReadOnly, skipWriteOnly: this.props.skipWriteOnly, showTitle: this.props.showTitle, level: this.props.level })))));
            }
          };
          Ha.contextType = st, Ha = ((p, f) => {
            for (var h, w = f, P = p.length - 1; P >= 0; P--) (h = p[P]) && (w = h(w) || w);
            return w;
          })([zt.observer], Ha);
          let eu = class extends i.Component {
            constructor() {
              super(...arguments), this.changeActiveChild = (p) => {
                p.idx !== void 0 && this.props.parent.activateOneOf(p.idx);
              };
            }
            sortOptions(p, f) {
              if (f.length === 0) return;
              const h = {};
              f.forEach((w, P) => {
                h[w] = P;
              }), p.sort((w, P) => h[w.value] > h[P.value] ? 1 : -1);
            }
            render() {
              const { parent: p, enumValues: f } = this.props;
              if (p.oneOf === void 0) return null;
              const h = p.oneOf.map((P, L) => ({ value: P.title, idx: L })), w = h[p.activeOneOf].value;
              return this.sortOptions(h, f), i.createElement(za, { value: w, options: h, onChange: this.changeActiveChild, ariaLabel: "Example" });
            }
          };
          eu = ((p, f) => {
            for (var h, w = f, P = p.length - 1; P >= 0; P--) (h = p[P]) && (w = h(w) || w);
            return w;
          })([zt.observer], eu);
          const Wa = (0, zt.observer)(({ schema: { fields: p = [], title: f }, showTitle: h, discriminator: w, skipReadOnly: P, skipWriteOnly: L, level: z, fieldParentsName: ee }) => {
            const { expandSingleSchemaField: ue, showObjectSchemaExamples: pe, schemasExpansionLevel: xe } = i.useContext(st), le = i.useMemo(() => P || L ? p.filter((Ve) => !(P && Ve.schema.readOnly || L && Ve.schema.writeOnly)) : p, [P, L, p]), we = ue && le.length === 1 || xe >= z;
            return i.createElement(Da, null, h && i.createElement($b, null, f), i.createElement("tbody", null, x(le, (Ve, it) => i.createElement(Ha, { key: Ve.name, isLast: it, field: Ve, expandByDefault: we, fieldParentsName: Number(z) > 1 ? ee : [], renderDiscriminatorSwitch: (w == null ? void 0 : w.fieldName) === Ve.name ? () => i.createElement(eu, { parent: w.parentSchema, enumValues: Ve.schema.enum }) : void 0, className: Ve.expanded ? "expanded" : void 0, showExamples: pe, skipReadOnly: P, skipWriteOnly: L, showTitle: h, level: z }))));
          });
          var $m = Object.defineProperty, Rm = Object.defineProperties, tu = Object.getOwnPropertyDescriptors, qr = Object.getOwnPropertySymbols, Nb = Object.prototype.hasOwnProperty, jb = Object.prototype.propertyIsEnumerable, ru = (p, f, h) => f in p ? $m(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h, zr = (p, f) => {
            for (var h in f || (f = {})) Nb.call(f, h) && ru(p, h, f[h]);
            if (qr) for (var h of qr(f)) jb.call(f, h) && ru(p, h, f[h]);
            return p;
          }, Im = (p, f) => Rm(p, tu(f));
          const nt = K.div`
  padding-left: ${({ theme: p }) => 2 * p.spacing.unit}px;
`;
          class Qo extends i.PureComponent {
            render() {
              const f = this.props.schema, h = f.items, w = this.props.fieldParentsName, P = f.minItems === void 0 && f.maxItems === void 0 ? "" : `(${Mr(f)})`, L = w && [...w.slice(0, -1), w[w.length - 1] + "[]"];
              return f.fields ? i.createElement(Wa, Im(zr({}, this.props), { level: this.props.level, fieldParentsName: L })) : !f.displayType || h || P.length ? i.createElement("div", null, i.createElement(Ef, null, " Array ", P), i.createElement(nt, null, i.createElement(qi, Im(zr({}, this.props), { schema: h, fieldParentsName: L }))), i.createElement(Of, null)) : i.createElement("div", null, i.createElement(Ba, null, f.displayType));
            }
          }
          var Xf = Object.defineProperty, Nm = Object.defineProperties, Lb = Object.getOwnPropertyDescriptors, Ka = Object.getOwnPropertySymbols, zc = Object.prototype.hasOwnProperty, Jf = Object.prototype.propertyIsEnumerable, Zf = (p, f, h) => f in p ? Xf(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h, ed = (p, f, h, w) => {
            for (var P, L = f, z = p.length - 1; z >= 0; z--) (P = p[z]) && (L = P(L) || L);
            return L;
          };
          let nu = class extends i.Component {
            constructor() {
              super(...arguments), this.activateOneOf = () => {
                this.props.schema.activateOneOf(this.props.idx);
              };
            }
            render() {
              const { idx: p, schema: f, subSchema: h } = this.props;
              return i.createElement(_f, { $deprecated: h.deprecated, $active: p === f.activeOneOf, onClick: this.activateOneOf }, h.title || h.typePrefix + h.displayType);
            }
          };
          nu = ed([zt.observer], nu);
          let Qa = class extends i.Component {
            render() {
              const { schema: { oneOf: p }, schema: f } = this.props;
              if (p === void 0) return null;
              const h = p[f.activeOneOf];
              return i.createElement("div", null, i.createElement(Fa, null, " ", f.oneOfType, " "), i.createElement(bc, null, p.map((P, L) => i.createElement(nu, { key: P.pointer, schema: f, subSchema: P, idx: L }))), i.createElement("div", null, p[f.activeOneOf].deprecated && i.createElement(Un, { type: "warning" }, "Deprecated")), i.createElement(Va, { constraints: h.constraints }), i.createElement(qi, (w = ((P, L) => {
                for (var z in L || (L = {})) zc.call(L, z) && Zf(P, z, L[z]);
                if (Ka) for (var z of Ka(L)) Jf.call(L, z) && Zf(P, z, L[z]);
                return P;
              })({}, this.props), Nm(w, Lb({ schema: h })))));
              var w;
            }
          };
          Qa = ed([zt.observer], Qa);
          const Bc = (0, zt.observer)(({ schema: p }) => i.createElement("div", null, i.createElement(Ba, null, p.displayType), p.title && i.createElement(Jl, null, " ", p.title, " "), i.createElement(Ic, null, " ", F("recursive"), " ")));
          var Br = Object.defineProperty, ci = Object.defineProperties, io = Object.getOwnPropertyDescriptors, iu = Object.getOwnPropertySymbols, td = Object.prototype.hasOwnProperty, Wn = Object.prototype.propertyIsEnumerable, rd = (p, f, h) => f in p ? Br(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h, An = (p, f) => {
            for (var h in f || (f = {})) td.call(f, h) && rd(p, h, f[h]);
            if (iu) for (var h of iu(f)) Wn.call(f, h) && rd(p, h, f[h]);
            return p;
          }, nd = (p, f) => ci(p, io(f));
          let qi = class extends i.Component {
            render() {
              var p;
              const f = this.props, { schema: h } = f, w = ((le, we) => {
                var Ve = {};
                for (var it in le) td.call(le, it) && we.indexOf(it) < 0 && (Ve[it] = le[it]);
                if (le != null && iu) for (var it of iu(le)) we.indexOf(it) < 0 && Wn.call(le, it) && (Ve[it] = le[it]);
                return Ve;
              })(f, ["schema"]), P = (w.level || 0) + 1;
              if (!h) return i.createElement("em", null, " Schema not provided ");
              const { type: L, oneOf: z, discriminatorProp: ee, isCircular: ue } = h;
              if (ue) return i.createElement(Bc, { schema: h });
              if (ee !== void 0) {
                if (!z || !z.length) return console.warn(`Looks like you are using discriminator wrong: you don't have any definition inherited from the ${h.title}`), null;
                const le = z[h.activeOneOf];
                return le.isCircular ? i.createElement(Bc, { schema: le }) : i.createElement(Wa, nd(An({}, w), { level: P, schema: le, discriminator: { fieldName: ee, parentSchema: h } }));
              }
              if (z !== void 0) return i.createElement(Qa, An({ schema: h }, w));
              const pe = ce(L) ? L : [L];
              if (pe.includes("object")) {
                if ((p = h.fields) != null && p.length) return i.createElement(Wa, nd(An({}, this.props), { level: P }));
              } else if (pe.includes("array")) return i.createElement(Qo, nd(An({}, this.props), { level: P }));
              const xe = { schema: h, name: "", required: !1, description: h.description, externalDocs: h.externalDocs, deprecated: !1, toggle: () => null, expanded: !1 };
              return i.createElement("div", null, i.createElement(Pm, { field: xe }));
            }
          };
          qi = ((p, f) => {
            for (var h, w = f, P = p.length - 1; P >= 0; P--) (h = p[P]) && (w = h(w) || w);
            return w;
          })([zt.observer], qi);
          var jm = Object.defineProperty, Lm = Object.defineProperties, Mm = Object.getOwnPropertyDescriptors, Dm = Object.getOwnPropertySymbols, Uc = Object.prototype.hasOwnProperty, id = Object.prototype.propertyIsEnumerable, Pn = (p, f, h) => f in p ? jm(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h;
          class Nt extends i.PureComponent {
            constructor() {
              super(...arguments), this.renderDropdown = (f) => {
                return i.createElement(to, (h = ((w, P) => {
                  for (var L in P || (P = {})) Uc.call(P, L) && Pn(w, L, P[L]);
                  if (Dm) for (var L of Dm(P)) id.call(P, L) && Pn(w, L, P[L]);
                  return w;
                })({ Label: Cf, Dropdown: Gl }, f), Lm(h, Mm({ variant: "dark" }))));
                var h;
              };
            }
            static getMediaType(f, h) {
              if (!f) return {};
              const w = { schema: { $ref: f } };
              return h && (w.examples = { example: { $ref: h } }), w;
            }
            get mediaModel() {
              const { parser: f, schemaRef: h, exampleRef: w, options: P } = this.props;
              return this._mediaModel || (this._mediaModel = new ff(f, "json", !1, Nt.getMediaType(h, w), P)), this._mediaModel;
            }
            render() {
              const { showReadOnly: f = !0, showWriteOnly: h = !1, showExample: w = !0 } = this.props;
              return i.createElement(Xs, null, i.createElement(Tr, null, i.createElement(Sn, null, i.createElement(qi, { skipWriteOnly: !h, skipReadOnly: !f, schema: this.mediaModel.schema })), w && i.createElement(xn, null, i.createElement($r, null, i.createElement(zf, { renderDropdown: this.renderDropdown, mediaType: this.mediaModel })))));
            }
          }
          const $r = K.div`
  background: ${({ theme: p }) => p.codeBlock.backgroundColor};
  & > div,
  & > pre {
    padding: ${(p) => 4 * p.theme.spacing.unit}px;
    margin: 0;
  }

  & > div > pre {
    padding: 0;
  }
`, _r = (Z().div`
  background-color: #e4e7eb;
`, Z().ul`
  display: inline;
  list-style: none;
  padding: 0;

  li {
    display: inherit;

    &:after {
      content: ',';
    }
    &:last-child:after {
      content: none;
    }
  }
`, Z().code`
  font-size: ${(p) => p.theme.typography.code.fontSize};
  font-family: ${(p) => p.theme.typography.code.fontFamily};
  margin: 0 3px;
  padding: 0.2em;
  display: inline-block;
  line-height: 1;

  &:after {
    content: ',';
    font-weight: normal;
  }

  &:last-child:after {
    content: none;
  }
`), Ur = Z().span`
  &:after {
    content: ' and ';
    font-weight: normal;
  }

  &:last-child:after {
    content: none;
  }

  ${pr};
`, dn = Z().span`
  ${(p) => !p.$expanded && "white-space: nowrap;"}
  &:after {
    content: ' or ';
    ${(p) => p.$expanded && "content: ' or \\a';"}
    white-space: pre;
  }

  &:last-child:after,
  &:only-child:after {
    content: none;
  }

  ${pr};
`, Ya = Z().div`
  flex: 1 1 auto;
  cursor: pointer;
`, Ar = Z().div`
  width: ${(p) => p.theme.schema.defaultDetailsWidth};
  text-overflow: ellipsis;
  border-radius: 4px;
  overflow: hidden;
  ${(p) => p.$expanded && `background: ${p.theme.colors.gray[100]};
     padding: 8px 9.6px;
     margin: 20px 0;
     width: 100%;
    `};
  ${$.lessThan("small")`
    margin-top: 10px;
  `}
`, su = Z()(Bo)`
  display: inline-block;
  margin: 0;
`, Yo = Z().div`
  width: 100%;
  display: flex;
  margin: 1em 0;
  flex-direction: ${(p) => p.$expanded ? "column" : "row"};
  ${$.lessThan("small")`
    flex-direction: column;
  `}
`, Tn = Z().div`
  margin: 0.5em 0;
`, Vc = Z().div`
  border-bottom: 1px solid ${({ theme: p }) => p.colors.border.dark};
  margin-bottom: 1.5em;
  padding-bottom: 0.7em;

  h5 {
    line-height: 1em;
    margin: 0 0 0.6em;
    font-size: ${({ theme: p }) => p.typography.fontSize};
  }

  .redoc-markdown p:first-child {
    display: inline;
  }
`;
          function ou({ children: p, height: f }) {
            const h = i.createRef(), [w, P] = i.useState(!1), [L, z] = i.useState(!1);
            return i.useEffect(() => {
              h.current && h.current.clientHeight + 20 < h.current.scrollHeight && z(!0);
            }, [h]), i.createElement(i.Fragment, null, i.createElement(hn, { ref: h, className: w ? "" : "container", style: { height: w ? "auto" : f } }, p), i.createElement(sd, { $dimmed: !w }, L && i.createElement(Ga, { onClick: () => {
              P(!w);
            } }, w ? "See less" : "See more")));
          }
          const hn = Z().div`
  overflow-y: hidden;
`, sd = Z().div`
  text-align: center;
  line-height: 1.5em;
  ${({ $dimmed: p }) => p && `background-image: linear-gradient(to bottom, transparent,rgb(255 255 255));
     position: relative;
     top: -0.5em;
     padding-top: 0.5em;
     background-position-y: -1em;
    `}
`, Ga = Z().a`
  cursor: pointer;
`, hs = i.memo(function(p) {
            const { type: f, flow: h, RequiredScopes: w } = p, P = Object.keys((h == null ? void 0 : h.scopes) || {});
            return i.createElement(i.Fragment, null, i.createElement(Tn, null, i.createElement("b", null, "Flow type: "), i.createElement("code", null, f, " ")), (f === "implicit" || f === "authorizationCode") && i.createElement(Tn, null, i.createElement("strong", null, " Authorization URL: "), i.createElement("code", null, i.createElement("a", { target: "_blank", rel: "noopener noreferrer", href: h.authorizationUrl }, h.authorizationUrl))), (f === "password" || f === "clientCredentials" || f === "authorizationCode") && i.createElement(Tn, null, i.createElement("b", null, " Token URL: "), i.createElement("code", null, h.tokenUrl)), h.refreshUrl && i.createElement(Tn, null, i.createElement("strong", null, " Refresh URL: "), i.createElement("code", null, h.refreshUrl)), !!P.length && i.createElement(i.Fragment, null, w || null, i.createElement(Tn, null, i.createElement("b", null, " Scopes: ")), i.createElement(ou, { height: "4em" }, i.createElement("ul", null, P.map((L) => i.createElement("li", { key: L }, i.createElement("code", null, L), " -", " ", i.createElement(xr, { className: "redoc-markdown", inline: !0, source: h.scopes[L] || "" })))))));
          });
          function au(p) {
            const { RequiredScopes: f, scheme: h } = p;
            return i.createElement(nr, null, h.apiKey ? i.createElement(i.Fragment, null, i.createElement(Tn, null, i.createElement("b", null, ae(h.apiKey.in || ""), " parameter name: "), i.createElement("code", null, h.apiKey.name)), f) : h.http ? i.createElement(i.Fragment, null, i.createElement(Tn, null, i.createElement("b", null, "HTTP Authorization Scheme: "), i.createElement("code", null, h.http.scheme)), i.createElement(Tn, null, h.http.scheme === "bearer" && h.http.bearerFormat && i.createElement(i.Fragment, null, i.createElement("b", null, "Bearer format: "), i.createElement("code", null, h.http.bearerFormat))), f) : h.openId ? i.createElement(i.Fragment, null, i.createElement(Tn, null, i.createElement("b", null, "Connect URL: "), i.createElement("code", null, i.createElement("a", { target: "_blank", rel: "noopener noreferrer", href: h.openId.connectUrl }, h.openId.connectUrl))), f) : h.flows ? Object.keys(h.flows).map((w) => i.createElement(hs, { key: w, type: w, RequiredScopes: f, flow: h.flows[w] })) : null);
          }
          const Xa = { oauth2: "OAuth2", apiKey: "API Key", http: "HTTP", openIdConnect: "OpenID Connect" };
          class zi extends i.PureComponent {
            render() {
              return this.props.securitySchemes.schemes.map((f) => i.createElement(Xs, { id: f.sectionId, key: f.id }, i.createElement(Tr, null, i.createElement(Sn, null, i.createElement(ps, null, i.createElement(gc, { to: f.sectionId }), f.displayName), i.createElement(xr, { source: f.description || "" }), i.createElement(Vc, null, i.createElement(Tn, null, i.createElement("b", null, "Security Scheme Type: "), i.createElement("span", null, Xa[f.type] || f.type)), i.createElement(au, { scheme: f }))))));
            }
          }
          var lu = (p, f, h) => new Promise((w, P) => {
            var L = (ue) => {
              try {
                ee(h.next(ue));
              } catch (pe) {
                P(pe);
              }
            }, z = (ue) => {
              try {
                ee(h.throw(ue));
              } catch (pe) {
                P(pe);
              }
            }, ee = (ue) => ue.done ? w(ue.value) : Promise.resolve(ue.value).then(L, z);
            ee((h = h.apply(p, f)).next());
          });
          function so(p, f) {
            return lu(this, arguments, function* (h, w, P = {}) {
              const L = yield He(h || w);
              return new ms(L, w, P);
            });
          }
          class ms {
            constructor(f, h, w = {}, P = !0) {
              this.marker = new ft(), this.disposer = null, this.rawOptions = w, this.options = new ie(w, uu), this.scroll = new Ci(this.options), zn.updateOnHistory(oi.currentId, this.scroll), this.spec = new Na(f, h, this.options), this.menu = new zn(this.spec, this.scroll, oi), this.options.disableSearch || (this.search = new qo(), P && this.search.indexItems(this.menu.items), this.disposer = (0, Y.observe)(this.menu, "activeItemIdx", (L) => {
                this.updateMarkOnMenu(L.newValue);
              }));
            }
            static fromJS(f) {
              const h = new ms(f.spec.data, f.spec.url, f.options, !1);
              return h.menu.activeItemIdx = f.menu.activeItemIdx || 0, h.menu.activate(h.menu.flatItems[h.menu.activeItemIdx]), h.options.disableSearch || h.search.load(f.searchIndex), h;
            }
            onDidMount() {
              this.menu.updateOnHistory(), this.updateMarkOnMenu(this.menu.activeItemIdx);
            }
            dispose() {
              this.scroll.dispose(), this.menu.dispose(), this.search && this.search.dispose(), this.disposer != null && this.disposer();
            }
            toJS() {
              return lu(this, null, function* () {
                return { menu: { activeItemIdx: this.menu.activeItemIdx }, spec: { url: this.spec.parser.specUrl, data: this.spec.parser.spec }, searchIndex: this.search ? yield this.search.toJS() : void 0, options: this.rawOptions };
              });
            }
            updateMarkOnMenu(f) {
              const h = Math.max(0, f), w = Math.min(this.menu.flatItems.length, h + 5), P = [];
              for (let L = h; L < w; L++) {
                const z = this.menu.getElementAt(L);
                z && P.push(z);
              }
              if (f === -1 && m) {
                const L = document.querySelector('[data-role="redoc-description"]'), z = document.querySelector('[data-role="redoc-summary"]');
                L && P.push(L), z && P.push(z);
              }
              this.marker.addOnly(P), this.marker.mark();
            }
          }
          const uu = { allowedMdComponents: { [ss]: { component: zi, propsSelector: (p) => ({ securitySchemes: p.spec.securitySchemes }) }, [El]: { component: zi, propsSelector: (p) => ({ securitySchemes: p.spec.securitySchemes }) }, [ko]: { component: Nt, propsSelector: (p) => ({ parser: p.spec.parser, options: p.options }) } } }, od = K(cs)`
  margin-top: 0;
  margin-bottom: 0.5em;

  ${me("ApiHeader")};
`, Hc = K.a`
  border: 1px solid ${(p) => p.theme.colors.primary.main};
  color: ${(p) => p.theme.colors.primary.main};
  font-weight: normal;
  margin-left: 0.5em;
  padding: 4px 8px 4px;
  display: inline-block;
  text-decoration: none;
  cursor: pointer;

  ${me("DownloadButton")};
`, Go = K.span`
  &::before {
    content: '|';
    display: inline-block;
    opacity: 0.5;
    width: ${15}px;
    text-align: center;
  }

  &:last-child::after {
    display: none;
  }
`, rn = K.div`
  overflow: hidden;
`, oo = K.div`
  display: flex;
  flex-wrap: wrap;
  // hide separator on new lines: idea from https://stackoverflow.com/a/31732902/1749888
  margin-left: -${15}px;
`;
          let mn = class extends i.Component {
            render() {
              const { store: p } = this.props, { info: f, externalDocs: h } = p.spec, w = p.options.hideDownloadButtons, P = f.downloadUrls, L = f.downloadFileName, z = f.license && i.createElement(Go, null, "License:", " ", f.license.identifier ? f.license.identifier : i.createElement("a", { href: f.license.url }, f.license.name)) || null, ee = f.contact && f.contact.url && i.createElement(Go, null, "URL: ", i.createElement("a", { href: f.contact.url }, f.contact.url)) || null, ue = f.contact && f.contact.email && i.createElement(Go, null, f.contact.name || "E-mail", ":", " ", i.createElement("a", { href: "mailto:" + f.contact.email }, f.contact.email)) || null, pe = f.termsOfService && i.createElement(Go, null, i.createElement("a", { href: f.termsOfService }, "Terms of Service")) || null, xe = f.version && i.createElement("span", null, "(", f.version, ")") || null;
              return i.createElement(Xs, null, i.createElement(Tr, null, i.createElement(Sn, { className: "api-info" }, i.createElement(od, null, f.title, " ", xe), !w && i.createElement("p", null, F("downloadSpecification"), ":", P == null ? void 0 : P.map(({ title: le, url: we }) => i.createElement(Hc, { download: L || !0, target: "_blank", href: we, rel: "noreferrer", key: we }, le))), i.createElement(nr, null, (f.license || f.contact || f.termsOfService) && i.createElement(rn, null, i.createElement(oo, null, ue, " ", ee, " ", z, " ", pe)) || null), i.createElement(xr, { source: p.spec.info.summary, "data-role": "redoc-summary" }), i.createElement(xr, { source: p.spec.info.description, "data-role": "redoc-description" }), h && i.createElement(no, { externalDocs: h }))));
            }
          };
          mn = ((p, f) => {
            for (var h, w = f, P = p.length - 1; P >= 0; P--) (h = p[P]) && (w = h(w) || w);
            return w;
          })([zt.observer], mn);
          const gn = K.img`
  max-height: ${(p) => p.theme.logo.maxHeight};
  max-width: ${(p) => p.theme.logo.maxWidth};
  padding: ${(p) => p.theme.logo.gutter};
  width: 100%;
  display: block;
`, Fm = K.div`
  text-align: center;
`, ad = K.a`
  display: inline-block;
`;
          let Ja = class extends i.Component {
            render() {
              const { info: p } = this.props, f = p["x-logo"];
              if (!f || !f.url) return null;
              const h = f.href || p.contact && p.contact.url, w = f.altText ? f.altText : "logo", P = i.createElement(gn, { src: f.url, alt: w });
              return i.createElement(Fm, { style: { backgroundColor: f.backgroundColor } }, h ? (L = h, (z) => i.createElement(ad, { href: L }, z))(P) : P);
              var L;
            }
          };
          Ja = ((p, f) => {
            for (var h, w = f, P = p.length - 1; P >= 0; P--) (h = p[P]) && (w = h(w) || w);
            return w;
          })([zt.observer], Ja);
          var Mb = Object.defineProperty, gs = Object.getOwnPropertySymbols, qm = Object.prototype.hasOwnProperty, ld = Object.prototype.propertyIsEnumerable, ao = (p, f, h) => f in p ? Mb(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h, cu = (p, f) => {
            for (var h in f || (f = {})) qm.call(f, h) && ao(p, h, f[h]);
            if (gs) for (var h of gs(f)) ld.call(f, h) && ao(p, h, f[h]);
            return p;
          };
          class Xo extends i.Component {
            render() {
              return i.createElement(Vt, null, (f) => i.createElement(Bn, null, (h) => this.renderWithOptionsAndStore(f, h)));
            }
            renderWithOptionsAndStore(f, h) {
              const { source: w, htmlWrap: P = (z) => z } = this.props;
              if (!h) throw new Error("When using components in markdown, store prop must be provided");
              const L = new Pi(f, this.props.parentId).renderMdWithComponents(w);
              return L.length ? L.map((z, ee) => {
                if (typeof z == "string") return i.cloneElement(P(i.createElement(On, { html: z, inline: !1, compact: !1 })), { key: ee });
                const ue = z.component;
                return i.createElement(ue, cu({ key: ee }, cu(cu({}, z.props), z.propsSelector(h))));
              }) : null;
            }
          }
          var zm = aV();
          const Jo = K.span.attrs((p) => ({ className: `operation-type ${p.type}` }))`
  width: 9ex;
  display: inline-block;
  height: ${(p) => p.theme.typography.code.fontSize};
  line-height: ${(p) => p.theme.typography.code.fontSize};
  background-color: ${(p) => p.color || "#333"};
  border-radius: 3px;
  background-repeat: no-repeat;
  background-position: 6px 4px;
  font-size: 7px;
  font-family: Verdana, sans-serif; // web-safe
  color: white;
  text-transform: uppercase;
  text-align: center;
  font-weight: bold;
  vertical-align: middle;
  margin-right: 6px;
  margin-top: 2px;

  &.get {
    background-color: ${({ theme: p }) => p.colors.http.get};
  }

  &.post {
    background-color: ${({ theme: p }) => p.colors.http.post};
  }

  &.put {
    background-color: ${({ theme: p }) => p.colors.http.put};
  }

  &.options {
    background-color: ${({ theme: p }) => p.colors.http.options};
  }

  &.patch {
    background-color: ${({ theme: p }) => p.colors.http.patch};
  }

  &.delete {
    background-color: ${({ theme: p }) => p.colors.http.delete};
  }

  &.basic {
    background-color: ${({ theme: p }) => p.colors.http.basic};
  }

  &.link {
    background-color: ${({ theme: p }) => p.colors.http.link};
  }

  &.head {
    background-color: ${({ theme: p }) => p.colors.http.head};
  }

  &.hook {
    background-color: ${({ theme: p }) => p.colors.primary.main};
  }

  &.schema {
    background-color: ${({ theme: p }) => p.colors.http.basic};
  }
`;
          function Za(p, { theme: f }, h) {
            return p > 1 ? f.sidebar.level1Items[h] : p === 1 ? f.sidebar.groupItems[h] : "";
          }
          const pu = K.ul`
  margin: 0;
  padding: 0;

  &:first-child {
    padding-bottom: 32px;
  }

  & & {
    font-size: 0.929em;
  }

  ${(p) => p.$expanded ? "" : "display: none;"};
`, Bm = K.li`
  list-style: none inside none;
  overflow: hidden;
  text-overflow: ellipsis;
  padding: 0;
  ${(p) => p.depth === 0 ? "margin-top: 15px" : ""};
`, Um = { 0: Pe`
    opacity: 0.7;
    text-transform: ${({ theme: p }) => p.sidebar.groupItems.textTransform};
    font-size: 0.8em;
    padding-bottom: 0;
    cursor: default;
  `, 1: Pe`
    font-size: 0.929em;
    text-transform: ${({ theme: p }) => p.sidebar.level1Items.textTransform};
  ` }, fu = K.label.attrs((p) => ({ className: zm("-depth" + p.$depth, { active: p.$active }) }))`
  cursor: pointer;
  color: ${(p) => p.$active ? Za(p.$depth, p, "activeTextColor") : p.theme.sidebar.textColor};
  margin: 0;
  padding: 12.5px ${(p) => 4 * p.theme.spacing.unit}px;
  ${({ $depth: p, $type: f, theme: h }) => f === "section" && p > 1 && "padding-left: " + 8 * h.spacing.unit + "px;" || ""}
  display: flex;
  justify-content: space-between;
  font-family: ${(p) => p.theme.typography.headings.fontFamily};
  ${(p) => Um[p.$depth]};
  background-color: ${(p) => p.$active ? Za(p.$depth, p, "activeBackgroundColor") : p.theme.sidebar.backgroundColor};

  ${(p) => p.$deprecated && La || ""};

  &:hover {
    color: ${(p) => Za(p.$depth, p, "activeTextColor")};
    background-color: ${(p) => Za(p.$depth, p, "activeBackgroundColor")};
  }

  ${$i} {
    height: ${({ theme: p }) => p.sidebar.arrow.size};
    width: ${({ theme: p }) => p.sidebar.arrow.size};
    polygon {
      fill: ${({ theme: p }) => p.sidebar.arrow.color};
    }
  }
`, Wc = K.span`
  display: inline-block;
  vertical-align: middle;
  width: ${(p) => p.width ? p.width : "auto"};
  overflow: hidden;
  text-overflow: ellipsis;
`, lo = K.div`
  ${({ theme: p }) => Pe`
    font-size: 0.8em;
    margin-top: ${2 * p.spacing.unit}px;
    text-align: center;
    position: fixed;
    width: ${p.sidebar.width};
    bottom: 0;
    background: ${p.sidebar.backgroundColor};

    a,
    a:visited,
    a:hover {
      color: ${p.sidebar.textColor} !important;
      padding: ${p.spacing.unit}px 0;
      border-top: 1px solid ${(0, u.darken)(0.1, p.sidebar.backgroundColor)};
      text-decoration: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }
  `};
  img {
    width: 15px;
    margin-right: 5px;
  }

  ${$.lessThan("small")`
    width: 100%;
  `};
`, Db = K.button`
  border: 0;
  width: 100%;
  text-align: left;
  & > * {
    vertical-align: middle;
  }

  ${$i} {
    polygon {
      fill: ${({ theme: p }) => (0, u.darken)(p.colors.tonalOffset, p.colors.gray[100])};
    }
  }
`, el = K.span`
  text-decoration: ${(p) => p.$deprecated ? "line-through" : "none"};
  margin-right: 8px;
`, Vm = K(Jo)`
  margin: 0 5px 0 0;
`, fr = K((p) => {
            const { name: f, opened: h, className: w, onClick: P, httpVerb: L, deprecated: z } = p;
            return i.createElement(Db, { className: w, onClick: P || void 0 }, i.createElement(Vm, { type: L }, Dn(L)), i.createElement($i, { size: "1.5em", direction: h ? "down" : "right", float: "left" }), i.createElement(el, { $deprecated: z }, f), z ? i.createElement(Un, { type: "warning" }, " ", F("deprecated"), " ") : null);
          })`
  padding: 10px;
  border-radius: 2px;
  margin-bottom: 4px;
  line-height: 1.5em;
  background-color: ${({ theme: p }) => p.colors.gray[100]};
  cursor: pointer;
  outline-color: ${({ theme: p }) => (0, u.darken)(p.colors.tonalOffset, p.colors.gray[100])};
`, Fb = K.div`
  padding: 10px 25px;
  background-color: ${({ theme: p }) => p.colors.gray[50]};
  margin-bottom: 5px;
  margin-top: 5px;
`;
          class Hm extends i.PureComponent {
            constructor() {
              super(...arguments), this.selectElement = () => {
                Li.selectElement(this.child);
              };
            }
            render() {
              const { children: f } = this.props;
              return i.createElement("div", { ref: (h) => this.child = h, onClick: this.selectElement, onFocus: this.selectElement, tabIndex: 0, role: "button" }, f);
            }
          }
          const qb = K.div`
  cursor: pointer;
  position: relative;
  margin-bottom: 5px;
`, Wm = K.span`
  font-family: ${(p) => p.theme.typography.code.fontFamily};
  margin-left: 10px;
  flex: 1;
  overflow-x: hidden;
  text-overflow: ellipsis;
`, Km = K.button`
  outline: 0;
  color: inherit;
  width: 100%;
  text-align: left;
  cursor: pointer;
  padding: 10px 30px 10px ${(p) => p.$inverted ? "10px" : "20px"};
  border-radius: ${(p) => p.$inverted ? "0" : "4px 4px 0 0"};
  background-color: ${(p) => p.$inverted ? "transparent" : p.theme.codeBlock.backgroundColor};
  display: flex;
  white-space: nowrap;
  align-items: center;
  border: ${(p) => p.$inverted ? "0" : "1px solid transparent"};
  border-bottom: ${(p) => p.$inverted ? "1px solid #ccc" : "0"};
  transition: border-color 0.25s ease;

  ${(p) => p.$expanded && !p.$inverted && `border-color: ${p.theme.colors.border.dark};` || ""}

  .${Wm} {
    color: ${(p) => p.$inverted ? p.theme.colors.text.primary : "#ffffff"};
  }
  &:focus {
    box-shadow: inset 0 2px 2px rgba(0, 0, 0, 0.45), 0 2px 0 rgba(128, 128, 128, 0.25);
  }
`, Qm = K.span.attrs((p) => ({ className: `http-verb ${p.type}` }))`
  font-size: ${(p) => p.$compact ? "0.8em" : "0.929em"};
  line-height: ${(p) => p.$compact ? "18px" : "20px"};
  background-color: ${(p) => p.theme.colors.http[p.type] || "#999999"};
  color: #ffffff;
  padding: ${(p) => p.$compact ? "2px 8px" : "3px 10px"};
  text-transform: uppercase;
  font-family: ${(p) => p.theme.typography.headings.fontFamily};
  margin: 0;
`, zb = K.div`
  position: absolute;
  width: 100%;
  z-index: 100;
  background: ${(p) => p.theme.rightPanel.servers.overlay.backgroundColor};
  color: ${(p) => p.theme.rightPanel.servers.overlay.textColor};
  box-sizing: border-box;
  box-shadow: 0 0 6px rgba(0, 0, 0, 0.33);
  overflow: hidden;
  border-bottom-left-radius: 4px;
  border-bottom-right-radius: 4px;
  transition: all 0.25s ease;
  visibility: hidden;
  ${(p) => p.$expanded ? "visibility: visible;" : "transform: translateY(-50%) scaleY(0);"}
`, Kn = K.div`
  padding: 10px;
`, ud = K.div`
  padding: 5px;
  border: 1px solid #ccc;
  background: ${(p) => p.theme.rightPanel.servers.url.backgroundColor};
  word-break: break-all;
  color: ${(p) => p.theme.colors.primary.main};
  > span {
    color: ${(p) => p.theme.colors.text.primary};
  }
`;
          class cd extends i.Component {
            constructor(f) {
              super(f), this.toggle = () => {
                this.setState({ expanded: !this.state.expanded });
              }, this.state = { expanded: !1 };
            }
            render() {
              const { operation: f, inverted: h, hideHostname: w } = this.props, { expanded: P } = this.state;
              return i.createElement(st.Consumer, null, (L) => i.createElement(qb, null, i.createElement(Km, { onClick: this.toggle, $expanded: P, $inverted: h }, i.createElement(Qm, { type: f.httpVerb, $compact: this.props.compact }, f.httpVerb), i.createElement(Wm, null, f.path), i.createElement($i, { float: "right", color: h ? "black" : "white", size: "20px", direction: P ? "up" : "down", style: { marginRight: "-25px" } })), i.createElement(zb, { $expanded: P, "aria-hidden": !P }, f.servers.map((z) => {
                const ee = L.expandDefaultServerVariables ? qs(z.url, z.variables) : z.url, ue = H(ee);
                return i.createElement(Kn, { key: ee }, i.createElement(xr, { source: z.description || "", compact: !0 }), i.createElement(Hm, null, i.createElement(ud, null, i.createElement("span", null, w || L.hideHostname ? ue === "/" ? "" : ue : ee), f.path)));
              }))));
            }
          }
          class uo extends i.PureComponent {
            render() {
              const { place: f, parameters: h } = this.props;
              return h && h.length ? i.createElement("div", { key: f }, i.createElement(Bo, null, f, " Parameters"), i.createElement(Da, null, i.createElement("tbody", null, x(h, (w, P) => i.createElement(Ha, { key: w.name, isLast: P, field: w, showExamples: !0 }))))) : null;
            }
          }
          let ys = class extends i.Component {
            constructor() {
              super(...arguments), this.switchMedia = ({ idx: p }) => {
                this.props.content && p !== void 0 && this.props.content.activate(p);
              };
            }
            render() {
              const { content: p } = this.props;
              if (!p || !p.mediaTypes || !p.mediaTypes.length) return null;
              const f = p.activeMimeIdx, h = p.mediaTypes.map((P, L) => ({ value: P.name, idx: L })), w = ({ children: P }) => this.props.withLabel ? i.createElement($c, null, i.createElement(Cc, null, "Content type"), P) : P;
              return i.createElement(i.Fragment, null, i.createElement(w, null, this.props.renderDropdown({ value: h[f].value, options: h, onChange: this.switchMedia, ariaLabel: "Content type" })), this.props.children(p.active));
            }
          };
          ys = ((p, f) => {
            for (var h, w = f, P = p.length - 1; P >= 0; P--) (h = p[P]) && (w = h(w) || w);
            return w;
          })([zt.observer], ys);
          var Zo = Object.defineProperty, ea = Object.getOwnPropertySymbols, Kc = Object.prototype.hasOwnProperty, Qc = Object.prototype.propertyIsEnumerable, Ym = (p, f, h) => f in p ? Zo(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h, Yc = (p, f) => {
            for (var h in f || (f = {})) Kc.call(f, h) && Ym(p, h, f[h]);
            if (ea) for (var h of ea(f)) Qc.call(f, h) && Ym(p, h, f[h]);
            return p;
          }, Bb = (p, f) => {
            var h = {};
            for (var w in p) Kc.call(p, w) && f.indexOf(w) < 0 && (h[w] = p[w]);
            if (p != null && ea) for (var w of ea(p)) f.indexOf(w) < 0 && Qc.call(p, w) && (h[w] = p[w]);
            return h;
          };
          const Gm = ["path", "query", "cookie", "header"];
          class Gc extends i.PureComponent {
            orderParams(f) {
              const h = {};
              return f.forEach((w) => {
                var P, L, z;
                z = w, (P = h)[L = w.in] || (P[L] = []), P[L].push(z);
              }), h;
            }
            render() {
              const { body: f, parameters: h = [] } = this.props;
              if (f === void 0 && h === void 0) return null;
              const w = this.orderParams(h), P = h.length > 0 ? Gm : [], L = f && f.content, z = f && f.description, ee = f && f.required;
              return i.createElement(i.Fragment, null, P.map((ue) => i.createElement(uo, { key: ue, place: ue, parameters: w[ue] })), L && i.createElement(du, { content: L, description: z, bodyRequired: ee }));
            }
          }
          function Xc(p) {
            var f = p, { bodyRequired: h } = f, w = Bb(f, ["bodyRequired"]);
            const P = typeof h == "boolean" && !!h, L = typeof h == "boolean" && !h;
            return i.createElement(Bo, { key: "header" }, "Request Body schema: ", i.createElement(to, Yc({}, w)), P && i.createElement(fd, null, "required"), L && i.createElement(Ub, null, "optional"));
          }
          function du(p) {
            const { content: f, description: h, bodyRequired: w } = p, { isRequestType: P } = f;
            return i.createElement(ys, { content: f, renderDropdown: (L) => i.createElement(Xc, Yc({ bodyRequired: w }, L)) }, ({ schema: L }) => i.createElement(i.Fragment, null, h !== void 0 && i.createElement(xr, { source: h }), (L == null ? void 0 : L.type) === "object" && i.createElement(Va, { constraints: (L == null ? void 0 : L.constraints) || [] }), i.createElement(qi, { skipReadOnly: P, skipWriteOnly: !P, key: "schema", schema: L })));
          }
          const pd = `
  text-transform: lowercase;
  margin-left: 0;
  line-height: 1.5em;
`, fd = K(Rc)`
  ${pd}
`, Ub = K("div")`
  ${pd}
  color: ${({ theme: p }) => p.colors.text.secondary};
  font-size: ${(p) => p.theme.schema.labelsTextSize};
`, dd = i.memo(function({ title: p, type: f, empty: h, code: w, opened: P, className: L, onClick: z }) {
            return i.createElement("button", { className: L, onClick: !h && z || void 0, "aria-expanded": P, disabled: h }, !h && i.createElement($i, { size: "1.5em", color: f, direction: P ? "down" : "right", float: "left" }), i.createElement(Zc, null, w, " "), i.createElement(xr, { compact: !0, inline: !0, source: p }));
          }), hd = K(dd)`
  display: block;
  border: 0;
  width: 100%;
  text-align: left;
  padding: 10px;
  border-radius: 2px;
  margin-bottom: 4px;
  line-height: 1.5em;
  cursor: pointer;

  color: ${(p) => p.theme.colors.responses[p.type].color};
  background-color: ${(p) => p.theme.colors.responses[p.type].backgroundColor};
  &:focus {
    outline: auto ${(p) => p.theme.colors.responses[p.type].color};
  }
  ${(p) => p.empty ? `
cursor: default;
&::before {
  content: "—";
  font-weight: bold;
  width: 1.5em;
  text-align: center;
  display: inline-block;
  vertical-align: top;
}
&:focus {
  outline: 0;
}
` : ""};
`, Jc = K.div`
  padding: 10px;
`, md = K(Bo).attrs({ as: "caption" })`
  text-align: left;
  margin-top: 1em;
  caption-side: top;
`, Zc = K.strong`
  vertical-align: top;
`;
          class gd extends i.PureComponent {
            render() {
              const { headers: f } = this.props;
              return f === void 0 || f.length === 0 ? null : i.createElement(Da, null, i.createElement(md, null, " Response Headers "), i.createElement("tbody", null, x(f, (h, w) => i.createElement(Ha, { isLast: w, key: h.name, field: h, showExamples: !0 }))));
            }
          }
          var Vb = Object.defineProperty, hu = Object.getOwnPropertySymbols, Hb = Object.prototype.hasOwnProperty, mu = Object.prototype.propertyIsEnumerable, Xm = (p, f, h) => f in p ? Vb(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h;
          class gu extends i.PureComponent {
            constructor() {
              super(...arguments), this.renderDropdown = (f) => i.createElement(Bo, { key: "header" }, "Response Schema: ", i.createElement(to, ((h, w) => {
                for (var P in w || (w = {})) Hb.call(w, P) && Xm(h, P, w[P]);
                if (hu) for (var P of hu(w)) mu.call(w, P) && Xm(h, P, w[P]);
                return h;
              })({}, f)));
            }
            render() {
              const { description: f, extensions: h, headers: w, content: P } = this.props.response;
              return i.createElement(i.Fragment, null, f && i.createElement(xr, { source: f }), i.createElement(Cr, { extensions: h }), i.createElement(gd, { headers: w }), i.createElement(ys, { content: P, renderDropdown: this.renderDropdown }, ({ schema: L }) => i.createElement(i.Fragment, null, (L == null ? void 0 : L.type) === "object" && i.createElement(Va, { constraints: (L == null ? void 0 : L.constraints) || [] }), i.createElement(qi, { skipWriteOnly: !0, key: "schema", schema: L }))));
            }
          }
          const s = (0, zt.observer)(({ response: p }) => {
            const { extensions: f, headers: h, type: w, summary: P, description: L, code: z, expanded: ee, content: ue } = p, pe = i.useMemo(() => ue === void 0 ? [] : ue.mediaTypes.filter((le) => le.schema !== void 0), [ue]), xe = i.useMemo(() => !(f && Object.keys(f).length !== 0 || h.length !== 0 || pe.length !== 0 || L), [f, h, pe, L]);
            return i.createElement("div", null, i.createElement(hd, { onClick: () => p.toggle(), type: w, empty: xe, title: P || "", code: z, opened: ee }), ee && !xe && i.createElement(Jc, null, i.createElement(gu, { response: p })));
          }), l = K.h3`
  font-size: 1.3em;
  padding: 0.2em 0;
  margin: 3em 0 1.1em;
  color: ${({ theme: p }) => p.colors.text.primary};
  font-weight: normal;
`;
          class y extends i.PureComponent {
            render() {
              const { responses: f, isCallback: h } = this.props;
              return f && f.length !== 0 ? i.createElement("div", null, i.createElement(l, null, F(h ? "callbackResponses" : "responses")), f.map((w) => i.createElement(s, { key: w.code, response: w }))) : null;
            }
          }
          function E(p) {
            const { security: f, showSecuritySchemeType: h, expanded: w } = p, P = f.schemes.length > 1;
            return f.schemes.length === 0 ? i.createElement(dn, { $expanded: w }, "None") : i.createElement(dn, { $expanded: w }, P && "(", f.schemes.map((L) => i.createElement(Ur, { key: L.id }, h && `${Xa[L.type] || L.type}: `, i.createElement("i", null, L.displayName), w && L.scopes.length ? [" (", L.scopes.map((z) => i.createElement(_r, { key: z }, z)), ") "] : null)), P && ") ");
          }
          const I = ({ scopes: p }) => p.length ? i.createElement("div", null, i.createElement("b", null, "Required scopes: "), p.map((f, h) => i.createElement(i.Fragment, { key: h }, i.createElement("code", null, f), " "))) : null;
          function M(p) {
            const f = wf(), h = f == null ? void 0 : f.options.showSecuritySchemeType, [w, P] = (0, i.useState)(!1), { securities: L } = p;
            if (!(L != null && L.length) || f != null && f.options.hideSecuritySection) return null;
            const z = f == null ? void 0 : f.spec.securitySchemes.schemes.filter(({ id: ee }) => L.find((ue) => ue.schemes.find((pe) => pe.id === ee)));
            return i.createElement(i.Fragment, null, i.createElement(Yo, { $expanded: w }, i.createElement(Ya, { onClick: () => P(!w) }, i.createElement(su, null, "Authorizations:"), i.createElement($i, { size: "1.3em", direction: w ? "down" : "right" })), i.createElement(Ar, { $expanded: w }, L.map((ee, ue) => i.createElement(E, { key: ue, expanded: w, showSecuritySchemeType: h, security: ee })))), w && !!(z != null && z.length) && z.map((ee, ue) => i.createElement(Vc, { key: ue }, i.createElement("h5", null, i.createElement(G, null), " ", Xa[ee.type] || ee.type, ": ", ee.id), i.createElement(xr, { source: ee.description || "" }), i.createElement(au, { key: ee.id, scheme: ee, RequiredScopes: i.createElement(I, { scopes: de(ee.id, L) }) }))));
          }
          const G = () => i.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "11", height: "11" }, i.createElement("path", { fill: "currentColor", d: "M18 10V6A6 6 0 0 0 6 6v4H3v14h18V10h-3zM8 6c0-2.206 1.794-4 4-4s4 1.794 4 4v4H8V6zm11 16H5V12h14v10z" }));
          function de(p, f) {
            const h = [];
            let w = f.length;
            for (; w--; ) {
              const P = f[w];
              let L = P.schemes.length;
              for (; L--; ) {
                const z = P.schemes[L];
                z.id === p && Array.isArray(z.scopes) && h.push(...z.scopes);
              }
            }
            return Array.from(new Set(h));
          }
          let be = class extends i.Component {
            render() {
              const { operation: p } = this.props, { description: f, externalDocs: h } = p, w = !(!f && !h);
              return i.createElement(Fb, null, w && i.createElement(Re, null, f !== void 0 && i.createElement(xr, { source: f }), h && i.createElement(no, { externalDocs: h })), i.createElement(cd, { operation: this.props.operation, inverted: !0, compact: !0 }), i.createElement(Cr, { extensions: p.extensions }), i.createElement(M, { securities: p.security }), i.createElement(Gc, { parameters: p.parameters, body: p.requestBody }), i.createElement(y, { responses: p.responses, isCallback: p.isCallback }));
            }
          };
          be = ((p, f) => {
            for (var h, w = f, P = p.length - 1; P >= 0; P--) (h = p[P]) && (w = h(w) || w);
            return w;
          })([zt.observer], be);
          const Re = K.div`
  margin-bottom: ${({ theme: p }) => 3 * p.spacing.unit}px;
`;
          let Be = class extends i.Component {
            constructor() {
              super(...arguments), this.toggle = () => {
                this.props.callbackOperation.toggle();
              };
            }
            render() {
              const { name: p, expanded: f, httpVerb: h, deprecated: w } = this.props.callbackOperation;
              return i.createElement(i.Fragment, null, i.createElement(fr, { onClick: this.toggle, name: p, opened: f, httpVerb: h, deprecated: w }), f && i.createElement(be, { operation: this.props.callbackOperation }));
            }
          };
          Be = ((p, f) => {
            for (var h, w = f, P = p.length - 1; P >= 0; P--) (h = p[P]) && (w = h(w) || w);
            return w;
          })([zt.observer], Be);
          class We extends i.PureComponent {
            render() {
              const { callbacks: f } = this.props;
              return f && f.length !== 0 ? i.createElement("div", null, i.createElement(Ue, null, " Callbacks "), f.map((h) => h.operations.map((w, P) => i.createElement(Be, { key: `${h.name}_${P}`, callbackOperation: w })))) : null;
            }
          }
          const Ue = K.h3`
  font-size: 1.3em;
  padding: 0.2em 0;
  margin: 3em 0 1.1em;
  color: ${({ theme: p }) => p.colors.text.primary};
  font-weight: normal;
`;
          let et = class extends i.Component {
            constructor(p) {
              super(p), this.switchItem = ({ idx: f }) => {
                this.props.items && f !== void 0 && this.setState({ activeItemIdx: f });
              }, this.state = { activeItemIdx: 0 };
            }
            render() {
              const { items: p } = this.props;
              if (!p || !p.length) return null;
              const f = ({ children: h }) => this.props.label ? i.createElement($c, null, i.createElement(Cc, null, this.props.label), h) : h;
              return i.createElement(i.Fragment, null, i.createElement(f, null, this.props.renderDropdown({ value: this.props.options[this.state.activeItemIdx].value, options: this.props.options, onChange: this.switchItem, ariaLabel: this.props.label || "Callback" })), this.props.children(p[this.state.activeItemIdx]));
            }
          };
          et = ((p, f) => {
            for (var h, w = f, P = p.length - 1; P >= 0; P--) (h = p[P]) && (w = h(w) || w);
            return w;
          })([zt.observer], et);
          var ut = Object.defineProperty, pt = Object.defineProperties, gr = Object.getOwnPropertyDescriptors, Ae = Object.getOwnPropertySymbols, Ee = Object.prototype.hasOwnProperty, Ce = Object.prototype.propertyIsEnumerable, Qe = (p, f, h) => f in p ? ut(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h;
          let ot = class extends i.Component {
            constructor() {
              super(...arguments), this.renderDropdown = (p) => {
                return i.createElement(to, (f = ((h, w) => {
                  for (var P in w || (w = {})) Ee.call(w, P) && Qe(h, P, w[P]);
                  if (Ae) for (var P of Ae(w)) Ce.call(w, P) && Qe(h, P, w[P]);
                  return h;
                })({ Label: Tc, Dropdown: Gl }, p), pt(f, gr({ variant: "dark" }))));
                var f;
              };
            }
            render() {
              const p = this.props.content;
              return p === void 0 ? null : i.createElement(ys, { content: p, renderDropdown: this.renderDropdown, withLabel: !0 }, (f) => i.createElement(zf, { key: "samples", mediaType: f, renderDropdown: this.renderDropdown }));
            }
          };
          ot = ((p, f) => {
            for (var h, w = f, P = p.length - 1; P >= 0; P--) (h = p[P]) && (w = h(w) || w);
            return w;
          })([zt.observer], ot);
          class yt extends i.Component {
            render() {
              const f = this.props.callback.codeSamples.find((h) => Ia(h));
              return f ? i.createElement(vt, null, i.createElement(ot, { content: f.requestBodyContent })) : null;
            }
          }
          const vt = K.div`
  margin-top: 15px;
`;
          var xt = Object.defineProperty, Rr = Object.defineProperties, Ft = Object.getOwnPropertyDescriptors, vs = Object.getOwnPropertySymbols, Wb = Object.prototype.hasOwnProperty, J$ = Object.prototype.propertyIsEnumerable, Mx = (p, f, h) => f in p ? xt(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h;
          let Jm = class extends i.Component {
            constructor() {
              super(...arguments), this.renderDropdown = (p) => {
                return i.createElement(to, (f = ((h, w) => {
                  for (var P in w || (w = {})) Wb.call(w, P) && Mx(h, P, w[P]);
                  if (vs) for (var P of vs(w)) J$.call(w, P) && Mx(h, P, w[P]);
                  return h;
                })({ Label: Tc, Dropdown: Gl }, p), Rr(f, Ft({ variant: "dark" }))));
                var f;
              };
            }
            render() {
              const { callbacks: p } = this.props;
              if (!p || p.length === 0) return null;
              const f = p.map((w) => w.operations.map((P) => P)).reduce((w, P) => w.concat(P), []);
              if (!f.some((w) => w.codeSamples.length > 0)) return null;
              const h = f.map((w, P) => ({ value: `${w.httpVerb.toUpperCase()}: ${w.name}`, idx: P }));
              return i.createElement("div", null, i.createElement(ql, null, " Callback payload samples "), i.createElement(Z$, null, i.createElement(et, { items: f, renderDropdown: this.renderDropdown, label: "Callback", options: h }, (w) => i.createElement(yt, { key: "callbackPayloadSample", callback: w, renderDropdown: this.renderDropdown }))));
            }
          };
          Jm.contextType = st, Jm = ((p, f) => {
            for (var h, w = f, P = p.length - 1; P >= 0; P--) (h = p[P]) && (w = h(w) || w);
            return w;
          })([zt.observer], Jm);
          const Z$ = K.div`
  background: ${({ theme: p }) => p.codeBlock.backgroundColor};
  padding: ${(p) => 4 * p.theme.spacing.unit}px;
`;
          let Zm = class extends i.Component {
            render() {
              const { operation: p } = this.props, f = p.codeSamples, h = f.length > 0, w = f.length === 1 && this.context.hideSingleRequestSampleTab;
              return h && i.createElement("div", null, i.createElement(ql, null, " ", F("requestSamples"), " "), i.createElement(Js, { defaultIndex: 0 }, i.createElement(fs.TabList, { hidden: w }, f.map((P) => i.createElement(fs.Tab, { key: P.lang + "_" + (P.label || "") }, P.label !== void 0 ? P.label : P.lang))), f.map((P) => i.createElement(fs.TabPanel, { key: P.lang + "_" + (P.label || "") }, Ia(P) ? i.createElement("div", null, i.createElement(ot, { content: P.requestBodyContent })) : i.createElement(Yl, { lang: P.lang, source: P.source }))))) || null;
            }
          };
          Zm.contextType = st, Zm = ((p, f) => {
            for (var h, w = f, P = p.length - 1; P >= 0; P--) (h = p[P]) && (w = h(w) || w);
            return w;
          })([zt.observer], Zm);
          let eg = class extends i.Component {
            render() {
              const { operation: p } = this.props, f = p.responses.filter((h) => h.content && h.content.hasSample);
              return f.length > 0 && i.createElement("div", null, i.createElement(ql, null, " ", F("responseSamples"), " "), i.createElement(Js, { defaultIndex: 0 }, i.createElement(fs.TabList, null, f.map((h) => i.createElement(fs.Tab, { className: "tab-" + h.type, key: h.code }, h.code))), f.map((h) => i.createElement(fs.TabPanel, { key: h.code }, i.createElement("div", null, i.createElement(ot, { content: h.content })))))) || null;
            }
          };
          eg = ((p, f) => {
            for (var h, w = f, P = p.length - 1; P >= 0; P--) (h = p[P]) && (w = h(w) || w);
            return w;
          })([zt.observer], eg);
          var eR = Object.defineProperty, tR = Object.defineProperties, rR = Object.getOwnPropertyDescriptors, Dx = Object.getOwnPropertySymbols, nR = Object.prototype.hasOwnProperty, iR = Object.prototype.propertyIsEnumerable, Fx = (p, f, h) => f in p ? eR(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h;
          const sR = K.div`
  margin-bottom: ${({ theme: p }) => 6 * p.spacing.unit}px;
`, qx = (0, zt.observer)(({ operation: p }) => {
            const { name: f, description: h, deprecated: w, externalDocs: P, isWebhook: L, httpVerb: z, badges: ee } = p, ue = !(!h && !P), { showWebhookVerb: pe } = i.useContext(st), xe = ee.filter(({ position: we }) => we === "before"), le = ee.filter(({ position: we }) => we === "after");
            return i.createElement(st.Consumer, null, (we) => {
              return i.createElement(Tr, (Ve = ((_t, Et) => {
                for (var gt in Et || (Et = {})) nR.call(Et, gt) && Fx(_t, gt, Et[gt]);
                if (Dx) for (var gt of Dx(Et)) iR.call(Et, gt) && Fx(_t, gt, Et[gt]);
                return _t;
              })({}, { [tn]: p.operationHash }), it = { id: p.operationHash }, tR(Ve, rR(it))), i.createElement(Sn, null, i.createElement(ps, null, i.createElement(gc, { to: p.id }), xe.map(({ name: _t, color: Et }) => i.createElement(Un, { type: "primary", key: _t, color: Et }, _t)), f, " ", w && i.createElement(Un, { type: "warning" }, " Deprecated "), L && i.createElement(Un, { type: "primary" }, " ", "Webhook ", pe && z && "| " + z.toUpperCase()), le.map(({ name: _t, color: Et }) => i.createElement(Un, { type: "primary", key: _t, color: Et }, _t))), we.pathInMiddlePanel && !L && i.createElement(cd, { operation: p, inverted: !0 }), ue && i.createElement(sR, null, h !== void 0 && i.createElement(xr, { source: h }), P && i.createElement(no, { externalDocs: P })), i.createElement(Cr, { extensions: p.extensions }), i.createElement(M, { securities: p.security }), i.createElement(Gc, { parameters: p.parameters, body: p.requestBody }), i.createElement(y, { responses: p.responses }), i.createElement(We, { callbacks: p.callbacks })), i.createElement(xn, null, !we.pathInMiddlePanel && !L && i.createElement(cd, { operation: p }), i.createElement(Zm, { operation: p }), i.createElement(eg, { operation: p }), i.createElement(Jm, { callbacks: p.callbacks })));
              var Ve, it;
            });
          });
          var oR = Object.defineProperty, zx = Object.getOwnPropertySymbols, aR = Object.prototype.hasOwnProperty, lR = Object.prototype.propertyIsEnumerable, Bx = (p, f, h) => f in p ? oR(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h, tg = (p, f, h, w) => {
            for (var P, L = f, z = p.length - 1; z >= 0; z--) (P = p[z]) && (L = P(L) || L);
            return L;
          };
          let yd = class extends i.Component {
            render() {
              const p = this.props.items;
              return p.length === 0 ? null : p.map((f) => i.createElement(rg, { key: f.id, item: f }));
            }
          };
          yd = tg([zt.observer], yd);
          let rg = class extends i.Component {
            render() {
              const p = this.props.item;
              let f;
              const { type: h } = p;
              switch (h) {
                case "group":
                  f = null;
                  break;
                case "tag":
                case "section":
                default:
                  f = i.createElement(ng, ((w, P) => {
                    for (var L in P || (P = {})) aR.call(P, L) && Bx(w, L, P[L]);
                    if (zx) for (var L of zx(P)) lR.call(P, L) && Bx(w, L, P[L]);
                    return w;
                  })({}, this.props));
                  break;
                case "operation":
                  f = i.createElement(ig, { item: p });
              }
              return i.createElement(i.Fragment, null, f && i.createElement(Xs, { id: p.id, $underlined: p.type === "operation" }, f), p.items && i.createElement(yd, { items: p.items }));
            }
          };
          rg = tg([zt.observer], rg);
          const uR = (p) => i.createElement(Sn, { $compact: !0 }, p);
          let ng = class extends i.Component {
            render() {
              const { name: p, description: f, externalDocs: h, level: w } = this.props.item, P = w === 2 ? lm : ps;
              return i.createElement(i.Fragment, null, i.createElement(Tr, null, i.createElement(Sn, { $compact: !1 }, i.createElement(P, null, i.createElement(gc, { to: this.props.item.id }), p))), i.createElement(Xo, { parentId: this.props.item.id, source: f || "", htmlWrap: uR }), h && i.createElement(Tr, null, i.createElement(Sn, null, i.createElement(no, { externalDocs: h }))));
            }
          };
          ng = tg([zt.observer], ng);
          let ig = class extends i.Component {
            render() {
              return i.createElement(qx, { operation: this.props.item });
            }
          };
          ig = tg([zt.observer], ig);
          var cR = Object.defineProperty, pR = Object.defineProperties, fR = Object.getOwnPropertyDescriptors, Ux = Object.getOwnPropertySymbols, dR = Object.prototype.hasOwnProperty, hR = Object.prototype.propertyIsEnumerable, Vx = (p, f, h) => f in p ? cR(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h;
          let vd = class extends i.Component {
            constructor() {
              super(...arguments), this.ref = i.createRef(), this.activate = (p) => {
                this.props.onActivate(this.props.item), p.stopPropagation();
              };
            }
            componentDidMount() {
              this.scrollIntoViewIfActive();
            }
            componentDidUpdate() {
              this.scrollIntoViewIfActive();
            }
            scrollIntoViewIfActive() {
              this.props.item.active && this.ref.current && S(this.ref.current);
            }
            render() {
              const { item: p, withoutChildren: f } = this.props;
              return i.createElement(Bm, { tabIndex: 0, onClick: this.activate, onKeyDown: (w) => {
                w.key !== "Enter" && w.key !== " " || (this.props.onActivate(this.props.item), w.stopPropagation());
              }, depth: p.depth, "data-item-id": p.id, role: "menuitem", "aria-label": p.sidebarLabel, "aria-expanded": p.expanded }, p.type === "operation" ? i.createElement(Hx, (h = ((w, P) => {
                for (var L in P || (P = {})) dR.call(P, L) && Vx(w, L, P[L]);
                if (Ux) for (var L of Ux(P)) hR.call(P, L) && Vx(w, L, P[L]);
                return w;
              })({}, this.props), pR(h, fR({ item: p })))) : i.createElement(fu, { $depth: p.depth, $active: p.active, $type: p.type, ref: this.ref }, p.type === "schema" && i.createElement(Jo, { type: "schema" }, "schema"), i.createElement(Wc, { width: "calc(100% - 38px)", title: p.sidebarLabel }, p.sidebarLabel, this.props.children), p.depth > 0 && p.items.length > 0 && i.createElement($i, { float: "right", direction: p.expanded ? "down" : "right" }) || null), !f && p.items && p.items.length > 0 && i.createElement(bd, { expanded: p.expanded, items: p.items, onActivate: this.props.onActivate }));
              var h;
            }
          };
          vd = ((p, f) => {
            for (var h, w = f, P = p.length - 1; P >= 0; P--) (h = p[P]) && (w = h(w) || w);
            return w;
          })([zt.observer], vd);
          const Hx = (0, zt.observer)((p) => {
            var f;
            const { item: h } = p, w = i.createRef(), { showWebhookVerb: P } = i.useContext(st);
            return i.useEffect(() => {
              p.item.active && w.current && S(w.current);
            }, [p.item.active, w]), i.createElement(fu, { $depth: h.depth, $active: h.active, $deprecated: h.deprecated, ref: w }, h.badges && ((f = h.badges) == null ? void 0 : f.map(({ name: L, color: z }) => i.createElement(Jo, { type: "badge", color: z, key: L }, L))), h.isWebhook ? i.createElement(Jo, { type: "hook" }, P ? h.httpVerb : F("webhook")) : i.createElement(Jo, { type: h.httpVerb }, Dn(h.httpVerb)), i.createElement(Wc, { tabIndex: 0, width: "calc(100% - 38px)" }, h.sidebarLabel, p.children));
          });
          var mR = Object.defineProperty, Wx = Object.getOwnPropertySymbols, gR = Object.prototype.hasOwnProperty, yR = Object.prototype.propertyIsEnumerable, Kx = (p, f, h) => f in p ? mR(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h;
          let bd = class extends i.Component {
            render() {
              const { items: p, root: f, className: h } = this.props, w = this.props.expanded == null || this.props.expanded;
              return i.createElement(pu, ((P, L) => {
                for (var z in L || (L = {})) gR.call(L, z) && Kx(P, z, L[z]);
                if (Wx) for (var z of Wx(L)) yR.call(L, z) && Kx(P, z, L[z]);
                return P;
              })({ className: h, style: this.props.style, $expanded: w }, f ? { role: "menu" } : {}), p.map((P, L) => i.createElement(vd, { key: L, item: P, onActivate: this.props.onActivate })));
            }
          };
          function vR() {
            const [p, f] = (0, i.useState)(!1);
            return (0, i.useEffect)(() => {
              f(!0);
            }, []), p ? i.createElement("img", { alt: "redocly logo", onError: () => f(!1), src: "https://cdn.redoc.ly/redoc/logo-mini.svg" }) : null;
          }
          bd = ((p, f) => {
            for (var h, w = f, P = p.length - 1; P >= 0; P--) (h = p[P]) && (w = h(w) || w);
            return w;
          })([zt.observer], bd);
          let wd = class extends i.Component {
            constructor() {
              super(...arguments), this.activate = (p) => {
                if (p && p.active && this.context.menuToggle) return p.expanded ? p.collapse() : p.expand();
                this.props.menu.activateAndScroll(p, !0), setTimeout(() => {
                  this._updateScroll && this._updateScroll();
                });
              }, this.saveScrollUpdate = (p) => {
                this._updateScroll = p;
              };
            }
            render() {
              const p = this.props.menu;
              return i.createElement(qa, { updateFn: this.saveScrollUpdate, className: this.props.className, options: { wheelPropagation: !1 } }, i.createElement(bd, { items: p.items, onActivate: this.activate, root: !0 }), i.createElement(lo, null, i.createElement("a", { target: "_blank", rel: "noopener noreferrer", href: "https://redocly.com/redoc/" }, i.createElement(vR, null), "API docs by Redocly")));
            }
          };
          wd.contextType = st, wd = ((p, f) => {
            for (var h, w = f, P = p.length - 1; P >= 0; P--) (h = p[P]) && (w = h(w) || w);
            return w;
          })([zt.observer], wd);
          const bR = ({ open: p }) => {
            const f = p ? 8 : -4;
            return i.createElement(wR, null, i.createElement(Qx, { size: 15, style: { transform: `translate(2px, ${f}px) rotate(180deg)`, transition: "transform 0.2s ease" } }), i.createElement(Qx, { size: 15, style: { transform: `translate(2px, ${0 - f}px)`, transition: "transform 0.2s ease" } }));
          }, Qx = ({ size: p = 10, className: f = "", style: h }) => i.createElement("svg", { className: f, style: h || {}, viewBox: "0 0 926.23699 573.74994", version: "1.1", x: "0px", y: "0px", width: p, height: p }, i.createElement("g", { transform: "translate(904.92214,-879.1482)" }, i.createElement("path", { d: `
          m -673.67664,1221.6502 -231.2455,-231.24803 55.6165,
          -55.627 c 30.5891,-30.59485 56.1806,-55.627 56.8701,-55.627 0.6894,
          0 79.8637,78.60862 175.9427,174.68583 l 174.6892,174.6858 174.6892,
          -174.6858 c 96.079,-96.07721 175.253196,-174.68583 175.942696,
          -174.68583 0.6895,0 26.281,25.03215 56.8701,
          55.627 l 55.6165,55.627 -231.245496,231.24803 c -127.185,127.1864
          -231.5279,231.248 -231.873,231.248 -0.3451,0 -104.688,
          -104.0616 -231.873,-231.248 z
        `, fill: "currentColor" }))), wR = K.div`
  user-select: none;
  width: 20px;
  height: 20px;
  align-self: center;
  display: flex;
  flex-direction: column;
  color: ${(p) => p.theme.colors.primary.main};
`;
          let Kb;
          m && (Kb = o(230));
          const sg = Kb && Kb(), SR = K.div`
  width: ${(p) => p.theme.sidebar.width};
  background-color: ${(p) => p.theme.sidebar.backgroundColor};
  overflow: hidden;
  display: flex;
  flex-direction: column;

  backface-visibility: hidden;
  /* contain: strict; TODO: breaks layout since Chrome 80*/

  height: 100vh;
  position: sticky;
  position: -webkit-sticky;
  top: 0;

  ${$.lessThan("small")`
    position: fixed;
    z-index: 20;
    width: 100%;
    background: ${({ theme: p }) => p.sidebar.backgroundColor};
    display: ${(p) => p.$open ? "flex" : "none"};
  `};

  @media print {
    display: none;
  }
`, xR = K.div`
  outline: none;
  user-select: none;
  background-color: ${({ theme: p }) => p.fab.backgroundColor};
  color: ${(p) => p.theme.colors.primary.main};
  display: none;
  cursor: pointer;
  position: fixed;
  right: 20px;
  z-index: 100;
  border-radius: 50%;
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
  ${$.lessThan("small")`
    display: flex;
  `};

  bottom: 44px;

  width: 60px;
  height: 60px;
  padding: 0 20px;
  svg {
    color: ${({ theme: p }) => p.fab.color};
  }

  @media print {
    display: none;
  }
`;
          let Sd = class extends i.Component {
            constructor() {
              super(...arguments), this.state = { offsetTop: "0px" }, this.toggleNavMenu = () => {
                this.props.menu.toggleSidebar();
              };
            }
            componentDidMount() {
              sg && sg.add(this.stickyElement), this.setState({ offsetTop: this.getScrollYOffset(this.context) });
            }
            componentWillUnmount() {
              sg && sg.remove(this.stickyElement);
            }
            getScrollYOffset(p) {
              let f;
              return f = this.props.scrollYOffset !== void 0 ? ie.normalizeScrollYOffset(this.props.scrollYOffset)() : p.scrollYOffset(), f + "px";
            }
            render() {
              const p = this.props.menu.sideBarOpened, f = this.state.offsetTop;
              return i.createElement(i.Fragment, null, i.createElement(SR, { $open: p, className: this.props.className, style: { top: f, height: `calc(100vh - ${f})` }, ref: (h) => {
                this.stickyElement = h;
              } }, this.props.children), !this.context.hideFab && i.createElement(xR, { onClick: this.toggleNavMenu }, i.createElement(bR, { open: p })));
            }
          };
          Sd.contextType = st, Sd = ((p, f) => {
            for (var h, w = f, P = p.length - 1; P >= 0; P--) (h = p[P]) && (w = h(w) || w);
            return w;
          })([zt.observer], Sd);
          const Yx = K.div`
  ${({ theme: p }) => `
  font-family: ${p.typography.fontFamily};
  font-size: ${p.typography.fontSize};
  font-weight: ${p.typography.fontWeightRegular};
  line-height: ${p.typography.lineHeight};
  color: ${p.colors.text.primary};
  display: flex;
  position: relative;
  text-align: left;

  -webkit-font-smoothing: ${p.typography.smoothing};
  font-smoothing: ${p.typography.smoothing};
  ${p.typography.optimizeSpeed ? "text-rendering: optimizeSpeed !important" : ""};

  tap-highlight-color: rgba(0, 0, 0, 0);
  text-size-adjust: 100%;

  * {
    box-sizing: border-box;
    -webkit-tap-highlight-color: rgba(255, 255, 255, 0);
  }
`};
`, Gx = K.div`
  z-index: 1;
  position: relative;
  overflow: hidden;
  width: calc(100% - ${(p) => p.theme.sidebar.width});
  ${$.lessThan("small", !0)`
    width: 100%;
  `};

  contain: layout;
`, Xx = K.div`
  background: ${({ theme: p }) => p.rightPanel.backgroundColor};
  position: absolute;
  top: 0;
  bottom: 0;
  right: 0;
  width: ${({ theme: p }) => {
            if (p.rightPanel.width.endsWith("%")) {
              const f = parseInt(p.rightPanel.width, 10);
              return `calc((100% - ${p.sidebar.width}) * ${f / 100})`;
            }
            return p.rightPanel.width;
          }};
  ${$.lessThan("medium", !0)`
    display: none;
  `};
`, _R = K.div`
  padding: 5px 0;
`, ER = K.input.attrs(() => ({ className: "search-input" }))`
  width: calc(100% - ${(p) => 8 * p.theme.spacing.unit}px);
  box-sizing: border-box;
  margin: 0 ${(p) => 4 * p.theme.spacing.unit}px;
  padding: 5px ${(p) => 2 * p.theme.spacing.unit}px 5px
    ${(p) => 4 * p.theme.spacing.unit}px;
  border: 0;
  border-bottom: 1px solid
    ${({ theme: p }) => ((0, u.getLuminance)(p.sidebar.backgroundColor) > 0.5 ? u.darken : u.lighten)(0.1, p.sidebar.backgroundColor)};
  font-family: ${({ theme: p }) => p.typography.fontFamily};
  font-weight: bold;
  font-size: 13px;
  color: ${(p) => p.theme.sidebar.textColor};
  background-color: transparent;
  outline: none;
`, OR = K((p) => i.createElement("svg", { className: p.className, version: "1.1", viewBox: "0 0 1000 1000", x: "0px", xmlns: "http://www.w3.org/2000/svg", y: "0px" }, i.createElement("path", { d: "M968.2,849.4L667.3,549c83.9-136.5,66.7-317.4-51.7-435.6C477.1-25,252.5-25,113.9,113.4c-138.5,138.3-138.5,362.6,0,501C219.2,730.1,413.2,743,547.6,666.5l301.9,301.4c43.6,43.6,76.9,14.9,104.2-12.4C981,928.3,1011.8,893,968.2,849.4z M524.5,522c-88.9,88.7-233,88.7-321.8,0c-88.9-88.7-88.9-232.6,0-321.3c88.9-88.7,233-88.7,321.8,0C613.4,289.4,613.4,433.3,524.5,522z" }))).attrs({ className: "search-icon" })`
  position: absolute;
  left: ${(p) => 4 * p.theme.spacing.unit}px;
  height: 1.8em;
  width: 0.9em;

  path {
    fill: ${(p) => p.theme.sidebar.textColor};
  }
`, Jx = K.div`
  padding: ${(p) => p.theme.spacing.unit}px 0;
  background-color: ${({ theme: p }) => (0, u.darken)(0.05, p.sidebar.backgroundColor)}};
  color: ${(p) => p.theme.sidebar.textColor};
  min-height: 150px;
  max-height: 250px;
  border-top: ${({ theme: p }) => (0, u.darken)(0.1, p.sidebar.backgroundColor)}};
  border-bottom: ${({ theme: p }) => (0, u.darken)(0.1, p.sidebar.backgroundColor)}};
  margin-top: 10px;
  line-height: 1.4;
  font-size: 0.9em;
  
  li {
    background-color: inherit;
  }

  ${fu} {
    padding-top: 6px;
    padding-bottom: 6px;

    &:hover,
    &.active {
      background-color: ${({ theme: p }) => (0, u.darken)(0.1, p.sidebar.backgroundColor)};
    }

    > svg {
      display: none;
    }
  }
`, kR = K.i`
  position: absolute;
  display: inline-block;
  width: ${(p) => 2 * p.theme.spacing.unit}px;
  text-align: center;
  right: ${(p) => 4 * p.theme.spacing.unit}px;
  line-height: 2em;
  vertical-align: middle;
  margin-right: 2px;
  cursor: pointer;
  font-style: normal;
  color: '#666';
`;
          var AR = Object.defineProperty, PR = Object.getOwnPropertyDescriptor;
          class og extends i.PureComponent {
            constructor(f) {
              super(f), this.activeItemRef = null, this.clear = () => {
                this.setState({ results: [], noResults: !1, term: "", activeItemIdx: -1 }), this.props.marker.unmark();
              }, this.handleKeyDown = (h) => {
                if (h.keyCode === 27 && this.clear(), h.keyCode === 40 && (this.setState({ activeItemIdx: Math.min(this.state.activeItemIdx + 1, this.state.results.length - 1) }), h.preventDefault()), h.keyCode === 38 && (this.setState({ activeItemIdx: Math.max(0, this.state.activeItemIdx - 1) }), h.preventDefault()), h.keyCode === 13) {
                  const w = this.state.results[this.state.activeItemIdx];
                  if (w) {
                    const P = this.props.getItemById(w.meta);
                    P && this.props.onActivate(P);
                  }
                }
              }, this.search = (h) => {
                const { minCharacterLengthToInitSearch: w } = this.context, P = h.target.value;
                P.length < w ? this.clearResults(P) : this.setState({ term: P }, () => this.searchCallback(this.state.term));
              }, this.state = { results: [], noResults: !1, term: "", activeItemIdx: -1 };
            }
            clearResults(f) {
              this.setState({ results: [], noResults: !1, term: f }), this.props.marker.unmark();
            }
            setResults(f, h) {
              this.setState({ results: f, noResults: f.length === 0 }), this.props.marker.mark(h);
            }
            searchCallback(f) {
              this.props.search.search(f).then((h) => {
                this.setResults(h, f);
              });
            }
            render() {
              const { activeItemIdx: f } = this.state, h = this.state.results.filter((w) => this.props.getItemById(w.meta)).map((w) => ({ item: this.props.getItemById(w.meta), score: w.score })).sort((w, P) => P.score - w.score);
              return i.createElement(_R, { role: "search" }, this.state.term && i.createElement(kR, { onClick: this.clear }, "×"), i.createElement(OR, null), i.createElement(ER, { value: this.state.term, onKeyDown: this.handleKeyDown, placeholder: "Search...", "aria-label": "Search", type: "text", onChange: this.search }), h.length > 0 && i.createElement(qa, { options: { wheelPropagation: !1 } }, i.createElement(Jx, { "data-role": "search:results" }, h.map((w, P) => i.createElement(vd, { item: Object.create(w.item, { active: { value: P === f } }), onActivate: this.props.onActivate, withoutChildren: !0, key: w.item.id, "data-role": "search:result" })))), this.state.term && this.state.noResults ? i.createElement(Jx, { "data-role": "search:results" }, F("noResultsFound")) : null);
            }
          }
          og.contextType = st, ((p, f, h) => {
            for (var w, P = PR(f, h), L = p.length - 1; L >= 0; L--) (w = p[L]) && (P = w(f, h, P) || P);
            P && AR(f, h, P);
          })([Ye.bind, (0, Ye.debounce)(400)], og.prototype, "searchCallback");
          class Qb extends i.Component {
            componentDidMount() {
              this.props.store.onDidMount();
            }
            componentWillUnmount() {
              this.props.store.dispose();
            }
            render() {
              const { store: { spec: f, menu: h, options: w, search: P, marker: L } } = this.props, z = this.props.store;
              return i.createElement(je, { theme: w.theme }, i.createElement(Zt, { value: z }, i.createElement(at, { value: w }, i.createElement(Yx, { className: "redoc-wrap" }, i.createElement(Sd, { menu: h, className: "menu-content" }, i.createElement(Ja, { info: f.info }), !w.disableSearch && i.createElement(og, { search: P, marker: L, getItemById: h.getItemById, onActivate: h.activateAndScroll }) || null, i.createElement(wd, { menu: h })), i.createElement(Gx, { className: "api-content" }, i.createElement(mn, { store: z }), i.createElement(yd, { items: h.items })), i.createElement(Xx, null)))));
            }
          }
          Qb.propTypes = { store: mt.instanceOf(ms).isRequired };
          var TR = Object.defineProperty, Zx = Object.getOwnPropertySymbols, CR = Object.prototype.hasOwnProperty, $R = Object.prototype.propertyIsEnumerable, e1 = (p, f, h) => f in p ? TR(p, f, { enumerable: !0, configurable: !0, writable: !0, value: h }) : p[f] = h, RR = (p, f) => {
            for (var h in f || (f = {})) CR.call(f, h) && e1(p, h, f[h]);
            if (Zx) for (var h of Zx(f)) $R.call(f, h) && e1(p, h, f[h]);
            return p;
          };
          const IR = function(p) {
            const { spec: f, specUrl: h, options: w = {}, onLoaded: P } = p, L = B(w.hideLoading, !1), z = new ie(w);
            if (z.nonce !== void 0) try {
              o.nc = z.nonce;
            } catch {
            }
            return i.createElement(ke, null, i.createElement(bf, { spec: f ? RR({}, f) : void 0, specUrl: h, options: w, onLoaded: P }, ({ loading: ee, store: ue }) => ee ? L ? null : i.createElement(ct, { color: z.theme.colors.primary.main }) : i.createElement(Qb, { store: ue })));
          };
        }(), a;
      }();
    });
  }(Ty)), Ty.exports;
}
var cV = uV();
const pV = () => {
  const [e, t] = Pt.useState(null);
  return Pt.useEffect(() => {
    const r = acquireVsCodeApi();
    window.addEventListener("message", (n) => {
      const o = n.data;
      switch (o.command) {
        case "preview":
          const a = JSON.parse(o.text);
          t(a);
          break;
      }
    }), r.postMessage({ command: "init" });
  }, []), e ? /* @__PURE__ */ Uw.jsx(cV.RedocStandalone, { options: { disableSearch: !0, hideDownloadButton: !0 }, spec: e }) : /* @__PURE__ */ Uw.jsx("p", { children: "Loading..." });
};
zA.render(/* @__PURE__ */ Uw.jsx(pV, {}), document.getElementById("root"));
